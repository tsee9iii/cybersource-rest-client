/**
 * CyberSource Merged Spec
 * All CyberSource API specs merged together. These are available at https://developer.cybersource.com/api/reference/api-reference.html
 *
 * OpenAPI spec version: 0.0.1
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import localVarRequest = require('request');
import http = require('http');
import Promise = require('bluebird');

let defaultBasePath = 'https://apitest.cybersource.com';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

/* tslint:disable:no-unused-variable */
let primitives = [
                    "string",
                    "boolean",
                    "double",
                    "integer",
                    "long",
                    "float",
                    "number",
                    "any"
                 ];

class ObjectSerializer {

    public static findCorrectType(data: any, expectedType: string) {
        if (data == undefined) {
            return expectedType;
        } else if (primitives.indexOf(expectedType.toLowerCase()) !== -1) {
            return expectedType;
        } else if (expectedType === "Date") {
            return expectedType;
        } else {
            if (enumsMap[expectedType]) {
                return expectedType;
            }

            if (!typeMap[expectedType]) {
                return expectedType; // w/e we don't know the type
            }

            // Check the discriminator
            let discriminatorProperty = typeMap[expectedType].discriminator;
            if (discriminatorProperty == null) {
                return expectedType; // the type does not have a discriminator. use it.
            } else {
                if (data[discriminatorProperty]) {
                    return data[discriminatorProperty]; // use the type given in the discriminator
                } else {
                    return expectedType; // discriminator was not present (or an empty string)
                }
            }
        }
    }

    public static serialize(data: any, type: string) {
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData: any[] = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.serialize(date, subType));
            }
            return transformedData;
        } else if (type === "Date") {
            return data.toString();
        } else {
            if (enumsMap[type]) {
                return data;
            }
            if (!typeMap[type]) { // in case we dont know the type
                return data;
            }

            // get the map for the correct type.
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            let instance: {[index: string]: any} = {};
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.baseName] = ObjectSerializer.serialize(data[attributeType.name], attributeType.type);
            }
            return instance;
        }
    }

    public static deserialize(data: any, type: string) {
        // polymorphism may change the actual type.
        type = ObjectSerializer.findCorrectType(data, type);
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData: any[] = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.deserialize(date, subType));
            }
            return transformedData;
        } else if (type === "Date") {
            return new Date(data);
        } else {
            if (enumsMap[type]) {// is Enum
                return data;
            }

            if (!typeMap[type]) { // dont know the type
                return data;
            }
            let instance = new typeMap[type]();
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.name] = ObjectSerializer.deserialize(data[attributeType.baseName], attributeType.type);
            }
            return instance;
        }
    }
}

export class Accountupdaterv1batchesIncluded {
    'tokens'?: Array<Accountupdaterv1batchesIncludedTokens>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "tokens",
            "baseName": "tokens",
            "type": "Array<Accountupdaterv1batchesIncludedTokens>"
        }    ];

    static getAttributeTypeMap() {
        return Accountupdaterv1batchesIncluded.attributeTypeMap;
    }
}

export class Accountupdaterv1batchesIncludedTokens {
    'id': string;
    'expirationMonth'?: string;
    'expirationYear'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "expirationMonth",
            "baseName": "expirationMonth",
            "type": "string"
        },
        {
            "name": "expirationYear",
            "baseName": "expirationYear",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Accountupdaterv1batchesIncludedTokens.attributeTypeMap;
    }
}

export class ActivateDeactivatePlanResponse {
    'links'?: PtsV2IncrementalAuthorizationPatch201ResponseLinks;
    /**
    * An unique identification number generated by Cybersource to identify the submitted request. Returned by all services. It is also appended to the endpoint of the resource. On incremental authorizations, this value with be the same as the identification number returned in the original authorization response. 
    */
    'id'?: string;
    /**
    * Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ` **Example** `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.). The `T` separates the date and the time. The `Z` indicates UTC.  Returned by Cybersource for all services. 
    */
    'submitTimeUtc'?: string;
    /**
    * The status of the submitted transaction.  Possible values:  - COMPLETED 
    */
    'status'?: string;
    'planInformation'?: UpdatePlanResponsePlanInformation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "PtsV2IncrementalAuthorizationPatch201ResponseLinks"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "submitTimeUtc",
            "baseName": "submitTimeUtc",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "planInformation",
            "baseName": "planInformation",
            "type": "UpdatePlanResponsePlanInformation"
        }    ];

    static getAttributeTypeMap() {
        return ActivateDeactivatePlanResponse.attributeTypeMap;
    }
}

export class ActivateSubscriptionResponse {
    'links'?: PtsV2IncrementalAuthorizationPatch201ResponseLinks;
    /**
    * An unique identification number generated by Cybersource to identify the submitted request. Returned by all services. It is also appended to the endpoint of the resource. On incremental authorizations, this value with be the same as the identification number returned in the original authorization response. 
    */
    'id'?: string;
    /**
    * Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ` **Example** `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.). The `T` separates the date and the time. The `Z` indicates UTC.  Returned by Cybersource for all services. 
    */
    'submitTimeUtc'?: string;
    /**
    * The status of the submitted transaction.  Possible values:  - COMPLETED 
    */
    'status'?: string;
    'subscriptionInformation'?: ActivateSubscriptionResponseSubscriptionInformation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "PtsV2IncrementalAuthorizationPatch201ResponseLinks"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "submitTimeUtc",
            "baseName": "submitTimeUtc",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "subscriptionInformation",
            "baseName": "subscriptionInformation",
            "type": "ActivateSubscriptionResponseSubscriptionInformation"
        }    ];

    static getAttributeTypeMap() {
        return ActivateSubscriptionResponse.attributeTypeMap;
    }
}

export class ActivateSubscriptionResponseSubscriptionInformation {
    /**
    * Subscription code. 
    */
    'code'?: string;
    /**
    * Subscription Status: - `ACTIVE` 
    */
    'status'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ActivateSubscriptionResponseSubscriptionInformation.attributeTypeMap;
    }
}

export class AddNegativeListRequest {
    'orderInformation'?: Riskv1liststypeentriesOrderInformation;
    'paymentInformation'?: Riskv1liststypeentriesPaymentInformation;
    'clientReferenceInformation'?: Riskv1liststypeentriesClientReferenceInformation;
    'deviceInformation'?: Riskv1liststypeentriesDeviceInformation;
    'riskInformation'?: Riskv1liststypeentriesRiskInformation;
    'buyerInformation'?: Riskv1liststypeentriesBuyerInformation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "orderInformation",
            "baseName": "orderInformation",
            "type": "Riskv1liststypeentriesOrderInformation"
        },
        {
            "name": "paymentInformation",
            "baseName": "paymentInformation",
            "type": "Riskv1liststypeentriesPaymentInformation"
        },
        {
            "name": "clientReferenceInformation",
            "baseName": "clientReferenceInformation",
            "type": "Riskv1liststypeentriesClientReferenceInformation"
        },
        {
            "name": "deviceInformation",
            "baseName": "deviceInformation",
            "type": "Riskv1liststypeentriesDeviceInformation"
        },
        {
            "name": "riskInformation",
            "baseName": "riskInformation",
            "type": "Riskv1liststypeentriesRiskInformation"
        },
        {
            "name": "buyerInformation",
            "baseName": "buyerInformation",
            "type": "Riskv1liststypeentriesBuyerInformation"
        }    ];

    static getAttributeTypeMap() {
        return AddNegativeListRequest.attributeTypeMap;
    }
}

export class AuthReversalRequest {
    'clientReferenceInformation'?: Ptsv2paymentsidreversalsClientReferenceInformation;
    'reversalInformation'?: Ptsv2paymentsidreversalsReversalInformation;
    'processingInformation'?: Ptsv2paymentsidreversalsProcessingInformation;
    'orderInformation'?: Ptsv2paymentsidreversalsOrderInformation;
    'pointOfSaleInformation'?: Ptsv2paymentsidreversalsPointOfSaleInformation;
    'paymentInformation'?: Ptsv2paymentsidreversalsPaymentInformation;
    'processorInformation'?: Ptsv2paymentsProcessorInformationReversal;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "clientReferenceInformation",
            "baseName": "clientReferenceInformation",
            "type": "Ptsv2paymentsidreversalsClientReferenceInformation"
        },
        {
            "name": "reversalInformation",
            "baseName": "reversalInformation",
            "type": "Ptsv2paymentsidreversalsReversalInformation"
        },
        {
            "name": "processingInformation",
            "baseName": "processingInformation",
            "type": "Ptsv2paymentsidreversalsProcessingInformation"
        },
        {
            "name": "orderInformation",
            "baseName": "orderInformation",
            "type": "Ptsv2paymentsidreversalsOrderInformation"
        },
        {
            "name": "pointOfSaleInformation",
            "baseName": "pointOfSaleInformation",
            "type": "Ptsv2paymentsidreversalsPointOfSaleInformation"
        },
        {
            "name": "paymentInformation",
            "baseName": "paymentInformation",
            "type": "Ptsv2paymentsidreversalsPaymentInformation"
        },
        {
            "name": "processorInformation",
            "baseName": "processorInformation",
            "type": "Ptsv2paymentsProcessorInformationReversal"
        }    ];

    static getAttributeTypeMap() {
        return AuthReversalRequest.attributeTypeMap;
    }
}

export class Binv1binlookupClientReferenceInformation {
    'partner'?: Riskv1decisionsClientReferenceInformationPartner;
    /**
    * The name of the Connection Method client (such as Virtual Terminal or SOAP Toolkit API) that the merchant uses to send a transaction request to CyberSource. 
    */
    'applicationName'?: string;
    /**
    * Version of the CyberSource application or integration used for a transaction. 
    */
    'applicationVersion'?: string;
    /**
    * The entity that is responsible for running the transaction and submitting the processing request to CyberSource. This could be a person, a system, or a connection method. 
    */
    'applicationUser'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "partner",
            "baseName": "partner",
            "type": "Riskv1decisionsClientReferenceInformationPartner"
        },
        {
            "name": "applicationName",
            "baseName": "applicationName",
            "type": "string"
        },
        {
            "name": "applicationVersion",
            "baseName": "applicationVersion",
            "type": "string"
        },
        {
            "name": "applicationUser",
            "baseName": "applicationUser",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Binv1binlookupClientReferenceInformation.attributeTypeMap;
    }
}

export class Binv1binlookupPaymentInformation {
    'card'?: Binv1binlookupPaymentInformationCard;
    'customer'?: GetAllSubscriptionsResponsePaymentInformationCustomer;
    'paymentInstrument'?: Ptsv2paymentsPaymentInformationPaymentInstrument;
    'instrumentIdentifier'?: Ptsv2paymentsPaymentInformationInstrumentIdentifier;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "card",
            "baseName": "card",
            "type": "Binv1binlookupPaymentInformationCard"
        },
        {
            "name": "customer",
            "baseName": "customer",
            "type": "GetAllSubscriptionsResponsePaymentInformationCustomer"
        },
        {
            "name": "paymentInstrument",
            "baseName": "paymentInstrument",
            "type": "Ptsv2paymentsPaymentInformationPaymentInstrument"
        },
        {
            "name": "instrumentIdentifier",
            "baseName": "instrumentIdentifier",
            "type": "Ptsv2paymentsPaymentInformationInstrumentIdentifier"
        }    ];

    static getAttributeTypeMap() {
        return Binv1binlookupPaymentInformation.attributeTypeMap;
    }
}

export class Binv1binlookupPaymentInformationCard {
    /**
    * The customer’s payment card number, also known as the Primary Account Number (PAN). You can also use this field for encoded account numbers.  #### FDMS Nashville Required. String (19)  #### GPX Required if `pointOfSaleInformation.entryMode=keyed`. However, this field is optional if your account is configured for relaxed requirements for address data and expiration date. **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.  #### All other processors Required if `pointOfSaleInformation.entryMode=keyed`. However, this field is optional if your account is configured for relaxed requirements for address data and expiration date. **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting. 
    */
    'number'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "number",
            "baseName": "number",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Binv1binlookupPaymentInformationCard.attributeTypeMap;
    }
}

export class Binv1binlookupProcessingInformation {
    /**
    * Bin Source File Identifier.  Possible values: - itmx - rupay 
    */
    'binSource'?: string;
    'payoutOptions'?: Binv1binlookupProcessingInformationPayoutOptions;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "binSource",
            "baseName": "binSource",
            "type": "string"
        },
        {
            "name": "payoutOptions",
            "baseName": "payoutOptions",
            "type": "Binv1binlookupProcessingInformationPayoutOptions"
        }    ];

    static getAttributeTypeMap() {
        return Binv1binlookupProcessingInformation.attributeTypeMap;
    }
}

/**
* Payout fields request parameters 
*/
export class Binv1binlookupProcessingInformationPayoutOptions {
    /**
    * If `true` then provide attributes related to fund transfer/payouts. If payout information not found then response will have standard account lookup.  Possible values: - true - false 
    */
    'payoutInquiry'?: boolean;
    /**
    * The networks specified in this field must be a subset of the information provided during program enrollment    Possible values: - 0020 : Accel/Exchange - 0024 : CU24 - 0003 : Interlink - 0016 : Maestro - 0018 : NYCE - 0027 : NYCE - 0009 : Pulse - 0017 : Pulse - 0019 : Pulse - 0008 : Star - 0010 : Star - 0011 : Star - 0012 : Star - 0015 : Star - 0002 : Visa/PLUS 
    */
    'networkId'?: string;
    /**
    * BIN under which the Funds Transfer application is registered. This must match the information provided during enrollment. 
    */
    'acquirerBin'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "payoutInquiry",
            "baseName": "payoutInquiry",
            "type": "boolean"
        },
        {
            "name": "networkId",
            "baseName": "networkId",
            "type": "string"
        },
        {
            "name": "acquirerBin",
            "baseName": "acquirerBin",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Binv1binlookupProcessingInformationPayoutOptions.attributeTypeMap;
    }
}

export class Binv1binlookupTokenInformation {
    /**
    * TMS Transient Token, 64 hexadecimal id value representing captured payment credentials (including Sensitive Authentication Data, e.g. CVV). 
    */
    'jti'?: string;
    /**
    * Flex API Transient Token encoded as JWT (JSON Web Token), e.g. Flex microform or Unified Payment checkout result. 
    */
    'transientTokenJwt'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "jti",
            "baseName": "jti",
            "type": "string"
        },
        {
            "name": "transientTokenJwt",
            "baseName": "transientTokenJwt",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Binv1binlookupTokenInformation.attributeTypeMap;
    }
}

export class Boardingv1registrationsDocumentInformation {
    'signedDocuments'?: Array<Boardingv1registrationsDocumentInformationSignedDocuments>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "signedDocuments",
            "baseName": "signedDocuments",
            "type": "Array<Boardingv1registrationsDocumentInformationSignedDocuments>"
        }    ];

    static getAttributeTypeMap() {
        return Boardingv1registrationsDocumentInformation.attributeTypeMap;
    }
}

export class Boardingv1registrationsDocumentInformationSignedDocuments {
    'documentId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "documentId",
            "baseName": "documentId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Boardingv1registrationsDocumentInformationSignedDocuments.attributeTypeMap;
    }
}

export class Boardingv1registrationsIntegrationInformation {
    'oauth2'?: Array<Boardingv1registrationsIntegrationInformationOauth2>;
    /**
    * tenantConfigurations is an array of objects that includes the tenant information this merchant is associated with.
    */
    'tenantConfigurations'?: Array<Boardingv1registrationsIntegrationInformationTenantConfigurations>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "oauth2",
            "baseName": "oauth2",
            "type": "Array<Boardingv1registrationsIntegrationInformationOauth2>"
        },
        {
            "name": "tenantConfigurations",
            "baseName": "tenantConfigurations",
            "type": "Array<Boardingv1registrationsIntegrationInformationTenantConfigurations>"
        }    ];

    static getAttributeTypeMap() {
        return Boardingv1registrationsIntegrationInformation.attributeTypeMap;
    }
}

export class Boardingv1registrationsIntegrationInformationOauth2 {
    'clientId': string;
    'state'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "clientId",
            "baseName": "client_id",
            "type": "string"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Boardingv1registrationsIntegrationInformationOauth2.attributeTypeMap;
    }
}

export class Boardingv1registrationsIntegrationInformationTenantConfigurations {
    /**
    * The solutionId is the unique identifier for this system resource. Partner can use it to reference the specific solution through out the system. 
    */
    'solutionId': string;
    'tenantInformation'?: Boardingv1registrationsIntegrationInformationTenantInformation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "solutionId",
            "baseName": "solutionId",
            "type": "string"
        },
        {
            "name": "tenantInformation",
            "baseName": "tenantInformation",
            "type": "Boardingv1registrationsIntegrationInformationTenantInformation"
        }    ];

    static getAttributeTypeMap() {
        return Boardingv1registrationsIntegrationInformationTenantConfigurations.attributeTypeMap;
    }
}

export class Boardingv1registrationsIntegrationInformationTenantInformation {
    /**
    * The TenantId is an external Solution Identifier given by Tech Partners like SAP.
    */
    'tenantId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "tenantId",
            "baseName": "tenantId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Boardingv1registrationsIntegrationInformationTenantInformation.attributeTypeMap;
    }
}

export class Boardingv1registrationsOrganizationInformation {
    'organizationId'?: string;
    /**
    * This field is required for Organization Types: MERCHANT, TRANSACTING 
    */
    'parentOrganizationId'?: string;
    'childOrganizations'?: Array<string>;
    /**
    * Determines the type of organization in the hirarchy that this registration will use to onboard this Organization Possible Values:   - 'TRANSACTING'   - 'STRUCTURAL'   - 'MERCHANT' 
    */
    'type'?: Boardingv1registrationsOrganizationInformation.TypeEnum;
    /**
    * Determines the status that the organization will be after being onboarded Possible Values:             - 'LIVE'             - 'TEST'             - 'DRAFT' 
    */
    'status'?: Boardingv1registrationsOrganizationInformation.StatusEnum;
    /**
    * This denotes the one organization, with exception to the TRANSACTING types, that is allowed to be used for configuration purposes against products.  Eventually this field will be deprecated and all organizations will be allowed for product configuration.
    */
    'configurable'?: boolean;
    'businessInformation': Boardingv1registrationsOrganizationInformationBusinessInformation;
    'KYC'?: Boardingv1registrationsOrganizationInformationKYC;
    'owners'?: Array<Boardingv1registrationsOrganizationInformationOwners>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "organizationId",
            "baseName": "organizationId",
            "type": "string"
        },
        {
            "name": "parentOrganizationId",
            "baseName": "parentOrganizationId",
            "type": "string"
        },
        {
            "name": "childOrganizations",
            "baseName": "childOrganizations",
            "type": "Array<string>"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "Boardingv1registrationsOrganizationInformation.TypeEnum"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "Boardingv1registrationsOrganizationInformation.StatusEnum"
        },
        {
            "name": "configurable",
            "baseName": "configurable",
            "type": "boolean"
        },
        {
            "name": "businessInformation",
            "baseName": "businessInformation",
            "type": "Boardingv1registrationsOrganizationInformationBusinessInformation"
        },
        {
            "name": "KYC",
            "baseName": "KYC",
            "type": "Boardingv1registrationsOrganizationInformationKYC"
        },
        {
            "name": "owners",
            "baseName": "owners",
            "type": "Array<Boardingv1registrationsOrganizationInformationOwners>"
        }    ];

    static getAttributeTypeMap() {
        return Boardingv1registrationsOrganizationInformation.attributeTypeMap;
    }
}

export namespace Boardingv1registrationsOrganizationInformation {
    export enum TypeEnum {
        TRANSACTING = <any> 'TRANSACTING',
        STRUCTURAL = <any> 'STRUCTURAL',
        MERCHANT = <any> 'MERCHANT'
    }
    export enum StatusEnum {
        LIVE = <any> 'LIVE',
        TEST = <any> 'TEST',
        DRAFT = <any> 'DRAFT'
    }
}
export class Boardingv1registrationsOrganizationInformationBusinessInformation {
    'name': string;
    'doingBusinessAs'?: string;
    'description'?: string;
    /**
    * `Format: YYYY-MM-DD` Example 2016-08-11 equals August 11, 2016 
    */
    'startDate'?: string;
    'address'?: Boardingv1registrationsOrganizationInformationBusinessInformationAddress;
    /**
    * Merchant perferred time zone Possible Values: - 'Pacific/Pago_Pago' - 'Pacific/Honolulu' - 'America/Anchorage' - 'America/Vancouver' - 'America/Los_Angeles' - 'America/Phoenix' - 'America/Edmonton' - 'America/Denver' - 'America/Winnipeg' - 'America/Mexico_City' - 'America/Chicago' - 'America/Bogota' - 'America/Indianapolis' - 'America/New_York' - 'America/La_Paz' - 'America/Halifax' - 'America/St_Johns' - 'America/Buenos_Aires' - 'America/Godthab' - 'America/Sao_Paulo' - 'America/Noronha' - 'Atlantic/Cape_Verde' - 'GMT' - 'Europe/Dublin' - 'Europe/Lisbon' - 'Europe/London' - 'Africa/Tunis' - 'Europe/Vienna' - 'Europe/Brussels' - 'Europe/Zurich' - 'Europe/Prague' - 'Europe/Berlin' - 'Europe/Copenhagen' - 'Europe/Madrid' - 'Europe/Budapest' - 'Europe/Rome' - 'Africa/Tripoli' - 'Europe/Monaco' - 'Europe/Malta' - 'Europe/Amsterdam' - 'Europe/Oslo' - 'Europe/Warsaw' - 'Europe/Stockholm' - 'Europe/Belgrade' - 'Europe/Paris' - 'Africa/Johannesburg' - 'Europe/Minsk' - 'Africa/Cairo' - 'Europe/Helsinki' - 'Europe/Athens' - 'Asia/Jerusalem' - 'Europe/Riga' - 'Europe/Bucharest' - 'Europe/Istanbul' - 'Asia/Riyadh' - 'Europe/Moscow' - 'Asia/Dubai' - 'Asia/Baku' - 'Asia/Tbilisi' - 'Asia/Calcutta' - 'Asia/Katmandu' - 'Asia/Dacca' - 'Asia/Rangoon' - 'Asia/Jakarta' - 'Asia/Saigon' - 'Asia/Bangkok' - 'Australia/Perth' - 'Asia/Hong_Kong' - 'Asia/Macao' - 'Asia/Kuala_Lumpur' - 'Asia/Manila' - 'Asia/Singapore' - 'Asia/Taipei' - 'Asia/Shanghai' - 'Asia/Seoul' - 'Asia/Tokyo' - 'Asia/Yakutsk' - 'Australia/Adelaide' - 'Australia/Brisbane' - 'Australia/Broken_Hill' - 'Australia/Darwin' - 'Australia/Eucla' - 'Australia/Hobart' - 'Australia/Lindeman' - 'Australia/Sydney' - 'Australia/Lord_Howe' - 'Australia/Melbourne' - 'Asia/Magadan' - 'Pacific/Norfolk' - 'Pacific/Auckland' 
    */
    'timeZone'?: Boardingv1registrationsOrganizationInformationBusinessInformation.TimeZoneEnum;
    'websiteUrl'?: string;
    /**
    * Business type Possible Values:   - 'PARTNERSHIP'   - 'SOLE_PROPRIETORSHIP'   - 'CORPORATION'   - 'LLC'   - 'NON_PROFIT'   - 'TRUST' 
    */
    'type'?: Boardingv1registrationsOrganizationInformationBusinessInformation.TypeEnum;
    'taxId'?: string;
    'phoneNumber'?: string;
    'businessContact'?: Boardingv1registrationsOrganizationInformationBusinessInformationBusinessContact;
    'technicalContact'?: Boardingv1registrationsOrganizationInformationBusinessInformationBusinessContact;
    'emergencyContact'?: Boardingv1registrationsOrganizationInformationBusinessInformationBusinessContact;
    /**
    * Industry standard Merchant Category Code (MCC)
    */
    'merchantCategoryCode'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "doingBusinessAs",
            "baseName": "doingBusinessAs",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "startDate",
            "baseName": "startDate",
            "type": "string"
        },
        {
            "name": "address",
            "baseName": "address",
            "type": "Boardingv1registrationsOrganizationInformationBusinessInformationAddress"
        },
        {
            "name": "timeZone",
            "baseName": "timeZone",
            "type": "Boardingv1registrationsOrganizationInformationBusinessInformation.TimeZoneEnum"
        },
        {
            "name": "websiteUrl",
            "baseName": "websiteUrl",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "Boardingv1registrationsOrganizationInformationBusinessInformation.TypeEnum"
        },
        {
            "name": "taxId",
            "baseName": "taxId",
            "type": "string"
        },
        {
            "name": "phoneNumber",
            "baseName": "phoneNumber",
            "type": "string"
        },
        {
            "name": "businessContact",
            "baseName": "businessContact",
            "type": "Boardingv1registrationsOrganizationInformationBusinessInformationBusinessContact"
        },
        {
            "name": "technicalContact",
            "baseName": "technicalContact",
            "type": "Boardingv1registrationsOrganizationInformationBusinessInformationBusinessContact"
        },
        {
            "name": "emergencyContact",
            "baseName": "emergencyContact",
            "type": "Boardingv1registrationsOrganizationInformationBusinessInformationBusinessContact"
        },
        {
            "name": "merchantCategoryCode",
            "baseName": "merchantCategoryCode",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Boardingv1registrationsOrganizationInformationBusinessInformation.attributeTypeMap;
    }
}

export namespace Boardingv1registrationsOrganizationInformationBusinessInformation {
    export enum TimeZoneEnum {
        PacificPagoPago = <any> 'Pacific/Pago_Pago',
        PacificHonolulu = <any> 'Pacific/Honolulu',
        AmericaAnchorage = <any> 'America/Anchorage',
        AmericaVancouver = <any> 'America/Vancouver',
        AmericaLosAngeles = <any> 'America/Los_Angeles',
        AmericaPhoenix = <any> 'America/Phoenix',
        AmericaEdmonton = <any> 'America/Edmonton',
        AmericaDenver = <any> 'America/Denver',
        AmericaWinnipeg = <any> 'America/Winnipeg',
        AmericaMexicoCity = <any> 'America/Mexico_City',
        AmericaChicago = <any> 'America/Chicago',
        AmericaBogota = <any> 'America/Bogota',
        AmericaIndianapolis = <any> 'America/Indianapolis',
        AmericaNewYork = <any> 'America/New_York',
        AmericaLaPaz = <any> 'America/La_Paz',
        AmericaHalifax = <any> 'America/Halifax',
        AmericaStJohns = <any> 'America/St_Johns',
        AmericaBuenosAires = <any> 'America/Buenos_Aires',
        AmericaGodthab = <any> 'America/Godthab',
        AmericaSaoPaulo = <any> 'America/Sao_Paulo',
        AmericaNoronha = <any> 'America/Noronha',
        AtlanticCapeVerde = <any> 'Atlantic/Cape_Verde',
        GMT = <any> 'GMT',
        EuropeDublin = <any> 'Europe/Dublin',
        EuropeLisbon = <any> 'Europe/Lisbon',
        EuropeLondon = <any> 'Europe/London',
        AfricaTunis = <any> 'Africa/Tunis',
        EuropeVienna = <any> 'Europe/Vienna',
        EuropeBrussels = <any> 'Europe/Brussels',
        EuropeZurich = <any> 'Europe/Zurich',
        EuropePrague = <any> 'Europe/Prague',
        EuropeBerlin = <any> 'Europe/Berlin',
        EuropeCopenhagen = <any> 'Europe/Copenhagen',
        EuropeMadrid = <any> 'Europe/Madrid',
        EuropeBudapest = <any> 'Europe/Budapest',
        EuropeRome = <any> 'Europe/Rome',
        AfricaTripoli = <any> 'Africa/Tripoli',
        EuropeMonaco = <any> 'Europe/Monaco',
        EuropeMalta = <any> 'Europe/Malta',
        EuropeAmsterdam = <any> 'Europe/Amsterdam',
        EuropeOslo = <any> 'Europe/Oslo',
        EuropeWarsaw = <any> 'Europe/Warsaw',
        EuropeStockholm = <any> 'Europe/Stockholm',
        EuropeBelgrade = <any> 'Europe/Belgrade',
        EuropeParis = <any> 'Europe/Paris',
        AfricaJohannesburg = <any> 'Africa/Johannesburg',
        EuropeMinsk = <any> 'Europe/Minsk',
        AfricaCairo = <any> 'Africa/Cairo',
        EuropeHelsinki = <any> 'Europe/Helsinki',
        EuropeAthens = <any> 'Europe/Athens',
        AsiaJerusalem = <any> 'Asia/Jerusalem',
        EuropeRiga = <any> 'Europe/Riga',
        EuropeBucharest = <any> 'Europe/Bucharest',
        EuropeIstanbul = <any> 'Europe/Istanbul',
        AsiaRiyadh = <any> 'Asia/Riyadh',
        EuropeMoscow = <any> 'Europe/Moscow',
        AsiaDubai = <any> 'Asia/Dubai',
        AsiaBaku = <any> 'Asia/Baku',
        AsiaTbilisi = <any> 'Asia/Tbilisi',
        AsiaCalcutta = <any> 'Asia/Calcutta',
        AsiaKatmandu = <any> 'Asia/Katmandu',
        AsiaDacca = <any> 'Asia/Dacca',
        AsiaRangoon = <any> 'Asia/Rangoon',
        AsiaJakarta = <any> 'Asia/Jakarta',
        AsiaSaigon = <any> 'Asia/Saigon',
        AsiaBangkok = <any> 'Asia/Bangkok',
        AustraliaPerth = <any> 'Australia/Perth',
        AsiaHongKong = <any> 'Asia/Hong_Kong',
        AsiaMacao = <any> 'Asia/Macao',
        AsiaKualaLumpur = <any> 'Asia/Kuala_Lumpur',
        AsiaManila = <any> 'Asia/Manila',
        AsiaSingapore = <any> 'Asia/Singapore',
        AsiaTaipei = <any> 'Asia/Taipei',
        AsiaShanghai = <any> 'Asia/Shanghai',
        AsiaSeoul = <any> 'Asia/Seoul',
        AsiaTokyo = <any> 'Asia/Tokyo',
        AsiaYakutsk = <any> 'Asia/Yakutsk',
        AustraliaAdelaide = <any> 'Australia/Adelaide',
        AustraliaBrisbane = <any> 'Australia/Brisbane',
        AustraliaBrokenHill = <any> 'Australia/Broken_Hill',
        AustraliaDarwin = <any> 'Australia/Darwin',
        AustraliaEucla = <any> 'Australia/Eucla',
        AustraliaHobart = <any> 'Australia/Hobart',
        AustraliaLindeman = <any> 'Australia/Lindeman',
        AustraliaSydney = <any> 'Australia/Sydney',
        AustraliaLordHowe = <any> 'Australia/Lord_Howe',
        AustraliaMelbourne = <any> 'Australia/Melbourne',
        AsiaMagadan = <any> 'Asia/Magadan',
        PacificNorfolk = <any> 'Pacific/Norfolk',
        PacificAuckland = <any> 'Pacific/Auckland'
    }
    export enum TypeEnum {
        PARTNERSHIP = <any> 'PARTNERSHIP',
        SOLEPROPRIETORSHIP = <any> 'SOLE_PROPRIETORSHIP',
        CORPORATION = <any> 'CORPORATION',
        LLC = <any> 'LLC',
        NONPROFIT = <any> 'NON_PROFIT',
        TRUST = <any> 'TRUST'
    }
}
export class Boardingv1registrationsOrganizationInformationBusinessInformationAddress {
    'country': string;
    'address1': string;
    'address2'?: string;
    /**
    * City of the billing address.
    */
    'locality': string;
    /**
    * State or province of the billing address. Required for United States and Canada.
    */
    'administrativeArea'?: string;
    /**
    * Postal code for the billing address. The postal code must consist of 5 to 9 digits. Required for United States and Canada.
    */
    'postalCode'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "country",
            "baseName": "country",
            "type": "string"
        },
        {
            "name": "address1",
            "baseName": "address1",
            "type": "string"
        },
        {
            "name": "address2",
            "baseName": "address2",
            "type": "string"
        },
        {
            "name": "locality",
            "baseName": "locality",
            "type": "string"
        },
        {
            "name": "administrativeArea",
            "baseName": "administrativeArea",
            "type": "string"
        },
        {
            "name": "postalCode",
            "baseName": "postalCode",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Boardingv1registrationsOrganizationInformationBusinessInformationAddress.attributeTypeMap;
    }
}

export class Boardingv1registrationsOrganizationInformationBusinessInformationBusinessContact {
    'firstName': string;
    'middleName'?: string;
    'lastName': string;
    'phoneNumber': string;
    'email': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "firstName",
            "baseName": "firstName",
            "type": "string"
        },
        {
            "name": "middleName",
            "baseName": "middleName",
            "type": "string"
        },
        {
            "name": "lastName",
            "baseName": "lastName",
            "type": "string"
        },
        {
            "name": "phoneNumber",
            "baseName": "phoneNumber",
            "type": "string"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Boardingv1registrationsOrganizationInformationBusinessInformationBusinessContact.attributeTypeMap;
    }
}

export class Boardingv1registrationsOrganizationInformationKYC {
    'whenIsCustomerCharged': Boardingv1registrationsOrganizationInformationKYC.WhenIsCustomerChargedEnum;
    'whenIsCustomerChargedDescription'?: string;
    'offerSubscriptions': boolean;
    'monthlySubscriptionPercent'?: number;
    'quarterlySubscriptionPercent'?: number;
    'semiAnnualSubscriptionPercent'?: number;
    'annualSubscriptionPercent'?: number;
    'timeToProductDelivery': Boardingv1registrationsOrganizationInformationKYC.TimeToProductDeliveryEnum;
    'estimatedMonthlySales': number;
    'averageOrderAmount': number;
    'largestExpectedOrderAmount': number;
    'depositBankAccount'?: Boardingv1registrationsOrganizationInformationKYCDepositBankAccount;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "whenIsCustomerCharged",
            "baseName": "whenIsCustomerCharged",
            "type": "Boardingv1registrationsOrganizationInformationKYC.WhenIsCustomerChargedEnum"
        },
        {
            "name": "whenIsCustomerChargedDescription",
            "baseName": "whenIsCustomerChargedDescription",
            "type": "string"
        },
        {
            "name": "offerSubscriptions",
            "baseName": "offerSubscriptions",
            "type": "boolean"
        },
        {
            "name": "monthlySubscriptionPercent",
            "baseName": "monthlySubscriptionPercent",
            "type": "number"
        },
        {
            "name": "quarterlySubscriptionPercent",
            "baseName": "quarterlySubscriptionPercent",
            "type": "number"
        },
        {
            "name": "semiAnnualSubscriptionPercent",
            "baseName": "semiAnnualSubscriptionPercent",
            "type": "number"
        },
        {
            "name": "annualSubscriptionPercent",
            "baseName": "annualSubscriptionPercent",
            "type": "number"
        },
        {
            "name": "timeToProductDelivery",
            "baseName": "timeToProductDelivery",
            "type": "Boardingv1registrationsOrganizationInformationKYC.TimeToProductDeliveryEnum"
        },
        {
            "name": "estimatedMonthlySales",
            "baseName": "estimatedMonthlySales",
            "type": "number"
        },
        {
            "name": "averageOrderAmount",
            "baseName": "averageOrderAmount",
            "type": "number"
        },
        {
            "name": "largestExpectedOrderAmount",
            "baseName": "largestExpectedOrderAmount",
            "type": "number"
        },
        {
            "name": "depositBankAccount",
            "baseName": "depositBankAccount",
            "type": "Boardingv1registrationsOrganizationInformationKYCDepositBankAccount"
        }    ];

    static getAttributeTypeMap() {
        return Boardingv1registrationsOrganizationInformationKYC.attributeTypeMap;
    }
}

export namespace Boardingv1registrationsOrganizationInformationKYC {
    export enum WhenIsCustomerChargedEnum {
        ONETIMEBEFORE = <any> 'ONETIMEBEFORE',
        ONETIMEAFTER = <any> 'ONETIMEAFTER',
        OTHER = <any> 'OTHER'
    }
    export enum TimeToProductDeliveryEnum {
        INSTANT = <any> 'INSTANT',
        UPTO2 = <any> 'UPTO2',
        UPTO5 = <any> 'UPTO5',
        UPTO10 = <any> 'UPTO10',
        GREATERTHAN10 = <any> 'GREATERTHAN10'
    }
}
export class Boardingv1registrationsOrganizationInformationKYCDepositBankAccount {
    'accountHolderName': string;
    'accountType': Boardingv1registrationsOrganizationInformationKYCDepositBankAccount.AccountTypeEnum;
    'accountRoutingNumber': string;
    'accountNumber': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "accountHolderName",
            "baseName": "accountHolderName",
            "type": "string"
        },
        {
            "name": "accountType",
            "baseName": "accountType",
            "type": "Boardingv1registrationsOrganizationInformationKYCDepositBankAccount.AccountTypeEnum"
        },
        {
            "name": "accountRoutingNumber",
            "baseName": "accountRoutingNumber",
            "type": "string"
        },
        {
            "name": "accountNumber",
            "baseName": "accountNumber",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Boardingv1registrationsOrganizationInformationKYCDepositBankAccount.attributeTypeMap;
    }
}

export namespace Boardingv1registrationsOrganizationInformationKYCDepositBankAccount {
    export enum AccountTypeEnum {
        Checking = <any> 'checking',
        Savings = <any> 'savings',
        Corporatechecking = <any> 'corporatechecking',
        Corporatesavings = <any> 'corporatesavings'
    }
}
export class Boardingv1registrationsOrganizationInformationOwners {
    'firstName': string;
    'middleName'?: string;
    'lastName': string;
    /**
    * `Format: YYYY-MM-DD` Example 2016-08-11 equals August 11, 2016 
    */
    'birthDate': string;
    /**
    * Determines whether the owner is the Primary owner of the organization
    */
    'isPrimary': boolean;
    /**
    * Social Security Number
    */
    'ssn'?: string;
    /**
    * Passport number
    */
    'passportNumber'?: string;
    'passportCountry'?: string;
    'jobTitle': string;
    /**
    * Determines whether owner has significant responsibility to control, manage or direct the company
    */
    'hasSignificantResponsability': boolean;
    /**
    * Determines the percentage of ownership this owner has. For the primary owner the percentage can be from 0-100; for other owners the percentage can be from 25-100 and the sum of ownership accross owners cannot exceed 100
    */
    'ownershipPercentage': number;
    'phoneNumber': string;
    'email': string;
    'address': Boardingv1registrationsOrganizationInformationBusinessInformationAddress;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "firstName",
            "baseName": "firstName",
            "type": "string"
        },
        {
            "name": "middleName",
            "baseName": "middleName",
            "type": "string"
        },
        {
            "name": "lastName",
            "baseName": "lastName",
            "type": "string"
        },
        {
            "name": "birthDate",
            "baseName": "birthDate",
            "type": "string"
        },
        {
            "name": "isPrimary",
            "baseName": "isPrimary",
            "type": "boolean"
        },
        {
            "name": "ssn",
            "baseName": "ssn",
            "type": "string"
        },
        {
            "name": "passportNumber",
            "baseName": "passportNumber",
            "type": "string"
        },
        {
            "name": "passportCountry",
            "baseName": "passportCountry",
            "type": "string"
        },
        {
            "name": "jobTitle",
            "baseName": "jobTitle",
            "type": "string"
        },
        {
            "name": "hasSignificantResponsability",
            "baseName": "hasSignificantResponsability",
            "type": "boolean"
        },
        {
            "name": "ownershipPercentage",
            "baseName": "ownershipPercentage",
            "type": "number"
        },
        {
            "name": "phoneNumber",
            "baseName": "phoneNumber",
            "type": "string"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "address",
            "baseName": "address",
            "type": "Boardingv1registrationsOrganizationInformationBusinessInformationAddress"
        }    ];

    static getAttributeTypeMap() {
        return Boardingv1registrationsOrganizationInformationOwners.attributeTypeMap;
    }
}

export class Boardingv1registrationsProductInformation {
    'selectedProducts'?: Boardingv1registrationsProductInformationSelectedProducts;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "selectedProducts",
            "baseName": "selectedProducts",
            "type": "Boardingv1registrationsProductInformationSelectedProducts"
        }    ];

    static getAttributeTypeMap() {
        return Boardingv1registrationsProductInformation.attributeTypeMap;
    }
}

export class Boardingv1registrationsProductInformationSelectedProducts {
    'payments'?: PaymentsProducts;
    'risk'?: RiskProducts;
    'commerceSolutions'?: CommerceSolutionsProducts;
    'valueAddedServices'?: ValueAddedServicesProducts;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "payments",
            "baseName": "payments",
            "type": "PaymentsProducts"
        },
        {
            "name": "risk",
            "baseName": "risk",
            "type": "RiskProducts"
        },
        {
            "name": "commerceSolutions",
            "baseName": "commerceSolutions",
            "type": "CommerceSolutionsProducts"
        },
        {
            "name": "valueAddedServices",
            "baseName": "valueAddedServices",
            "type": "ValueAddedServicesProducts"
        }    ];

    static getAttributeTypeMap() {
        return Boardingv1registrationsProductInformationSelectedProducts.attributeTypeMap;
    }
}

export class Boardingv1registrationsRegistrationInformation {
    'boardingRegistrationId'?: string;
    /**
    * Time of request in UTC. `Format: YYYY-MM-DDThh:mm:ssZ`  Example 2016-08-11T22:47:57Z equals August 11, 2016, at 22:47:57 (10:47:57 p.m.). The T separates the date and the time. The Z indicates UTC. 
    */
    'submitTimeUtc'?: Date;
    /**
    * The status of Registration request Possible Values:   - 'PROCESSING': This status is for Registrations that are still in Progress, you can get the latest status by calling the GET endpoint using the Registration Id   - 'SUCCESS': This status is for Registrations that were successfull on every step of the on boarding process.   - 'FAILURE': This status is for Registrations that fail before the Organization was created; please refer to the details section in the reponse for more information.   - 'PARTIAL': This status is for Registrations that created the Organization successfully but fail in at least on step while configuring it; please refer to the details section in the response for more information. 
    */
    'status'?: Boardingv1registrationsRegistrationInformation.StatusEnum;
    'boardingPackageId'?: string;
    /**
    * Determines the boarding flow for this registration. Possible Values:   - 'ENTERPRISE'   - 'SMB'   - 'ADDPRODUCT' 
    */
    'boardingFlow'?: Boardingv1registrationsRegistrationInformation.BoardingFlowEnum;
    /**
    * In case mode is not provided the API will use COMPLETE as default Possible Values:   - 'COMPLETE'   - 'PARTIAL' 
    */
    'mode'?: Boardingv1registrationsRegistrationInformation.ModeEnum;
    'salesRepId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "boardingRegistrationId",
            "baseName": "boardingRegistrationId",
            "type": "string"
        },
        {
            "name": "submitTimeUtc",
            "baseName": "submitTimeUtc",
            "type": "Date"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "Boardingv1registrationsRegistrationInformation.StatusEnum"
        },
        {
            "name": "boardingPackageId",
            "baseName": "boardingPackageId",
            "type": "string"
        },
        {
            "name": "boardingFlow",
            "baseName": "boardingFlow",
            "type": "Boardingv1registrationsRegistrationInformation.BoardingFlowEnum"
        },
        {
            "name": "mode",
            "baseName": "mode",
            "type": "Boardingv1registrationsRegistrationInformation.ModeEnum"
        },
        {
            "name": "salesRepId",
            "baseName": "salesRepId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Boardingv1registrationsRegistrationInformation.attributeTypeMap;
    }
}

export namespace Boardingv1registrationsRegistrationInformation {
    export enum StatusEnum {
        PROCESSING = <any> 'PROCESSING',
        SUCCESS = <any> 'SUCCESS',
        FAILURE = <any> 'FAILURE',
        PARTIAL = <any> 'PARTIAL'
    }
    export enum BoardingFlowEnum {
        ENTERPRISE = <any> 'ENTERPRISE',
        SMB = <any> 'SMB',
        ADDPRODUCT = <any> 'ADDPRODUCT'
    }
    export enum ModeEnum {
        COMPLETE = <any> 'COMPLETE',
        PARTIAL = <any> 'PARTIAL'
    }
}
export class Body {
    /**
    * Valid Values:   * oneOff   * amexRegistration 
    */
    'type'?: string;
    'included': Accountupdaterv1batchesIncluded;
    /**
    * Reference used by merchant to identify batch.
    */
    'merchantReference'?: string;
    /**
    * Email used to notify the batch status.
    */
    'notificationEmail': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "included",
            "baseName": "included",
            "type": "Accountupdaterv1batchesIncluded"
        },
        {
            "name": "merchantReference",
            "baseName": "merchantReference",
            "type": "string"
        },
        {
            "name": "notificationEmail",
            "baseName": "notificationEmail",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Body.attributeTypeMap;
    }
}

export class Body1 {
    /**
    * Merchant ID associated to the new device or terminal. This merchant ID will be treated as the primary for this terminal. 
    */
    'merchantId': string;
    /**
    * An optional description or label for this terminal.
    */
    'description'?: string;
    /**
    * An identifier in the partner system which is used setup the terminal firmware, software and configurations.
    */
    'deviceExternalId'?: string;
    /**
    * Payment processor details associated to this terminal.
    */
    'paymentProcessor'?: Array<Dmsv2devicesPaymentProcessor>;
    /**
    * Serial number of the terminal. Once set, serialNumber cannot be updated to a new value. 
    */
    'serialNumber'?: string;
    /**
    * Key serial identifier of the card encryption BDK that is loaded on this device.
    */
    'cardEncryptionKsi'?: string;
    /**
    * An optional name of the card encryption BDK that is loaded on this device.
    */
    'cardEncryptionKeyName'?: string;
    /**
    * Key serial identifier of the PIN encryption BDK that is loaded on this device.
    */
    'pinEncryptionKsi'?: string;
    /**
    * An optional name of the PIN BDK that is loaded on this device.
    */
    'pinEncryptionKeyName'?: string;
    /**
    * Device or terminal hardware revison number.
    */
    'hardwareRevision'?: string;
    /**
    * Device or terminal firmware or OS version.
    */
    'firmwareVersion'?: string;
    /**
    * Device or terminal payment software version.
    */
    'paymentSoftwareVersion'?: string;
    /**
    * Device or terminal software configuration profile version.
    */
    'configVersion'?: string;
    /**
    * Serial number of the tamper evident bag used for shipping the terminal.
    */
    'teBagSerialNumber'?: string;
    /**
    *  Terminal shipped date in UTC. `Format: YYYY-MM-DDThh:mm:ssZ`  Example 2016-08-11T22:47:57Z equals August 11, 2016, at 22:47:57 (10:47:57 p.m.). The T separates the date and the time. The Z indicates UTC. 
    */
    'shippedDateInUTC'?: Date;
    /**
    * Tracking number from the shipping carrier.
    */
    'shippingTrackingNumber'?: string;
    /**
    * Status of the terminal. Status cannot be made active without setting paymentProcessor, terminalId and serialNumber. statusChangeReason should be \"In Production\" for active terminals. 
    */
    'status'?: Body1.StatusEnum;
    /**
    * Reason for change in status. Terminals only with following exsting statusChangeReason can be updated:     -- In Production     -- Pending Setup     -- Other 
    */
    'statusChangeReason'?: Body1.StatusChangeReasonEnum;
    /**
    * Reason for replacement of this device. This is only recorded if statusChangeReason is \"Replaced\". 
    */
    'replacementReason'?: Body1.ReplacementReasonEnum;
    /**
    * The serial number of the device that replaces the current one. This is only recorded if statusChangeReason is \"Replaced\". 
    */
    'replacementSerialNumber'?: string;
    /**
    * An optional ticket number to track the device state.
    */
    'ticketNumber'?: string;
    /**
    * An addtional comment about the device state.
    */
    'comment'?: string;
    /**
    * P2PE status of the terminal. If existing p2peStatus is \"Disabled\", it cannot be switched back to \"Enabled\". 
    */
    'p2peStatus'?: Body1.P2peStatusEnum;
    /**
    * P2PE confirmation status from the merchant. This is recorded only if p2peStatus is \"Enabled\". 
    */
    'p2peConfirmation'?: Body1.P2peConfirmationEnum;
    /**
    *  P2PE confirmation timestamp in UTC. `Format: YYYY-MM-DDThh:mm:ssZ`. Example 2016-08-11T22:47:57Z equals August 11, 2016, at 22:47:57 (10:47:57 p.m.). The T separates the date and the time. The Z indicates UTC. This is recorded only if p2peConfirmation is \"Confirmed\". 
    */
    'p2peConfirmationDateInUTC'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "merchantId",
            "baseName": "merchantId",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "deviceExternalId",
            "baseName": "deviceExternalId",
            "type": "string"
        },
        {
            "name": "paymentProcessor",
            "baseName": "paymentProcessor",
            "type": "Array<Dmsv2devicesPaymentProcessor>"
        },
        {
            "name": "serialNumber",
            "baseName": "serialNumber",
            "type": "string"
        },
        {
            "name": "cardEncryptionKsi",
            "baseName": "cardEncryptionKsi",
            "type": "string"
        },
        {
            "name": "cardEncryptionKeyName",
            "baseName": "cardEncryptionKeyName",
            "type": "string"
        },
        {
            "name": "pinEncryptionKsi",
            "baseName": "pinEncryptionKsi",
            "type": "string"
        },
        {
            "name": "pinEncryptionKeyName",
            "baseName": "pinEncryptionKeyName",
            "type": "string"
        },
        {
            "name": "hardwareRevision",
            "baseName": "hardwareRevision",
            "type": "string"
        },
        {
            "name": "firmwareVersion",
            "baseName": "firmwareVersion",
            "type": "string"
        },
        {
            "name": "paymentSoftwareVersion",
            "baseName": "paymentSoftwareVersion",
            "type": "string"
        },
        {
            "name": "configVersion",
            "baseName": "configVersion",
            "type": "string"
        },
        {
            "name": "teBagSerialNumber",
            "baseName": "teBagSerialNumber",
            "type": "string"
        },
        {
            "name": "shippedDateInUTC",
            "baseName": "shippedDateInUTC",
            "type": "Date"
        },
        {
            "name": "shippingTrackingNumber",
            "baseName": "shippingTrackingNumber",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "Body1.StatusEnum"
        },
        {
            "name": "statusChangeReason",
            "baseName": "statusChangeReason",
            "type": "Body1.StatusChangeReasonEnum"
        },
        {
            "name": "replacementReason",
            "baseName": "replacementReason",
            "type": "Body1.ReplacementReasonEnum"
        },
        {
            "name": "replacementSerialNumber",
            "baseName": "replacementSerialNumber",
            "type": "string"
        },
        {
            "name": "ticketNumber",
            "baseName": "ticketNumber",
            "type": "string"
        },
        {
            "name": "comment",
            "baseName": "comment",
            "type": "string"
        },
        {
            "name": "p2peStatus",
            "baseName": "p2peStatus",
            "type": "Body1.P2peStatusEnum"
        },
        {
            "name": "p2peConfirmation",
            "baseName": "p2peConfirmation",
            "type": "Body1.P2peConfirmationEnum"
        },
        {
            "name": "p2peConfirmationDateInUTC",
            "baseName": "p2peConfirmationDateInUTC",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return Body1.attributeTypeMap;
    }
}

export namespace Body1 {
    export enum StatusEnum {
        Active = <any> 'Active',
        Inactive = <any> 'Inactive'
    }
    export enum StatusChangeReasonEnum {
        InProduction = <any> 'In Production',
        PendingSetup = <any> 'Pending Setup',
        Returned = <any> 'Returned',
        Replaced = <any> 'Replaced',
        LostStolen = <any> 'Lost/Stolen',
        BrokenDamaged = <any> 'Broken/Damaged',
        EndOfLife = <any> 'End of Life',
        Other = <any> 'Other'
    }
    export enum ReplacementReasonEnum {
        ChipReadError = <any> 'Chip Read Error',
        Compromised = <any> 'Compromised',
        IncorrectKeyInjection = <any> 'Incorrect Key Injection',
        IncorrectPassword = <any> 'Incorrect Password',
        PowerIssue = <any> 'Power Issue',
        SuspectedTampering = <any> 'Suspected Tampering',
        Tampered = <any> 'Tampered',
        TerminalError = <any> 'Terminal Error',
        Other = <any> 'Other'
    }
    export enum P2peStatusEnum {
        Enabled = <any> 'Enabled',
        Disabled = <any> 'Disabled'
    }
    export enum P2peConfirmationEnum {
        Pending = <any> 'Pending',
        Confirmed = <any> 'Confirmed',
        Rejected = <any> 'Rejected'
    }
}
export class Body2 {
    /**
    * Device ID or organization id of the device to be customized.
    */
    'id': string;
    /**
    * Valid values are Device and organization.
    */
    'type': string;
    /**
    * List of the Customization key and value pairs to set for the given id.
    */
    'customizations': { [key: string]: string; };

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "customizations",
            "baseName": "customizations",
            "type": "{ [key: string]: string; }"
        }    ];

    static getAttributeTypeMap() {
        return Body2.attributeTypeMap;
    }
}

export class Body3 {
    /**
    * Device ID or organization id of the device to be customized.
    */
    'id': string;
    /**
    * Valid values are Device and organization.
    */
    'type': string;
    /**
    * List of the Customization key and value pairs to set for the given id.
    */
    'customizations': { [key: string]: string; };

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "customizations",
            "baseName": "customizations",
            "type": "{ [key: string]: string; }"
        }    ];

    static getAttributeTypeMap() {
        return Body3.attributeTypeMap;
    }
}

export class CancelSubscriptionResponse {
    'links'?: PtsV2IncrementalAuthorizationPatch201ResponseLinks;
    /**
    * An unique identification number generated by Cybersource to identify the submitted request. Returned by all services. It is also appended to the endpoint of the resource. On incremental authorizations, this value with be the same as the identification number returned in the original authorization response. 
    */
    'id'?: string;
    /**
    * Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ` **Example** `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.). The `T` separates the date and the time. The `Z` indicates UTC.  Returned by Cybersource for all services. 
    */
    'submitTimeUtc'?: string;
    /**
    * The status of the submitted transaction.  Possible values:  - ACCEPTED 
    */
    'status'?: string;
    'subscriptionInformation'?: CancelSubscriptionResponseSubscriptionInformation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "PtsV2IncrementalAuthorizationPatch201ResponseLinks"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "submitTimeUtc",
            "baseName": "submitTimeUtc",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "subscriptionInformation",
            "baseName": "subscriptionInformation",
            "type": "CancelSubscriptionResponseSubscriptionInformation"
        }    ];

    static getAttributeTypeMap() {
        return CancelSubscriptionResponse.attributeTypeMap;
    }
}

export class CancelSubscriptionResponseSubscriptionInformation {
    /**
    * Subscription code. 
    */
    'code'?: string;
    /**
    * Subscription Status: - `CANCELLED` 
    */
    'status'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CancelSubscriptionResponseSubscriptionInformation.attributeTypeMap;
    }
}

export class CapturePaymentRequest {
    'clientReferenceInformation'?: Ptsv2paymentsClientReferenceInformation;
    'processingInformation'?: Ptsv2paymentsidcapturesProcessingInformation;
    'paymentInformation'?: Ptsv2paymentsidcapturesPaymentInformation;
    'orderInformation'?: Ptsv2paymentsidcapturesOrderInformation;
    'buyerInformation'?: Ptsv2paymentsidcapturesBuyerInformation;
    'deviceInformation'?: Ptsv2paymentsidcapturesDeviceInformation;
    'merchantInformation'?: Ptsv2paymentsidcapturesMerchantInformation;
    'aggregatorInformation'?: Ptsv2paymentsidcapturesAggregatorInformation;
    'pointOfSaleInformation'?: Ptsv2paymentsidcapturesPointOfSaleInformation;
    /**
    * The object containing the custom data that the merchant defines. 
    */
    'merchantDefinedInformation'?: Array<Ptsv2paymentsMerchantDefinedInformation>;
    'merchantDefinedSecureInformation'?: Ptsv2paymentsMerchantDefinedSecureInformation;
    'installmentInformation'?: Ptsv2paymentsidcapturesInstallmentInformation;
    'travelInformation'?: Ptsv2paymentsTravelInformation;
    'promotionInformation'?: Ptsv2paymentsPromotionInformation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "clientReferenceInformation",
            "baseName": "clientReferenceInformation",
            "type": "Ptsv2paymentsClientReferenceInformation"
        },
        {
            "name": "processingInformation",
            "baseName": "processingInformation",
            "type": "Ptsv2paymentsidcapturesProcessingInformation"
        },
        {
            "name": "paymentInformation",
            "baseName": "paymentInformation",
            "type": "Ptsv2paymentsidcapturesPaymentInformation"
        },
        {
            "name": "orderInformation",
            "baseName": "orderInformation",
            "type": "Ptsv2paymentsidcapturesOrderInformation"
        },
        {
            "name": "buyerInformation",
            "baseName": "buyerInformation",
            "type": "Ptsv2paymentsidcapturesBuyerInformation"
        },
        {
            "name": "deviceInformation",
            "baseName": "deviceInformation",
            "type": "Ptsv2paymentsidcapturesDeviceInformation"
        },
        {
            "name": "merchantInformation",
            "baseName": "merchantInformation",
            "type": "Ptsv2paymentsidcapturesMerchantInformation"
        },
        {
            "name": "aggregatorInformation",
            "baseName": "aggregatorInformation",
            "type": "Ptsv2paymentsidcapturesAggregatorInformation"
        },
        {
            "name": "pointOfSaleInformation",
            "baseName": "pointOfSaleInformation",
            "type": "Ptsv2paymentsidcapturesPointOfSaleInformation"
        },
        {
            "name": "merchantDefinedInformation",
            "baseName": "merchantDefinedInformation",
            "type": "Array<Ptsv2paymentsMerchantDefinedInformation>"
        },
        {
            "name": "merchantDefinedSecureInformation",
            "baseName": "merchantDefinedSecureInformation",
            "type": "Ptsv2paymentsMerchantDefinedSecureInformation"
        },
        {
            "name": "installmentInformation",
            "baseName": "installmentInformation",
            "type": "Ptsv2paymentsidcapturesInstallmentInformation"
        },
        {
            "name": "travelInformation",
            "baseName": "travelInformation",
            "type": "Ptsv2paymentsTravelInformation"
        },
        {
            "name": "promotionInformation",
            "baseName": "promotionInformation",
            "type": "Ptsv2paymentsPromotionInformation"
        }    ];

    static getAttributeTypeMap() {
        return CapturePaymentRequest.attributeTypeMap;
    }
}

export class CardProcessingConfig {
    'common'?: CardProcessingConfigCommon;
    'features'?: CardProcessingConfigFeatures;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "common",
            "baseName": "common",
            "type": "CardProcessingConfigCommon"
        },
        {
            "name": "features",
            "baseName": "features",
            "type": "CardProcessingConfigFeatures"
        }    ];

    static getAttributeTypeMap() {
        return CardProcessingConfig.attributeTypeMap;
    }
}

export class CardProcessingConfigCommon {
    /**
    * e.g. * amexdirect * barclays2 * CUP * EFTPOS * fdiglobal * gpngsapv3 * gpx * smartfdc * tsys * vero * VPC  For VPC, CUP and EFTPOS processors, replace the processor name from VPC or CUP or EFTPOS to the actual processor name in the sample request. e.g. replace VPC with &lt;your vpc processor&gt; 
    */
    'processors'?: { [key: string]: CardProcessingConfigCommonProcessors; };
    /**
    * Vendor code assigned by American Express. Applicable for TSYS (tsys) processor.
    */
    'amexVendorCode'?: string;
    /**
    * Authorization Finality indicator. Please note that the input can be in small case or capitals but response is in small case as of now. It will be made capitals everywhere in the next version. Applicable for Elavon Americas (elavonamericas), TSYS (tsys), Barclays (barclays2), Streamline (streamline2), Six (six), Barclays HISO (barclayshiso), GPN (gpn), FDI Global (fdiglobal), GPX (gpx), Paymentech Tampa (paymentechtampa), FDC Nashville (smartfdc), VPC and Chase Paymentech Salem (chasepaymentechsalem) processors.  Validation details (for selected processors)...  <table> <thead><tr><th>Processor</th><th>Acceptance Type</th><th>Required</th><th>Default Value</th></tr></thead> <tr><td>Barclays</td><td>cnp, cp, hybrid</td><td>No</td><td>FINAL</td></tr> <tr><td>Barclays HISO</td><td>cnp, cp, hybrid</td><td>Yes</td><td>FINAL</td></tr> </table> 
    */
    'defaultAuthTypeCode'?: CardProcessingConfigCommon.DefaultAuthTypeCodeEnum;
    /**
    * MAID aka MasterCard assigned ID, MasterCard equivalent of Merchant Verification Value by Visa. Applicable for VPC, GPX (gpx) and FDI Global (fdiglobal) processors.
    */
    'masterCardAssignedId'?: string;
    /**
    * Allow merchants to accept partial authorization approvals. Applicable for Elavon Americas (elavonamericas), VPC, GPX (gpx), FDI Global (fdiglobal), FDC Nashville (smartfdc), GPN (gpn), TSYS (tsys), American Express Direct (amexdirect), Paymentech Tampa (paymentechtampa) and Chase Paymentech Salem (chasepaymentechsalem) processors.  Validation details (for selected processors)...  <table> <thead><tr><th>Processor</th><th>Acceptance Type</th><th>Required</th><th>Default Value</th></tr></thead> <tr><td>American Express Direct</td><td>cnp, cp, hybrid</td><td>No</td><td>No</td></tr> </table> 
    */
    'enablePartialAuth'?: boolean;
    /**
    * Indicates type of business product or service of the merchant. Applicable for Chase Paymentech Salem (chasepaymentechsalem), FDI Global (fdiglobal), RUPAY, Elavon Americas (elavonamericas), American Express Direct (amexdirect), CMCIC (cmcic), GPX (gpx), VPC, TSYS (tsys), EFTPOS, CUP, Paymentech Tampa (paymentechtampa), CB2A, Barclays (barclays2), Prisma (prisma) and GPN (gpn) processors.  Validation details (for selected processors)...  <table> <thead><tr><th>Processor</th><th>Acceptance Type</th><th>Required</th><th>Min. Length</th><th>Max. Length</th><th>Regex</th></tr></thead> <tr><td>Barclays</td><td>cnp</td><td>No</td><td>4</td><td>4</td><td>^[0-9]+$</td></tr> <tr><td>American Express Direct</td><td>cnp, cp, hybrid</td><td>Yes</td><td>4</td><td>4</td><td>^[0-9]+$</td></tr> </table> 
    */
    'merchantCategoryCode'?: string;
    /**
    * The Standard Industrial Classification (SIC) are four-digit codes that categorize the industries that companies belong to based on their business activities. Standard Industrial Classification codes were mostly replaced by the six-digit North American Industry Classification System (NAICS). Applicable for VPC and GPX (gpx) processors.
    */
    'sicCode'?: string;
    /**
    * Food and Consumer Service ID. Identifies the merchant as being certified and approved to accept Food Stamps. Applicable for GPX (gpx) processor.
    */
    'foodAndConsumerServiceId'?: string;
    /**
    * Enables you to split an order into multiple shipments with multiple captures. This feature is provided by CyberSource and supports three different scenarios:  * multiple authorizations * multiple captures * multiple authorizations with multiple captures  Applicable for VPC processors. 
    */
    'enableSplitShipment'?: boolean;
    /**
    * Reduces your interchange fees by using automatic authorization refresh and automatic partial authorization reversal. Applicable for VPC processors.
    */
    'enableInterchangeOptimization'?: boolean;
    /**
    * Identifier provided to merchants who opt for Visa’s delegated authorization program. Applicable for VPC processors.
    */
    'visaDelegatedAuthenticationId'?: string;
    /**
    * Blocks over-refunds when the aggregated refund amount is higher than the percentage set for this field. Applicable for GPX (gpx), VPC and Chase Paymentech Salem (chasepaymentechsalem) processors.
    */
    'creditCardRefundLimitPercent'?: string;
    /**
    * Limits refunds to the percentage set in this field. Applicable for GPX (gpx) and VPC processors.
    */
    'businessCenterCreditCardRefundLimitPercent'?: string;
    /**
    * Enables this merchant account to capture amounts greater than the authorization amount. Applicable for GPX (gpx), VPC, Paymentech Tampa (paymentechtampa) and Chase Paymentech Salem (chasepaymentechsalem) processors.
    */
    'allowCapturesGreaterThanAuthorizations'?: boolean;
    /**
    * Helps prevent duplicate transactions. Applicable for VPC, GPX (gpx) and Chase Paymentech Salem (chasepaymentechsalem) processors.
    */
    'enableDuplicateMerchantReferenceNumberBlocking'?: boolean;
    /**
    * This is a local merchant ID used by merchants in addition to the conventional merchant ID. This value is sent to the issuer. Applicable for VPC and Prisma (prisma) processors.
    */
    'domesticMerchantId'?: boolean;
    /**
    * Indicates whether merchant processes Level 3 transactions. Applicable for TSYS (tsys), Barclays (barclays2), Paymentech Tampa (paymentechtampa), FDI Global (fdiglobal), Elavon Americas (elavonamericas) and Chase Paymentech Salem (chasepaymentechsalem) processors.  Validation details (for selected processors)...  <table> <thead><tr><th>Processor</th><th>Acceptance Type</th><th>Required</th></tr></thead> <tr><td>Barclays</td><td>cnp</td><td>No</td></tr> </table> 
    */
    'processLevel3Data'?: string;
    /**
    * The ID assigned to the sub-merchant. Applicable for American Express Direct (amexdirect) processor.  Validation details (for selected processors)...  <table> <thead><tr><th>Processor</th><th>Acceptance Type</th><th>Required</th><th>Min. Length</th><th>Max. Length</th><th>Regex</th></tr></thead> <tr><td>American Express Direct</td><td>cnp, cp, hybrid</td><td>No</td><td>1</td><td>20</td><td>^[0-9a-zA-Z&#92;-&#92;_&#92;,\\s.]+$</td></tr> </table> 
    */
    'subMerchantId'?: string;
    /**
    * Sub-merchant's business name. Applicable for American Express Direct (amexdirect) processor.  Validation details (for selected processors)...  <table> <thead><tr><th>Processor</th><th>Acceptance Type</th><th>Required</th><th>Min. Length</th><th>Max. Length</th><th>Regex</th></tr></thead> <tr><td>American Express Direct</td><td>cnp, cp, hybrid</td><td>No</td><td>1</td><td>37</td><td>^[0-9a-zA-Z&#92;-&#92;_&#92;,\\s.]+$</td></tr> </table> 
    */
    'subMerchantBusinessName'?: string;
    /**
    * It denotes merchant's preference on secondary brand for routing in case of co-branded cards. Applicable for EFTPOS processors.
    */
    'preferCobadgedSecondaryBrand'?: boolean;
    'merchantDescriptorInformation'?: CardProcessingConfigCommonMerchantDescriptorInformation;
    /**
    * Indicates whether the merchant is government controlled. Applicable for VPC processors.
    */
    'governmentControlled'?: boolean;
    /**
    * This field is used to indicate whether the merchant wants to drop the billing information from the request. If this field is set to true, then the billing information will be dropped from the request. If this field is set to false, then the billing information will be sent in the request.
    */
    'dropBillingInfo'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "processors",
            "baseName": "processors",
            "type": "{ [key: string]: CardProcessingConfigCommonProcessors; }"
        },
        {
            "name": "amexVendorCode",
            "baseName": "amexVendorCode",
            "type": "string"
        },
        {
            "name": "defaultAuthTypeCode",
            "baseName": "defaultAuthTypeCode",
            "type": "CardProcessingConfigCommon.DefaultAuthTypeCodeEnum"
        },
        {
            "name": "masterCardAssignedId",
            "baseName": "masterCardAssignedId",
            "type": "string"
        },
        {
            "name": "enablePartialAuth",
            "baseName": "enablePartialAuth",
            "type": "boolean"
        },
        {
            "name": "merchantCategoryCode",
            "baseName": "merchantCategoryCode",
            "type": "string"
        },
        {
            "name": "sicCode",
            "baseName": "sicCode",
            "type": "string"
        },
        {
            "name": "foodAndConsumerServiceId",
            "baseName": "foodAndConsumerServiceId",
            "type": "string"
        },
        {
            "name": "enableSplitShipment",
            "baseName": "enableSplitShipment",
            "type": "boolean"
        },
        {
            "name": "enableInterchangeOptimization",
            "baseName": "enableInterchangeOptimization",
            "type": "boolean"
        },
        {
            "name": "visaDelegatedAuthenticationId",
            "baseName": "visaDelegatedAuthenticationId",
            "type": "string"
        },
        {
            "name": "creditCardRefundLimitPercent",
            "baseName": "creditCardRefundLimitPercent",
            "type": "string"
        },
        {
            "name": "businessCenterCreditCardRefundLimitPercent",
            "baseName": "businessCenterCreditCardRefundLimitPercent",
            "type": "string"
        },
        {
            "name": "allowCapturesGreaterThanAuthorizations",
            "baseName": "allowCapturesGreaterThanAuthorizations",
            "type": "boolean"
        },
        {
            "name": "enableDuplicateMerchantReferenceNumberBlocking",
            "baseName": "enableDuplicateMerchantReferenceNumberBlocking",
            "type": "boolean"
        },
        {
            "name": "domesticMerchantId",
            "baseName": "domesticMerchantId",
            "type": "boolean"
        },
        {
            "name": "processLevel3Data",
            "baseName": "processLevel3Data",
            "type": "string"
        },
        {
            "name": "subMerchantId",
            "baseName": "subMerchantId",
            "type": "string"
        },
        {
            "name": "subMerchantBusinessName",
            "baseName": "subMerchantBusinessName",
            "type": "string"
        },
        {
            "name": "preferCobadgedSecondaryBrand",
            "baseName": "preferCobadgedSecondaryBrand",
            "type": "boolean"
        },
        {
            "name": "merchantDescriptorInformation",
            "baseName": "merchantDescriptorInformation",
            "type": "CardProcessingConfigCommonMerchantDescriptorInformation"
        },
        {
            "name": "governmentControlled",
            "baseName": "governmentControlled",
            "type": "boolean"
        },
        {
            "name": "dropBillingInfo",
            "baseName": "dropBillingInfo",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return CardProcessingConfigCommon.attributeTypeMap;
    }
}

export namespace CardProcessingConfigCommon {
    export enum DefaultAuthTypeCodeEnum {
        PRE = <any> 'PRE',
        FINAL = <any> 'FINAL',
        UNDEFINED = <any> 'UNDEFINED'
    }
}
/**
* Identifies the financial institution acting as the acquirer of this customer transaction. The acquirer is the member or system user that signed the merchant.
*/
export class CardProcessingConfigCommonAcquirer {
    /**
    * Identifier of the acquirer. This number is usually assigned by Visa. Applicable for VPC, GPX (gpx), CMCIC (cmcic), EFTPOS, CB2A, CUP, American Express Direct (amexdirect) and Six (six) processors.  Validation details (for selected processors)...  <table> <thead><tr><th>Processor</th><th>Acceptance Type</th><th>Required</th><th>Min. Length</th><th>Max. Length</th><th>Regex</th><th>Default Value</th></tr></thead> <tr><td>American Express Direct</td><td>cnp, cp, hybrid</td><td>Yes</td><td>1</td><td>13</td><td>^[0-9]+$</td><td>1111</td></tr> </table> 
    */
    'institutionId'?: string;
    /**
    * Number assigned by MasterCard to banks to identify the member in transactions. Applicable for VPC and GPX (gpx) processors.
    */
    'interbankCardAssociationId'?: string;
    /**
    * Assigned by Discover to identify the acquirer. Applicable for VPC and GPX (gpx) processors.
    */
    'discoverInstitutionId'?: string;
    /**
    * Assigned by China Union Pay to identify the acquirer. Applicable for VPC processors.
    */
    'unionPayInstitutionId'?: string;
    /**
    * Assigned by Diners Club to identify the acquirer. Applicable for VPC processors.
    */
    'dinersClubInstitutionId'?: string;
    /**
    * ISO 4217 format. Applicable for VPC, GPX (gpx), EFTPOS, RUPAY, Prisma (prisma) and CUP processors.
    */
    'countryCode'?: string;
    /**
    * The BIN to which this capturefile is sent. This field must contain a valid BIN. Applicable for VPC and GPX (gpx) processors.
    */
    'fileDestinationBin'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "institutionId",
            "baseName": "institutionId",
            "type": "string"
        },
        {
            "name": "interbankCardAssociationId",
            "baseName": "interbankCardAssociationId",
            "type": "string"
        },
        {
            "name": "discoverInstitutionId",
            "baseName": "discoverInstitutionId",
            "type": "string"
        },
        {
            "name": "unionPayInstitutionId",
            "baseName": "unionPayInstitutionId",
            "type": "string"
        },
        {
            "name": "dinersClubInstitutionId",
            "baseName": "dinersClubInstitutionId",
            "type": "string"
        },
        {
            "name": "countryCode",
            "baseName": "countryCode",
            "type": "string"
        },
        {
            "name": "fileDestinationBin",
            "baseName": "fileDestinationBin",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CardProcessingConfigCommonAcquirer.attributeTypeMap;
    }
}

export class CardProcessingConfigCommonCurrencies {
    'enabled'?: boolean;
    /**
    * Indicates whether the card-present transaction is activated for the selected currency. If both enabledCardPresent and enabledCardNotPresent are set to null, then enabledCardPresent will have the value of enabled.
    */
    'enabledCardPresent'?: boolean;
    /**
    * Indicates whether the card-not-present transaction is activated for the selected currency. If both enabledCardPresent and enabledCardNotPresent are set to null, then enabledCardNotPresent will have the value of enabled.
    */
    'enabledCardNotPresent'?: boolean;
    /**
    * Merchant ID assigned by an acquirer or a processor. Should not be overridden by any other party.
    */
    'merchantId'?: string;
    /**
    * The 'Terminal Id' aka TID, is an identifier used for with your payments processor. Depending on the processor and payment acceptance type this may also be the default Terminal ID used for Card Present and Virtual Terminal transactions. 
    */
    'terminalId'?: string;
    /**
    * Applicable for Prisma (prisma) processor.
    */
    'terminalIds'?: Array<string>;
    /**
    * Service Establishment Number (a.k.a. SE Number) is a unique ten-digit number assigned by American Express to a merchant that accepts American Express cards. 10 digit number provided by acquirer currency. This may be unique for each currency, however it depends on the way the processor is set up for the merchant. 
    */
    'serviceEnablementNumber'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "enabled",
            "baseName": "enabled",
            "type": "boolean"
        },
        {
            "name": "enabledCardPresent",
            "baseName": "enabledCardPresent",
            "type": "boolean"
        },
        {
            "name": "enabledCardNotPresent",
            "baseName": "enabledCardNotPresent",
            "type": "boolean"
        },
        {
            "name": "merchantId",
            "baseName": "merchantId",
            "type": "string"
        },
        {
            "name": "terminalId",
            "baseName": "terminalId",
            "type": "string"
        },
        {
            "name": "terminalIds",
            "baseName": "terminalIds",
            "type": "Array<string>"
        },
        {
            "name": "serviceEnablementNumber",
            "baseName": "serviceEnablementNumber",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CardProcessingConfigCommonCurrencies.attributeTypeMap;
    }
}

export class CardProcessingConfigCommonCurrencies1 {
    'enabled'?: boolean;
    /**
    * Indicates whether the card-present transaction is activated for the selected currency. If both enabledCardPresent and enabledCardNotPresent are set to null, then enabledCardPresent will have the value of enabled. 
    */
    'enabledCardPresent'?: boolean;
    /**
    * Indicates whether the card-present transaction is activated for the selected currency. If both enabledCardPresent and enabledCardNotPresent are set to null, then enabledCardNotPresent will have the value of enabled. 
    */
    'enabledCardNotPresent'?: boolean;
    /**
    * Merchant ID assigned by an acquirer or a processor. Should not be overriden by any other party.  Validation details (for selected processors)...  <table> <thead><tr><th>Processor</th><th>Acceptance Type</th><th>Required</th><th>Min. Length</th><th>Max. Length</th><th>Regex</th></tr></thead> <tr><td>Barclays</td><td>cp, cnp, hybrid</td><td>Yes</td><td>1</td><td>11</td><td>^[0-9a-zA-Z]+$</td></tr> </table> 
    */
    'merchantId'?: any;
    /**
    * The 'Terminal Id' aka TID, is an identifier used for with your payments processor. Depending on the processor and payment acceptance type this may also be the default Terminal ID used for Card Present and Virtual Terminal transactions.  Validation details (for selected processors)...  <table> <thead><tr><th>Processor</th><th>Acceptance Type</th><th>Required</th><th>Min. Length</th><th>Max. Length</th><th>Regex</th></tr></thead> <tr><td>Barclays</td><td>cp, cnp, hybrid</td><td>Yes</td><td>8</td><td>8</td><td>^[0-9]+$</td></tr> </table> 
    */
    'terminalId'?: any;
    /**
    * Applicable for Prisma (prisma) processor.
    */
    'terminalIds'?: Array<string>;
    /**
    * Service Establishment Number (a.k.a. SE Number) is a unique ten-digit number assigned by American Express to a merchant that accepts American Express cards. 10 digit number provided by acquirer currency. This may be unique for each currency, however it depends on the way the processor is set up for the merchant.  Validation details (for selected processors)...  <table> <thead><tr><th>Processor</th><th>Acceptance Type</th><th>Required</th><th>Min. Length</th><th>Max. Length</th><th>Regex</th></tr></thead> <tr><td>American Express Direct</td><td>cp, cnp, hybrid</td><td>Yes</td><td>10</td><td>10</td><td>^[0-9]+$</td></tr> </table> 
    */
    'serviceEnablementNumber'?: any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "enabled",
            "baseName": "enabled",
            "type": "boolean"
        },
        {
            "name": "enabledCardPresent",
            "baseName": "enabledCardPresent",
            "type": "boolean"
        },
        {
            "name": "enabledCardNotPresent",
            "baseName": "enabledCardNotPresent",
            "type": "boolean"
        },
        {
            "name": "merchantId",
            "baseName": "merchantId",
            "type": "any"
        },
        {
            "name": "terminalId",
            "baseName": "terminalId",
            "type": "any"
        },
        {
            "name": "terminalIds",
            "baseName": "terminalIds",
            "type": "Array<string>"
        },
        {
            "name": "serviceEnablementNumber",
            "baseName": "serviceEnablementNumber",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return CardProcessingConfigCommonCurrencies1.attributeTypeMap;
    }
}

/**
* A merchant descriptor is the line of copy that identifies transactions on a cardholder’s account activity and statement. If this information is not populated, the data will be retrieved from OMS.
*/
export class CardProcessingConfigCommonMerchantDescriptorInformation {
    /**
    * Applicable for TSYS (tsys), RUPAY, American Express Direct (amexdirect) and Elavon Americas (elavonamericas) processors.  Validation details (for selected processors)...  <table> <thead><tr><th>Processor</th><th>Acceptance Type</th><th>Required</th><th>Min. Length</th><th>Max. Length</th><th>Regex</th></tr></thead> <tr><td>American Express Direct</td><td>cnp, cp, hybrid</td><td>Yes</td><td>1</td><td>38</td><td>^[0-9a-zA-Z\\s]+$</td></tr> </table> 
    */
    'name'?: string;
    /**
    * Applicable for American Express Direct (amexdirect), TSYS (tsys), RUPAY and Elavon Americas (elavonamericas) processors.  Validation details (for selected processors)...  <table> <thead><tr><th>Processor</th><th>Acceptance Type</th><th>Required</th><th>Min. Length</th><th>Max. Length</th><th>Regex</th></tr></thead> <tr><td>American Express Direct</td><td>cnp, cp, hybrid</td><td>Yes</td><td>1</td><td>21</td><td>^[0-9a-zA-Z\\s]+$</td></tr> </table> 
    */
    'city'?: string;
    /**
    * Applicable for Six (six), Elavon Americas (elavonamericas), TSYS (tsys) and American Express Direct (amexdirect) processors.  Validation details (for selected processors)...  <table> <thead><tr><th>Processor</th><th>Acceptance Type</th><th>Required</th><th>Min. Length</th><th>Max. Length</th><th>Regex</th></tr></thead> <tr><td>American Express Direct</td><td>cnp, cp, hybrid</td><td>Yes</td><td>3</td><td>3</td><td>^[A-Z]+$</td></tr> </table> 
    */
    'country'?: string;
    /**
    * Applicable for RUPAY, Elavon Americas (elavonamericas), American Express Direct (amexdirect) and TSYS (tsys) processors.  Validation details (for selected processors)...  <table> <thead><tr><th>Processor</th><th>Acceptance Type</th><th>Required</th><th>Min. Length</th><th>Max. Length</th><th>Regex</th></tr></thead> <tr><td>American Express Direct</td><td>cnp, cp, hybrid</td><td>Yes</td><td>1</td><td>20</td><td>^[0-9a-zA-Z\\s]+$</td></tr> </table> 
    */
    'phone'?: string;
    /**
    * Applicable for RUPAY, TSYS (tsys), Elavon Americas (elavonamericas) and American Express Direct (amexdirect) processors.  Validation details (for selected processors)...  <table> <thead><tr><th>Processor</th><th>Acceptance Type</th><th>Required</th><th>Min. Length</th><th>Max. Length</th><th>Regex</th></tr></thead> <tr><td>American Express Direct</td><td>cnp, cp, hybrid</td><td>No</td><td>1</td><td>3</td><td>^[A-Z]+$</td></tr> </table> 
    */
    'state'?: string;
    /**
    * Applicable for American Express Direct (amexdirect), TSYS (tsys) and Elavon Americas (elavonamericas) processors.  Validation details (for selected processors)...  <table> <thead><tr><th>Processor</th><th>Acceptance Type</th><th>Required</th><th>Min. Length</th><th>Max. Length</th><th>Regex</th></tr></thead> <tr><td>American Express Direct</td><td>cnp, cp, hybrid</td><td>Yes</td><td>1</td><td>38</td><td>^[0-9a-zA-Z\\s]+$</td></tr> </table> 
    */
    'street'?: string;
    /**
    * Applicable for Elavon Americas (elavonamericas), RUPAY, American Express Direct (amexdirect) and TSYS (tsys) processors.  Validation details (for selected processors)...  <table> <thead><tr><th>Processor</th><th>Acceptance Type</th><th>Required</th><th>Min. Length</th><th>Max. Length</th><th>Regex</th></tr></thead> <tr><td>American Express Direct</td><td>cnp, cp, hybrid</td><td>Yes</td><td>1</td><td>15</td><td>^[0-9a-zA-Z\\s]+$</td></tr> </table> 
    */
    'zip'?: string;
    /**
    * Applicable for RUPAY and American Express Direct (amexdirect) processors.  Validation details (for selected processors)...  <table> <thead><tr><th>Processor</th><th>Acceptance Type</th><th>Required</th><th>Min. Length</th><th>Max. Length</th><th>Regex</th></tr></thead> <tr><td>American Express Direct</td><td>cnp, hybrid</td><td>Yes</td><td>1</td><td>40</td><td>URL</td></tr> <tr><td>American Express Direct</td><td>cp</td><td>No</td><td>1</td><td>40</td><td>URL</td></tr> </table> 
    */
    'url'?: string;
    /**
    * Country Cf Origin of merchant is applicable for VPC Processors and is dependent on governmentControlled attribute.
    */
    'countryOfOrigin'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "city",
            "baseName": "city",
            "type": "string"
        },
        {
            "name": "country",
            "baseName": "country",
            "type": "string"
        },
        {
            "name": "phone",
            "baseName": "phone",
            "type": "string"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "string"
        },
        {
            "name": "street",
            "baseName": "street",
            "type": "string"
        },
        {
            "name": "zip",
            "baseName": "zip",
            "type": "string"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        },
        {
            "name": "countryOfOrigin",
            "baseName": "countryOfOrigin",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CardProcessingConfigCommonMerchantDescriptorInformation.attributeTypeMap;
    }
}

export class CardProcessingConfigCommonPaymentTypes {
    'enabled'?: boolean;
    /**
    * Three-character [ISO 4217 ALPHA-3 Standard Currency Codes.](http://apps.cybersource.com/library/documentation/sbc/quickref/currencies.pdf)
    */
    'currencies'?: { [key: string]: CardProcessingConfigCommonCurrencies; };

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "enabled",
            "baseName": "enabled",
            "type": "boolean"
        },
        {
            "name": "currencies",
            "baseName": "currencies",
            "type": "{ [key: string]: CardProcessingConfigCommonCurrencies; }"
        }    ];

    static getAttributeTypeMap() {
        return CardProcessingConfigCommonPaymentTypes.attributeTypeMap;
    }
}

export class CardProcessingConfigCommonProcessors {
    /**
    * Determines the batching group that separates merchants for special batching times. Batching groups can separate merchant batches by the following criteria:  * Timezone * Merchant deadlines * Large merchants (top 10) * Merchants with Service-Level Agreements  Applicable for Chase Paymentech Salem (chasepaymentechsalem), Streamline (streamline2), Six (six), Barclays (barclays2), Paymentech Tampa (paymentechtampa), CMCIC (cmcic), FDC Nashville (smartfdc), RUPAY, American Express Direct (amexdirect), GPN (gpn), VPC, GPX (gpx), CB2A, Barclays HISO (barclayshiso), TSYS (tsys) and FDI Global (fdiglobal) processors.  Validation details (for selected processors)...  <table> <thead><tr><th>Processor</th><th>Acceptance Type</th><th>Required</th></tr></thead> <tr><td>Barclays</td><td>cnp, cp, hybrid</td><td>Yes</td></tr> <tr><td>Barclays HISO</td><td>cnp, cp, hybrid</td><td>Yes</td></tr> <tr><td>American Express Direct</td><td>cnp, cp, hybrid</td><td>No</td></tr> </table> 
    */
    'batchGroup'?: string;
    /**
    * Indicates the type of money transfer used in the transaction. Applicable for VPC and GPX (gpx) processors.
    */
    'businessApplicationId'?: string;
    /**
    * Identify merchants that participate in Select Merchant Fee (SMF) programs. Unique to the merchant. Applicable for GPX (gpx) and VPC processors.
    */
    'merchantVerificationValue'?: string;
    /**
    * Routing Number to identify banks within the United States. Applicable for GPX (gpx) processors.
    */
    'abaNumber'?: string;
    'acquirer'?: CardProcessingConfigCommonAcquirer;
    /**
    * Merchant ID assigned by an acquirer or a processor. Should not be overriden by any other party.  Validation details (for selected processors)...  <table> <thead><tr><th>Processor</th><th>Acceptance Type</th><th>Required</th><th>Min. Length</th><th>Max. Length</th><th>Regex</th></tr></thead> <tr><td>Barclays HISO</td><td>cp, cnp, hybrid</td><td>Yes</td><td>1</td><td>15</td><td>^[0-9a-zA-Z]+$</td></tr> <tr><td>Barclays</td><td>cp, cnp, hybrid</td><td>Yes</td><td>1</td><td>11</td><td>^[0-9a-zA-Z]+$</td></tr> </table> 
    */
    'merchantId': string;
    /**
    * The 'Terminal Id' aka TID, is an identifier used for with your payments processor. Depending on the processor and payment acceptance type this may also be the default Terminal ID used for Card Present and Virtual Terminal transactions.  Validation details (for selected processors)...  <table> <thead><tr><th>Processor</th><th>Acceptance Type</th><th>Required</th><th>Min. Length</th><th>Max. Length</th><th>Regex</th></tr></thead> <tr><td>Barclays HISO</td><td>cnp, hybrid</td><td>Yes</td><td>1</td><td>16</td><td>^[0-9a-zA-Z]+$</td></tr> <tr><td>Barclays HISO</td><td>cp</td><td>No</td><td>1</td><td>16</td><td>^[0-9a-zA-Z]+$</td></tr> </table> 
    */
    'terminalId'?: string;
    /**
    * Valid values are: * VISA * MASTERCARD * AMERICAN_EXPRESS * CUP * EFTPOS * DINERS_CLUB * DISCOVER * JCB 
    */
    'paymentTypes'?: { [key: string]: CardProcessingConfigCommonPaymentTypes; };
    /**
    * Three-character [ISO 4217 ALPHA-3 Standard Currency Codes.](http://apps.cybersource.com/library/documentation/sbc/quickref/currencies.pdf)
    */
    'currencies'?: { [key: string]: CardProcessingConfigCommonCurrencies1; };
    /**
    * This field is used as aggregator Id when Visa payment type is selected
    */
    'visaAggregatorId'?: string;
    /**
    * This field is used as aggregator Id when Amex payment type is selected
    */
    'amexAggregatorId'?: string;
    /**
    * This field is used as aggregator Id when Master Card payment type is selected
    */
    'masterCardAggregatorId'?: string;
    /**
    * The Standard Industrial Classification (SIC) are four-digit codes that categorize the industries that companies belong to based on their business activities. Standard Industrial Classification codes were mostly replaced by the six-digit North American Industry Classification System (NAICS). Applicable for VPC and GPX (gpx) processors.
    */
    'sicCode'?: string;
    /**
    * Allows multiple captures for a single authorization transaction. Applicable for Paymentech Tampa (paymentechtampa), VPC, American Express Direct (amexdirect) and GPX (gpx) processors.  Validation details (for selected processors)...  <table> <thead><tr><th>Processor</th><th>Acceptance Type</th><th>Required</th><th>Default Value</th></tr></thead> <tr><td>American Express Direct</td><td>cp, hybrid</td><td>Yes</td><td>No</td></tr> <tr><td>American Express Direct</td><td>cnp</td><td>No</td><td>No</td></tr> </table> 
    */
    'allowMultipleBills'?: boolean;
    /**
    * Enables partner to enable/disable merchant descriptors values. Applicable for VPC, EFTPOS and CUP processors.
    */
    'allowMerchantDescriptorOverride'?: boolean;
    /**
    * To enable airline transactions. Applicable for TSYS (tsys), VPC, Elavon Americas (elavonamericas), FDI Global (fdiglobal), GPX (gpx), Barclays (barclays2) and American Express Direct (amexdirect) processors.  Validation details (for selected processors)...  <table> <thead><tr><th>Processor</th><th>Acceptance Type</th><th>Required</th></tr></thead> <tr><td>Barclays</td><td>cnp, cp, hybrid</td><td>No</td></tr> <tr><td>American Express Direct</td><td>cp, cnp, hybrid</td><td>No</td></tr> </table> 
    */
    'enhancedData'?: string;
    /**
    * Indicates whether the merchant is compliant with Hotel and Motel Fire Safety Act of 1990. Applicable for GPX (gpx) and VPC processors.
    */
    'fireSafetyIndicator'?: boolean;
    /**
    * To enable quasi-cash transactions. A quasi-cash transaction is a cash-like transaction for the sale of items that are directly convertible to cash, such as:- Casino gaming chips, Money orders, Wire transfers.  Applicable for GPX (gpx), TSYS (tsys), Barclays (barclays2) and VPC processors.  Validation details (for selected processors)...  <table> <thead><tr><th>Processor</th><th>Acceptance Type</th><th>Required</th><th>Default Value</th></tr></thead> <tr><td>Barclays</td><td>cnp, cp, hybrid</td><td>No</td><td>No</td></tr> </table> 
    */
    'quasiCash'?: boolean;
    /**
    * Identifier assigned by the acquirer. Applicable for RUPAY, VPC and Six (six) processors.
    */
    'acquirerMerchantId'?: string;
    /**
    * Enables Enhanced AVS/Automated Address Verification Plus (AAV+).  Valid values: \"basic\" - Standard address verification system.   When a processor supports AVS for a transaction’s card type, the issuing bank uses AVS to confirm that the customer has provided the correct billing address.   When a customer provides incorrect information, the transaction might be fraudulent. \"basic + name\" - Enhanced address verification system.   Consists of the standard AVS functionality plus verification of some additional fields.   The additional fields that are verified for Enhanced AVS are:   - customer_firstname   - customer_lastname \"basic + name + shipto\" - Automated address verification plus.   Consists of the Enhanced AVS functionality plus verification of some additional fields.   AAV+ intended for merchants who deliver physical goods to a different address than the billing address.   AAV+ verifies the additional fields only when the standard and Enhanced AVS tests pass first.   For information about Enhanced AVS - The additional fields that are verified for AAV+ are:   - ship_to_firstname   - ship_to_lastname   - ship_to_address1   - ship_to_country   - ship_to_zip   - ship_to_phone   - customer_phone(American Express Direct only)  Applicable for American Express Direct (amexdirect) processor.  Validation details (for selected processors)...  <table> <thead><tr><th>Processor</th><th>Acceptance Type</th><th>Required</th><th>Default Value</th></tr></thead> <tr><td>American Express Direct</td><td>cnp, cp, hybrid</td><td>Yes</td><td>basic</td></tr> </table> 
    */
    'avsFormat'?: string;
    /**
    * Amex Direct specific merchant config value which determines what length (either 9 or Unique 12-char reference number) of reference number will be CYBS generated if the merchant does not pass in a trans_ref_no. Can be any combination of alpha, numeric and special characters, and/or binary data in hexadecimal.  Applicable for American Express Direct (amexdirect) processor.  Validation details (for selected processors)...  <table> <thead><tr><th>Processor</th><th>Acceptance Type</th><th>Required</th><th>Default Value</th></tr></thead> <tr><td>American Express Direct</td><td>cp, cnp, hybrid</td><td>No</td><td>No</td></tr> </table> 
    */
    'enableLongTransRefNo'?: boolean;
    /**
    * Field that indicates whether merchant will send level 2 data for Amex cards. Applicable for American Express Direct (amexdirect) processor.  Validation details (for selected processors)...  <table> <thead><tr><th>Processor</th><th>Acceptance Type</th><th>Required</th><th>Default Value</th></tr></thead> <tr><td>American Express Direct</td><td>cp, cnp, hybrid</td><td>No</td><td>No</td></tr> </table> 
    */
    'enableLevel2'?: boolean;
    /**
    * This flag related to multiple transaction advice addendum field. It is used to display descriptive information about a transaction on customer’s American Express card statement. Applicable for American Express Direct (amexdirect) processor.  Validation details (for selected processors)...  <table> <thead><tr><th>Processor</th><th>Acceptance Type</th><th>Required</th><th>Default Value</th></tr></thead> <tr><td>American Express Direct</td><td>cp, cnp, hybrid</td><td>No</td><td>No</td></tr> </table> 
    */
    'enableMultipleTransactionAdviceAddendum'?: boolean;
    /**
    * Advice addendum field. It is used to display descriptive information about a transaction on customer’s American Express card statement. Applicable for TSYS (tsys), FDI Global (fdiglobal) and American Express Direct (amexdirect) processors.  Validation details (for selected processors)...  <table> <thead><tr><th>Processor</th><th>Acceptance Type</th><th>Required</th><th>Min. Length</th><th>Max. Length</th><th>Regex</th></tr></thead> <tr><td>American Express Direct</td><td>cnp, cp, hybrid</td><td>No</td><td>1</td><td>40</td><td>^[0-9a-zA-Z&#92;-\\s.]+$</td></tr> </table> 
    */
    'amexTransactionAdviceAddendum1'?: string;
    /**
    * This flag is related to offer/line item details to be included instead of sending one line item, and a grand total. Example, offer0, offer 1...offer n. Applicable for American Express Direct (amexdirect) and Elavon Americas (elavonamericas) processors.  Validation details (for selected processors)...  <table> <thead><tr><th>Processor</th><th>Acceptance Type</th><th>Required</th><th>Default Value</th></tr></thead> <tr><td>American Express Direct</td><td>cp, cnp, hybrid</td><td>No</td><td>No</td></tr> </table> 
    */
    'enableMultiLineItems'?: boolean;
    /**
    * To enable merchant to send in transaction reference number (unique reconciliation ID). Applicable for VPC, Vero (vero), FDI Global (fdiglobal), Six (six), CB2A, CUP, VPC, Chase Paymentech Salem (chasepaymentechsalem), Fiserv (fiserv), Elavon Americas (elavonamericas) and EFTPOS processors.
    */
    'enableTransactionReferenceNumber'?: boolean;
    /**
    * Enables to meet the Visa mandate requirements to reverse unused authorizations, benefitting the customer by releasing the hold on unused credit card funds. Applicable for CB2A, Elavon Americas (elavonamericas), Six (six), VPC and American Express Direct (amexdirect) processors.  Validation details (for selected processors)...  <table> <thead><tr><th>Processor</th><th>Acceptance Type</th><th>Required</th><th>Default Value</th></tr></thead> <tr><td>American Express Direct</td><td>cp, cnp, hybrid</td><td>No</td><td>No</td></tr> </table> 
    */
    'enableAutoAuthReversalAfterVoid'?: boolean;
    /**
    * When this is enabled, authorization responses from American Express expresspay transactions include the Primary Account Number (PAN) and expiration date of the card. Applicable for American Express Direct (amexdirect) processor.
    */
    'enableExpresspayPanTranslation'?: boolean;
    /**
    * Authorizes a credit. Reduces refund chargebacks and prevents customers from seeing the online update for credits which are otherwise offline settlements.
    */
    'enableCreditAuth'?: boolean;
    /**
    * Field used to identify the industry type of the merchant submitting the authorization request.  Valid values: `0` – unknown or unsure `A` – auto rental (EMV supported) `B` – bank/financial institution (EMV supported) `D` – direct marketing `F` – food/restaurant (EMV supported) `G` – grocery store/super market (EMV supported) `H` – hotel (EMV supported) `L` – limited amount terminal (EMV supported) `O` – oil company/automated fueling system (EMV supported) `P` – passenger transport (EMV supported) `R` – retail (EMV supported) Applicable for TSYS (tsys), RUPAY and Elavon Americas (elavonamericas) processors. 
    */
    'industryCode'?: CardProcessingConfigCommonProcessors.IndustryCodeEnum;
    /**
    * Field that indicates whether merchant will send level 2 data for Amex cards. Applicable for TSYS (tsys) processor.
    */
    'sendAmexLevel2Data'?: boolean;
    /**
    * A soft descriptor is a text, rendered on a cardholder’s statement, describing a particular product or service, purchased by the cardholder. Descriptors are intended to help the cardholder identify the products or services purchased. Valid values: `1` - trans_ref_no `2` - merchant_descriptor `3` - trans_ref_no and merchant_descriptor Applicable for TSYS (tsys) processor. 
    */
    'softDescriptorType'?: string;
    /**
    * V-number provided by TSYS info. The leading `V` must be replaced by a `7`. For example, replace `V1234567` with `71234567`. Applicable for TSYS (tsys) processor.
    */
    'vitalNumber'?: string;
    /**
    * 6 digit agent bank number provided by acquirer. Applicable for TSYS (tsys) processor.
    */
    'bankNumber'?: string;
    /**
    * 6 digit chain number provided by acquirer. Applicable for TSYS (tsys) processor.
    */
    'chainNumber'?: string;
    /**
    * 6 digits acquirer bank identification number. Applicable for TSYS (tsys) processor.
    */
    'merchantBinNumber'?: string;
    /**
    * 5 digit merchant location number. Unless otherwise specified by merchant’s bank or processor, this field should default to 00001. Applicable for TSYS (tsys) processor.
    */
    'merchantLocationNumber'?: string;
    /**
    * 4 digits number used to identify a specific merchant store location within the member systems. Applicable for TSYS (tsys) processor.
    */
    'storeID'?: string;
    /**
    * Contains travel agency code if airline ticket was issued by a travel agency. Applicable for TSYS (tsys) processor.
    */
    'travelAgencyCode'?: string;
    /**
    * Contains travel agency name if airline ticket was issued by travel agency. Applicable for TSYS (tsys) processor.
    */
    'travelAgencyName'?: string;
    /**
    * This field is used to indicate Merchant's settlement currency. [ISO 4217 ALPHA-3 Standard Currency Codes] Applicable for TSYS (tsys) and Streamline (streamline2) processors.
    */
    'settlementCurrency'?: string;
    /**
    * Indicates whether Least Cost Routing is enabled. Applicable for EFTPOS and CUP processors.
    */
    'enableLeastCostRouting'?: boolean;
    /**
    * This field denotes EFTPOS Merchant's choice of receiving CVV Processing Response in return. Applicable for EFTPOS processors.
    */
    'enableCVVResponseIndicator'?: boolean;
    /**
    * Applicable for Barclays (barclays2) processor.  Validation details (for selected processors)...  <table> <thead><tr><th>Processor</th><th>Acceptance Type</th><th>Required</th><th>Default Value</th></tr></thead> <tr><td>Barclays</td><td>cnp, cp, hybrid</td><td>No</td><td>Yes</td></tr> </table> 
    */
    'enableMultiCurrencyProcessing'?: string;
    /**
    * ‘POS Network Switching’ or ‘Alternate Routing’ means merchant can process PIN Debit transactions without a PIN. Set the value to ‘Yes’ if it is supported. Applicable for FDI Global (fdiglobal) processor.
    */
    'enablePosNetworkSwitching'?: boolean;
    /**
    * Enable dynamic currency conversion for a merchant.
    */
    'enableDynamicCurrencyConversion'?: boolean;
    /**
    * Merchant Tier defines the type of merchant, the numeric Merchant Tier value is allocated by EFTPOS. Applicable for EFTPOS processors.
    */
    'merchantTier'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "batchGroup",
            "baseName": "batchGroup",
            "type": "string"
        },
        {
            "name": "businessApplicationId",
            "baseName": "businessApplicationId",
            "type": "string"
        },
        {
            "name": "merchantVerificationValue",
            "baseName": "merchantVerificationValue",
            "type": "string"
        },
        {
            "name": "abaNumber",
            "baseName": "abaNumber",
            "type": "string"
        },
        {
            "name": "acquirer",
            "baseName": "acquirer",
            "type": "CardProcessingConfigCommonAcquirer"
        },
        {
            "name": "merchantId",
            "baseName": "merchantId",
            "type": "string"
        },
        {
            "name": "terminalId",
            "baseName": "terminalId",
            "type": "string"
        },
        {
            "name": "paymentTypes",
            "baseName": "paymentTypes",
            "type": "{ [key: string]: CardProcessingConfigCommonPaymentTypes; }"
        },
        {
            "name": "currencies",
            "baseName": "currencies",
            "type": "{ [key: string]: CardProcessingConfigCommonCurrencies1; }"
        },
        {
            "name": "visaAggregatorId",
            "baseName": "visaAggregatorId",
            "type": "string"
        },
        {
            "name": "amexAggregatorId",
            "baseName": "amexAggregatorId",
            "type": "string"
        },
        {
            "name": "masterCardAggregatorId",
            "baseName": "masterCardAggregatorId",
            "type": "string"
        },
        {
            "name": "sicCode",
            "baseName": "sicCode",
            "type": "string"
        },
        {
            "name": "allowMultipleBills",
            "baseName": "allowMultipleBills",
            "type": "boolean"
        },
        {
            "name": "allowMerchantDescriptorOverride",
            "baseName": "allowMerchantDescriptorOverride",
            "type": "boolean"
        },
        {
            "name": "enhancedData",
            "baseName": "enhancedData",
            "type": "string"
        },
        {
            "name": "fireSafetyIndicator",
            "baseName": "fireSafetyIndicator",
            "type": "boolean"
        },
        {
            "name": "quasiCash",
            "baseName": "quasiCash",
            "type": "boolean"
        },
        {
            "name": "acquirerMerchantId",
            "baseName": "acquirerMerchantId",
            "type": "string"
        },
        {
            "name": "avsFormat",
            "baseName": "avsFormat",
            "type": "string"
        },
        {
            "name": "enableLongTransRefNo",
            "baseName": "enableLongTransRefNo",
            "type": "boolean"
        },
        {
            "name": "enableLevel2",
            "baseName": "enableLevel2",
            "type": "boolean"
        },
        {
            "name": "enableMultipleTransactionAdviceAddendum",
            "baseName": "enableMultipleTransactionAdviceAddendum",
            "type": "boolean"
        },
        {
            "name": "amexTransactionAdviceAddendum1",
            "baseName": "amexTransactionAdviceAddendum1",
            "type": "string"
        },
        {
            "name": "enableMultiLineItems",
            "baseName": "enableMultiLineItems",
            "type": "boolean"
        },
        {
            "name": "enableTransactionReferenceNumber",
            "baseName": "enableTransactionReferenceNumber",
            "type": "boolean"
        },
        {
            "name": "enableAutoAuthReversalAfterVoid",
            "baseName": "enableAutoAuthReversalAfterVoid",
            "type": "boolean"
        },
        {
            "name": "enableExpresspayPanTranslation",
            "baseName": "enableExpresspayPanTranslation",
            "type": "boolean"
        },
        {
            "name": "enableCreditAuth",
            "baseName": "enableCreditAuth",
            "type": "boolean"
        },
        {
            "name": "industryCode",
            "baseName": "industryCode",
            "type": "CardProcessingConfigCommonProcessors.IndustryCodeEnum"
        },
        {
            "name": "sendAmexLevel2Data",
            "baseName": "sendAmexLevel2Data",
            "type": "boolean"
        },
        {
            "name": "softDescriptorType",
            "baseName": "softDescriptorType",
            "type": "string"
        },
        {
            "name": "vitalNumber",
            "baseName": "vitalNumber",
            "type": "string"
        },
        {
            "name": "bankNumber",
            "baseName": "bankNumber",
            "type": "string"
        },
        {
            "name": "chainNumber",
            "baseName": "chainNumber",
            "type": "string"
        },
        {
            "name": "merchantBinNumber",
            "baseName": "merchantBinNumber",
            "type": "string"
        },
        {
            "name": "merchantLocationNumber",
            "baseName": "merchantLocationNumber",
            "type": "string"
        },
        {
            "name": "storeID",
            "baseName": "storeID",
            "type": "string"
        },
        {
            "name": "travelAgencyCode",
            "baseName": "travelAgencyCode",
            "type": "string"
        },
        {
            "name": "travelAgencyName",
            "baseName": "travelAgencyName",
            "type": "string"
        },
        {
            "name": "settlementCurrency",
            "baseName": "settlementCurrency",
            "type": "string"
        },
        {
            "name": "enableLeastCostRouting",
            "baseName": "enableLeastCostRouting",
            "type": "boolean"
        },
        {
            "name": "enableCVVResponseIndicator",
            "baseName": "enableCVVResponseIndicator",
            "type": "boolean"
        },
        {
            "name": "enableMultiCurrencyProcessing",
            "baseName": "enableMultiCurrencyProcessing",
            "type": "string"
        },
        {
            "name": "enablePosNetworkSwitching",
            "baseName": "enablePosNetworkSwitching",
            "type": "boolean"
        },
        {
            "name": "enableDynamicCurrencyConversion",
            "baseName": "enableDynamicCurrencyConversion",
            "type": "boolean"
        },
        {
            "name": "merchantTier",
            "baseName": "merchantTier",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CardProcessingConfigCommonProcessors.attributeTypeMap;
    }
}

export namespace CardProcessingConfigCommonProcessors {
    export enum IndustryCodeEnum {
        _0 = <any> '0',
        A = <any> 'A',
        B = <any> 'B',
        D = <any> 'D',
        F = <any> 'F',
        G = <any> 'G',
        H = <any> 'H',
        L = <any> 'L',
        O = <any> 'O',
        P = <any> 'P',
        R = <any> 'R'
    }
}
export class CardProcessingConfigFeatures {
    'cardNotPresent'?: CardProcessingConfigFeaturesCardNotPresent;
    'cardPresent'?: CardProcessingConfigFeaturesCardPresent;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "cardNotPresent",
            "baseName": "cardNotPresent",
            "type": "CardProcessingConfigFeaturesCardNotPresent"
        },
        {
            "name": "cardPresent",
            "baseName": "cardPresent",
            "type": "CardProcessingConfigFeaturesCardPresent"
        }    ];

    static getAttributeTypeMap() {
        return CardProcessingConfigFeatures.attributeTypeMap;
    }
}

export class CardProcessingConfigFeaturesCardNotPresent {
    /**
    * e.g. * amexdirect * barclays2 * CUP * EFTPOS * fdiglobal * gpx * smartfdc * tsys * vero * VPC  For VPC, CUP and EFTPOS processors, replace the processor name from VPC or CUP or EFTPOS to the actual processor name in the sample request. e.g. replace VPC with &lt;your vpc processor&gt; 
    */
    'processors'?: { [key: string]: CardProcessingConfigFeaturesCardNotPresentProcessors; };
    /**
    * Flag for a sale request that indicates whether to allow the capture service to run even when the authorization receives an AVS decline. Applicable for VPC, FDI Global (fdiglobal), GPX (gpx) and GPN (gpn) processors.
    */
    'ignoreAddressVerificationSystem'?: boolean;
    /**
    * Indicates if a merchant is enabled for Straight Through Processing - B2B invoice payments. Applicable for FDI Global (fdiglobal), TSYS (tsys), VPC and GPX (gpx) processors.
    */
    'visaStraightThroughProcessingOnly'?: boolean;
    /**
    * Advice addendum field. It is used to display descriptive information about a transaction on customer’s American Express card statement. Applicable for TSYS (tsys), FDI Global (fdiglobal) and American Express Direct (amexdirect) processors.
    */
    'amexTransactionAdviceAddendum1'?: string;
    'installment'?: CardProcessingConfigFeaturesCardNotPresentInstallment;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "processors",
            "baseName": "processors",
            "type": "{ [key: string]: CardProcessingConfigFeaturesCardNotPresentProcessors; }"
        },
        {
            "name": "ignoreAddressVerificationSystem",
            "baseName": "ignoreAddressVerificationSystem",
            "type": "boolean"
        },
        {
            "name": "visaStraightThroughProcessingOnly",
            "baseName": "visaStraightThroughProcessingOnly",
            "type": "boolean"
        },
        {
            "name": "amexTransactionAdviceAddendum1",
            "baseName": "amexTransactionAdviceAddendum1",
            "type": "string"
        },
        {
            "name": "installment",
            "baseName": "installment",
            "type": "CardProcessingConfigFeaturesCardNotPresentInstallment"
        }    ];

    static getAttributeTypeMap() {
        return CardProcessingConfigFeaturesCardNotPresent.attributeTypeMap;
    }
}

export class CardProcessingConfigFeaturesCardNotPresentInstallment {
    /**
    * This flag is to enable for installment plan programs. Applicable for Fiserv (fiserv), Vero (vero) and American Express Direct (amexdirect) processors.  Validation details (for selected processors)...  <table> <thead><tr><th>Processor</th><th>Acceptance Type</th><th>Required</th><th>Default Value</th></tr></thead> <tr><td>American Express Direct</td><td>cnp</td><td>No</td><td>No</td></tr> </table> 
    */
    'enableInstallment'?: boolean;
    /**
    * This indicates the type of funding for the installment plan associated with the payment.  Valid values: \"merchant\" - Merchant-funded installment plan \"issuer\" - Issuer-funded installment plan  Applicable for Fiserv (fiserv), American Express Direct (amexdirect) and Vero (vero) processors.  Validation details (for selected processors)...  <table> <thead><tr><th>Processor</th><th>Acceptance Type</th><th>Required</th></tr></thead> <tr><td>American Express Direct</td><td>cnp</td><td>No</td></tr> </table> 
    */
    'installmentPlan'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "enableInstallment",
            "baseName": "enableInstallment",
            "type": "boolean"
        },
        {
            "name": "installmentPlan",
            "baseName": "installmentPlan",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CardProcessingConfigFeaturesCardNotPresentInstallment.attributeTypeMap;
    }
}

export class CardProcessingConfigFeaturesCardNotPresentPayouts {
    /**
    * Applicable for VPC processors.
    */
    'reimbursementCode'?: string;
    /**
    * This code identifies the financial institution acting as the acquirer of this customer transaction. The acquirer is the member or system user that signed the merchant. This number is usually a Visa-assigned. Applicable for VPC processors.
    */
    'acquiringInstitutionId'?: string;
    /**
    * Transaction type. List of supported identifiers documented in the Developer Guide. Applicable for GPX (gpx) and VPC processors.
    */
    'businessApplicationId'?: string;
    /**
    * Applicable for GPX (gpx) and VPC processors.
    */
    'financialInstitutionId'?: string;
    /**
    * Routing Number to identify banks within the United States. Applicable for VPC processors.
    */
    'merchantAbaNumber'?: string;
    /**
    * Order of the networks in which Visa should make routing decisions. Applicable for VPC processors.
    */
    'networkOrder'?: string;
    /**
    * Three-character [ISO 4217 ALPHA-3 Standard Currency Codes.](http://apps.cybersource.com/library/documentation/sbc/quickref/currencies.pdf)
    */
    'currencies'?: { [key: string]: CardProcessingConfigFeaturesCardNotPresentPayoutsCurrencies; };
    /**
    * Merchant ID assigned by an acquirer or a processor. Should not be overridden by any other party.  Validation details (for selected processors)...  <table> <thead><tr><th>Processor</th><th>Acceptance Type</th><th>Required</th><th>Min. Length</th><th>Max. Length</th><th>Regex</th></tr></thead> <tr><td>Barclays</td><td>cnp, hybrid</td><td>No</td><td>1</td><td>11</td><td>^[0-9]+$</td></tr> </table> 
    */
    'merchantId'?: string;
    /**
    * The 'Terminal Id' aka TID, is an identifier used for with your payments processor. Depending on the processor and payment acceptance type this may also be the default Terminal ID used for Card Present and Virtual Terminal transactions.  Validation details (for selected processors)...  <table> <thead><tr><th>Processor</th><th>Acceptance Type</th><th>Required</th><th>Min. Length</th><th>Max. Length</th><th>Regex</th></tr></thead> <tr><td>Barclays</td><td>cnp, hybrid</td><td>No</td><td>1</td><td>255</td><td>^[0-9:&#92;-]+$</td></tr> </table> 
    */
    'terminalId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "reimbursementCode",
            "baseName": "reimbursementCode",
            "type": "string"
        },
        {
            "name": "acquiringInstitutionId",
            "baseName": "acquiringInstitutionId",
            "type": "string"
        },
        {
            "name": "businessApplicationId",
            "baseName": "businessApplicationId",
            "type": "string"
        },
        {
            "name": "financialInstitutionId",
            "baseName": "financialInstitutionId",
            "type": "string"
        },
        {
            "name": "merchantAbaNumber",
            "baseName": "merchantAbaNumber",
            "type": "string"
        },
        {
            "name": "networkOrder",
            "baseName": "networkOrder",
            "type": "string"
        },
        {
            "name": "currencies",
            "baseName": "currencies",
            "type": "{ [key: string]: CardProcessingConfigFeaturesCardNotPresentPayoutsCurrencies; }"
        },
        {
            "name": "merchantId",
            "baseName": "merchantId",
            "type": "string"
        },
        {
            "name": "terminalId",
            "baseName": "terminalId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CardProcessingConfigFeaturesCardNotPresentPayouts.attributeTypeMap;
    }
}

export class CardProcessingConfigFeaturesCardNotPresentPayoutsCurrencies {
    'enabled'?: boolean;
    /**
    * Indicates whether the card-present transaction is activated for the selected currency. If both enabledCardPresent and enabledCardNotPresent are set to null, then enabledCardPresent will have the value of enabled. 
    */
    'enabledCardPresent'?: boolean;
    /**
    * Indicates whether the card-present transaction is activated for the selected currency. If both enabledCardPresent and enabledCardNotPresent are set to null, then enabledCardNotPresent will have the value of enabled. 
    */
    'enabledCardNotPresent'?: boolean;
    /**
    * Merchant ID assigned by an acquirer or a processor. Should not be overriden by any other party.
    */
    'merchantId'?: string;
    /**
    * The 'Terminal Id' aka TID, is an identifier used for with your payments processor. Depending on the processor and payment acceptance type this may also be the default Terminal ID used for Card Present and Virtual Terminal transactions. 
    */
    'terminalId'?: string;
    /**
    * Applicable for Prisma (prisma) processor.
    */
    'terminalIds'?: Array<string>;
    /**
    * Service Establishment Number (a.k.a. SE Number) is a unique ten-digit number assigned by American Express to a merchant that accepts American Express cards. 10 digit number provided by acquirer currency. This may be unique for each currency, however it depends on the way the processor is set up for the merchant. 
    */
    'serviceEnablementNumber'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "enabled",
            "baseName": "enabled",
            "type": "boolean"
        },
        {
            "name": "enabledCardPresent",
            "baseName": "enabledCardPresent",
            "type": "boolean"
        },
        {
            "name": "enabledCardNotPresent",
            "baseName": "enabledCardNotPresent",
            "type": "boolean"
        },
        {
            "name": "merchantId",
            "baseName": "merchantId",
            "type": "string"
        },
        {
            "name": "terminalId",
            "baseName": "terminalId",
            "type": "string"
        },
        {
            "name": "terminalIds",
            "baseName": "terminalIds",
            "type": "Array<string>"
        },
        {
            "name": "serviceEnablementNumber",
            "baseName": "serviceEnablementNumber",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CardProcessingConfigFeaturesCardNotPresentPayoutsCurrencies.attributeTypeMap;
    }
}

export class CardProcessingConfigFeaturesCardNotPresentProcessors {
    /**
    * Enables you to submit the payment transaction without one or more of the fields for the billTo or card_expiration. Applicable for Elavon Americas (elavonamericas), CB2A, Six (six), CMCIC (cmcic), GPX (gpx), GPN (gpn), VPC, Vero (vero), Fiserv (fiserv), American Express Direct (amexdirect), Chase Paymentech Salem (chasepaymentechsalem), RUPAY, FDI Global (fdiglobal) and Barclays HISO (barclayshiso) processors.  Validation details (for selected processors)...  <table> <thead><tr><th>Processor</th><th>Acceptance Type</th><th>Required</th><th>Default Value</th></tr></thead> <tr><td>Barclays HISO</td><td>cp, cnp, hybrid</td><td>No</td><td>Yes</td></tr> <tr><td>American Express Direct</td><td>cnp</td><td>No</td><td>No</td></tr> <tr><td>American Express Direct</td><td>cp</td><td>No</td><td>Yes</td></tr> <tr><td>American Express Direct</td><td>hybrid</td><td>Yes</td><td>Yes</td></tr> </table> 
    */
    'relaxAddressVerificationSystem'?: boolean;
    /**
    * Allows Zip code without country. Applicable for American Express Direct (amexdirect), GPX (gpx), VPC, FDI Global (fdiglobal), Elavon Americas (elavonamericas), Chase Paymentech Salem (chasepaymentechsalem), RUPAY, GPN (gpn) and Barclays HISO (barclayshiso) processors.  Validation details (for selected processors)...  <table> <thead><tr><th>Processor</th><th>Acceptance Type</th><th>Required</th><th>Default Value</th></tr></thead> <tr><td>Barclays HISO</td><td>cp, cnp, both</td><td>No</td><td>Yes</td></tr> <tr><td>American Express Direct</td><td>cp, hybrid</td><td>No</td><td>Yes</td></tr> <tr><td>American Express Direct</td><td>cnp</td><td>No</td><td>No</td></tr> </table> 
    */
    'relaxAddressVerificationSystemAllowZipWithoutCountry'?: boolean;
    /**
    * Allows transactions that use an expired card. Applicable for American Express Direct (amexdirect), GPN (gpn), Barclays HISO (barclayshiso), Elavon Americas (elavonamericas), VPC, FDI Global (fdiglobal), GPX (gpx), RUPAY, Six (six), Chase Paymentech Salem (chasepaymentechsalem) and CB2A processors.  Validation details (for selected processors)...  <table> <thead><tr><th>Processor</th><th>Acceptance Type</th><th>Required</th><th>Default Value</th></tr></thead> <tr><td>Barclays HISO</td><td>cp, cnp, hybrid</td><td>No</td><td>Yes</td></tr> <tr><td>American Express Direct</td><td>cp, hybrid</td><td>No</td><td>Yes</td></tr> <tr><td>American Express Direct</td><td>cnp</td><td>No</td><td>No</td></tr> </table> 
    */
    'relaxAddressVerificationSystemAllowExpiredCard'?: boolean;
    /**
    * MasterCard Expert Monitoring Solutions (EMS) provides a predictive, behavior-based fraud score in real time during authorizations for card-not-present (CNP) transactions on cards issued in the U.S. Applicable for GPX (gpx) and VPC processors.
    */
    'enableEmsTransactionRiskScore'?: boolean;
    /**
    * Applicable for VPC processors.
    */
    'prestigiousPropertyIndicator'?: string;
    'payouts'?: CardProcessingConfigFeaturesCardNotPresentPayouts;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "relaxAddressVerificationSystem",
            "baseName": "relaxAddressVerificationSystem",
            "type": "boolean"
        },
        {
            "name": "relaxAddressVerificationSystemAllowZipWithoutCountry",
            "baseName": "relaxAddressVerificationSystemAllowZipWithoutCountry",
            "type": "boolean"
        },
        {
            "name": "relaxAddressVerificationSystemAllowExpiredCard",
            "baseName": "relaxAddressVerificationSystemAllowExpiredCard",
            "type": "boolean"
        },
        {
            "name": "enableEmsTransactionRiskScore",
            "baseName": "enableEmsTransactionRiskScore",
            "type": "boolean"
        },
        {
            "name": "prestigiousPropertyIndicator",
            "baseName": "prestigiousPropertyIndicator",
            "type": "string"
        },
        {
            "name": "payouts",
            "baseName": "payouts",
            "type": "CardProcessingConfigFeaturesCardNotPresentPayouts"
        }    ];

    static getAttributeTypeMap() {
        return CardProcessingConfigFeaturesCardNotPresentProcessors.attributeTypeMap;
    }
}

export class CardProcessingConfigFeaturesCardPresent {
    /**
    * e.g. * amexdirect * barclays2 * CUP * EFTPOS * fdiglobal * gpx * smartfdc * tsys * vero * VPC  For VPC, CUP and EFTPOS processors, replace the processor name from VPC or CUP or EFTPOS to the actual processor name in the sample request. e.g. replace VPC with &lt;your vpc processor&gt; 
    */
    'processors'?: { [key: string]: CardProcessingConfigFeaturesCardPresentProcessors; };
    /**
    * Used for Card Present and Virtual Terminal Transactions for Terminal ID lookup. Applicable for GPX (gpx) processor.
    */
    'enableTerminalIdLookup'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "processors",
            "baseName": "processors",
            "type": "{ [key: string]: CardProcessingConfigFeaturesCardPresentProcessors; }"
        },
        {
            "name": "enableTerminalIdLookup",
            "baseName": "enableTerminalIdLookup",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return CardProcessingConfigFeaturesCardPresent.attributeTypeMap;
    }
}

export class CardProcessingConfigFeaturesCardPresentProcessors {
    /**
    * Default Terminal ID used for Card Present and Virtual Terminal transactions. Applicable for VPC, GPX (gpx), American Express Direct (amexdirect) and Chase Paymentech Salem (chasepaymentechsalem) processors.  Validation details (for selected processors)...  <table> <thead><tr><th>Processor</th><th>Acceptance Type</th><th>Required</th><th>Min. Length</th><th>Max. Length</th><th>Regex</th><th>Default Value</th></tr></thead> <tr><td>American Express Direct</td><td>cp</td><td>Yes</td><td>4</td><td>8</td><td>^[0-9a-zA-Z]+$</td><td>1111</td></tr> </table> 
    */
    'defaultPointOfSaleTerminalId'?: string;
    /**
    * For retail transactions, if merchant chooses to send the terminal id in the API, then that value has to be validated before being used. Holds a comma separated list of all possible terminal ids that the merchant is likely to send. Applicable for VPC processors.
    */
    'pointOfSaleTerminalIds'?: Array<string>;
    /**
    * Disables terminal ID validation. Applicable for VPC processors.
    */
    'disablePointOfSaleTerminalIdValidation'?: boolean;
    /**
    * Order of the networks in which Visa should make routing decisions. Applicable for GPX (gpx) and VPC processors.
    */
    'pinDebitNetworkOrder'?: string;
    /**
    * This attribute requests VIP to qualify a given PIN Debit transaction for a certain type of interchange program. Y = SMS supermarket, Z = SMS general merchant. Applicable for GPX (gpx) and VPC processors.
    */
    'pinDebitReimbursementCode'?: string;
    /**
    * Acquirer Institution ID for the PIN Debit Transactions. Applicable for GPX (gpx) and VPC processors.
    */
    'financialInstitutionId'?: string;
    /**
    * Enables CyberSource PIN Translation for Online PIN Transactions. Please ensure you have exchanged PIN keys with CyberSource to use this feature. Applicable for VPC processors.
    */
    'enablePinTranslation'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "defaultPointOfSaleTerminalId",
            "baseName": "defaultPointOfSaleTerminalId",
            "type": "string"
        },
        {
            "name": "pointOfSaleTerminalIds",
            "baseName": "pointOfSaleTerminalIds",
            "type": "Array<string>"
        },
        {
            "name": "disablePointOfSaleTerminalIdValidation",
            "baseName": "disablePointOfSaleTerminalIdValidation",
            "type": "boolean"
        },
        {
            "name": "pinDebitNetworkOrder",
            "baseName": "pinDebitNetworkOrder",
            "type": "string"
        },
        {
            "name": "pinDebitReimbursementCode",
            "baseName": "pinDebitReimbursementCode",
            "type": "string"
        },
        {
            "name": "financialInstitutionId",
            "baseName": "financialInstitutionId",
            "type": "string"
        },
        {
            "name": "enablePinTranslation",
            "baseName": "enablePinTranslation",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return CardProcessingConfigFeaturesCardPresentProcessors.attributeTypeMap;
    }
}

export class CaseManagementActionsRequest {
    'decisionInformation': Riskv1decisionsidactionsDecisionInformation;
    'processingInformation'?: Riskv1decisionsidactionsProcessingInformation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "decisionInformation",
            "baseName": "decisionInformation",
            "type": "Riskv1decisionsidactionsDecisionInformation"
        },
        {
            "name": "processingInformation",
            "baseName": "processingInformation",
            "type": "Riskv1decisionsidactionsProcessingInformation"
        }    ];

    static getAttributeTypeMap() {
        return CaseManagementActionsRequest.attributeTypeMap;
    }
}

export class CaseManagementCommentsRequest {
    /**
    * Comments to be added to case.
    */
    'comments': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "comments",
            "baseName": "comments",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CaseManagementCommentsRequest.attributeTypeMap;
    }
}

export class CheckPayerAuthEnrollmentRequest {
    'clientReferenceInformation'?: Riskv1authenticationsetupsClientReferenceInformation;
    'orderInformation'?: Riskv1authenticationsOrderInformation;
    'paymentInformation'?: Riskv1authenticationsPaymentInformation;
    'processingInformation'?: Riskv1authenticationsetupsProcessingInformation;
    'tokenInformation'?: Riskv1authenticationsetupsTokenInformation;
    'buyerInformation'?: Riskv1authenticationsBuyerInformation;
    'deviceInformation'?: Riskv1authenticationsDeviceInformation;
    'merchantInformation'?: Riskv1decisionsMerchantInformation;
    'acquirerInformation'?: Riskv1decisionsAcquirerInformation;
    'recurringPaymentInformation'?: Ptsv2paymentsRecurringPaymentInformation;
    'consumerAuthenticationInformation'?: Riskv1decisionsConsumerAuthenticationInformation;
    'riskInformation'?: Riskv1authenticationsRiskInformation;
    'travelInformation'?: Riskv1authenticationsTravelInformation;
    'merchantDefinedInformation'?: Array<Riskv1decisionsMerchantDefinedInformation>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "clientReferenceInformation",
            "baseName": "clientReferenceInformation",
            "type": "Riskv1authenticationsetupsClientReferenceInformation"
        },
        {
            "name": "orderInformation",
            "baseName": "orderInformation",
            "type": "Riskv1authenticationsOrderInformation"
        },
        {
            "name": "paymentInformation",
            "baseName": "paymentInformation",
            "type": "Riskv1authenticationsPaymentInformation"
        },
        {
            "name": "processingInformation",
            "baseName": "processingInformation",
            "type": "Riskv1authenticationsetupsProcessingInformation"
        },
        {
            "name": "tokenInformation",
            "baseName": "tokenInformation",
            "type": "Riskv1authenticationsetupsTokenInformation"
        },
        {
            "name": "buyerInformation",
            "baseName": "buyerInformation",
            "type": "Riskv1authenticationsBuyerInformation"
        },
        {
            "name": "deviceInformation",
            "baseName": "deviceInformation",
            "type": "Riskv1authenticationsDeviceInformation"
        },
        {
            "name": "merchantInformation",
            "baseName": "merchantInformation",
            "type": "Riskv1decisionsMerchantInformation"
        },
        {
            "name": "acquirerInformation",
            "baseName": "acquirerInformation",
            "type": "Riskv1decisionsAcquirerInformation"
        },
        {
            "name": "recurringPaymentInformation",
            "baseName": "recurringPaymentInformation",
            "type": "Ptsv2paymentsRecurringPaymentInformation"
        },
        {
            "name": "consumerAuthenticationInformation",
            "baseName": "consumerAuthenticationInformation",
            "type": "Riskv1decisionsConsumerAuthenticationInformation"
        },
        {
            "name": "riskInformation",
            "baseName": "riskInformation",
            "type": "Riskv1authenticationsRiskInformation"
        },
        {
            "name": "travelInformation",
            "baseName": "travelInformation",
            "type": "Riskv1authenticationsTravelInformation"
        },
        {
            "name": "merchantDefinedInformation",
            "baseName": "merchantDefinedInformation",
            "type": "Array<Riskv1decisionsMerchantDefinedInformation>"
        }    ];

    static getAttributeTypeMap() {
        return CheckPayerAuthEnrollmentRequest.attributeTypeMap;
    }
}

export class CommerceSolutionsProducts {
    'tokenManagement'?: CommerceSolutionsProductsTokenManagement;
    'accountUpdater'?: CommerceSolutionsProductsAccountUpdater;
    'binLookup'?: CommerceSolutionsProductsBinLookup;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "tokenManagement",
            "baseName": "tokenManagement",
            "type": "CommerceSolutionsProductsTokenManagement"
        },
        {
            "name": "accountUpdater",
            "baseName": "accountUpdater",
            "type": "CommerceSolutionsProductsAccountUpdater"
        },
        {
            "name": "binLookup",
            "baseName": "binLookup",
            "type": "CommerceSolutionsProductsBinLookup"
        }    ];

    static getAttributeTypeMap() {
        return CommerceSolutionsProducts.attributeTypeMap;
    }
}

export class CommerceSolutionsProductsAccountUpdater {
    'subscriptionInformation'?: PaymentsProductsAlternativePaymentMethodsSubscriptionInformation;
    'configurationInformation'?: CommerceSolutionsProductsAccountUpdaterConfigurationInformation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "subscriptionInformation",
            "baseName": "subscriptionInformation",
            "type": "PaymentsProductsAlternativePaymentMethodsSubscriptionInformation"
        },
        {
            "name": "configurationInformation",
            "baseName": "configurationInformation",
            "type": "CommerceSolutionsProductsAccountUpdaterConfigurationInformation"
        }    ];

    static getAttributeTypeMap() {
        return CommerceSolutionsProductsAccountUpdater.attributeTypeMap;
    }
}

export class CommerceSolutionsProductsAccountUpdaterConfigurationInformation {
    'templateId'?: string;
    'configurations'?: CommerceSolutionsProductsAccountUpdaterConfigurationInformationConfigurations;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "templateId",
            "baseName": "templateId",
            "type": "string"
        },
        {
            "name": "configurations",
            "baseName": "configurations",
            "type": "CommerceSolutionsProductsAccountUpdaterConfigurationInformationConfigurations"
        }    ];

    static getAttributeTypeMap() {
        return CommerceSolutionsProductsAccountUpdaterConfigurationInformation.attributeTypeMap;
    }
}

export class CommerceSolutionsProductsAccountUpdaterConfigurationInformationConfigurations {
    'masterCard'?: CommerceSolutionsProductsAccountUpdaterConfigurationInformationConfigurationsMasterCard;
    'visa'?: CommerceSolutionsProductsAccountUpdaterConfigurationInformationConfigurationsVisa;
    'amex'?: CommerceSolutionsProductsAccountUpdaterConfigurationInformationConfigurationsAmex;
    'preferredDay'?: number;
    'daysWindow'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "masterCard",
            "baseName": "masterCard",
            "type": "CommerceSolutionsProductsAccountUpdaterConfigurationInformationConfigurationsMasterCard"
        },
        {
            "name": "visa",
            "baseName": "visa",
            "type": "CommerceSolutionsProductsAccountUpdaterConfigurationInformationConfigurationsVisa"
        },
        {
            "name": "amex",
            "baseName": "amex",
            "type": "CommerceSolutionsProductsAccountUpdaterConfigurationInformationConfigurationsAmex"
        },
        {
            "name": "preferredDay",
            "baseName": "preferredDay",
            "type": "number"
        },
        {
            "name": "daysWindow",
            "baseName": "daysWindow",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return CommerceSolutionsProductsAccountUpdaterConfigurationInformationConfigurations.attributeTypeMap;
    }
}

export class CommerceSolutionsProductsAccountUpdaterConfigurationInformationConfigurationsAmex {
    /**
    * Type of mode. Valid values are `tokenApi` or `dailyHarvest`.
    */
    'mode'?: string;
    'seNumber'?: string;
    'subscriberId'?: string;
    'active'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "mode",
            "baseName": "mode",
            "type": "string"
        },
        {
            "name": "seNumber",
            "baseName": "seNumber",
            "type": "string"
        },
        {
            "name": "subscriberId",
            "baseName": "subscriberId",
            "type": "string"
        },
        {
            "name": "active",
            "baseName": "active",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return CommerceSolutionsProductsAccountUpdaterConfigurationInformationConfigurationsAmex.attributeTypeMap;
    }
}

export class CommerceSolutionsProductsAccountUpdaterConfigurationInformationConfigurationsMasterCard {
    /**
    * MasterCard merchant identified number
    */
    'merchantId': string;
    /**
    * Number assigned by MasterCard to a financial institution, third-party processor or other member to identify the member in transaction.
    */
    'interbankCardAssociationNumber': string;
    'active'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "merchantId",
            "baseName": "merchantId",
            "type": "string"
        },
        {
            "name": "interbankCardAssociationNumber",
            "baseName": "interbankCardAssociationNumber",
            "type": "string"
        },
        {
            "name": "active",
            "baseName": "active",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return CommerceSolutionsProductsAccountUpdaterConfigurationInformationConfigurationsMasterCard.attributeTypeMap;
    }
}

export class CommerceSolutionsProductsAccountUpdaterConfigurationInformationConfigurationsVisa {
    /**
    * Visa merchant identified number
    */
    'merchantId': string;
    /**
    * Visa assigned segment ID for each group of merchants participating in VAU.
    */
    'segmentId': string;
    'active'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "merchantId",
            "baseName": "merchantId",
            "type": "string"
        },
        {
            "name": "segmentId",
            "baseName": "segmentId",
            "type": "string"
        },
        {
            "name": "active",
            "baseName": "active",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return CommerceSolutionsProductsAccountUpdaterConfigurationInformationConfigurationsVisa.attributeTypeMap;
    }
}

export class CommerceSolutionsProductsBinLookup {
    'subscriptionInformation'?: PaymentsProductsAlternativePaymentMethodsSubscriptionInformation;
    'configurationInformation'?: CommerceSolutionsProductsBinLookupConfigurationInformation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "subscriptionInformation",
            "baseName": "subscriptionInformation",
            "type": "PaymentsProductsAlternativePaymentMethodsSubscriptionInformation"
        },
        {
            "name": "configurationInformation",
            "baseName": "configurationInformation",
            "type": "CommerceSolutionsProductsBinLookupConfigurationInformation"
        }    ];

    static getAttributeTypeMap() {
        return CommerceSolutionsProductsBinLookup.attributeTypeMap;
    }
}

export class CommerceSolutionsProductsBinLookupConfigurationInformation {
    'configurations'?: CommerceSolutionsProductsBinLookupConfigurationInformationConfigurations;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "configurations",
            "baseName": "configurations",
            "type": "CommerceSolutionsProductsBinLookupConfigurationInformationConfigurations"
        }    ];

    static getAttributeTypeMap() {
        return CommerceSolutionsProductsBinLookupConfigurationInformation.attributeTypeMap;
    }
}

export class CommerceSolutionsProductsBinLookupConfigurationInformationConfigurations {
    /**
    * This flag indicates if the merchant is configured to make payout calls
    */
    'isPayoutOptionsEnabled'?: boolean;
    /**
    * This flag indicates if the merchant is configured to receive account prefix
    */
    'isAccountPrefixEnabled'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "isPayoutOptionsEnabled",
            "baseName": "isPayoutOptionsEnabled",
            "type": "boolean"
        },
        {
            "name": "isAccountPrefixEnabled",
            "baseName": "isAccountPrefixEnabled",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return CommerceSolutionsProductsBinLookupConfigurationInformationConfigurations.attributeTypeMap;
    }
}

export class CommerceSolutionsProductsTokenManagement {
    'subscriptionInformation'?: PaymentsProductsAlternativePaymentMethodsSubscriptionInformation;
    'configurationInformation'?: CommerceSolutionsProductsTokenManagementConfigurationInformation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "subscriptionInformation",
            "baseName": "subscriptionInformation",
            "type": "PaymentsProductsAlternativePaymentMethodsSubscriptionInformation"
        },
        {
            "name": "configurationInformation",
            "baseName": "configurationInformation",
            "type": "CommerceSolutionsProductsTokenManagementConfigurationInformation"
        }    ];

    static getAttributeTypeMap() {
        return CommerceSolutionsProductsTokenManagement.attributeTypeMap;
    }
}

export class CommerceSolutionsProductsTokenManagementConfigurationInformation {
    'templateId'?: string;
    'configurations'?: CommerceSolutionsProductsTokenManagementConfigurationInformationConfigurations;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "templateId",
            "baseName": "templateId",
            "type": "string"
        },
        {
            "name": "configurations",
            "baseName": "configurations",
            "type": "CommerceSolutionsProductsTokenManagementConfigurationInformationConfigurations"
        }    ];

    static getAttributeTypeMap() {
        return CommerceSolutionsProductsTokenManagementConfigurationInformation.attributeTypeMap;
    }
}

export class CommerceSolutionsProductsTokenManagementConfigurationInformationConfigurations {
    /**
    * Specify the Vault ID to which transacting MID needs to be assigned.Provide Vault ID as seen on EBC Vault management page. If not provided , transacting MID will be assigned to the existing default Vault at merchant's level. If there are no Vaults at merchant level , a new Vault will be created and transacting MID will be assigned to it.
    */
    'parentProfileId'?: string;
    'vault'?: CommerceSolutionsProductsTokenManagementConfigurationInformationConfigurationsVault;
    'networkTokenEnrollment'?: NetworkTokenEnrollment;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "parentProfileId",
            "baseName": "parentProfileId",
            "type": "string"
        },
        {
            "name": "vault",
            "baseName": "vault",
            "type": "CommerceSolutionsProductsTokenManagementConfigurationInformationConfigurationsVault"
        },
        {
            "name": "networkTokenEnrollment",
            "baseName": "networkTokenEnrollment",
            "type": "NetworkTokenEnrollment"
        }    ];

    static getAttributeTypeMap() {
        return CommerceSolutionsProductsTokenManagementConfigurationInformationConfigurations.attributeTypeMap;
    }
}

export class CommerceSolutionsProductsTokenManagementConfigurationInformationConfigurationsVault {
    /**
    * Default token type to be used. Possible Values:   - 'CUSTOMER'  - 'PAYMENT_INSTRUMENT'  - 'INSTRUMENT_IDENTIFIER' 
    */
    'defaultTokenType'?: CommerceSolutionsProductsTokenManagementConfigurationInformationConfigurationsVault.DefaultTokenTypeEnum;
    /**
    * Location where the vault will be stored.  Use 'IDC' (the Indian Data Centre) when merchant is storing token data in India  or 'GDC' (the Global Data Centre) for all other cases.  Possible Values:    - 'IDC'   - 'GDC' 
    */
    'location'?: CommerceSolutionsProductsTokenManagementConfigurationInformationConfigurationsVault.LocationEnum;
    'tokenFormats'?: TmsTokenFormats;
    'tokenPermissions'?: TokenPermissions;
    'sensitivePrivileges'?: TmsSensitivePrivileges;
    'nullify'?: TmsNullify;
    'networkTokenServices'?: TmsNetworkTokenServices;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "defaultTokenType",
            "baseName": "defaultTokenType",
            "type": "CommerceSolutionsProductsTokenManagementConfigurationInformationConfigurationsVault.DefaultTokenTypeEnum"
        },
        {
            "name": "location",
            "baseName": "location",
            "type": "CommerceSolutionsProductsTokenManagementConfigurationInformationConfigurationsVault.LocationEnum"
        },
        {
            "name": "tokenFormats",
            "baseName": "tokenFormats",
            "type": "TmsTokenFormats"
        },
        {
            "name": "tokenPermissions",
            "baseName": "tokenPermissions",
            "type": "TokenPermissions"
        },
        {
            "name": "sensitivePrivileges",
            "baseName": "sensitivePrivileges",
            "type": "TmsSensitivePrivileges"
        },
        {
            "name": "nullify",
            "baseName": "nullify",
            "type": "TmsNullify"
        },
        {
            "name": "networkTokenServices",
            "baseName": "networkTokenServices",
            "type": "TmsNetworkTokenServices"
        }    ];

    static getAttributeTypeMap() {
        return CommerceSolutionsProductsTokenManagementConfigurationInformationConfigurationsVault.attributeTypeMap;
    }
}

export namespace CommerceSolutionsProductsTokenManagementConfigurationInformationConfigurationsVault {
    export enum DefaultTokenTypeEnum {
        CUSTOMER = <any> 'CUSTOMER',
        PAYMENTINSTRUMENT = <any> 'PAYMENT_INSTRUMENT',
        INSTRUMENTIDENTIFIER = <any> 'INSTRUMENT_IDENTIFIER'
    }
    export enum LocationEnum {
        IDC = <any> 'IDC',
        GDC = <any> 'GDC'
    }
}
export class CreateAdhocReportRequest {
    /**
    * Valid CyberSource Organization Id
    */
    'organizationId'?: string;
    'reportDefinitionName'?: string;
    /**
    * List of fields which needs to get included in a report
    */
    'reportFields'?: Array<string>;
    /**
    * 'Format of the report'                  Valid values: - application/xml - text/csv 
    */
    'reportMimeType'?: string;
    /**
    * Name of the report
    */
    'reportName'?: string;
    /**
    * Timezone of the report
    */
    'timezone'?: string;
    /**
    * Start time of the report
    */
    'reportStartTime'?: Date;
    /**
    * End time of the report
    */
    'reportEndTime'?: Date;
    'reportFilters'?: Reportingv3reportsReportFilters;
    'reportPreferences'?: Reportingv3reportsReportPreferences;
    /**
    * Specifies the group name
    */
    'groupName'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "organizationId",
            "baseName": "organizationId",
            "type": "string"
        },
        {
            "name": "reportDefinitionName",
            "baseName": "reportDefinitionName",
            "type": "string"
        },
        {
            "name": "reportFields",
            "baseName": "reportFields",
            "type": "Array<string>"
        },
        {
            "name": "reportMimeType",
            "baseName": "reportMimeType",
            "type": "string"
        },
        {
            "name": "reportName",
            "baseName": "reportName",
            "type": "string"
        },
        {
            "name": "timezone",
            "baseName": "timezone",
            "type": "string"
        },
        {
            "name": "reportStartTime",
            "baseName": "reportStartTime",
            "type": "Date"
        },
        {
            "name": "reportEndTime",
            "baseName": "reportEndTime",
            "type": "Date"
        },
        {
            "name": "reportFilters",
            "baseName": "reportFilters",
            "type": "Reportingv3reportsReportFilters"
        },
        {
            "name": "reportPreferences",
            "baseName": "reportPreferences",
            "type": "Reportingv3reportsReportPreferences"
        },
        {
            "name": "groupName",
            "baseName": "groupName",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CreateAdhocReportRequest.attributeTypeMap;
    }
}

export class CreateBillingAgreement {
    'agreementInformation'?: Ptsv2billingagreementsAgreementInformation;
    'clientReferenceInformation'?: Ptsv2billingagreementsClientReferenceInformation;
    'aggregatorInformation'?: Ptsv2billingagreementsAggregatorInformation;
    'consumerAuthenticationInformation'?: Ptsv2billingagreementsConsumerAuthenticationInformation;
    'deviceInformation'?: Ptsv2billingagreementsDeviceInformation;
    'installmentInformation'?: Ptsv2billingagreementsInstallmentInformation;
    'merchantInformation'?: Ptsv2billingagreementsMerchantInformation;
    'orderInformation'?: Ptsv2billingagreementsOrderInformation;
    'paymentInformation'?: Ptsv2billingagreementsPaymentInformation;
    'processingInformation'?: Ptsv2billingagreementsProcessingInformation;
    'buyerInformation'?: Ptsv2billingagreementsBuyerInformation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "agreementInformation",
            "baseName": "agreementInformation",
            "type": "Ptsv2billingagreementsAgreementInformation"
        },
        {
            "name": "clientReferenceInformation",
            "baseName": "clientReferenceInformation",
            "type": "Ptsv2billingagreementsClientReferenceInformation"
        },
        {
            "name": "aggregatorInformation",
            "baseName": "aggregatorInformation",
            "type": "Ptsv2billingagreementsAggregatorInformation"
        },
        {
            "name": "consumerAuthenticationInformation",
            "baseName": "consumerAuthenticationInformation",
            "type": "Ptsv2billingagreementsConsumerAuthenticationInformation"
        },
        {
            "name": "deviceInformation",
            "baseName": "deviceInformation",
            "type": "Ptsv2billingagreementsDeviceInformation"
        },
        {
            "name": "installmentInformation",
            "baseName": "installmentInformation",
            "type": "Ptsv2billingagreementsInstallmentInformation"
        },
        {
            "name": "merchantInformation",
            "baseName": "merchantInformation",
            "type": "Ptsv2billingagreementsMerchantInformation"
        },
        {
            "name": "orderInformation",
            "baseName": "orderInformation",
            "type": "Ptsv2billingagreementsOrderInformation"
        },
        {
            "name": "paymentInformation",
            "baseName": "paymentInformation",
            "type": "Ptsv2billingagreementsPaymentInformation"
        },
        {
            "name": "processingInformation",
            "baseName": "processingInformation",
            "type": "Ptsv2billingagreementsProcessingInformation"
        },
        {
            "name": "buyerInformation",
            "baseName": "buyerInformation",
            "type": "Ptsv2billingagreementsBuyerInformation"
        }    ];

    static getAttributeTypeMap() {
        return CreateBillingAgreement.attributeTypeMap;
    }
}

export class CreateBinLookupRequest {
    'clientReferenceInformation'?: Binv1binlookupClientReferenceInformation;
    'paymentInformation'?: Binv1binlookupPaymentInformation;
    'tokenInformation'?: Binv1binlookupTokenInformation;
    'processingInformation'?: Binv1binlookupProcessingInformation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "clientReferenceInformation",
            "baseName": "clientReferenceInformation",
            "type": "Binv1binlookupClientReferenceInformation"
        },
        {
            "name": "paymentInformation",
            "baseName": "paymentInformation",
            "type": "Binv1binlookupPaymentInformation"
        },
        {
            "name": "tokenInformation",
            "baseName": "tokenInformation",
            "type": "Binv1binlookupTokenInformation"
        },
        {
            "name": "processingInformation",
            "baseName": "processingInformation",
            "type": "Binv1binlookupProcessingInformation"
        }    ];

    static getAttributeTypeMap() {
        return CreateBinLookupRequest.attributeTypeMap;
    }
}

export class CreateBundledDecisionManagerCaseRequest {
    'clientReferenceInformation'?: Riskv1decisionsClientReferenceInformation;
    'processorInformation'?: Riskv1decisionsProcessorInformation;
    'processingInformation'?: Riskv1decisionsProcessingInformation;
    'paymentInformation'?: Riskv1decisionsPaymentInformation;
    'orderInformation': Riskv1decisionsOrderInformation;
    'buyerInformation'?: Riskv1decisionsBuyerInformation;
    'deviceInformation'?: Riskv1decisionsDeviceInformation;
    'riskInformation'?: Riskv1decisionsRiskInformation;
    'travelInformation'?: Riskv1decisionsTravelInformation;
    'merchantDefinedInformation'?: Array<Riskv1decisionsMerchantDefinedInformation>;
    'merchantInformation'?: Riskv1decisionsMerchantInformation;
    'acquirerInformation'?: Riskv1decisionsAcquirerInformation;
    'recurringPaymentInformation'?: Ptsv2paymentsRecurringPaymentInformation;
    'consumerAuthenticationInformation'?: Riskv1decisionsConsumerAuthenticationInformation;
    'watchlistScreeningInformation'?: Ptsv2paymentsWatchlistScreeningInformation;
    'tokenInformation'?: Riskv1decisionsTokenInformation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "clientReferenceInformation",
            "baseName": "clientReferenceInformation",
            "type": "Riskv1decisionsClientReferenceInformation"
        },
        {
            "name": "processorInformation",
            "baseName": "processorInformation",
            "type": "Riskv1decisionsProcessorInformation"
        },
        {
            "name": "processingInformation",
            "baseName": "processingInformation",
            "type": "Riskv1decisionsProcessingInformation"
        },
        {
            "name": "paymentInformation",
            "baseName": "paymentInformation",
            "type": "Riskv1decisionsPaymentInformation"
        },
        {
            "name": "orderInformation",
            "baseName": "orderInformation",
            "type": "Riskv1decisionsOrderInformation"
        },
        {
            "name": "buyerInformation",
            "baseName": "buyerInformation",
            "type": "Riskv1decisionsBuyerInformation"
        },
        {
            "name": "deviceInformation",
            "baseName": "deviceInformation",
            "type": "Riskv1decisionsDeviceInformation"
        },
        {
            "name": "riskInformation",
            "baseName": "riskInformation",
            "type": "Riskv1decisionsRiskInformation"
        },
        {
            "name": "travelInformation",
            "baseName": "travelInformation",
            "type": "Riskv1decisionsTravelInformation"
        },
        {
            "name": "merchantDefinedInformation",
            "baseName": "merchantDefinedInformation",
            "type": "Array<Riskv1decisionsMerchantDefinedInformation>"
        },
        {
            "name": "merchantInformation",
            "baseName": "merchantInformation",
            "type": "Riskv1decisionsMerchantInformation"
        },
        {
            "name": "acquirerInformation",
            "baseName": "acquirerInformation",
            "type": "Riskv1decisionsAcquirerInformation"
        },
        {
            "name": "recurringPaymentInformation",
            "baseName": "recurringPaymentInformation",
            "type": "Ptsv2paymentsRecurringPaymentInformation"
        },
        {
            "name": "consumerAuthenticationInformation",
            "baseName": "consumerAuthenticationInformation",
            "type": "Riskv1decisionsConsumerAuthenticationInformation"
        },
        {
            "name": "watchlistScreeningInformation",
            "baseName": "watchlistScreeningInformation",
            "type": "Ptsv2paymentsWatchlistScreeningInformation"
        },
        {
            "name": "tokenInformation",
            "baseName": "tokenInformation",
            "type": "Riskv1decisionsTokenInformation"
        }    ];

    static getAttributeTypeMap() {
        return CreateBundledDecisionManagerCaseRequest.attributeTypeMap;
    }
}

export class CreateCreditRequest {
    'clientReferenceInformation'?: Ptsv2paymentsClientReferenceInformation;
    'processingInformation'?: Ptsv2creditsProcessingInformation;
    'paymentInformation'?: Ptsv2paymentsidrefundsPaymentInformation;
    'orderInformation'?: Ptsv2paymentsidrefundsOrderInformation;
    'buyerInformation'?: Ptsv2paymentsidcapturesBuyerInformation;
    'deviceInformation'?: Ptsv2paymentsidcapturesDeviceInformation;
    'merchantInformation'?: Ptsv2paymentsidrefundsMerchantInformation;
    'aggregatorInformation'?: Ptsv2paymentsidcapturesAggregatorInformation;
    'pointOfSaleInformation'?: Ptsv2paymentsPointOfSaleInformation;
    /**
    * The object containing the custom data that the merchant defines. 
    */
    'merchantDefinedInformation'?: Array<Ptsv2paymentsMerchantDefinedInformation>;
    'merchantDefinedSecureInformation'?: Ptsv2paymentsMerchantDefinedSecureInformation;
    'installmentInformation'?: Ptsv2creditsInstallmentInformation;
    'travelInformation'?: Ptsv2paymentsTravelInformation;
    'recipientInformation'?: Ptsv2creditsRecipientInformation;
    'senderInformation'?: Ptsv2creditsSenderInformation;
    'promotionInformation'?: Ptsv2paymentsPromotionInformation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "clientReferenceInformation",
            "baseName": "clientReferenceInformation",
            "type": "Ptsv2paymentsClientReferenceInformation"
        },
        {
            "name": "processingInformation",
            "baseName": "processingInformation",
            "type": "Ptsv2creditsProcessingInformation"
        },
        {
            "name": "paymentInformation",
            "baseName": "paymentInformation",
            "type": "Ptsv2paymentsidrefundsPaymentInformation"
        },
        {
            "name": "orderInformation",
            "baseName": "orderInformation",
            "type": "Ptsv2paymentsidrefundsOrderInformation"
        },
        {
            "name": "buyerInformation",
            "baseName": "buyerInformation",
            "type": "Ptsv2paymentsidcapturesBuyerInformation"
        },
        {
            "name": "deviceInformation",
            "baseName": "deviceInformation",
            "type": "Ptsv2paymentsidcapturesDeviceInformation"
        },
        {
            "name": "merchantInformation",
            "baseName": "merchantInformation",
            "type": "Ptsv2paymentsidrefundsMerchantInformation"
        },
        {
            "name": "aggregatorInformation",
            "baseName": "aggregatorInformation",
            "type": "Ptsv2paymentsidcapturesAggregatorInformation"
        },
        {
            "name": "pointOfSaleInformation",
            "baseName": "pointOfSaleInformation",
            "type": "Ptsv2paymentsPointOfSaleInformation"
        },
        {
            "name": "merchantDefinedInformation",
            "baseName": "merchantDefinedInformation",
            "type": "Array<Ptsv2paymentsMerchantDefinedInformation>"
        },
        {
            "name": "merchantDefinedSecureInformation",
            "baseName": "merchantDefinedSecureInformation",
            "type": "Ptsv2paymentsMerchantDefinedSecureInformation"
        },
        {
            "name": "installmentInformation",
            "baseName": "installmentInformation",
            "type": "Ptsv2creditsInstallmentInformation"
        },
        {
            "name": "travelInformation",
            "baseName": "travelInformation",
            "type": "Ptsv2paymentsTravelInformation"
        },
        {
            "name": "recipientInformation",
            "baseName": "recipientInformation",
            "type": "Ptsv2creditsRecipientInformation"
        },
        {
            "name": "senderInformation",
            "baseName": "senderInformation",
            "type": "Ptsv2creditsSenderInformation"
        },
        {
            "name": "promotionInformation",
            "baseName": "promotionInformation",
            "type": "Ptsv2paymentsPromotionInformation"
        }    ];

    static getAttributeTypeMap() {
        return CreateCreditRequest.attributeTypeMap;
    }
}

export class CreateInvoiceRequest {
    'clientReferenceInformation'?: Invoicingv2invoicesClientReferenceInformation;
    'customerInformation'?: Invoicingv2invoicesCustomerInformation;
    'processingInformation'?: Invoicingv2invoicesProcessingInformation;
    'invoiceInformation': Invoicingv2invoicesInvoiceInformation;
    'orderInformation': Invoicingv2invoicesOrderInformation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "clientReferenceInformation",
            "baseName": "clientReferenceInformation",
            "type": "Invoicingv2invoicesClientReferenceInformation"
        },
        {
            "name": "customerInformation",
            "baseName": "customerInformation",
            "type": "Invoicingv2invoicesCustomerInformation"
        },
        {
            "name": "processingInformation",
            "baseName": "processingInformation",
            "type": "Invoicingv2invoicesProcessingInformation"
        },
        {
            "name": "invoiceInformation",
            "baseName": "invoiceInformation",
            "type": "Invoicingv2invoicesInvoiceInformation"
        },
        {
            "name": "orderInformation",
            "baseName": "orderInformation",
            "type": "Invoicingv2invoicesOrderInformation"
        }    ];

    static getAttributeTypeMap() {
        return CreateInvoiceRequest.attributeTypeMap;
    }
}

export class CreateOrderRequest {
    'clientReferenceInformation'?: Ptsv2intentsClientReferenceInformation;
    'processingInformation'?: Ptsv2intentsProcessingInformation;
    'merchantInformation'?: Ptsv2intentsMerchantInformation;
    'paymentInformation'?: Ptsv2intentsPaymentInformation;
    'orderInformation'?: Ptsv2intentsOrderInformation;
    'senderInformation'?: Ptsv2intentsSenderInformation;
    'eventInformation'?: Ptsv2intentsEventInformation;
    'travelInformation'?: Ptsv2intentsTravelInformation;
    'recipientInformation'?: Ptsv2intentsRecipientInformation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "clientReferenceInformation",
            "baseName": "clientReferenceInformation",
            "type": "Ptsv2intentsClientReferenceInformation"
        },
        {
            "name": "processingInformation",
            "baseName": "processingInformation",
            "type": "Ptsv2intentsProcessingInformation"
        },
        {
            "name": "merchantInformation",
            "baseName": "merchantInformation",
            "type": "Ptsv2intentsMerchantInformation"
        },
        {
            "name": "paymentInformation",
            "baseName": "paymentInformation",
            "type": "Ptsv2intentsPaymentInformation"
        },
        {
            "name": "orderInformation",
            "baseName": "orderInformation",
            "type": "Ptsv2intentsOrderInformation"
        },
        {
            "name": "senderInformation",
            "baseName": "senderInformation",
            "type": "Ptsv2intentsSenderInformation"
        },
        {
            "name": "eventInformation",
            "baseName": "eventInformation",
            "type": "Ptsv2intentsEventInformation"
        },
        {
            "name": "travelInformation",
            "baseName": "travelInformation",
            "type": "Ptsv2intentsTravelInformation"
        },
        {
            "name": "recipientInformation",
            "baseName": "recipientInformation",
            "type": "Ptsv2intentsRecipientInformation"
        }    ];

    static getAttributeTypeMap() {
        return CreateOrderRequest.attributeTypeMap;
    }
}

export class CreatePaymentLinkRequest {
    'clientReferenceInformation'?: Invoicingv2invoicesClientReferenceInformation;
    'processingInformation': Iplv2paymentlinksProcessingInformation;
    'purchaseInformation': Iplv2paymentlinksPurchaseInformation;
    'orderInformation': Iplv2paymentlinksOrderInformation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "clientReferenceInformation",
            "baseName": "clientReferenceInformation",
            "type": "Invoicingv2invoicesClientReferenceInformation"
        },
        {
            "name": "processingInformation",
            "baseName": "processingInformation",
            "type": "Iplv2paymentlinksProcessingInformation"
        },
        {
            "name": "purchaseInformation",
            "baseName": "purchaseInformation",
            "type": "Iplv2paymentlinksPurchaseInformation"
        },
        {
            "name": "orderInformation",
            "baseName": "orderInformation",
            "type": "Iplv2paymentlinksOrderInformation"
        }    ];

    static getAttributeTypeMap() {
        return CreatePaymentLinkRequest.attributeTypeMap;
    }
}

export class CreatePaymentRequest {
    'clientReferenceInformation'?: Ptsv2paymentsClientReferenceInformation;
    'processingInformation'?: Ptsv2paymentsProcessingInformation;
    'issuerInformation'?: Ptsv2paymentsIssuerInformation;
    'paymentInformation'?: Ptsv2paymentsPaymentInformation;
    'orderInformation'?: Ptsv2paymentsOrderInformation;
    'buyerInformation'?: Ptsv2paymentsBuyerInformation;
    'senderInformation'?: Ptsv2paymentsSenderInformation;
    'recipientInformation'?: Ptsv2paymentsRecipientInformation;
    'deviceInformation'?: Ptsv2paymentsDeviceInformation;
    'merchantInformation'?: Ptsv2paymentsMerchantInformation;
    'aggregatorInformation'?: Ptsv2paymentsAggregatorInformation;
    'consumerAuthenticationInformation'?: Ptsv2paymentsConsumerAuthenticationInformation;
    'pointOfSaleInformation'?: Ptsv2paymentsPointOfSaleInformation;
    /**
    * The object containing the custom data that the merchant defines. 
    */
    'merchantDefinedInformation'?: Array<Ptsv2paymentsMerchantDefinedInformation>;
    'merchantDefinedSecureInformation'?: Ptsv2paymentsMerchantDefinedSecureInformation;
    'installmentInformation'?: Ptsv2paymentsInstallmentInformation;
    'travelInformation'?: Ptsv2paymentsTravelInformation;
    'healthCareInformation'?: Ptsv2paymentsHealthCareInformation;
    'promotionInformation'?: Ptsv2paymentsPromotionInformation;
    'tokenInformation'?: Ptsv2paymentsTokenInformation;
    'invoiceDetails'?: Ptsv2paymentsInvoiceDetails;
    'processorInformation'?: Ptsv2paymentsProcessorInformation;
    'agreementInformation'?: Ptsv2paymentsAgreementInformation;
    'riskInformation'?: Ptsv2paymentsRiskInformation;
    'acquirerInformation'?: Ptsv2paymentsAcquirerInformation;
    'recurringPaymentInformation'?: Ptsv2paymentsRecurringPaymentInformation;
    'unscheduledPaymentInformation'?: Ptsv2paymentsUnscheduledPaymentInformation;
    'hostedPaymentInformation'?: Ptsv2paymentsHostedPaymentInformation;
    'watchlistScreeningInformation'?: Ptsv2paymentsWatchlistScreeningInformation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "clientReferenceInformation",
            "baseName": "clientReferenceInformation",
            "type": "Ptsv2paymentsClientReferenceInformation"
        },
        {
            "name": "processingInformation",
            "baseName": "processingInformation",
            "type": "Ptsv2paymentsProcessingInformation"
        },
        {
            "name": "issuerInformation",
            "baseName": "issuerInformation",
            "type": "Ptsv2paymentsIssuerInformation"
        },
        {
            "name": "paymentInformation",
            "baseName": "paymentInformation",
            "type": "Ptsv2paymentsPaymentInformation"
        },
        {
            "name": "orderInformation",
            "baseName": "orderInformation",
            "type": "Ptsv2paymentsOrderInformation"
        },
        {
            "name": "buyerInformation",
            "baseName": "buyerInformation",
            "type": "Ptsv2paymentsBuyerInformation"
        },
        {
            "name": "senderInformation",
            "baseName": "senderInformation",
            "type": "Ptsv2paymentsSenderInformation"
        },
        {
            "name": "recipientInformation",
            "baseName": "recipientInformation",
            "type": "Ptsv2paymentsRecipientInformation"
        },
        {
            "name": "deviceInformation",
            "baseName": "deviceInformation",
            "type": "Ptsv2paymentsDeviceInformation"
        },
        {
            "name": "merchantInformation",
            "baseName": "merchantInformation",
            "type": "Ptsv2paymentsMerchantInformation"
        },
        {
            "name": "aggregatorInformation",
            "baseName": "aggregatorInformation",
            "type": "Ptsv2paymentsAggregatorInformation"
        },
        {
            "name": "consumerAuthenticationInformation",
            "baseName": "consumerAuthenticationInformation",
            "type": "Ptsv2paymentsConsumerAuthenticationInformation"
        },
        {
            "name": "pointOfSaleInformation",
            "baseName": "pointOfSaleInformation",
            "type": "Ptsv2paymentsPointOfSaleInformation"
        },
        {
            "name": "merchantDefinedInformation",
            "baseName": "merchantDefinedInformation",
            "type": "Array<Ptsv2paymentsMerchantDefinedInformation>"
        },
        {
            "name": "merchantDefinedSecureInformation",
            "baseName": "merchantDefinedSecureInformation",
            "type": "Ptsv2paymentsMerchantDefinedSecureInformation"
        },
        {
            "name": "installmentInformation",
            "baseName": "installmentInformation",
            "type": "Ptsv2paymentsInstallmentInformation"
        },
        {
            "name": "travelInformation",
            "baseName": "travelInformation",
            "type": "Ptsv2paymentsTravelInformation"
        },
        {
            "name": "healthCareInformation",
            "baseName": "healthCareInformation",
            "type": "Ptsv2paymentsHealthCareInformation"
        },
        {
            "name": "promotionInformation",
            "baseName": "promotionInformation",
            "type": "Ptsv2paymentsPromotionInformation"
        },
        {
            "name": "tokenInformation",
            "baseName": "tokenInformation",
            "type": "Ptsv2paymentsTokenInformation"
        },
        {
            "name": "invoiceDetails",
            "baseName": "invoiceDetails",
            "type": "Ptsv2paymentsInvoiceDetails"
        },
        {
            "name": "processorInformation",
            "baseName": "processorInformation",
            "type": "Ptsv2paymentsProcessorInformation"
        },
        {
            "name": "agreementInformation",
            "baseName": "agreementInformation",
            "type": "Ptsv2paymentsAgreementInformation"
        },
        {
            "name": "riskInformation",
            "baseName": "riskInformation",
            "type": "Ptsv2paymentsRiskInformation"
        },
        {
            "name": "acquirerInformation",
            "baseName": "acquirerInformation",
            "type": "Ptsv2paymentsAcquirerInformation"
        },
        {
            "name": "recurringPaymentInformation",
            "baseName": "recurringPaymentInformation",
            "type": "Ptsv2paymentsRecurringPaymentInformation"
        },
        {
            "name": "unscheduledPaymentInformation",
            "baseName": "unscheduledPaymentInformation",
            "type": "Ptsv2paymentsUnscheduledPaymentInformation"
        },
        {
            "name": "hostedPaymentInformation",
            "baseName": "hostedPaymentInformation",
            "type": "Ptsv2paymentsHostedPaymentInformation"
        },
        {
            "name": "watchlistScreeningInformation",
            "baseName": "watchlistScreeningInformation",
            "type": "Ptsv2paymentsWatchlistScreeningInformation"
        }    ];

    static getAttributeTypeMap() {
        return CreatePaymentRequest.attributeTypeMap;
    }
}

export class CreatePlanRequest {
    'clientReferenceInformation'?: Rbsv1plansClientReferenceInformation;
    'planInformation'?: Rbsv1plansPlanInformation;
    'orderInformation'?: Rbsv1plansOrderInformation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "clientReferenceInformation",
            "baseName": "clientReferenceInformation",
            "type": "Rbsv1plansClientReferenceInformation"
        },
        {
            "name": "planInformation",
            "baseName": "planInformation",
            "type": "Rbsv1plansPlanInformation"
        },
        {
            "name": "orderInformation",
            "baseName": "orderInformation",
            "type": "Rbsv1plansOrderInformation"
        }    ];

    static getAttributeTypeMap() {
        return CreatePlanRequest.attributeTypeMap;
    }
}

export class CreatePlanResponse {
    'links'?: PtsV2IncrementalAuthorizationPatch201ResponseLinks;
    /**
    * An unique identification number generated by Cybersource to identify the submitted request. Returned by all services. It is also appended to the endpoint of the resource. On incremental authorizations, this value with be the same as the identification number returned in the original authorization response. 
    */
    'id'?: string;
    /**
    * Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ` **Example** `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.). The `T` separates the date and the time. The `Z` indicates UTC.  Returned by Cybersource for all services. 
    */
    'submitTimeUtc'?: string;
    /**
    * The status of the submitted transaction.  Possible values:  - COMPLETED 
    */
    'status'?: string;
    'planInformation'?: CreatePlanResponsePlanInformation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "PtsV2IncrementalAuthorizationPatch201ResponseLinks"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "submitTimeUtc",
            "baseName": "submitTimeUtc",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "planInformation",
            "baseName": "planInformation",
            "type": "CreatePlanResponsePlanInformation"
        }    ];

    static getAttributeTypeMap() {
        return CreatePlanResponse.attributeTypeMap;
    }
}

export class CreatePlanResponsePlanInformation {
    /**
    * Plan code 
    */
    'code'?: string;
    /**
    * Plan Status:  - `DRAFT`  - `ACTIVE` 
    */
    'status'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CreatePlanResponsePlanInformation.attributeTypeMap;
    }
}

export class CreateReportSubscriptionRequest {
    /**
    * Valid CyberSource organizationId
    */
    'organizationId'?: string;
    /**
    * Valid Report Definition Name
    */
    'reportDefinitionName': string;
    'reportFields': Array<string>;
    /**
    * Valid values: - application/xml - text/csv 
    */
    'reportMimeType': string;
    /**
    * 'The frequency for which subscription is created.' **NOTE: Do not document USER_DEFINED Frequency field in developer center** Valid Values:   - 'DAILY'   - 'WEEKLY'   - 'MONTHLY'   - 'USER_DEFINED' 
    */
    'reportFrequency': string;
    /**
    * If the reportFrequency is User-defined, reportInterval should be in **ISO 8601 time format** Please refer the following link to know more about ISO 8601 format.[Rfc Time Format](https://en.wikipedia.org/wiki/ISO_8601#Durations)  **Example time format for 2 hours and 30 Mins:**   - PT2H30M **NOTE: Do not document reportInterval field in developer center** 
    */
    'reportInterval'?: string;
    'reportName': string;
    'timezone': string;
    /**
    * The hour at which the report generation should start. It should be in hhmm format.
    */
    'startTime': string;
    /**
    * This is the start day if the frequency is WEEKLY or MONTHLY. The value varies from 1-7 for WEEKLY and 1-31 for MONTHLY. For WEEKLY 1 means Sunday and 7 means Saturday. By default the value is 1.
    */
    'startDay'?: number;
    /**
    * List of filters to apply
    */
    'reportFilters'?: { [key: string]: Array<string>; };
    'reportPreferences'?: Reportingv3reportsReportPreferences;
    /**
    * Valid GroupName
    */
    'groupName'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "organizationId",
            "baseName": "organizationId",
            "type": "string"
        },
        {
            "name": "reportDefinitionName",
            "baseName": "reportDefinitionName",
            "type": "string"
        },
        {
            "name": "reportFields",
            "baseName": "reportFields",
            "type": "Array<string>"
        },
        {
            "name": "reportMimeType",
            "baseName": "reportMimeType",
            "type": "string"
        },
        {
            "name": "reportFrequency",
            "baseName": "reportFrequency",
            "type": "string"
        },
        {
            "name": "reportInterval",
            "baseName": "reportInterval",
            "type": "string"
        },
        {
            "name": "reportName",
            "baseName": "reportName",
            "type": "string"
        },
        {
            "name": "timezone",
            "baseName": "timezone",
            "type": "string"
        },
        {
            "name": "startTime",
            "baseName": "startTime",
            "type": "string"
        },
        {
            "name": "startDay",
            "baseName": "startDay",
            "type": "number"
        },
        {
            "name": "reportFilters",
            "baseName": "reportFilters",
            "type": "{ [key: string]: Array<string>; }"
        },
        {
            "name": "reportPreferences",
            "baseName": "reportPreferences",
            "type": "Reportingv3reportsReportPreferences"
        },
        {
            "name": "groupName",
            "baseName": "groupName",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CreateReportSubscriptionRequest.attributeTypeMap;
    }
}

export class CreateSearchRequest {
    /**
    * Indicates whether or not you want to save this search request for future use. The options are:  * `true` * `false` (default value)  If set to `true`, this field returns `searchID` in the response. You can use this value to retrieve the details of the saved search. 
    */
    'save'?: boolean;
    /**
    * Name of this search. When `save` is set to `true`, this search is saved with this name. 
    */
    'name'?: string;
    /**
    * Merchant’s time zone in ISO standard, using the TZ database format. For example: `America/Chicago` 
    */
    'timezone'?: string;
    /**
    * String that contains the filters and variables for which you want to search. For information about supported field-filters and operators, see the [Query Filters]( https://developer.cybersource.com/api/developer-guides/dita-txn-search-details-rest-api-dev-guide-102718/txn-search-intro/txn-filtering.html) section of the Transaction Search Developer Guide. 
    */
    'query'?: string;
    /**
    * Controls the starting point within the collection of results, which defaults to 0. The first item in the collection is retrieved by setting a zero offset.  For example, if you have a collection of 15 items to be retrieved from a resource and you specify limit=5, you can retrieve the entire set of results in 3 successive requests by varying the offset value like this:  `offset=0` `offset=5` `offset=10`  **Note:** If an offset larger than the number of results is provided, this will result in no embedded object being returned. 
    */
    'offset'?: number;
    /**
    * Controls the maximum number of items that may be returned for a single request. The default is 20, the maximum is 2500. 
    */
    'limit'?: number;
    /**
    * A comma separated list of the following form:  `submitTimeUtc:desc` 
    */
    'sort'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "save",
            "baseName": "save",
            "type": "boolean"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "timezone",
            "baseName": "timezone",
            "type": "string"
        },
        {
            "name": "query",
            "baseName": "query",
            "type": "string"
        },
        {
            "name": "offset",
            "baseName": "offset",
            "type": "number"
        },
        {
            "name": "limit",
            "baseName": "limit",
            "type": "number"
        },
        {
            "name": "sort",
            "baseName": "sort",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CreateSearchRequest.attributeTypeMap;
    }
}

export class CreateSessionReq {
    'clientReferenceInformation'?: Ptsv2refreshpaymentstatusidClientReferenceInformation;
    'processingInformation'?: Ptsv2paymentreferencesProcessingInformation;
    'paymentInformation'?: Ptsv2paymentreferencesPaymentInformation;
    'orderInformation'?: Ptsv2paymentreferencesOrderInformation;
    'buyerInformation'?: Ptsv2paymentreferencesBuyerInformation;
    'deviceInformation'?: Ptsv2paymentreferencesDeviceInformation;
    'merchantInformation'?: Ptsv2paymentreferencesMerchantInformation;
    'userInterface'?: Ptsv2paymentreferencesUserInterface;
    /**
    * The object containing the custom data that the merchant defines. 
    */
    'merchantDefinedInformation'?: Array<Ptsv2paymentsMerchantDefinedInformation>;
    'agreementInformation'?: Ptsv2paymentreferencesAgreementInformation;
    'travelInformation'?: Ptsv2paymentreferencesTravelInformation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "clientReferenceInformation",
            "baseName": "clientReferenceInformation",
            "type": "Ptsv2refreshpaymentstatusidClientReferenceInformation"
        },
        {
            "name": "processingInformation",
            "baseName": "processingInformation",
            "type": "Ptsv2paymentreferencesProcessingInformation"
        },
        {
            "name": "paymentInformation",
            "baseName": "paymentInformation",
            "type": "Ptsv2paymentreferencesPaymentInformation"
        },
        {
            "name": "orderInformation",
            "baseName": "orderInformation",
            "type": "Ptsv2paymentreferencesOrderInformation"
        },
        {
            "name": "buyerInformation",
            "baseName": "buyerInformation",
            "type": "Ptsv2paymentreferencesBuyerInformation"
        },
        {
            "name": "deviceInformation",
            "baseName": "deviceInformation",
            "type": "Ptsv2paymentreferencesDeviceInformation"
        },
        {
            "name": "merchantInformation",
            "baseName": "merchantInformation",
            "type": "Ptsv2paymentreferencesMerchantInformation"
        },
        {
            "name": "userInterface",
            "baseName": "userInterface",
            "type": "Ptsv2paymentreferencesUserInterface"
        },
        {
            "name": "merchantDefinedInformation",
            "baseName": "merchantDefinedInformation",
            "type": "Array<Ptsv2paymentsMerchantDefinedInformation>"
        },
        {
            "name": "agreementInformation",
            "baseName": "agreementInformation",
            "type": "Ptsv2paymentreferencesAgreementInformation"
        },
        {
            "name": "travelInformation",
            "baseName": "travelInformation",
            "type": "Ptsv2paymentreferencesTravelInformation"
        }    ];

    static getAttributeTypeMap() {
        return CreateSessionReq.attributeTypeMap;
    }
}

export class CreateSessionRequest {
    'clientReferenceInformation'?: Ptsv2refreshpaymentstatusidClientReferenceInformation;
    'processingInformation'?: Ptsv2paymentreferencesProcessingInformation;
    'paymentInformation'?: Ptsv2paymentreferencesPaymentInformation;
    'orderInformation'?: Ptsv2paymentreferencesOrderInformation;
    'buyerInformation'?: Ptsv2paymentreferencesBuyerInformation;
    'deviceInformation'?: Ptsv2paymentreferencesDeviceInformation;
    'merchantInformation'?: Ptsv2paymentreferencesMerchantInformation;
    'userInterface'?: Ptsv2paymentreferencesUserInterface;
    /**
    * The object containing the custom data that the merchant defines. 
    */
    'merchantDefinedInformation'?: Array<Ptsv2paymentsMerchantDefinedInformation>;
    'agreementInformation'?: Ptsv2paymentreferencesAgreementInformation;
    'travelInformation'?: Ptsv2paymentreferencesTravelInformation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "clientReferenceInformation",
            "baseName": "clientReferenceInformation",
            "type": "Ptsv2refreshpaymentstatusidClientReferenceInformation"
        },
        {
            "name": "processingInformation",
            "baseName": "processingInformation",
            "type": "Ptsv2paymentreferencesProcessingInformation"
        },
        {
            "name": "paymentInformation",
            "baseName": "paymentInformation",
            "type": "Ptsv2paymentreferencesPaymentInformation"
        },
        {
            "name": "orderInformation",
            "baseName": "orderInformation",
            "type": "Ptsv2paymentreferencesOrderInformation"
        },
        {
            "name": "buyerInformation",
            "baseName": "buyerInformation",
            "type": "Ptsv2paymentreferencesBuyerInformation"
        },
        {
            "name": "deviceInformation",
            "baseName": "deviceInformation",
            "type": "Ptsv2paymentreferencesDeviceInformation"
        },
        {
            "name": "merchantInformation",
            "baseName": "merchantInformation",
            "type": "Ptsv2paymentreferencesMerchantInformation"
        },
        {
            "name": "userInterface",
            "baseName": "userInterface",
            "type": "Ptsv2paymentreferencesUserInterface"
        },
        {
            "name": "merchantDefinedInformation",
            "baseName": "merchantDefinedInformation",
            "type": "Array<Ptsv2paymentsMerchantDefinedInformation>"
        },
        {
            "name": "agreementInformation",
            "baseName": "agreementInformation",
            "type": "Ptsv2paymentreferencesAgreementInformation"
        },
        {
            "name": "travelInformation",
            "baseName": "travelInformation",
            "type": "Ptsv2paymentreferencesTravelInformation"
        }    ];

    static getAttributeTypeMap() {
        return CreateSessionRequest.attributeTypeMap;
    }
}

export class CreateSubscriptionRequest {
    'clientReferenceInformation'?: Rbsv1subscriptionsClientReferenceInformation;
    'processingInformation'?: Rbsv1subscriptionsProcessingInformation;
    'planInformation'?: Rbsv1subscriptionsPlanInformation;
    'subscriptionInformation'?: Rbsv1subscriptionsSubscriptionInformation;
    'paymentInformation'?: Rbsv1subscriptionsPaymentInformation;
    'orderInformation'?: GetAllPlansResponseOrderInformation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "clientReferenceInformation",
            "baseName": "clientReferenceInformation",
            "type": "Rbsv1subscriptionsClientReferenceInformation"
        },
        {
            "name": "processingInformation",
            "baseName": "processingInformation",
            "type": "Rbsv1subscriptionsProcessingInformation"
        },
        {
            "name": "planInformation",
            "baseName": "planInformation",
            "type": "Rbsv1subscriptionsPlanInformation"
        },
        {
            "name": "subscriptionInformation",
            "baseName": "subscriptionInformation",
            "type": "Rbsv1subscriptionsSubscriptionInformation"
        },
        {
            "name": "paymentInformation",
            "baseName": "paymentInformation",
            "type": "Rbsv1subscriptionsPaymentInformation"
        },
        {
            "name": "orderInformation",
            "baseName": "orderInformation",
            "type": "GetAllPlansResponseOrderInformation"
        }    ];

    static getAttributeTypeMap() {
        return CreateSubscriptionRequest.attributeTypeMap;
    }
}

export class CreateSubscriptionRequest1 {
    'clientReferenceInformation'?: Rbsv1subscriptionsClientReferenceInformation;
    'processingInformation'?: Rbsv1subscriptionsProcessingInformation;
    'planInformation'?: Rbsv1subscriptionsPlanInformation;
    'subscriptionInformation'?: Rbsv1subscriptionsSubscriptionInformation;
    'orderInformation'?: GetAllPlansResponseOrderInformation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "clientReferenceInformation",
            "baseName": "clientReferenceInformation",
            "type": "Rbsv1subscriptionsClientReferenceInformation"
        },
        {
            "name": "processingInformation",
            "baseName": "processingInformation",
            "type": "Rbsv1subscriptionsProcessingInformation"
        },
        {
            "name": "planInformation",
            "baseName": "planInformation",
            "type": "Rbsv1subscriptionsPlanInformation"
        },
        {
            "name": "subscriptionInformation",
            "baseName": "subscriptionInformation",
            "type": "Rbsv1subscriptionsSubscriptionInformation"
        },
        {
            "name": "orderInformation",
            "baseName": "orderInformation",
            "type": "GetAllPlansResponseOrderInformation"
        }    ];

    static getAttributeTypeMap() {
        return CreateSubscriptionRequest1.attributeTypeMap;
    }
}

export class CreateSubscriptionResponse {
    'links'?: CreateSubscriptionResponseLinks;
    /**
    * An unique identification number generated by Cybersource to identify the submitted request. Returned by all services. It is also appended to the endpoint of the resource. On incremental authorizations, this value with be the same as the identification number returned in the original authorization response. 
    */
    'id'?: string;
    /**
    * Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ` **Example** `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.). The `T` separates the date and the time. The `Z` indicates UTC.  Returned by Cybersource for all services. 
    */
    'submitTimeUtc'?: string;
    /**
    * The status of the submitted transaction.  Possible values:  - COMPLETED  - PENDING_REVIEW  - DECLINED  - INVALID_REQUEST 
    */
    'status'?: string;
    'subscriptionInformation'?: CreateSubscriptionResponseSubscriptionInformation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "CreateSubscriptionResponseLinks"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "submitTimeUtc",
            "baseName": "submitTimeUtc",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "subscriptionInformation",
            "baseName": "subscriptionInformation",
            "type": "CreateSubscriptionResponseSubscriptionInformation"
        }    ];

    static getAttributeTypeMap() {
        return CreateSubscriptionResponse.attributeTypeMap;
    }
}

export class CreateSubscriptionResponseLinks {
    'self'?: PtsV2PaymentsPost201ResponseLinksSelf;
    'update'?: PtsV2PaymentsPost201ResponseLinksSelf;
    'cancel'?: PtsV2PaymentsPost201ResponseLinksSelf;
    'suspend'?: PtsV2PaymentsPost201ResponseLinksSelf;
    'activate'?: PtsV2PaymentsPost201ResponseLinksSelf;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "self",
            "baseName": "self",
            "type": "PtsV2PaymentsPost201ResponseLinksSelf"
        },
        {
            "name": "update",
            "baseName": "update",
            "type": "PtsV2PaymentsPost201ResponseLinksSelf"
        },
        {
            "name": "cancel",
            "baseName": "cancel",
            "type": "PtsV2PaymentsPost201ResponseLinksSelf"
        },
        {
            "name": "suspend",
            "baseName": "suspend",
            "type": "PtsV2PaymentsPost201ResponseLinksSelf"
        },
        {
            "name": "activate",
            "baseName": "activate",
            "type": "PtsV2PaymentsPost201ResponseLinksSelf"
        }    ];

    static getAttributeTypeMap() {
        return CreateSubscriptionResponseLinks.attributeTypeMap;
    }
}

export class CreateSubscriptionResponseSubscriptionInformation {
    /**
    * Subscription code. 
    */
    'code'?: string;
    /**
    * Subscription Status:  - `PENDING`  - `ACTIVE`  - `FAILED` 
    */
    'status'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CreateSubscriptionResponseSubscriptionInformation.attributeTypeMap;
    }
}

export class CreateWebhook {
    /**
    * Client friendly webhook name.
    */
    'name'?: string;
    /**
    * Client friendly webhook description.
    */
    'description'?: string;
    /**
    * Organization Identifier (OrgId) or Merchant Identifier (MID).
    */
    'organizationId'?: string;
    /**
    * To see the valid productId and eventTypes, call the \"Create and Manage Webhooks - Retrieve a list of event types\" endpoint.
    */
    'products'?: Array<Notificationsubscriptionsv2webhooksProducts1>;
    /**
    * The client's endpoint (URL) to receive webhooks.
    */
    'webhookUrl'?: string;
    /**
    * The client's health check endpoint (URL). If the user does not provide the health check URL, it is the user's responsibility to re-activate the webhook if it is deactivated by calling the test endpoint. 
    */
    'healthCheckUrl'?: string;
    'retryPolicy'?: Notificationsubscriptionsv2webhooksRetryPolicy;
    /**
    * The webhook scope. 1. SELF The Webhook is used to deliver webhooks for only this Organization (or Merchant). 2. DESCENDANTS The Webhook is used to deliver webhooks for this Organization and its children. This field is optional.  
    */
    'notificationScope'?: CreateWebhook.NotificationScopeEnum;
    'securityPolicy'?: Notificationsubscriptionsv2webhooksSecurityPolicy;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "organizationId",
            "baseName": "organizationId",
            "type": "string"
        },
        {
            "name": "products",
            "baseName": "products",
            "type": "Array<Notificationsubscriptionsv2webhooksProducts1>"
        },
        {
            "name": "webhookUrl",
            "baseName": "webhookUrl",
            "type": "string"
        },
        {
            "name": "healthCheckUrl",
            "baseName": "healthCheckUrl",
            "type": "string"
        },
        {
            "name": "retryPolicy",
            "baseName": "retryPolicy",
            "type": "Notificationsubscriptionsv2webhooksRetryPolicy"
        },
        {
            "name": "notificationScope",
            "baseName": "notificationScope",
            "type": "CreateWebhook.NotificationScopeEnum"
        },
        {
            "name": "securityPolicy",
            "baseName": "securityPolicy",
            "type": "Notificationsubscriptionsv2webhooksSecurityPolicy"
        }    ];

    static getAttributeTypeMap() {
        return CreateWebhook.attributeTypeMap;
    }
}

export namespace CreateWebhook {
    export enum NotificationScopeEnum {
        SELF = <any> 'SELF',
        DESCENDANTS = <any> 'DESCENDANTS'
    }
}
export class DeletePlanResponse {
    /**
    * Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ` **Example** `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.). The `T` separates the date and the time. The `Z` indicates UTC.  Returned by Cybersource for all services. 
    */
    'submitTimeUtc'?: string;
    /**
    * The status of the submitted transaction.  Possible values:  - COMPLETED 
    */
    'status'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "submitTimeUtc",
            "baseName": "submitTimeUtc",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return DeletePlanResponse.attributeTypeMap;
    }
}

export class DeviceDeAssociateV3Request {
    /**
    * ID of the device to be de-associated.
    */
    'deviceId': string;
    /**
    * A field representing value of either account id or portfolio id.
    */
    'organizationId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "deviceId",
            "baseName": "deviceId",
            "type": "string"
        },
        {
            "name": "organizationId",
            "baseName": "organizationId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return DeviceDeAssociateV3Request.attributeTypeMap;
    }
}

export class DeviceTransferRequest {
    /**
    * ID of the device to be transferred.
    */
    'deviceId': string;
    /**
    * A field representing the merchant to which the device has to be transferred.
    */
    'merchantId'?: string;
    /**
    * A field representing value of either merchant, account or portfolio. It has a higher priority than merchantId, and will be preferred if request contains both merchantId and organizationId.
    */
    'organizationId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "deviceId",
            "baseName": "deviceId",
            "type": "string"
        },
        {
            "name": "merchantId",
            "baseName": "merchantId",
            "type": "string"
        },
        {
            "name": "organizationId",
            "baseName": "organizationId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return DeviceTransferRequest.attributeTypeMap;
    }
}

export class DmConfig {
    'processingOptions'?: DmConfigProcessingOptions;
    'organization'?: DmConfigOrganization;
    'portfolioControls'?: DmConfigPortfolioControls;
    'thirdparty'?: DmConfigThirdparty;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "processingOptions",
            "baseName": "processingOptions",
            "type": "DmConfigProcessingOptions"
        },
        {
            "name": "organization",
            "baseName": "organization",
            "type": "DmConfigOrganization"
        },
        {
            "name": "portfolioControls",
            "baseName": "portfolioControls",
            "type": "DmConfigPortfolioControls"
        },
        {
            "name": "thirdparty",
            "baseName": "thirdparty",
            "type": "DmConfigThirdparty"
        }    ];

    static getAttributeTypeMap() {
        return DmConfig.attributeTypeMap;
    }
}

export class DmConfigOrganization {
    /**
    * Must be one of the following : NO_GROUP, INCLUDE_IN_PARENTS_GROUP 
    */
    'hierarchyGroup'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "hierarchyGroup",
            "baseName": "hierarchyGroup",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return DmConfigOrganization.attributeTypeMap;
    }
}

export class DmConfigPortfolioControls {
    'hideRiskMenus'?: boolean;
    'hideRiskTransactionData'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "hideRiskMenus",
            "baseName": "hideRiskMenus",
            "type": "boolean"
        },
        {
            "name": "hideRiskTransactionData",
            "baseName": "hideRiskTransactionData",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return DmConfigPortfolioControls.attributeTypeMap;
    }
}

export class DmConfigProcessingOptions {
    'stepUpAuthEnabled'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "stepUpAuthEnabled",
            "baseName": "stepUpAuthEnabled",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return DmConfigProcessingOptions.attributeTypeMap;
    }
}

export class DmConfigThirdparty {
    'provider'?: DmConfigThirdpartyProvider;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "provider",
            "baseName": "provider",
            "type": "DmConfigThirdpartyProvider"
        }    ];

    static getAttributeTypeMap() {
        return DmConfigThirdparty.attributeTypeMap;
    }
}

export class DmConfigThirdpartyProvider {
    'accurint'?: DmConfigThirdpartyProviderAccurint;
    'credilink'?: DmConfigThirdpartyProviderCredilink;
    'ekata'?: DmConfigThirdpartyProviderEkata;
    'emailage'?: DmConfigThirdpartyProviderEmailage;
    'perseuss'?: DmConfigThirdpartyProviderPerseuss;
    'signifyd'?: DmConfigThirdpartyProviderSignifyd;
    'targus'?: DmConfigThirdpartyProviderTargus;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "accurint",
            "baseName": "accurint",
            "type": "DmConfigThirdpartyProviderAccurint"
        },
        {
            "name": "credilink",
            "baseName": "credilink",
            "type": "DmConfigThirdpartyProviderCredilink"
        },
        {
            "name": "ekata",
            "baseName": "ekata",
            "type": "DmConfigThirdpartyProviderEkata"
        },
        {
            "name": "emailage",
            "baseName": "emailage",
            "type": "DmConfigThirdpartyProviderEmailage"
        },
        {
            "name": "perseuss",
            "baseName": "perseuss",
            "type": "DmConfigThirdpartyProviderPerseuss"
        },
        {
            "name": "signifyd",
            "baseName": "signifyd",
            "type": "DmConfigThirdpartyProviderSignifyd"
        },
        {
            "name": "targus",
            "baseName": "targus",
            "type": "DmConfigThirdpartyProviderTargus"
        }    ];

    static getAttributeTypeMap() {
        return DmConfigThirdpartyProvider.attributeTypeMap;
    }
}

export class DmConfigThirdpartyProviderAccurint {
    'enabled'?: boolean;
    'credentials'?: DmConfigThirdpartyProviderAccurintCredentials;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "enabled",
            "baseName": "enabled",
            "type": "boolean"
        },
        {
            "name": "credentials",
            "baseName": "credentials",
            "type": "DmConfigThirdpartyProviderAccurintCredentials"
        }    ];

    static getAttributeTypeMap() {
        return DmConfigThirdpartyProviderAccurint.attributeTypeMap;
    }
}

export class DmConfigThirdpartyProviderAccurintCredentials {
    'username'?: string;
    'password'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "username",
            "baseName": "username",
            "type": "string"
        },
        {
            "name": "password",
            "baseName": "password",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return DmConfigThirdpartyProviderAccurintCredentials.attributeTypeMap;
    }
}

export class DmConfigThirdpartyProviderCredilink {
    'enabled'?: boolean;
    'enableRealTime'?: boolean;
    'useCybsCredentials'?: boolean;
    'credentials'?: DmConfigThirdpartyProviderCredilinkCredentials;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "enabled",
            "baseName": "enabled",
            "type": "boolean"
        },
        {
            "name": "enableRealTime",
            "baseName": "enableRealTime",
            "type": "boolean"
        },
        {
            "name": "useCybsCredentials",
            "baseName": "useCybsCredentials",
            "type": "boolean"
        },
        {
            "name": "credentials",
            "baseName": "credentials",
            "type": "DmConfigThirdpartyProviderCredilinkCredentials"
        }    ];

    static getAttributeTypeMap() {
        return DmConfigThirdpartyProviderCredilink.attributeTypeMap;
    }
}

export class DmConfigThirdpartyProviderCredilinkCredentials {
    'username'?: string;
    'password'?: string;
    'sigla'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "username",
            "baseName": "username",
            "type": "string"
        },
        {
            "name": "password",
            "baseName": "password",
            "type": "string"
        },
        {
            "name": "sigla",
            "baseName": "sigla",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return DmConfigThirdpartyProviderCredilinkCredentials.attributeTypeMap;
    }
}

export class DmConfigThirdpartyProviderEkata {
    'enabled'?: boolean;
    'enableRealTime'?: boolean;
    'useCybsCredentials'?: boolean;
    'credentials'?: DmConfigThirdpartyProviderEkataCredentials;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "enabled",
            "baseName": "enabled",
            "type": "boolean"
        },
        {
            "name": "enableRealTime",
            "baseName": "enableRealTime",
            "type": "boolean"
        },
        {
            "name": "useCybsCredentials",
            "baseName": "useCybsCredentials",
            "type": "boolean"
        },
        {
            "name": "credentials",
            "baseName": "credentials",
            "type": "DmConfigThirdpartyProviderEkataCredentials"
        }    ];

    static getAttributeTypeMap() {
        return DmConfigThirdpartyProviderEkata.attributeTypeMap;
    }
}

export class DmConfigThirdpartyProviderEkataCredentials {
    'apiKey'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "apiKey",
            "baseName": "apiKey",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return DmConfigThirdpartyProviderEkataCredentials.attributeTypeMap;
    }
}

export class DmConfigThirdpartyProviderEmailage {
    'enabled'?: boolean;
    'enableRealTime'?: boolean;
    'useCybsCredentials'?: boolean;
    'credentials'?: DmConfigThirdpartyProviderAccurintCredentials;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "enabled",
            "baseName": "enabled",
            "type": "boolean"
        },
        {
            "name": "enableRealTime",
            "baseName": "enableRealTime",
            "type": "boolean"
        },
        {
            "name": "useCybsCredentials",
            "baseName": "useCybsCredentials",
            "type": "boolean"
        },
        {
            "name": "credentials",
            "baseName": "credentials",
            "type": "DmConfigThirdpartyProviderAccurintCredentials"
        }    ];

    static getAttributeTypeMap() {
        return DmConfigThirdpartyProviderEmailage.attributeTypeMap;
    }
}

export class DmConfigThirdpartyProviderPerseuss {
    'enabled'?: boolean;
    'enableRealTime'?: boolean;
    'credentials'?: DmConfigThirdpartyProviderAccurintCredentials;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "enabled",
            "baseName": "enabled",
            "type": "boolean"
        },
        {
            "name": "enableRealTime",
            "baseName": "enableRealTime",
            "type": "boolean"
        },
        {
            "name": "credentials",
            "baseName": "credentials",
            "type": "DmConfigThirdpartyProviderAccurintCredentials"
        }    ];

    static getAttributeTypeMap() {
        return DmConfigThirdpartyProviderPerseuss.attributeTypeMap;
    }
}

export class DmConfigThirdpartyProviderSignifyd {
    'enabled'?: boolean;
    'credentials'?: DmConfigThirdpartyProviderSignifydCredentials;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "enabled",
            "baseName": "enabled",
            "type": "boolean"
        },
        {
            "name": "credentials",
            "baseName": "credentials",
            "type": "DmConfigThirdpartyProviderSignifydCredentials"
        }    ];

    static getAttributeTypeMap() {
        return DmConfigThirdpartyProviderSignifyd.attributeTypeMap;
    }
}

export class DmConfigThirdpartyProviderSignifydCredentials {
    'teamId'?: string;
    'apiKey'?: string;
    'secretKeyid'?: string;
    'secretKey'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "teamId",
            "baseName": "teamId",
            "type": "string"
        },
        {
            "name": "apiKey",
            "baseName": "apiKey",
            "type": "string"
        },
        {
            "name": "secretKeyid",
            "baseName": "secretKeyid",
            "type": "string"
        },
        {
            "name": "secretKey",
            "baseName": "secretKey",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return DmConfigThirdpartyProviderSignifydCredentials.attributeTypeMap;
    }
}

export class DmConfigThirdpartyProviderTargus {
    'enabled'?: boolean;
    'useCybsCredentials'?: boolean;
    'credentials'?: DmConfigThirdpartyProviderTargusCredentials;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "enabled",
            "baseName": "enabled",
            "type": "boolean"
        },
        {
            "name": "useCybsCredentials",
            "baseName": "useCybsCredentials",
            "type": "boolean"
        },
        {
            "name": "credentials",
            "baseName": "credentials",
            "type": "DmConfigThirdpartyProviderTargusCredentials"
        }    ];

    static getAttributeTypeMap() {
        return DmConfigThirdpartyProviderTargus.attributeTypeMap;
    }
}

export class DmConfigThirdpartyProviderTargusCredentials {
    'username'?: string;
    'password'?: string;
    'serviceId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "username",
            "baseName": "username",
            "type": "string"
        },
        {
            "name": "password",
            "baseName": "password",
            "type": "string"
        },
        {
            "name": "serviceId",
            "baseName": "serviceId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return DmConfigThirdpartyProviderTargusCredentials.attributeTypeMap;
    }
}

export class Dmsv2devicesPaymentProcessor {
    /**
    * Payment processor name.
    */
    'name'?: string;
    /**
    * ID associated with payment processing for this terminal.
    */
    'terminalId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "terminalId",
            "baseName": "terminalId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Dmsv2devicesPaymentProcessor.attributeTypeMap;
    }
}

export class Dmsv2devicetransferDetails {
    'field'?: string;
    'reason'?: string;
    'code'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "field",
            "baseName": "field",
            "type": "string"
        },
        {
            "name": "reason",
            "baseName": "reason",
            "type": "string"
        },
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Dmsv2devicetransferDetails.attributeTypeMap;
    }
}

export class Dmsv2devicetransferDetails1 {
    'field'?: string;
    'reason'?: string;
    'code'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "field",
            "baseName": "field",
            "type": "string"
        },
        {
            "name": "reason",
            "baseName": "reason",
            "type": "string"
        },
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Dmsv2devicetransferDetails1.attributeTypeMap;
    }
}

export class Dmsv3devicesdeassociateDevices {
    'deviceId'?: string;
    'reason'?: string;
    'code'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "deviceId",
            "baseName": "deviceId",
            "type": "string"
        },
        {
            "name": "reason",
            "baseName": "reason",
            "type": "string"
        },
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Dmsv3devicesdeassociateDevices.attributeTypeMap;
    }
}

export class ECheckConfig {
    'common'?: ECheckConfigCommon;
    'underwriting'?: ECheckConfigUnderwriting;
    'features'?: ECheckConfigFeatures;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "common",
            "baseName": "common",
            "type": "ECheckConfigCommon"
        },
        {
            "name": "underwriting",
            "baseName": "underwriting",
            "type": "ECheckConfigUnderwriting"
        },
        {
            "name": "features",
            "baseName": "features",
            "type": "ECheckConfigFeatures"
        }    ];

    static getAttributeTypeMap() {
        return ECheckConfig.attributeTypeMap;
    }
}

export class ECheckConfigCommon {
    'processors'?: { [key: string]: ECheckConfigCommonProcessors; };
    'internalOnly'?: ECheckConfigCommonInternalOnly;
    /**
    * Mandatory  Name on Merchant's Bank Account Only ASCII (Hex 20 to Hex 7E) 
    */
    'accountHolderName': string;
    /**
    * Mandatory  Type of account for Merchant's Bank Account Possible values: - checking - savings - corporatechecking - corporatesavings 
    */
    'accountType': string;
    /**
    * Mandatory  Routing number for Merchant's Bank Account US Account Routing Number 
    */
    'accountRoutingNumber': string;
    /**
    * Mandatory  Account number for Merchant's Bank Account 
    */
    'accountNumber': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "processors",
            "baseName": "processors",
            "type": "{ [key: string]: ECheckConfigCommonProcessors; }"
        },
        {
            "name": "internalOnly",
            "baseName": "internalOnly",
            "type": "ECheckConfigCommonInternalOnly"
        },
        {
            "name": "accountHolderName",
            "baseName": "accountHolderName",
            "type": "string"
        },
        {
            "name": "accountType",
            "baseName": "accountType",
            "type": "string"
        },
        {
            "name": "accountRoutingNumber",
            "baseName": "accountRoutingNumber",
            "type": "string"
        },
        {
            "name": "accountNumber",
            "baseName": "accountNumber",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ECheckConfigCommon.attributeTypeMap;
    }
}

export class ECheckConfigCommonInternalOnly {
    /**
    * *NEW* Used by EBC UI always set to true
    */
    'displayEcheckInfo'?: boolean;
    /**
    * *NEW* Payment Processing connection used to support eCheck, aka ACH, payment methods. Example * \"bofaach\" * \"wellsfargoach\" 
    */
    'processors'?: { [key: string]: ECheckConfigCommonInternalOnlyProcessors; };

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "displayEcheckInfo",
            "baseName": "displayEcheckInfo",
            "type": "boolean"
        },
        {
            "name": "processors",
            "baseName": "processors",
            "type": "{ [key: string]: ECheckConfigCommonInternalOnlyProcessors; }"
        }    ];

    static getAttributeTypeMap() {
        return ECheckConfigCommonInternalOnly.attributeTypeMap;
    }
}

/**
* Name of the payment processor. Example - \"wellsfargoach\"
*/
export class ECheckConfigCommonInternalOnlyProcessors {
    /**
    * *NEW* Flag to indicate whether the processor is migrated to the Common Connectivity Services Platform. Applicable for VPC and amexdirect processors. 
    */
    'enableCCS'?: boolean;
    /**
    * *NEW* The 'Terminal Id' aka TID, is an identifier used for with your payments processor. Depending on the processor and payment acceptance type this may also be the default Terminal ID used for Card Present and Virtual Terminal transactions. Applicable for VPC processors. 
    */
    'terminalId'?: string;
    /**
    * *NEW* This ensures the transaction reference # contains an identifier that can be viewed in CYBS
    */
    'enable15anTransactionReferenceNumber'?: boolean;
    /**
    * *NEW* This is used by the EBC2 application
    */
    'portalSupportedPaytypes'?: string;
    /**
    * *NEW*
    */
    'settlementMethod'?: ECheckConfigCommonInternalOnlyProcessors.SettlementMethodEnum;
    /**
    * *NEW*
    */
    'verificationLevel'?: ECheckConfigCommonInternalOnlyProcessors.VerificationLevelEnum;
    /**
    * *Moved* When set to Yes we will automatically update transactions to a completed status X-number of days after the transaction comes through; if no failure notification is received. When set to No means we will not update transaction status in this manner. For BAMS/Bank of America merchants, they should be set to No unless we are explicitly asked to set a merchant to YES.
    */
    'setCompletedState'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "enableCCS",
            "baseName": "enableCCS",
            "type": "boolean"
        },
        {
            "name": "terminalId",
            "baseName": "terminalId",
            "type": "string"
        },
        {
            "name": "enable15anTransactionReferenceNumber",
            "baseName": "enable15anTransactionReferenceNumber",
            "type": "boolean"
        },
        {
            "name": "portalSupportedPaytypes",
            "baseName": "portalSupportedPaytypes",
            "type": "string"
        },
        {
            "name": "settlementMethod",
            "baseName": "settlementMethod",
            "type": "ECheckConfigCommonInternalOnlyProcessors.SettlementMethodEnum"
        },
        {
            "name": "verificationLevel",
            "baseName": "verificationLevel",
            "type": "ECheckConfigCommonInternalOnlyProcessors.VerificationLevelEnum"
        },
        {
            "name": "setCompletedState",
            "baseName": "setCompletedState",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return ECheckConfigCommonInternalOnlyProcessors.attributeTypeMap;
    }
}

export namespace ECheckConfigCommonInternalOnlyProcessors {
    export enum SettlementMethodEnum {
        BESTGUESS = <any> 'BEST_GUESS'
    }
    export enum VerificationLevelEnum {
        VALIDATION = <any> 'VALIDATION'
    }
}
/**
* Payment Processing connection used to support eCheck, aka ACH, payment methods. Example - \"bofaach\"
*/
export class ECheckConfigCommonProcessors {
    /**
    * *EXISTING* Company (merchant) defined description of entry to receive.  For e.g. PAYROLL, GAS BILL, INS PREM. This field is alphanumeric
    */
    'companyEntryDescription': string;
    /**
    * *EXISTING* company ID assigned to merchant by Acquiring bank. This field is alphanumeric
    */
    'companyId'?: string;
    /**
    * *EXISTING* Capture requests are grouped into a batch bound for your payment processor. The batch time can be identified by reading the last 2-digits as military time. E.g., <processor>_16 = your processing cutoff is 4PM PST. Please note if you are in a different location you may then need to convert time zone as well.
    */
    'batchGroup'?: string;
    /**
    * *NEW* Accuity is the original validation service that checks the account/routing number for formatting issues. Used by WF and set to \"Yes\" unless told otherwise
    */
    'enableAccuityForAvs'?: boolean;
    /**
    * *NEW*
    */
    'accuityCheckType'?: ECheckConfigCommonProcessors.AccuityCheckTypeEnum;
    /**
    * *Moved* When set to Yes we will automatically update transactions to a completed status X-number of days after the transaction comes through; if no failure notification is received. When set to No means we will not update transaction status in this manner. For BAMS/Bank of America merchants, they should be set to No unless we are explicitly asked to set a merchant to YES.
    */
    'setCompletedState'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "companyEntryDescription",
            "baseName": "companyEntryDescription",
            "type": "string"
        },
        {
            "name": "companyId",
            "baseName": "companyId",
            "type": "string"
        },
        {
            "name": "batchGroup",
            "baseName": "batchGroup",
            "type": "string"
        },
        {
            "name": "enableAccuityForAvs",
            "baseName": "enableAccuityForAvs",
            "type": "boolean"
        },
        {
            "name": "accuityCheckType",
            "baseName": "accuityCheckType",
            "type": "ECheckConfigCommonProcessors.AccuityCheckTypeEnum"
        },
        {
            "name": "setCompletedState",
            "baseName": "setCompletedState",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return ECheckConfigCommonProcessors.attributeTypeMap;
    }
}

export namespace ECheckConfigCommonProcessors {
    export enum AccuityCheckTypeEnum {
        ALWAYS = <any> 'ALWAYS'
    }
}
export class ECheckConfigFeatures {
    'accountValidationService'?: ECheckConfigFeaturesAccountValidationService;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "accountValidationService",
            "baseName": "accountValidationService",
            "type": "ECheckConfigFeaturesAccountValidationService"
        }    ];

    static getAttributeTypeMap() {
        return ECheckConfigFeatures.attributeTypeMap;
    }
}

export class ECheckConfigFeaturesAccountValidationService {
    'internalOnly'?: ECheckConfigFeaturesAccountValidationServiceInternalOnly;
    /**
    * *NEW* Payment Processing connection used to support eCheck, aka ACH, payment methods. Example * \"bofaach\" * \"wellsfargoach\" 
    */
    'processors'?: { [key: string]: ECheckConfigFeaturesAccountValidationServiceProcessors; };

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "internalOnly",
            "baseName": "internalOnly",
            "type": "ECheckConfigFeaturesAccountValidationServiceInternalOnly"
        },
        {
            "name": "processors",
            "baseName": "processors",
            "type": "{ [key: string]: ECheckConfigFeaturesAccountValidationServiceProcessors; }"
        }    ];

    static getAttributeTypeMap() {
        return ECheckConfigFeaturesAccountValidationService.attributeTypeMap;
    }
}

export class ECheckConfigFeaturesAccountValidationServiceInternalOnly {
    /**
    * *NEW* Payment Processing connection used to support eCheck, aka ACH, payment methods. Example * \"bofaach\" * \"wellsfargoach\" 
    */
    'processors'?: { [key: string]: ECheckConfigFeaturesAccountValidationServiceInternalOnlyProcessors; };

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "processors",
            "baseName": "processors",
            "type": "{ [key: string]: ECheckConfigFeaturesAccountValidationServiceInternalOnlyProcessors; }"
        }    ];

    static getAttributeTypeMap() {
        return ECheckConfigFeaturesAccountValidationServiceInternalOnly.attributeTypeMap;
    }
}

/**
* Name of the payment processor. Example - \"wellsfargoach\"
*/
export class ECheckConfigFeaturesAccountValidationServiceInternalOnlyProcessors {
    /**
    * *NEW*
    */
    'avsVersion'?: ECheckConfigFeaturesAccountValidationServiceInternalOnlyProcessors.AvsVersionEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "avsVersion",
            "baseName": "avsVersion",
            "type": "ECheckConfigFeaturesAccountValidationServiceInternalOnlyProcessors.AvsVersionEnum"
        }    ];

    static getAttributeTypeMap() {
        return ECheckConfigFeaturesAccountValidationServiceInternalOnlyProcessors.attributeTypeMap;
    }
}

export namespace ECheckConfigFeaturesAccountValidationServiceInternalOnlyProcessors {
    export enum AvsVersionEnum {
        _2 = <any> '2'
    }
}
/**
* *NEW* Name of the payment processor. Example - \"wellsfargoach\"
*/
export class ECheckConfigFeaturesAccountValidationServiceProcessors {
    /**
    * *NEW* Determined in WF eTicket if account has opted into the Account Ownership Service.
    */
    'avsAccountOwnershipService'?: boolean;
    /**
    * *NEW* Determined in WF eTicket if account has opted into the Account Status Service.
    */
    'avsAccountStatusService'?: boolean;
    /**
    * *NEW* Taken from Addendum Agreement Column in boarding form.
    */
    'avsSignedAgreement'?: boolean;
    /**
    * *NEW*
    */
    'avsCalculatedResponseBehavior'?: ECheckConfigFeaturesAccountValidationServiceProcessors.AvsCalculatedResponseBehaviorEnum;
    /**
    * *NEW* Also known as the Additional ID. Taken from the boarding form.
    */
    'avsAdditionalId'?: string;
    /**
    * *NEW*
    */
    'enableAvs'?: boolean;
    /**
    * *NEW* Also known as the AVS Gateway Entity ID.
    */
    'avsEntityId'?: string;
    /**
    * *NEW*
    */
    'avsResultMode'?: ECheckConfigFeaturesAccountValidationServiceProcessors.AvsResultModeEnum;
    /**
    * *NEW* Applicable if the merchant wants to run AVS on token creation requests only.
    */
    'enableAvsTokenCreation'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "avsAccountOwnershipService",
            "baseName": "avsAccountOwnershipService",
            "type": "boolean"
        },
        {
            "name": "avsAccountStatusService",
            "baseName": "avsAccountStatusService",
            "type": "boolean"
        },
        {
            "name": "avsSignedAgreement",
            "baseName": "avsSignedAgreement",
            "type": "boolean"
        },
        {
            "name": "avsCalculatedResponseBehavior",
            "baseName": "avsCalculatedResponseBehavior",
            "type": "ECheckConfigFeaturesAccountValidationServiceProcessors.AvsCalculatedResponseBehaviorEnum"
        },
        {
            "name": "avsAdditionalId",
            "baseName": "avsAdditionalId",
            "type": "string"
        },
        {
            "name": "enableAvs",
            "baseName": "enableAvs",
            "type": "boolean"
        },
        {
            "name": "avsEntityId",
            "baseName": "avsEntityId",
            "type": "string"
        },
        {
            "name": "avsResultMode",
            "baseName": "avsResultMode",
            "type": "ECheckConfigFeaturesAccountValidationServiceProcessors.AvsResultModeEnum"
        },
        {
            "name": "enableAvsTokenCreation",
            "baseName": "enableAvsTokenCreation",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return ECheckConfigFeaturesAccountValidationServiceProcessors.attributeTypeMap;
    }
}

export namespace ECheckConfigFeaturesAccountValidationServiceProcessors {
    export enum AvsCalculatedResponseBehaviorEnum {
        Continue = <any> 'continue'
    }
    export enum AvsResultModeEnum {
        FULLRESPONSE = <any> 'FULL_RESPONSE',
        LOGICBOX = <any> 'LOGIC_BOX'
    }
}
export class ECheckConfigUnderwriting {
    /**
    * Mandatory  Free-text (csv)  Possible values (combination):  CCD — Cash Concentration or Disbursement, or CCD, is a charge or refund against a business checking account. One-time or recurring CCD transactions are fund transfers to or from a corporate entity. A standing authorization is required for recurring transactions. PPD — Prearranged Payment and Deposit Entry, or PPD, is a charge or refund against a customer’s checking or savings account. PPD entries can only be originated when payment and deposit terms between the merchant and the customer are prearranged. A written authorization from the customer is required for one-time transactions and a written standing authorization is required for recurring transactions. TEL — Telephone-Initiated Entry, or TEL, is a one-time charge against a customer’s checking or savings account. TEL transactions can only be originated when a business relationship between the merchant and the customer already exists; or if a relationship does not exist, then only when the customer initiates the telephone call to the merchant. Payment authorization is obtained from the customer by telephone. WEB — Internet-Initiated Entry or WEB is a charge against a customer’s checking or savings account. One-time or recurring WEB transactions are originated through the Internet. Payment authorization is also obtained from the customer through the Internet. 
    */
    'standardEntryClassCodes': string;
    /**
    * Mandatory  Determines whether CYBS has placed the merchant on a funding hold This will often be set to True for new merchants until the risk team has completed additional verification of their first transaction. It will be switched to \"false\" once underwriting review is completed and we are ready to start funding the merchant. 
    */
    'enableHold': boolean;
    /**
    * Mandatory  Monthly Maximum total Transaction Amount 12 digit including decimal 
    */
    'monthlyTotalTransactionAmountLimit': number;
    /**
    * Mandatory  Funds Hold Days (Number of days funds will be held before it will be deposited into merchant account) 3 digits 
    */
    'holdingDays': number;
    /**
    * Optional  Allow Credits (True/False) 
    */
    'enableCredits'?: boolean;
    /**
    * Mandatory  Maximum total Transaction Amount This is a per transaction limit. For example, the merchant is limited to processing transactions under $100 12 digits (including decimal - USD only) 
    */
    'transactionAmountLimit': number;
    /**
    * Mandatory Reserve Method  Possible value: - fixed - none Most merchants do not have a reserve attached to their account so the default value would be \"none.\"   For a Fixed Reserve, the reserve balance is established by either, (1) a receipt of a lump sum deposit from a merchant, or (2) withholding funds at a Reserve Rate established for the account from each batch settlement until the reserve balance is equal to a set Reserve Target. A Fixed Reserve may also be established by a combination of lump sum deposit and withholding of settlement funds.  A Rolling Reserve balance is established by withholding from a merchant’s available settlement funds at a Reserve Rate (percentage) and no Reserve Target is specified. Rather, each amount withheld is retained for a specified number of Reserve Holding Days and then released back to the merchant. 
    */
    'riskReserveMethod': string;
    /**
    * Mandatory  Reserve Rate (% of TPV)=> Relevant for Rolling Reserve and Fixed Reserve The percentage rate at which risk funds are withheld from each eCheck.Net batch settlement. 
    */
    'riskReserveRate': number;
    /**
    * Mandatory  Reserve Target (fixed $ amount)=> Relevant for Fixed Reserve ONLY  The maximum dollar amount that can be held in Risk Reserve for a fixed reserve. Once risk withholdings reach the Reserve Target established for the eCheck.Net account, a portion of available funds will be deposited to the merchant’s bank account 12 digit including decimal 
    */
    'riskReserveTargetAmount': number;
    /**
    * Solution organization id
    */
    'solutionOrganizationId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "standardEntryClassCodes",
            "baseName": "standardEntryClassCodes",
            "type": "string"
        },
        {
            "name": "enableHold",
            "baseName": "enableHold",
            "type": "boolean"
        },
        {
            "name": "monthlyTotalTransactionAmountLimit",
            "baseName": "monthlyTotalTransactionAmountLimit",
            "type": "number"
        },
        {
            "name": "holdingDays",
            "baseName": "holdingDays",
            "type": "number"
        },
        {
            "name": "enableCredits",
            "baseName": "enableCredits",
            "type": "boolean"
        },
        {
            "name": "transactionAmountLimit",
            "baseName": "transactionAmountLimit",
            "type": "number"
        },
        {
            "name": "riskReserveMethod",
            "baseName": "riskReserveMethod",
            "type": "string"
        },
        {
            "name": "riskReserveRate",
            "baseName": "riskReserveRate",
            "type": "number"
        },
        {
            "name": "riskReserveTargetAmount",
            "baseName": "riskReserveTargetAmount",
            "type": "number"
        },
        {
            "name": "solutionOrganizationId",
            "baseName": "solutionOrganizationId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ECheckConfigUnderwriting.attributeTypeMap;
    }
}

export class FraudMarkingActionRequest {
    'riskInformation': Riskv1decisionsidmarkingRiskInformation;
    'clientReferenceInformation'?: Riskv1liststypeentriesClientReferenceInformation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "riskInformation",
            "baseName": "riskInformation",
            "type": "Riskv1decisionsidmarkingRiskInformation"
        },
        {
            "name": "clientReferenceInformation",
            "baseName": "clientReferenceInformation",
            "type": "Riskv1liststypeentriesClientReferenceInformation"
        }    ];

    static getAttributeTypeMap() {
        return FraudMarkingActionRequest.attributeTypeMap;
    }
}

/**
* This is a server-to-server API request to generate the capture context that can be used to initiate an instance of Microform on an acceptance page.   The capture context is a digitally signed JWT that provides authentication, one-time keys, and the target origin to the Microform Integration application. 
*/
export class GenerateCaptureContextRequest {
    /**
    * Specify the version of Microform that you want to use. 
    */
    'clientVersion'?: string;
    /**
    * The [target origin](https://developer.mozilla.org/en-US/docs/Glossary/Origin) of the website on which you will be launching Microform is defined by the scheme (protocol), hostname (domain) and port number (if used).    You must use https://hostname (unless you use http://localhost) Wildcards are NOT supported.  Ensure that subdomains are included. Any valid top-level domain is supported (e.g. .com, .co.uk, .gov.br etc)  Examples:   - https://example.com   - https://subdomain.example.com   - https://example.com:8080<br><br>  If you are embedding within multiple nested iframes you need to specify the origins of all the browser contexts used, for example:    targetOrigins: [     \"https://example.com\",     \"https://basket.example.com\",     \"https://ecom.example.com\"   ]<br><br>  You can supply up to nine origins within the targetOrigins field for nested iframes. If the list of origins exceeds five ensure that you:   - Compare the list of origins in the v2/sessions targetOrigins field against the location.ancestorOrigins of the browser.    - Ensure that the count of origins and their content matches in both.  If any origins are absent or mismatched, the system will prevent Microform from loading and display a client-side error message. 
    */
    'targetOrigins'?: Array<string>;
    /**
    * The list of card networks you want to use for this Microform transaction.  Microform currently supports the following card networks: - VISA - MASTERCARD - AMEX - CARNET - CARTESBANCAIRES - CUP - DINERSCLUB - DISCOVER - EFTPOS - ELO - JCB - JCREW - MADA - MAESTRO - MEEZA - PAYPAK  **Important:**    - When integrating Microform (Card) at least one card network should be specified in the allowedCardNetworks field in the capture context request.   - When integrating Microform (ACH/eCheck) the allowedCardNetworks field is not required in the capture context request.   - When integrating both Microform (Card) and Microform (ACH/eCheck) at least one card network should be specified in the allowedCardNetworks field in the capture context request. 
    */
    'allowedCardNetworks'?: Array<string>;
    /**
    * The payment types that are allowed for the merchant.    Possible values when launching Microform: - CARD - CHECK <br><br> 
    */
    'allowedPaymentTypes'?: Array<string>;
    'transientTokenResponseOptions'?: Microformv2sessionsTransientTokenResponseOptions;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "clientVersion",
            "baseName": "clientVersion",
            "type": "string"
        },
        {
            "name": "targetOrigins",
            "baseName": "targetOrigins",
            "type": "Array<string>"
        },
        {
            "name": "allowedCardNetworks",
            "baseName": "allowedCardNetworks",
            "type": "Array<string>"
        },
        {
            "name": "allowedPaymentTypes",
            "baseName": "allowedPaymentTypes",
            "type": "Array<string>"
        },
        {
            "name": "transientTokenResponseOptions",
            "baseName": "transientTokenResponseOptions",
            "type": "Microformv2sessionsTransientTokenResponseOptions"
        }    ];

    static getAttributeTypeMap() {
        return GenerateCaptureContextRequest.attributeTypeMap;
    }
}

export class GenerateUnifiedCheckoutCaptureContextRequest {
    /**
    * Specify the version of Unified Checkout that you want to use.
    */
    'clientVersion'?: string;
    /**
    * The [target origin](https://developer.mozilla.org/en-US/docs/Glossary/Origin) of the website on which you will be launching Unified Checkout is defined by the scheme (protocol), hostname (domain) and port number (if used).    You must use https://hostname (unless you use http://localhost) Wildcards are NOT supported.  Ensure that subdomains are included. Any valid top-level domain is supported (e.g. .com, .co.uk, .gov.br etc)  Examples:   - https://example.com   - https://subdomain.example.com   - https://example.com:8080<br><br>  If you are embedding within multiple nested iframes you need to specify the origins of all the browser contexts used, for example:    targetOrigins: [     \"https://example.com\",     \"https://basket.example.com\",     \"https://ecom.example.com\"   ] 
    */
    'targetOrigins'?: Array<string>;
    /**
    * The list of card networks you want to use for this Unified Checkout transaction.  Unified Checkout currently supports the following card networks:     - VISA     - MASTERCARD     - AMEX     - CARNET     - CARTESBANCAIRES     - CUP     - DINERSCLUB     - DISCOVER     - EFTPOS     - ELO     - JCB     - JCREW     - MADA     - MAESTRO     - MEEZA     - PAYPAK 
    */
    'allowedCardNetworks'?: Array<string>;
    /**
    * The payment types that are allowed for the merchant.    Possible values when launching Unified Checkout:   - APPLEPAY   - CHECK   - CLICKTOPAY   - GOOGLEPAY   - PANENTRY                 - PAZE <br><br>  Unified Checkout also supports the following Alternative Payments:   - AFTERPAY<br><br>  Possible values when launching Click To Pay Drop-In UI: - CLICKTOPAY <br><br>  **Important:**    - CLICKTOPAY only available for Visa, Mastercard and AMEX for saved cards.   - Visa and Mastercard will look to tokenize using network tokenization for all Click to Pay requests.  Click to Pay uses Click to Pay token requester IDs and not the merchant's existing token requester.   - Apple Pay, Google Pay, Check, and Paze can be used independently without requiring PAN entry in the allowedPaymentTypes field.<br><br>  **Managing Google Pay Authentication Types** When you enable Google Pay on Unified Checkout you can specify optional parameters that define the types of card authentication you receive from Google Pay.<br><br>  **Managing Google Pay Authentication Types** Where Click to Pay is the payment type selected by the customer and the customer manually enters their card, the option to enroll their card in Click to Pay will be auto-checked if this field is set to \"true\".   This is only available where the merchant and cardholder are based in the following countries and the billing type is set to \"FULL\" or \"PARTIAL\".   - UAE   - Argentina   - Brazil   - Chile   - Colombia   - Kuwait   - Mexico   - Peru   - Qatar   - Saudi Arabia   - Ukraine   - South Africa<br><br>  If false, this is not present or not supported in the market.  Enrollment in Click to Pay is not checked for the customer when completing manual card entry. 
    */
    'allowedPaymentTypes'?: Array<string>;
    /**
    * Country the purchase is originating from (e.g. country of the merchant).  Use the two-character ISO Standard 
    */
    'country'?: string;
    /**
    * Localization of the User experience conforming to the ISO 639-1 language standards and two-character ISO Standard Country Code.  Please refer to list of [supported locales through Unified Checkout](https://developer.cybersource.com/docs/cybs/en-us/unified-checkout/developer/all/rest/unified-checkout/uc-appendix-languages.html) 
    */
    'locale'?: string;
    'captureMandate'?: Upv1capturecontextsCaptureMandate;
    'completeMandate'?: Upv1capturecontextsCompleteMandate;
    'orderInformation'?: Upv1capturecontextsOrderInformation;
    'transientTokenResponseOptions'?: Microformv2sessionsTransientTokenResponseOptions;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "clientVersion",
            "baseName": "clientVersion",
            "type": "string"
        },
        {
            "name": "targetOrigins",
            "baseName": "targetOrigins",
            "type": "Array<string>"
        },
        {
            "name": "allowedCardNetworks",
            "baseName": "allowedCardNetworks",
            "type": "Array<string>"
        },
        {
            "name": "allowedPaymentTypes",
            "baseName": "allowedPaymentTypes",
            "type": "Array<string>"
        },
        {
            "name": "country",
            "baseName": "country",
            "type": "string"
        },
        {
            "name": "locale",
            "baseName": "locale",
            "type": "string"
        },
        {
            "name": "captureMandate",
            "baseName": "captureMandate",
            "type": "Upv1capturecontextsCaptureMandate"
        },
        {
            "name": "completeMandate",
            "baseName": "completeMandate",
            "type": "Upv1capturecontextsCompleteMandate"
        },
        {
            "name": "orderInformation",
            "baseName": "orderInformation",
            "type": "Upv1capturecontextsOrderInformation"
        },
        {
            "name": "transientTokenResponseOptions",
            "baseName": "transientTokenResponseOptions",
            "type": "Microformv2sessionsTransientTokenResponseOptions"
        }    ];

    static getAttributeTypeMap() {
        return GenerateUnifiedCheckoutCaptureContextRequest.attributeTypeMap;
    }
}

export class GetAllPlansResponse {
    'links'?: GetAllPlansResponseLinks;
    /**
    * Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ` **Example** `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.). The `T` separates the date and the time. The `Z` indicates UTC.  Returned by Cybersource for all services. 
    */
    'submitTimeUtc'?: string;
    /**
    * total number of plans created
    */
    'totalCount'?: number;
    'plans'?: Array<GetAllPlansResponsePlans>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "GetAllPlansResponseLinks"
        },
        {
            "name": "submitTimeUtc",
            "baseName": "submitTimeUtc",
            "type": "string"
        },
        {
            "name": "totalCount",
            "baseName": "totalCount",
            "type": "number"
        },
        {
            "name": "plans",
            "baseName": "plans",
            "type": "Array<GetAllPlansResponsePlans>"
        }    ];

    static getAttributeTypeMap() {
        return GetAllPlansResponse.attributeTypeMap;
    }
}

export class GetAllPlansResponseLinks {
    'self'?: PtsV2PaymentsPost201ResponseLinksSelf;
    'next'?: PtsV2PaymentsPost201ResponseLinksSelf;
    'previous'?: PtsV2PaymentsPost201ResponseLinksSelf;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "self",
            "baseName": "self",
            "type": "PtsV2PaymentsPost201ResponseLinksSelf"
        },
        {
            "name": "next",
            "baseName": "next",
            "type": "PtsV2PaymentsPost201ResponseLinksSelf"
        },
        {
            "name": "previous",
            "baseName": "previous",
            "type": "PtsV2PaymentsPost201ResponseLinksSelf"
        }    ];

    static getAttributeTypeMap() {
        return GetAllPlansResponseLinks.attributeTypeMap;
    }
}

export class GetAllPlansResponseOrderInformation {
    'amountDetails'?: GetAllPlansResponseOrderInformationAmountDetails;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "amountDetails",
            "baseName": "amountDetails",
            "type": "GetAllPlansResponseOrderInformationAmountDetails"
        }    ];

    static getAttributeTypeMap() {
        return GetAllPlansResponseOrderInformation.attributeTypeMap;
    }
}

export class GetAllPlansResponseOrderInformationAmountDetails {
    /**
    * Currency used for the order. Use the three-character [ISO Standard Currency Codes.](http://apps.cybersource.com/library/documentation/sbc/quickref/currencies.pdf)  #### Used by **Authorization** Required field.  **Authorization Reversal** For an authorization reversal (`reversalInformation`) or a capture (`processingOptions.capture` is set to `true`), you must use the same currency that you used in your payment authorization request.  #### PIN Debit Currency for the amount you requested for the PIN debit purchase. This value is returned for partial authorizations. The issuing bank can approve a partial amount if the balance on the debit card is less than the requested transaction amount. For the possible values, see the [ISO Standard Currency Codes](https://developer.cybersource.com/library/documentation/sbc/quickref/currencies.pdf). Returned by PIN debit purchase.  For PIN debit reversal requests, you must use the same currency that was used for the PIN debit purchase or PIN debit credit that you are reversing. For the possible values, see the [ISO Standard Currency Codes](https://developer.cybersource.com/library/documentation/sbc/quickref/currencies.pdf).  Required field for PIN Debit purchase and PIN Debit credit requests. Optional field for PIN Debit reversal requests.  #### GPX This field is optional for reversing an authorization or credit.  #### DCC for First Data Your local currency.  #### Tax Calculation Required for international tax and value added tax only. Optional for U.S. and Canadian taxes. Your local currency. 
    */
    'currency'?: string;
    /**
    * Billing amount for the billing period. 
    */
    'billingAmount'?: string;
    /**
    * Subscription setup fee 
    */
    'setupFee'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "currency",
            "baseName": "currency",
            "type": "string"
        },
        {
            "name": "billingAmount",
            "baseName": "billingAmount",
            "type": "string"
        },
        {
            "name": "setupFee",
            "baseName": "setupFee",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetAllPlansResponseOrderInformationAmountDetails.attributeTypeMap;
    }
}

export class GetAllPlansResponsePlanInformation {
    /**
    * Plan code 
    */
    'code'?: string;
    /**
    * Plan Status:  - `DRAFT`  - `ACTIVE`  - `INACTIVE` 
    */
    'status'?: string;
    /**
    * Plan name 
    */
    'name'?: string;
    /**
    * Plan description 
    */
    'description'?: string;
    'billingPeriod'?: GetAllPlansResponsePlanInformationBillingPeriod;
    'billingCycles'?: GetAllPlansResponsePlanInformationBillingCycles;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "billingPeriod",
            "baseName": "billingPeriod",
            "type": "GetAllPlansResponsePlanInformationBillingPeriod"
        },
        {
            "name": "billingCycles",
            "baseName": "billingCycles",
            "type": "GetAllPlansResponsePlanInformationBillingCycles"
        }    ];

    static getAttributeTypeMap() {
        return GetAllPlansResponsePlanInformation.attributeTypeMap;
    }
}

export class GetAllPlansResponsePlanInformationBillingCycles {
    /**
    * Describe total number of billing cycles 
    */
    'total'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "total",
            "baseName": "total",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetAllPlansResponsePlanInformationBillingCycles.attributeTypeMap;
    }
}

/**
* Billing Frequency 
*/
export class GetAllPlansResponsePlanInformationBillingPeriod {
    /**
    * Example: - If length=1 & unit=month then charge every month - If length=7 & unit=day then charge every 7th day 
    */
    'length'?: string;
    /**
    * Calendar unit values.   possible values:   - `D` - day   - `M` - month   - `W` - week   - `Y` - year 
    */
    'unit'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "length",
            "baseName": "length",
            "type": "string"
        },
        {
            "name": "unit",
            "baseName": "unit",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetAllPlansResponsePlanInformationBillingPeriod.attributeTypeMap;
    }
}

/**
* Plan list.
*/
export class GetAllPlansResponsePlans {
    'links'?: PtsV2IncrementalAuthorizationPatch201ResponseLinks;
    /**
    * An unique identification number generated by Cybersource to identify the submitted request. Returned by all services. It is also appended to the endpoint of the resource. On incremental authorizations, this value with be the same as the identification number returned in the original authorization response. 
    */
    'id'?: string;
    'planInformation'?: GetAllPlansResponsePlanInformation;
    'orderInformation'?: GetAllPlansResponseOrderInformation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "PtsV2IncrementalAuthorizationPatch201ResponseLinks"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "planInformation",
            "baseName": "planInformation",
            "type": "GetAllPlansResponsePlanInformation"
        },
        {
            "name": "orderInformation",
            "baseName": "orderInformation",
            "type": "GetAllPlansResponseOrderInformation"
        }    ];

    static getAttributeTypeMap() {
        return GetAllPlansResponsePlans.attributeTypeMap;
    }
}

export class GetAllSubscriptionsResponse {
    'links'?: GetAllPlansResponseLinks;
    /**
    * Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ` **Example** `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.). The `T` separates the date and the time. The `Z` indicates UTC.  Returned by Cybersource for all services. 
    */
    'submitTimeUtc'?: string;
    /**
    * total number of subscriptions created
    */
    'totalCount'?: number;
    'subscriptions'?: Array<GetAllSubscriptionsResponseSubscriptions>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "GetAllPlansResponseLinks"
        },
        {
            "name": "submitTimeUtc",
            "baseName": "submitTimeUtc",
            "type": "string"
        },
        {
            "name": "totalCount",
            "baseName": "totalCount",
            "type": "number"
        },
        {
            "name": "subscriptions",
            "baseName": "subscriptions",
            "type": "Array<GetAllSubscriptionsResponseSubscriptions>"
        }    ];

    static getAttributeTypeMap() {
        return GetAllSubscriptionsResponse.attributeTypeMap;
    }
}

export class GetAllSubscriptionsResponseLinks {
    'self'?: PtsV2PaymentsPost201ResponseLinksSelf;
    'cancel'?: PtsV2PaymentsPost201ResponseLinksSelf;
    'suspend'?: PtsV2PaymentsPost201ResponseLinksSelf;
    'activate'?: PtsV2PaymentsPost201ResponseLinksSelf;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "self",
            "baseName": "self",
            "type": "PtsV2PaymentsPost201ResponseLinksSelf"
        },
        {
            "name": "cancel",
            "baseName": "cancel",
            "type": "PtsV2PaymentsPost201ResponseLinksSelf"
        },
        {
            "name": "suspend",
            "baseName": "suspend",
            "type": "PtsV2PaymentsPost201ResponseLinksSelf"
        },
        {
            "name": "activate",
            "baseName": "activate",
            "type": "PtsV2PaymentsPost201ResponseLinksSelf"
        }    ];

    static getAttributeTypeMap() {
        return GetAllSubscriptionsResponseLinks.attributeTypeMap;
    }
}

export class GetAllSubscriptionsResponseOrderInformation {
    'amountDetails'?: GetAllPlansResponseOrderInformationAmountDetails;
    'billTo'?: GetAllSubscriptionsResponseOrderInformationBillTo;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "amountDetails",
            "baseName": "amountDetails",
            "type": "GetAllPlansResponseOrderInformationAmountDetails"
        },
        {
            "name": "billTo",
            "baseName": "billTo",
            "type": "GetAllSubscriptionsResponseOrderInformationBillTo"
        }    ];

    static getAttributeTypeMap() {
        return GetAllSubscriptionsResponseOrderInformation.attributeTypeMap;
    }
}

export class GetAllSubscriptionsResponseOrderInformationBillTo {
    /**
    * Customer’s first name. 
    */
    'firstName'?: string;
    /**
    * Customer’s last name. 
    */
    'lastName'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "firstName",
            "baseName": "firstName",
            "type": "string"
        },
        {
            "name": "lastName",
            "baseName": "lastName",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetAllSubscriptionsResponseOrderInformationBillTo.attributeTypeMap;
    }
}

export class GetAllSubscriptionsResponsePaymentInformation {
    'customer'?: GetAllSubscriptionsResponsePaymentInformationCustomer;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "customer",
            "baseName": "customer",
            "type": "GetAllSubscriptionsResponsePaymentInformationCustomer"
        }    ];

    static getAttributeTypeMap() {
        return GetAllSubscriptionsResponsePaymentInformation.attributeTypeMap;
    }
}

export class GetAllSubscriptionsResponsePaymentInformationCustomer {
    /**
    * Unique identifier for the Customer token used in the transaction. When you include this value in your request, many of the fields that are normally required for an authorization or credit become optional. 
    */
    'id'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetAllSubscriptionsResponsePaymentInformationCustomer.attributeTypeMap;
    }
}

export class GetAllSubscriptionsResponsePlanInformation {
    /**
    * Plan code 
    */
    'code'?: string;
    /**
    * Plan name 
    */
    'name'?: string;
    'billingPeriod'?: GetAllPlansResponsePlanInformationBillingPeriod;
    'billingCycles'?: GetAllSubscriptionsResponsePlanInformationBillingCycles;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "billingPeriod",
            "baseName": "billingPeriod",
            "type": "GetAllPlansResponsePlanInformationBillingPeriod"
        },
        {
            "name": "billingCycles",
            "baseName": "billingCycles",
            "type": "GetAllSubscriptionsResponsePlanInformationBillingCycles"
        }    ];

    static getAttributeTypeMap() {
        return GetAllSubscriptionsResponsePlanInformation.attributeTypeMap;
    }
}

export class GetAllSubscriptionsResponsePlanInformationBillingCycles {
    /**
    * Describe total number of billing cycles 
    */
    'total'?: string;
    /**
    * Current billing cycle 
    */
    'current'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "total",
            "baseName": "total",
            "type": "string"
        },
        {
            "name": "current",
            "baseName": "current",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetAllSubscriptionsResponsePlanInformationBillingCycles.attributeTypeMap;
    }
}

export class GetAllSubscriptionsResponseSubscriptionInformation {
    /**
    * Subscription code. 
    */
    'code'?: string;
    /**
    * Plan Id. 
    */
    'planId'?: string;
    /**
    * Subscription Name 
    */
    'name'?: string;
    /**
    * Start date of the Subscription  Start date will be in UTC. Format: YYYY-MM-DDThh:mm:ssZ The T separates the date and the time. The Z indicates UTC.  **Example** 2022-08-11T22:47:57Z equals August 11, 2022, at 22:47:57 (10:47:57 p.m.). 
    */
    'startDate'?: string;
    /**
    * Subscription Status: - `PENDING` - `ACTIVE` - `FAILED` - `COMPLETED` - `DELINQUENT` - `SUSPENDED` - `CANCELLED` 
    */
    'status'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        },
        {
            "name": "planId",
            "baseName": "planId",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "startDate",
            "baseName": "startDate",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetAllSubscriptionsResponseSubscriptionInformation.attributeTypeMap;
    }
}

/**
* Subscription list
*/
export class GetAllSubscriptionsResponseSubscriptions {
    'links'?: GetAllSubscriptionsResponseLinks;
    /**
    * An unique identification number generated by Cybersource to identify the submitted request. Returned by all services. It is also appended to the endpoint of the resource. On incremental authorizations, this value with be the same as the identification number returned in the original authorization response. 
    */
    'id'?: string;
    'planInformation'?: GetAllSubscriptionsResponsePlanInformation;
    'subscriptionInformation'?: GetAllSubscriptionsResponseSubscriptionInformation;
    'paymentInformation'?: GetAllSubscriptionsResponsePaymentInformation;
    'orderInformation'?: GetAllSubscriptionsResponseOrderInformation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "GetAllSubscriptionsResponseLinks"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "planInformation",
            "baseName": "planInformation",
            "type": "GetAllSubscriptionsResponsePlanInformation"
        },
        {
            "name": "subscriptionInformation",
            "baseName": "subscriptionInformation",
            "type": "GetAllSubscriptionsResponseSubscriptionInformation"
        },
        {
            "name": "paymentInformation",
            "baseName": "paymentInformation",
            "type": "GetAllSubscriptionsResponsePaymentInformation"
        },
        {
            "name": "orderInformation",
            "baseName": "orderInformation",
            "type": "GetAllSubscriptionsResponseOrderInformation"
        }    ];

    static getAttributeTypeMap() {
        return GetAllSubscriptionsResponseSubscriptions.attributeTypeMap;
    }
}

export class GetPlanCodeResponse {
    /**
    * Plan code 
    */
    'code'?: string;
    /**
    * Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ` **Example** `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.). The `T` separates the date and the time. The `Z` indicates UTC.  Returned by Cybersource for all services. 
    */
    'submitTimeUtc'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        },
        {
            "name": "submitTimeUtc",
            "baseName": "submitTimeUtc",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetPlanCodeResponse.attributeTypeMap;
    }
}

export class GetPlanResponse {
    'links'?: PtsV2IncrementalAuthorizationPatch201ResponseLinks;
    /**
    * An unique identification number generated by Cybersource to identify the submitted request. Returned by all services. It is also appended to the endpoint of the resource. On incremental authorizations, this value with be the same as the identification number returned in the original authorization response. 
    */
    'id'?: string;
    /**
    * Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ` **Example** `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.). The `T` separates the date and the time. The `Z` indicates UTC.  Returned by Cybersource for all services. 
    */
    'submitTimeUtc'?: string;
    'planInformation'?: GetAllPlansResponsePlanInformation;
    'orderInformation'?: GetAllPlansResponseOrderInformation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "PtsV2IncrementalAuthorizationPatch201ResponseLinks"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "submitTimeUtc",
            "baseName": "submitTimeUtc",
            "type": "string"
        },
        {
            "name": "planInformation",
            "baseName": "planInformation",
            "type": "GetAllPlansResponsePlanInformation"
        },
        {
            "name": "orderInformation",
            "baseName": "orderInformation",
            "type": "GetAllPlansResponseOrderInformation"
        }    ];

    static getAttributeTypeMap() {
        return GetPlanResponse.attributeTypeMap;
    }
}

export class GetSubscriptionCodeResponse {
    /**
    * Subscription code. 
    */
    'code'?: string;
    /**
    * Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ` **Example** `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.). The `T` separates the date and the time. The `Z` indicates UTC.  Returned by Cybersource for all services. 
    */
    'submitTimeUtc'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        },
        {
            "name": "submitTimeUtc",
            "baseName": "submitTimeUtc",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetSubscriptionCodeResponse.attributeTypeMap;
    }
}

export class GetSubscriptionResponse {
    'links'?: GetAllSubscriptionsResponseLinks;
    /**
    * An unique identification number generated by Cybersource to identify the submitted request. Returned by all services. It is also appended to the endpoint of the resource. On incremental authorizations, this value with be the same as the identification number returned in the original authorization response. 
    */
    'id'?: string;
    /**
    * Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ` **Example** `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.). The `T` separates the date and the time. The `Z` indicates UTC.  Returned by Cybersource for all services. 
    */
    'submitTimeUtc'?: string;
    'planInformation'?: GetAllSubscriptionsResponsePlanInformation;
    'subscriptionInformation'?: GetAllSubscriptionsResponseSubscriptionInformation;
    'paymentInformation'?: GetAllSubscriptionsResponsePaymentInformation;
    'orderInformation'?: GetAllSubscriptionsResponseOrderInformation;
    'reactivationInformation'?: GetSubscriptionResponseReactivationInformation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "GetAllSubscriptionsResponseLinks"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "submitTimeUtc",
            "baseName": "submitTimeUtc",
            "type": "string"
        },
        {
            "name": "planInformation",
            "baseName": "planInformation",
            "type": "GetAllSubscriptionsResponsePlanInformation"
        },
        {
            "name": "subscriptionInformation",
            "baseName": "subscriptionInformation",
            "type": "GetAllSubscriptionsResponseSubscriptionInformation"
        },
        {
            "name": "paymentInformation",
            "baseName": "paymentInformation",
            "type": "GetAllSubscriptionsResponsePaymentInformation"
        },
        {
            "name": "orderInformation",
            "baseName": "orderInformation",
            "type": "GetAllSubscriptionsResponseOrderInformation"
        },
        {
            "name": "reactivationInformation",
            "baseName": "reactivationInformation",
            "type": "GetSubscriptionResponseReactivationInformation"
        }    ];

    static getAttributeTypeMap() {
        return GetSubscriptionResponse.attributeTypeMap;
    }
}

export class GetSubscriptionResponse1 {
    'links'?: GetSubscriptionResponse1Links;
    'buyerInformation'?: GetSubscriptionResponse1BuyerInformation;
    'paymentInstrument'?: GetSubscriptionResponse1PaymentInstrument;
    'shippingAddress'?: GetSubscriptionResponse1ShippingAddress;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "GetSubscriptionResponse1Links"
        },
        {
            "name": "buyerInformation",
            "baseName": "buyerInformation",
            "type": "GetSubscriptionResponse1BuyerInformation"
        },
        {
            "name": "paymentInstrument",
            "baseName": "paymentInstrument",
            "type": "GetSubscriptionResponse1PaymentInstrument"
        },
        {
            "name": "shippingAddress",
            "baseName": "shippingAddress",
            "type": "GetSubscriptionResponse1ShippingAddress"
        }    ];

    static getAttributeTypeMap() {
        return GetSubscriptionResponse1.attributeTypeMap;
    }
}

/**
* Customer information used during Follow-On Transaction.
*/
export class GetSubscriptionResponse1BuyerInformation {
    /**
    * Merchant identifier for the customer. 
    */
    'merchantCustomerID'?: string;
    /**
    * Customer's primary email address, including the full domain name. 
    */
    'email'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "merchantCustomerID",
            "baseName": "merchantCustomerID",
            "type": "string"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetSubscriptionResponse1BuyerInformation.attributeTypeMap;
    }
}

export class GetSubscriptionResponse1Links {
    'self'?: PtsV2PaymentsPost201ResponseLinksSelf;
    'create'?: PtsV2PaymentsPost201ResponseLinksSelf;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "self",
            "baseName": "self",
            "type": "PtsV2PaymentsPost201ResponseLinksSelf"
        },
        {
            "name": "create",
            "baseName": "create",
            "type": "PtsV2PaymentsPost201ResponseLinksSelf"
        }    ];

    static getAttributeTypeMap() {
        return GetSubscriptionResponse1Links.attributeTypeMap;
    }
}

/**
* Payment instrument used during Follow-On Transaction.
*/
export class GetSubscriptionResponse1PaymentInstrument {
    /**
    * The Id of the Payment Instrument Token.
    */
    'id'?: string;
    'bankAccount'?: GetSubscriptionResponse1PaymentInstrumentBankAccount;
    'card'?: GetSubscriptionResponse1PaymentInstrumentCard;
    'billTo'?: Tmsv2customersEmbeddedDefaultPaymentInstrumentBillTo;
    'buyerInformation'?: GetSubscriptionResponse1PaymentInstrumentBuyerInformation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "bankAccount",
            "baseName": "bankAccount",
            "type": "GetSubscriptionResponse1PaymentInstrumentBankAccount"
        },
        {
            "name": "card",
            "baseName": "card",
            "type": "GetSubscriptionResponse1PaymentInstrumentCard"
        },
        {
            "name": "billTo",
            "baseName": "billTo",
            "type": "Tmsv2customersEmbeddedDefaultPaymentInstrumentBillTo"
        },
        {
            "name": "buyerInformation",
            "baseName": "buyerInformation",
            "type": "GetSubscriptionResponse1PaymentInstrumentBuyerInformation"
        }    ];

    static getAttributeTypeMap() {
        return GetSubscriptionResponse1PaymentInstrument.attributeTypeMap;
    }
}

export class GetSubscriptionResponse1PaymentInstrumentBankAccount {
    /**
    * Account type.  Possible Values:  - checking : C  - general ledger : G This value is supported only on Wells Fargo ACH  - savings : S (U.S. dollars only)  - corporate checking : X (U.S. dollars only) 
    */
    'type'?: string;
    /**
    * Account number.  When processing encoded account numbers, use this field for the encoded account number. 
    */
    'number'?: string;
    /**
    * Bank routing number. This is also called the transit number 
    */
    'routingNumber'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "number",
            "baseName": "number",
            "type": "string"
        },
        {
            "name": "routingNumber",
            "baseName": "routingNumber",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetSubscriptionResponse1PaymentInstrumentBankAccount.attributeTypeMap;
    }
}

export class GetSubscriptionResponse1PaymentInstrumentBuyerInformation {
    /**
    * Company’s tax identifier. This is only used for eCheck service. 
    */
    'companyTaxID'?: string;
    /**
    * Currency used for the order. Use the three-character I[ISO Standard Currency Codes.](http://apps.cybersource.com/library/documentation/sbc/quickref/currencies.pdf)  For an authorization reversal (`reversalInformation`) or a capture (`processingOptions.capture` is set to `true`), you must use the same currency that you used in your payment authorization request.  #### DCC for First Data Your local currency. For details, see the `currency` field description in [Dynamic Currency Conversion For First Data Using the SCMP API](http://apps.cybersource.com/library/documentation/dev_guides/DCC_FirstData_SCMP/DCC_FirstData_SCMP_API.pdf). 
    */
    'currency'?: string;
    /**
    * Date of birth of the customer. Format: YYYY-MM-DD 
    */
    'dateOfBirth'?: string;
    'personalIdentification'?: Array<Tmsv2customersEmbeddedDefaultPaymentInstrumentBuyerInformationPersonalIdentification>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "companyTaxID",
            "baseName": "companyTaxID",
            "type": "string"
        },
        {
            "name": "currency",
            "baseName": "currency",
            "type": "string"
        },
        {
            "name": "dateOfBirth",
            "baseName": "dateOfBirth",
            "type": "string"
        },
        {
            "name": "personalIdentification",
            "baseName": "personalIdentification",
            "type": "Array<Tmsv2customersEmbeddedDefaultPaymentInstrumentBuyerInformationPersonalIdentification>"
        }    ];

    static getAttributeTypeMap() {
        return GetSubscriptionResponse1PaymentInstrumentBuyerInformation.attributeTypeMap;
    }
}

/**
* The masked number (PAN), expirationMonth, expirationYear and type of the card used during transaction. 
*/
export class GetSubscriptionResponse1PaymentInstrumentCard {
    /**
    * The masked customer’s payment card number, also known as the Primary Account Number (PAN). 
    */
    'number'?: string;
    /**
    * Two-digit month in which the payment card expires.  Format: `MM`.  Possible Values: `01` through `12`. 
    */
    'expirationMonth'?: string;
    /**
    * Four-digit year in which the credit card expires.  Format: `YYYY`. 
    */
    'expirationYear'?: string;
    /**
    * Value that indicates the card type. Possible Values v2 : v1:   * 001 : visa   * 002 : mastercard - Eurocard—European regional brand of Mastercard   * 003 : american express   * 004 : discover   * 005 : diners club   * 006 : carte blanche   * 007 : jcb   * 008 : optima   * 011 : twinpay credit   * 012 : twinpay debit   * 013 : walmart   * 014 : enRoute   * 015 : lowes consumer   * 016 : home depot consumer   * 017 : mbna   * 018 : dicks sportswear   * 019 : casual corner   * 020 : sears   * 021 : jal   * 023 : disney   * 024 : maestro uk domestic   * 025 : sams club consumer   * 026 : sams club business   * 028 : bill me later   * 029 : bebe   * 030 : restoration hardware   * 031 : delta online — use this value only for Ingenico ePayments. For other processors, use 001 for all Visa card types.   * 032 : solo   * 033 : visa electron   * 034 : dankort   * 035 : laser   * 036 : carte bleue — formerly Cartes Bancaires   * 037 : carta si   * 038 : pinless debit   * 039 : encoded account   * 040 : uatp   * 041 : household   * 042 : maestro international   * 043 : ge money uk   * 044 : korean cards   * 045 : style   * 046 : jcrew   * 047 : payease china processing ewallet   * 048 : payease china processing bank transfer   * 049 : meijer private label   * 050 : hipercard — supported only by the Comercio Latino processor.   * 051 : aura — supported only by the Comercio Latino processor.   * 052 : redecard   * 054 : elo — supported only by the Comercio Latino processor.   * 055 : capital one private label   * 056 : synchrony private label   * 057 : costco private label   * 060 : mada   * 062 : china union pay   * 063 : falabella private label 
    */
    'type'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "number",
            "baseName": "number",
            "type": "string"
        },
        {
            "name": "expirationMonth",
            "baseName": "expirationMonth",
            "type": "string"
        },
        {
            "name": "expirationYear",
            "baseName": "expirationYear",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetSubscriptionResponse1PaymentInstrumentCard.attributeTypeMap;
    }
}

/**
* Shipping address used during Follow-On Transaction.
*/
export class GetSubscriptionResponse1ShippingAddress {
    /**
    * The Id of the Shipping Address Token.
    */
    'id'?: string;
    'shipTo'?: Tmsv2customersEmbeddedDefaultShippingAddressShipTo;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "shipTo",
            "baseName": "shipTo",
            "type": "Tmsv2customersEmbeddedDefaultShippingAddressShipTo"
        }    ];

    static getAttributeTypeMap() {
        return GetSubscriptionResponse1ShippingAddress.attributeTypeMap;
    }
}

export class GetSubscriptionResponseReactivationInformation {
    /**
    * Number of payments that should have occurred while the subscription was in a suspended status. 
    */
    'skippedPaymentsCount'?: string;
    /**
    * Total amount that will be charged upon reactivation if `processSkippedPayments` is set to `true`. 
    */
    'skippedPaymentsTotalAmount'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "skippedPaymentsCount",
            "baseName": "skippedPaymentsCount",
            "type": "string"
        },
        {
            "name": "skippedPaymentsTotalAmount",
            "baseName": "skippedPaymentsTotalAmount",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GetSubscriptionResponseReactivationInformation.attributeTypeMap;
    }
}

export class IncrementAuthRequest {
    'clientReferenceInformation'?: Ptsv2paymentsidClientReferenceInformation;
    'processingInformation'?: Ptsv2paymentsidProcessingInformation;
    'orderInformation'?: Ptsv2paymentsidOrderInformation;
    'merchantInformation'?: Ptsv2paymentsidMerchantInformation;
    'travelInformation'?: Ptsv2paymentsidTravelInformation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "clientReferenceInformation",
            "baseName": "clientReferenceInformation",
            "type": "Ptsv2paymentsidClientReferenceInformation"
        },
        {
            "name": "processingInformation",
            "baseName": "processingInformation",
            "type": "Ptsv2paymentsidProcessingInformation"
        },
        {
            "name": "orderInformation",
            "baseName": "orderInformation",
            "type": "Ptsv2paymentsidOrderInformation"
        },
        {
            "name": "merchantInformation",
            "baseName": "merchantInformation",
            "type": "Ptsv2paymentsidMerchantInformation"
        },
        {
            "name": "travelInformation",
            "baseName": "travelInformation",
            "type": "Ptsv2paymentsidTravelInformation"
        }    ];

    static getAttributeTypeMap() {
        return IncrementAuthRequest.attributeTypeMap;
    }
}

/**
* Represents the Card Art Asset associated to the Network Token. 
*/
export class InlineResponse200 {
    /**
    * Unique identifier for the Card Art Asset. 
    */
    'id'?: string;
    /**
    * The type of Card Art Asset. 
    */
    'type'?: string;
    /**
    * The provider of the Card Art Asset. 
    */
    'provider'?: string;
    /**
    * Array of content objects representing the Card Art Asset. 
    */
    'content'?: Array<InlineResponse200Content>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "provider",
            "baseName": "provider",
            "type": "string"
        },
        {
            "name": "content",
            "baseName": "content",
            "type": "Array<InlineResponse200Content>"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse200.attributeTypeMap;
    }
}

export class InlineResponse2001 {
    /**
    * UUID uniquely generated for this comments. 
    */
    'id'?: string;
    /**
    * Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ` **Example** `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.). The `T` separates the date and the time. The `Z` indicates UTC.  Returned by Cybersource for all services. 
    */
    'submitTimeUtc'?: string;
    /**
    * The status of the submitted transaction. Possible values are: - `ACCEPTED` - `REJECTED` 
    */
    'status'?: string;
    'embedded'?: InlineResponse2001Embedded;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "submitTimeUtc",
            "baseName": "submitTimeUtc",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "embedded",
            "baseName": "_embedded",
            "type": "InlineResponse2001Embedded"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse2001.attributeTypeMap;
    }
}

export class InlineResponse20010 {
    /**
    * A collection of expiration dates and device ids
    */
    'expirations'?: Array<InlineResponse20010Expirations>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "expirations",
            "baseName": "expirations",
            "type": "Array<InlineResponse20010Expirations>"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse20010.attributeTypeMap;
    }
}

export class InlineResponse20010Expirations {
    /**
    * Id of the device
    */
    'deviceId'?: string;
    /**
    * Type of the device
    */
    'deviceType'?: string;
    /**
    * Epoc milliseconds of when the certificate of the device will expire
    */
    'expirationDateInMilliseconds'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "deviceId",
            "baseName": "deviceId",
            "type": "string"
        },
        {
            "name": "deviceType",
            "baseName": "deviceType",
            "type": "string"
        },
        {
            "name": "expirationDateInMilliseconds",
            "baseName": "expirationDateInMilliseconds",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse20010Expirations.attributeTypeMap;
    }
}

export class InlineResponse20011 {
    /**
    * Unique identifier of the customization
    */
    'id'?: string;
    /**
    * Version number of the customization
    */
    'version'?: number;
    /**
    * Map of all customization keys and their respective values
    */
    'customizations'?: { [key: string]: string; };
    /**
    * Map of all customization keys and their respective metadata
    */
    'customizationMetadata'?: Array<InlineResponse20011CustomizationMetadata>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "version",
            "baseName": "version",
            "type": "number"
        },
        {
            "name": "customizations",
            "baseName": "customizations",
            "type": "{ [key: string]: string; }"
        },
        {
            "name": "customizationMetadata",
            "baseName": "customizationMetadata",
            "type": "Array<InlineResponse20011CustomizationMetadata>"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse20011.attributeTypeMap;
    }
}

export class InlineResponse20011CustomizationMetadata {
    /**
    * Source of the customization (there are 5 possible values device, transactingMID, merchant, portfolio, semiIntegratedDefaults)
    */
    'source'?: string;
    /**
    * Format of the customization
    */
    'format'?: string;
    /**
    * Description of the customization
    */
    'description'?: string;
    /**
    * Display key of the customization
    */
    'displayKey'?: string;
    /**
    * Indicates if the customization is editable
    */
    'editable'?: boolean;
    /**
    * Type of the customization parameter (there are 4 possible values for now  COMMON, SEMI_INTEGRATED, LOGO, STANDALONE)
    */
    'paramType'?: string;
    /**
    * List of possible values for the customization
    */
    'possibleValues'?: Array<string>;
    /**
    * Indicates if multiple selections are allowed for the customization
    */
    'allowMultiSelect'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "source",
            "baseName": "source",
            "type": "string"
        },
        {
            "name": "format",
            "baseName": "format",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "displayKey",
            "baseName": "displayKey",
            "type": "string"
        },
        {
            "name": "editable",
            "baseName": "editable",
            "type": "boolean"
        },
        {
            "name": "paramType",
            "baseName": "paramType",
            "type": "string"
        },
        {
            "name": "possibleValues",
            "baseName": "possibleValues",
            "type": "Array<string>"
        },
        {
            "name": "allowMultiSelect",
            "baseName": "allowMultiSelect",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse20011CustomizationMetadata.attributeTypeMap;
    }
}

export class InlineResponse20012 {
    'links'?: Array<InlineResponse20012Links>;
    'object'?: string;
    'offset'?: number;
    'limit'?: number;
    'count'?: number;
    'total'?: number;
    'embedded'?: InlineResponse20012Embedded;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "Array<InlineResponse20012Links>"
        },
        {
            "name": "object",
            "baseName": "object",
            "type": "string"
        },
        {
            "name": "offset",
            "baseName": "offset",
            "type": "number"
        },
        {
            "name": "limit",
            "baseName": "limit",
            "type": "number"
        },
        {
            "name": "count",
            "baseName": "count",
            "type": "number"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "number"
        },
        {
            "name": "embedded",
            "baseName": "_embedded",
            "type": "InlineResponse20012Embedded"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse20012.attributeTypeMap;
    }
}

export class InlineResponse20012Embedded {
    'batches'?: Array<InlineResponse20012EmbeddedBatches>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "batches",
            "baseName": "batches",
            "type": "Array<InlineResponse20012EmbeddedBatches>"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse20012Embedded.attributeTypeMap;
    }
}

export class InlineResponse20012EmbeddedBatches {
    'links'?: InlineResponse20012EmbeddedLinks;
    /**
    * Unique identification number assigned to the submitted request.
    */
    'batchId'?: string;
    /**
    * ISO-8601 format: yyyy-MM-ddTHH:mm:ssZ
    */
    'batchCreatedDate'?: string;
    /**
    * ISO-8601 format: yyyy-MM-ddTHH:mm:ssZ
    */
    'batchModifiedDate'?: string;
    /**
    * Valid Values:   * SCHEDULER   * TOKEN_API   * CREDIT_CARD_FILE_UPLOAD   * AMEX_REGSITRY   * AMEX_REGISTRY_API   * AMEX_REGISTRY_API_SYNC   * AMEX_MAINTENANCE 
    */
    'batchSource'?: string;
    /**
    * Valid Values:   * SECURE_STORAGE   * TMS   * CYBERSOURCE 
    */
    'tokenSource'?: string;
    /**
    * Reference used by merchant to identify batch.
    */
    'merchantReference'?: string;
    /**
    * Valid Values:   * VISA   * MASTERCARD   * AMEX 
    */
    'batchCaEndpoints'?: Array<string>;
    /**
    * Valid Values:   * REJECTED   * RECEIVED   * VALIDATED   * DECLINED   * PROCESSING   * COMPLETE 
    */
    'status'?: string;
    'totals'?: InlineResponse20012EmbeddedTotals;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "InlineResponse20012EmbeddedLinks"
        },
        {
            "name": "batchId",
            "baseName": "batchId",
            "type": "string"
        },
        {
            "name": "batchCreatedDate",
            "baseName": "batchCreatedDate",
            "type": "string"
        },
        {
            "name": "batchModifiedDate",
            "baseName": "batchModifiedDate",
            "type": "string"
        },
        {
            "name": "batchSource",
            "baseName": "batchSource",
            "type": "string"
        },
        {
            "name": "tokenSource",
            "baseName": "tokenSource",
            "type": "string"
        },
        {
            "name": "merchantReference",
            "baseName": "merchantReference",
            "type": "string"
        },
        {
            "name": "batchCaEndpoints",
            "baseName": "batchCaEndpoints",
            "type": "Array<string>"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "totals",
            "baseName": "totals",
            "type": "InlineResponse20012EmbeddedTotals"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse20012EmbeddedBatches.attributeTypeMap;
    }
}

export class InlineResponse20012EmbeddedLinks {
    'reports'?: Array<InlineResponse20012EmbeddedLinksReports>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "reports",
            "baseName": "reports",
            "type": "Array<InlineResponse20012EmbeddedLinksReports>"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse20012EmbeddedLinks.attributeTypeMap;
    }
}

/**
* Retrieve the generated report of a batch when available.
*/
export class InlineResponse20012EmbeddedLinksReports {
    'href'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "href",
            "baseName": "href",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse20012EmbeddedLinksReports.attributeTypeMap;
    }
}

export class InlineResponse20012EmbeddedTotals {
    'acceptedRecords'?: number;
    'rejectedRecords'?: number;
    'updatedRecords'?: number;
    'caResponses'?: number;
    'caResponsesOmitted'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "acceptedRecords",
            "baseName": "acceptedRecords",
            "type": "number"
        },
        {
            "name": "rejectedRecords",
            "baseName": "rejectedRecords",
            "type": "number"
        },
        {
            "name": "updatedRecords",
            "baseName": "updatedRecords",
            "type": "number"
        },
        {
            "name": "caResponses",
            "baseName": "caResponses",
            "type": "number"
        },
        {
            "name": "caResponsesOmitted",
            "baseName": "caResponsesOmitted",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse20012EmbeddedTotals.attributeTypeMap;
    }
}

export class InlineResponse20012Links {
    /**
    * Valid Values:   * self   * first   * last   * prev   * next 
    */
    'rel'?: string;
    'href'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "rel",
            "baseName": "rel",
            "type": "string"
        },
        {
            "name": "href",
            "baseName": "href",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse20012Links.attributeTypeMap;
    }
}

export class InlineResponse20013 {
    'links'?: InlineResponse20013Links;
    /**
    * Unique identification number assigned to the submitted request.
    */
    'batchId'?: string;
    /**
    * ISO-8601 format: yyyy-MM-ddTHH:mm:ssZ
    */
    'batchCreatedDate'?: string;
    /**
    * Valid Values:   * SCHEDULER   * TOKEN_API   * CREDIT_CARD_FILE_UPLOAD   * AMEX_REGSITRY   * AMEX_REGISTRY_API   * AMEX_MAINTENANCE 
    */
    'batchSource'?: string;
    /**
    * Reference used by merchant to identify batch.
    */
    'merchantReference'?: string;
    'batchCaEndpoints'?: string;
    /**
    * Valid Values:   * REJECTED   * RECEIVED   * VALIDATED   * DECLINED   * PROCESSING   * COMPLETED 
    */
    'status'?: string;
    'totals'?: InlineResponse20012EmbeddedTotals;
    'billing'?: InlineResponse20013Billing;
    'description'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "InlineResponse20013Links"
        },
        {
            "name": "batchId",
            "baseName": "batchId",
            "type": "string"
        },
        {
            "name": "batchCreatedDate",
            "baseName": "batchCreatedDate",
            "type": "string"
        },
        {
            "name": "batchSource",
            "baseName": "batchSource",
            "type": "string"
        },
        {
            "name": "merchantReference",
            "baseName": "merchantReference",
            "type": "string"
        },
        {
            "name": "batchCaEndpoints",
            "baseName": "batchCaEndpoints",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "totals",
            "baseName": "totals",
            "type": "InlineResponse20012EmbeddedTotals"
        },
        {
            "name": "billing",
            "baseName": "billing",
            "type": "InlineResponse20013Billing"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse20013.attributeTypeMap;
    }
}

export class InlineResponse20013Billing {
    'nan'?: number;
    'ned'?: number;
    'acl'?: number;
    'cch'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "nan",
            "baseName": "nan",
            "type": "number"
        },
        {
            "name": "ned",
            "baseName": "ned",
            "type": "number"
        },
        {
            "name": "acl",
            "baseName": "acl",
            "type": "number"
        },
        {
            "name": "cch",
            "baseName": "cch",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse20013Billing.attributeTypeMap;
    }
}

export class InlineResponse20013Links {
    'self'?: InlineResponse202LinksStatus;
    'report'?: Array<InlineResponse20013LinksReport>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "self",
            "baseName": "self",
            "type": "InlineResponse202LinksStatus"
        },
        {
            "name": "report",
            "baseName": "report",
            "type": "Array<InlineResponse20013LinksReport>"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse20013Links.attributeTypeMap;
    }
}

export class InlineResponse20013LinksReport {
    'href'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "href",
            "baseName": "href",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse20013LinksReport.attributeTypeMap;
    }
}

export class InlineResponse20014 {
    'version'?: string;
    /**
    * ISO-8601 format: yyyy-MM-ddTHH:mm:ssZ
    */
    'reportCreatedDate'?: string;
    /**
    * Unique identification number assigned to the submitted request.
    */
    'batchId'?: string;
    /**
    * Valid Values:   * SCHEDULER   * TOKEN_API   * CREDIT_CARD_FILE_UPLOAD   * AMEX_REGSITRY   * AMEX_REGISTRY_API   * AMEX_MAINTENANCE 
    */
    'batchSource'?: string;
    'batchCaEndpoints'?: string;
    /**
    * ISO-8601 format: yyyy-MM-ddTHH:mm:ssZ
    */
    'batchCreatedDate'?: string;
    /**
    * Reference used by merchant to identify batch.
    */
    'merchantReference'?: string;
    'totals'?: InlineResponse20012EmbeddedTotals;
    'billing'?: InlineResponse20013Billing;
    'records'?: Array<InlineResponse20014Records>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "version",
            "baseName": "version",
            "type": "string"
        },
        {
            "name": "reportCreatedDate",
            "baseName": "reportCreatedDate",
            "type": "string"
        },
        {
            "name": "batchId",
            "baseName": "batchId",
            "type": "string"
        },
        {
            "name": "batchSource",
            "baseName": "batchSource",
            "type": "string"
        },
        {
            "name": "batchCaEndpoints",
            "baseName": "batchCaEndpoints",
            "type": "string"
        },
        {
            "name": "batchCreatedDate",
            "baseName": "batchCreatedDate",
            "type": "string"
        },
        {
            "name": "merchantReference",
            "baseName": "merchantReference",
            "type": "string"
        },
        {
            "name": "totals",
            "baseName": "totals",
            "type": "InlineResponse20012EmbeddedTotals"
        },
        {
            "name": "billing",
            "baseName": "billing",
            "type": "InlineResponse20013Billing"
        },
        {
            "name": "records",
            "baseName": "records",
            "type": "Array<InlineResponse20014Records>"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse20014.attributeTypeMap;
    }
}

export class InlineResponse20014Records {
    'id'?: string;
    'sourceRecord'?: InlineResponse20014SourceRecord;
    'responseRecord'?: InlineResponse20014ResponseRecord;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "sourceRecord",
            "baseName": "sourceRecord",
            "type": "InlineResponse20014SourceRecord"
        },
        {
            "name": "responseRecord",
            "baseName": "responseRecord",
            "type": "InlineResponse20014ResponseRecord"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse20014Records.attributeTypeMap;
    }
}

export class InlineResponse20014ResponseRecord {
    /**
    * Valid Values:   * NAN   * NED   * ACL   * CCH   * CUR   * NUP   * UNA   * ERR   * DEC 
    */
    'response'?: string;
    'reason'?: string;
    'token'?: string;
    'instrumentIdentifierId'?: string;
    /**
    * Valid Values:   * true   * false 
    */
    'instrumentIdentifierCreated'?: string;
    'cardNumber'?: string;
    'cardExpiryMonth'?: string;
    'cardExpiryYear'?: string;
    'cardType'?: string;
    'additionalUpdates'?: Array<InlineResponse20014ResponseRecordAdditionalUpdates>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "response",
            "baseName": "response",
            "type": "string"
        },
        {
            "name": "reason",
            "baseName": "reason",
            "type": "string"
        },
        {
            "name": "token",
            "baseName": "token",
            "type": "string"
        },
        {
            "name": "instrumentIdentifierId",
            "baseName": "instrumentIdentifierId",
            "type": "string"
        },
        {
            "name": "instrumentIdentifierCreated",
            "baseName": "instrumentIdentifierCreated",
            "type": "string"
        },
        {
            "name": "cardNumber",
            "baseName": "cardNumber",
            "type": "string"
        },
        {
            "name": "cardExpiryMonth",
            "baseName": "cardExpiryMonth",
            "type": "string"
        },
        {
            "name": "cardExpiryYear",
            "baseName": "cardExpiryYear",
            "type": "string"
        },
        {
            "name": "cardType",
            "baseName": "cardType",
            "type": "string"
        },
        {
            "name": "additionalUpdates",
            "baseName": "additionalUpdates",
            "type": "Array<InlineResponse20014ResponseRecordAdditionalUpdates>"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse20014ResponseRecord.attributeTypeMap;
    }
}

export class InlineResponse20014ResponseRecordAdditionalUpdates {
    'customerId'?: string;
    'paymentInstrumentId'?: string;
    'creator'?: string;
    /**
    * Valid Values:   * ACTIVE   * CLOSED 
    */
    'state'?: string;
    'message'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "customerId",
            "baseName": "customerId",
            "type": "string"
        },
        {
            "name": "paymentInstrumentId",
            "baseName": "paymentInstrumentId",
            "type": "string"
        },
        {
            "name": "creator",
            "baseName": "creator",
            "type": "string"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "string"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse20014ResponseRecordAdditionalUpdates.attributeTypeMap;
    }
}

export class InlineResponse20014SourceRecord {
    'token'?: string;
    'customerId'?: string;
    'paymentInstrumentId'?: string;
    'instrumentIdentifierId'?: string;
    'cardNumber'?: string;
    'cardExpiryMonth'?: string;
    'cardExpiryYear'?: string;
    'cardType'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "token",
            "baseName": "token",
            "type": "string"
        },
        {
            "name": "customerId",
            "baseName": "customerId",
            "type": "string"
        },
        {
            "name": "paymentInstrumentId",
            "baseName": "paymentInstrumentId",
            "type": "string"
        },
        {
            "name": "instrumentIdentifierId",
            "baseName": "instrumentIdentifierId",
            "type": "string"
        },
        {
            "name": "cardNumber",
            "baseName": "cardNumber",
            "type": "string"
        },
        {
            "name": "cardExpiryMonth",
            "baseName": "cardExpiryMonth",
            "type": "string"
        },
        {
            "name": "cardExpiryYear",
            "baseName": "cardExpiryYear",
            "type": "string"
        },
        {
            "name": "cardType",
            "baseName": "cardType",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse20014SourceRecord.attributeTypeMap;
    }
}

/**
* This object includes either a capture or reversal object. They each has the status of the action and link to the GET method to the following-on capture transaction or reversal transaction. 
*/
export class InlineResponse2001Embedded {
    'capture'?: InlineResponse2001EmbeddedCapture;
    'reversal'?: InlineResponse2001EmbeddedReversal;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "capture",
            "baseName": "capture",
            "type": "InlineResponse2001EmbeddedCapture"
        },
        {
            "name": "reversal",
            "baseName": "reversal",
            "type": "InlineResponse2001EmbeddedReversal"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse2001Embedded.attributeTypeMap;
    }
}

/**
* This object includes the status of the action and link to the GET method to the following-on capture transaction. 
*/
export class InlineResponse2001EmbeddedCapture {
    /**
    * The status of the capture if the capture is called. 
    */
    'status'?: string;
    'links'?: InlineResponse2001EmbeddedCaptureLinks;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "links",
            "baseName": "_links",
            "type": "InlineResponse2001EmbeddedCaptureLinks"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse2001EmbeddedCapture.attributeTypeMap;
    }
}

/**
* The link to the GET method to the capture transaction if the capture is called. 
*/
export class InlineResponse2001EmbeddedCaptureLinks {
    'self'?: InlineResponse2001EmbeddedCaptureLinksSelf;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "self",
            "baseName": "self",
            "type": "InlineResponse2001EmbeddedCaptureLinksSelf"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse2001EmbeddedCaptureLinks.attributeTypeMap;
    }
}

/**
* The object holds http method and endpoint if the capture is called. 
*/
export class InlineResponse2001EmbeddedCaptureLinksSelf {
    /**
    * This is the endpoint of the resource that was created by the successful request. 
    */
    'href'?: string;
    /**
    * This refers to the HTTP method that you can send to the self endpoint to retrieve details of the resource. 
    */
    'method'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "href",
            "baseName": "href",
            "type": "string"
        },
        {
            "name": "method",
            "baseName": "method",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse2001EmbeddedCaptureLinksSelf.attributeTypeMap;
    }
}

/**
* This object includes the status of the action and link to the GET method to the following-on reversal transaction. 
*/
export class InlineResponse2001EmbeddedReversal {
    /**
    * The status of the reversal if the auth reversal is called. 
    */
    'status'?: string;
    'links'?: InlineResponse2001EmbeddedReversalLinks;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "links",
            "baseName": "_links",
            "type": "InlineResponse2001EmbeddedReversalLinks"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse2001EmbeddedReversal.attributeTypeMap;
    }
}

/**
* The link to the GET method to the reversal transaction if the auth reversal is called. 
*/
export class InlineResponse2001EmbeddedReversalLinks {
    'self'?: InlineResponse2001EmbeddedReversalLinksSelf;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "self",
            "baseName": "self",
            "type": "InlineResponse2001EmbeddedReversalLinksSelf"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse2001EmbeddedReversalLinks.attributeTypeMap;
    }
}

/**
* The object holds http method and endpoint if the reversal is called. 
*/
export class InlineResponse2001EmbeddedReversalLinksSelf {
    /**
    * This is the endpoint of the resource that was created by the successful request. 
    */
    'href'?: string;
    /**
    * This refers to the HTTP method that you can send to the self endpoint to retrieve details of the resource. 
    */
    'method'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "href",
            "baseName": "href",
            "type": "string"
        },
        {
            "name": "method",
            "baseName": "method",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse2001EmbeddedReversalLinksSelf.attributeTypeMap;
    }
}

export class InlineResponse2002 {
    'registrationInformation'?: Boardingv1registrationsRegistrationInformation;
    'integrationInformation'?: InlineResponse2002IntegrationInformation;
    'organizationInformation'?: Boardingv1registrationsOrganizationInformation;
    'productInformation'?: Boardingv1registrationsProductInformation;
    'productInformationSetups'?: Array<InlineResponse2013ProductInformationSetups>;
    'documentInformation'?: Boardingv1registrationsDocumentInformation;
    'details'?: { [key: string]: Array<any>; };

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "registrationInformation",
            "baseName": "registrationInformation",
            "type": "Boardingv1registrationsRegistrationInformation"
        },
        {
            "name": "integrationInformation",
            "baseName": "integrationInformation",
            "type": "InlineResponse2002IntegrationInformation"
        },
        {
            "name": "organizationInformation",
            "baseName": "organizationInformation",
            "type": "Boardingv1registrationsOrganizationInformation"
        },
        {
            "name": "productInformation",
            "baseName": "productInformation",
            "type": "Boardingv1registrationsProductInformation"
        },
        {
            "name": "productInformationSetups",
            "baseName": "productInformationSetups",
            "type": "Array<InlineResponse2013ProductInformationSetups>"
        },
        {
            "name": "documentInformation",
            "baseName": "documentInformation",
            "type": "Boardingv1registrationsDocumentInformation"
        },
        {
            "name": "details",
            "baseName": "details",
            "type": "{ [key: string]: Array<any>; }"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse2002.attributeTypeMap;
    }
}

export class InlineResponse2002IntegrationInformation {
    'oauth2'?: Array<Boardingv1registrationsIntegrationInformationOauth2>;
    /**
    * tenantConfigurations is an array of objects that includes the tenant information this merchant is associated with.
    */
    'tenantConfigurations'?: Array<InlineResponse2002IntegrationInformationTenantConfigurations>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "oauth2",
            "baseName": "oauth2",
            "type": "Array<Boardingv1registrationsIntegrationInformationOauth2>"
        },
        {
            "name": "tenantConfigurations",
            "baseName": "tenantConfigurations",
            "type": "Array<InlineResponse2002IntegrationInformationTenantConfigurations>"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse2002IntegrationInformation.attributeTypeMap;
    }
}

export class InlineResponse2002IntegrationInformationTenantConfigurations {
    /**
    * The solutionId is the unique identifier for this system resource. Partner can use it to reference the specific solution through out the system. 
    */
    'solutionId'?: string;
    /**
    * The tenantConfigurationId is the unique identifier for this system resource. You will see various places where it must be referenced in the URI path, or when querying the hierarchy for ancestors or descendants. 
    */
    'tenantConfigurationId'?: string;
    'status'?: InlineResponse2002IntegrationInformationTenantConfigurations.StatusEnum;
    /**
    * Time of request in UTC.
    */
    'submitTimeUtc'?: Date;
    'tenantInformation'?: Boardingv1registrationsIntegrationInformationTenantInformation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "solutionId",
            "baseName": "solutionId",
            "type": "string"
        },
        {
            "name": "tenantConfigurationId",
            "baseName": "tenantConfigurationId",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "InlineResponse2002IntegrationInformationTenantConfigurations.StatusEnum"
        },
        {
            "name": "submitTimeUtc",
            "baseName": "submitTimeUtc",
            "type": "Date"
        },
        {
            "name": "tenantInformation",
            "baseName": "tenantInformation",
            "type": "Boardingv1registrationsIntegrationInformationTenantInformation"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse2002IntegrationInformationTenantConfigurations.attributeTypeMap;
    }
}

export namespace InlineResponse2002IntegrationInformationTenantConfigurations {
    export enum StatusEnum {
        LIVE = <any> 'LIVE',
        INACTIVE = <any> 'INACTIVE',
        TEST = <any> 'TEST'
    }
}
export class InlineResponse2003 {
    /**
    * Product ID.
    */
    'productId'?: string;
    /**
    * Product Name.
    */
    'productName'?: string;
    'eventTypes'?: Array<Notificationsubscriptionsv2productsorganizationIdEventTypes>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "productId",
            "baseName": "productId",
            "type": "string"
        },
        {
            "name": "productName",
            "baseName": "productName",
            "type": "string"
        },
        {
            "name": "eventTypes",
            "baseName": "eventTypes",
            "type": "Array<Notificationsubscriptionsv2productsorganizationIdEventTypes>"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse2003.attributeTypeMap;
    }
}

export class InlineResponse2004 {
    /**
    * Webhook Id. This is generated by the server.
    */
    'webhookId'?: string;
    /**
    * Organization ID.
    */
    'organizationId'?: string;
    'products'?: Array<Notificationsubscriptionsv2webhooksProducts>;
    /**
    * The client's endpoint (URL) to receive webhooks.
    */
    'webhookUrl'?: string;
    /**
    * The client's health check endpoint (URL).
    */
    'healthCheckUrl'?: string;
    /**
    * Webhook status.
    */
    'status'?: string;
    /**
    * Client friendly webhook name.
    */
    'name'?: string;
    /**
    * Client friendly webhook description.
    */
    'description'?: string;
    'retryPolicy'?: Notificationsubscriptionsv2webhooksRetryPolicy;
    'securityPolicy'?: Notificationsubscriptionsv2webhooksSecurityPolicy;
    /**
    * Date on which webhook was created/registered.
    */
    'createdOn'?: string;
    /**
    * The webhook scope. 1. SELF The Webhook is used to deliver webhooks for only this Organization (or Merchant). 2. DESCENDANTS The Webhook is used to deliver webhooks for this Organization and its children. This field is optional.  
    */
    'notificationScope'?: InlineResponse2004.NotificationScopeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "webhookId",
            "baseName": "webhookId",
            "type": "string"
        },
        {
            "name": "organizationId",
            "baseName": "organizationId",
            "type": "string"
        },
        {
            "name": "products",
            "baseName": "products",
            "type": "Array<Notificationsubscriptionsv2webhooksProducts>"
        },
        {
            "name": "webhookUrl",
            "baseName": "webhookUrl",
            "type": "string"
        },
        {
            "name": "healthCheckUrl",
            "baseName": "healthCheckUrl",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "retryPolicy",
            "baseName": "retryPolicy",
            "type": "Notificationsubscriptionsv2webhooksRetryPolicy"
        },
        {
            "name": "securityPolicy",
            "baseName": "securityPolicy",
            "type": "Notificationsubscriptionsv2webhooksSecurityPolicy"
        },
        {
            "name": "createdOn",
            "baseName": "createdOn",
            "type": "string"
        },
        {
            "name": "notificationScope",
            "baseName": "notificationScope",
            "type": "InlineResponse2004.NotificationScopeEnum"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse2004.attributeTypeMap;
    }
}

export namespace InlineResponse2004 {
    export enum NotificationScopeEnum {
        SELF = <any> 'SELF',
        DESCENDANTS = <any> 'DESCENDANTS'
    }
}
export class InlineResponse2005 {
    /**
    * Webhook Id. This is generated by the server.
    */
    'webhookId'?: string;
    /**
    * Organization ID.
    */
    'organizationId'?: string;
    'products'?: Array<Notificationsubscriptionsv2webhooksProducts>;
    /**
    * The client's endpoint (URL) to receive webhooks.
    */
    'webhookUrl'?: string;
    /**
    * The client's health check endpoint (URL).
    */
    'healthCheckUrl'?: string;
    /**
    * Webhook status.
    */
    'status'?: string;
    /**
    * Client friendly webhook name.
    */
    'name'?: string;
    /**
    * Client friendly webhook description.
    */
    'description'?: string;
    'retryPolicy'?: Notificationsubscriptionsv2webhooksRetryPolicy;
    'securityPolicy'?: Notificationsubscriptionsv2webhooksSecurityPolicy;
    /**
    * Date on which webhook was created/registered.
    */
    'createdOn'?: string;
    /**
    * Date on which webhook was most recently updated.
    */
    'updatedOn'?: string;
    /**
    * The webhook scope. 1. SELF The Webhook is used to deliver webhooks for only this Organization (or Merchant). 2. DESCENDANTS The Webhook is used to deliver webhooks for this Organization and its children. This field is optional.  
    */
    'notificationScope'?: InlineResponse2005.NotificationScopeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "webhookId",
            "baseName": "webhookId",
            "type": "string"
        },
        {
            "name": "organizationId",
            "baseName": "organizationId",
            "type": "string"
        },
        {
            "name": "products",
            "baseName": "products",
            "type": "Array<Notificationsubscriptionsv2webhooksProducts>"
        },
        {
            "name": "webhookUrl",
            "baseName": "webhookUrl",
            "type": "string"
        },
        {
            "name": "healthCheckUrl",
            "baseName": "healthCheckUrl",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "retryPolicy",
            "baseName": "retryPolicy",
            "type": "Notificationsubscriptionsv2webhooksRetryPolicy"
        },
        {
            "name": "securityPolicy",
            "baseName": "securityPolicy",
            "type": "Notificationsubscriptionsv2webhooksSecurityPolicy"
        },
        {
            "name": "createdOn",
            "baseName": "createdOn",
            "type": "string"
        },
        {
            "name": "updatedOn",
            "baseName": "updatedOn",
            "type": "string"
        },
        {
            "name": "notificationScope",
            "baseName": "notificationScope",
            "type": "InlineResponse2005.NotificationScopeEnum"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse2005.attributeTypeMap;
    }
}

export namespace InlineResponse2005 {
    export enum NotificationScopeEnum {
        SELF = <any> 'SELF',
        DESCENDANTS = <any> 'DESCENDANTS'
    }
}
export class InlineResponse2006 {
    /**
    * Time of request in UTC. `Format: YYYY-MM-DDThh:mm:ssZ`  Example 2016-08-11T22:47:57Z equals August 11, 2016, at 22:47:57 (10:47:57 p.m.). The T separates the date and the time. The Z indicates UTC. 
    */
    'submitTimeUtc'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "submitTimeUtc",
            "baseName": "submitTimeUtc",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse2006.attributeTypeMap;
    }
}

export class InlineResponse2007 {
    'status'?: InlineResponse2007.StatusEnum;
    'devices'?: Array<Dmsv3devicesdeassociateDevices>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "status",
            "baseName": "status",
            "type": "InlineResponse2007.StatusEnum"
        },
        {
            "name": "devices",
            "baseName": "devices",
            "type": "Array<Dmsv3devicesdeassociateDevices>"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse2007.attributeTypeMap;
    }
}

export namespace InlineResponse2007 {
    export enum StatusEnum {
        OK = <any> 'OK'
    }
}
export class InlineResponse2008 {
    /**
    * Total number of results.
    */
    'totalCount'?: number;
    /**
    * Controls the starting point within the collection of results, which defaults to 0. The first item in the collection is retrieved by setting a zero offset.  For example, if you have a collection of 15 items to be retrieved from a resource and you specify limit=5, you can retrieve the entire set of results in 3 successive requests by varying the offset value like this:  `offset=0` `offset=5` `offset=10`  **Note:** If an offset larger than the number of results is provided, this will result in no embedded object being returned. 
    */
    'offset'?: number;
    /**
    * Controls the maximum number of items that may be returned for a single request. The default is 20, the maximum is 2500. 
    */
    'limit'?: number;
    /**
    * A comma separated list of the following form:  `terminalCreationDate:desc or serialNumber or terminalUpdationDate` 
    */
    'sort'?: string;
    /**
    * Results for this page, this could be below the limit.
    */
    'count'?: number;
    /**
    * A collection of devices
    */
    'devices'?: Array<InlineResponse2008Devices>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "totalCount",
            "baseName": "totalCount",
            "type": "number"
        },
        {
            "name": "offset",
            "baseName": "offset",
            "type": "number"
        },
        {
            "name": "limit",
            "baseName": "limit",
            "type": "number"
        },
        {
            "name": "sort",
            "baseName": "sort",
            "type": "string"
        },
        {
            "name": "count",
            "baseName": "count",
            "type": "number"
        },
        {
            "name": "devices",
            "baseName": "devices",
            "type": "Array<InlineResponse2008Devices>"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse2008.attributeTypeMap;
    }
}

export class InlineResponse2008Devices {
    'readerId'?: string;
    'serialNumber'?: string;
    'model'?: string;
    'make'?: string;
    'hardwareRevision'?: string;
    /**
    * Status of the device. Possible Values:   - 'ACTIVE'   - 'INACTIVE' 
    */
    'status'?: InlineResponse2008Devices.StatusEnum;
    /**
    * Reason for change in status.
    */
    'statusChangeReason'?: string;
    /**
    * ID of the merchant to whom this device is assigned.
    */
    'merchantId'?: string;
    /**
    * ID of the account to whom the device assigned.
    */
    'accountId'?: string;
    /**
    * Timestamp in which the device was created.
    */
    'terminalCreationDate'?: Date;
    /**
    * Timestamp in which the device was updated/modified.
    */
    'terminalUpdationDate'?: Date;
    'paymentProcessorToTerminalMap'?: InlineResponse2008PaymentProcessorToTerminalMap;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "readerId",
            "baseName": "readerId",
            "type": "string"
        },
        {
            "name": "serialNumber",
            "baseName": "serialNumber",
            "type": "string"
        },
        {
            "name": "model",
            "baseName": "model",
            "type": "string"
        },
        {
            "name": "make",
            "baseName": "make",
            "type": "string"
        },
        {
            "name": "hardwareRevision",
            "baseName": "hardwareRevision",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "InlineResponse2008Devices.StatusEnum"
        },
        {
            "name": "statusChangeReason",
            "baseName": "statusChangeReason",
            "type": "string"
        },
        {
            "name": "merchantId",
            "baseName": "merchantId",
            "type": "string"
        },
        {
            "name": "accountId",
            "baseName": "accountId",
            "type": "string"
        },
        {
            "name": "terminalCreationDate",
            "baseName": "terminalCreationDate",
            "type": "Date"
        },
        {
            "name": "terminalUpdationDate",
            "baseName": "terminalUpdationDate",
            "type": "Date"
        },
        {
            "name": "paymentProcessorToTerminalMap",
            "baseName": "paymentProcessorToTerminalMap",
            "type": "InlineResponse2008PaymentProcessorToTerminalMap"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse2008Devices.attributeTypeMap;
    }
}

export namespace InlineResponse2008Devices {
    export enum StatusEnum {
        ACTIVE = <any> 'ACTIVE',
        INACTIVE = <any> 'INACTIVE'
    }
}
/**
* Mapping between processor and Terminal.
*/
export class InlineResponse2008PaymentProcessorToTerminalMap {
    'processor'?: string;
    'terminalId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "processor",
            "baseName": "processor",
            "type": "string"
        },
        {
            "name": "terminalId",
            "baseName": "terminalId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse2008PaymentProcessorToTerminalMap.attributeTypeMap;
    }
}

export class InlineResponse2009 {
    /**
    * String representation of certificate of the certificate issuing authority.
    */
    'certificateChain'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "certificateChain",
            "baseName": "certificateChain",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse2009.attributeTypeMap;
    }
}

export class InlineResponse200Content {
    /**
    * The MIME type of the Asset. 
    */
    'type'?: string;
    /**
    * The base64-encoded data of the Asset. 
    */
    'data'?: string;
    /**
    * The width of the Asset in pixels. 
    */
    'width'?: number;
    /**
    * The height of the Asset in pixels. 
    */
    'height'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "string"
        },
        {
            "name": "width",
            "baseName": "width",
            "type": "number"
        },
        {
            "name": "height",
            "baseName": "height",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse200Content.attributeTypeMap;
    }
}

export class InlineResponse201 {
    /**
    * An unique identification number generated by Cybersource to identify the submitted request. Returned by all services. It is also appended to the endpoint of the resource. On incremental authorizations, this value with be the same as the identification number returned in the original authorization response. 
    */
    'id'?: string;
    /**
    * The status of the request.  Possible values:  - COMPLETED 
    */
    'status'?: string;
    'paymentInformation'?: InlineResponse201PaymentInformation;
    'orderInformation'?: InlineResponse201OrderInformation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "paymentInformation",
            "baseName": "paymentInformation",
            "type": "InlineResponse201PaymentInformation"
        },
        {
            "name": "orderInformation",
            "baseName": "orderInformation",
            "type": "InlineResponse201OrderInformation"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse201.attributeTypeMap;
    }
}

export class InlineResponse2011 {
    /**
    * UUID uniquely generated for this comments. 
    */
    'id'?: string;
    /**
    * Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ` **Example** `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.). The `T` separates the date and the time. The `Z` indicates UTC.  Returned by Cybersource for all services. 
    */
    'submitTimeUtc'?: string;
    /**
    * Status of the comment creation. Possible values are: - `COMPLETED` 
    */
    'status'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "submitTimeUtc",
            "baseName": "submitTimeUtc",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse2011.attributeTypeMap;
    }
}

export class InlineResponse20110 {
    'status'?: InlineResponse20110.StatusEnum;
    'details'?: Array<Dmsv2devicetransferDetails>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "status",
            "baseName": "status",
            "type": "InlineResponse20110.StatusEnum"
        },
        {
            "name": "details",
            "baseName": "details",
            "type": "Array<Dmsv2devicetransferDetails>"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse20110.attributeTypeMap;
    }
}

export namespace InlineResponse20110 {
    export enum StatusEnum {
        CREATED = <any> 'CREATED',
        ACCEPTED = <any> 'ACCEPTED'
    }
}
export class InlineResponse2012 {
    /**
    * An unique identification number generated by Cybersource to identify the submitted request. Returned by all services. It is also appended to the endpoint of the resource. On incremental authorizations, this value with be the same as the identification number returned in the original authorization response. 
    */
    'id'?: string;
    /**
    * Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ` **Example** `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.). The `T` separates the date and the time. The `Z` indicates UTC.  Returned by Cybersource for all services. 
    */
    'submitTimeUtc'?: string;
    /**
    * The status of the submitted transaction.  Possible values:  - COMPLETED  - MULTIPLE  - NO MATCH 
    */
    'status'?: string;
    'paymentAccountInformation'?: TmsBinLookupPaymentAccountInformation;
    'issuerInformation'?: TmsBinLookupIssuerInformation;
    'payoutInformation'?: InlineResponse2012PayoutInformation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "submitTimeUtc",
            "baseName": "submitTimeUtc",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "paymentAccountInformation",
            "baseName": "paymentAccountInformation",
            "type": "TmsBinLookupPaymentAccountInformation"
        },
        {
            "name": "issuerInformation",
            "baseName": "issuerInformation",
            "type": "TmsBinLookupIssuerInformation"
        },
        {
            "name": "payoutInformation",
            "baseName": "payoutInformation",
            "type": "InlineResponse2012PayoutInformation"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse2012.attributeTypeMap;
    }
}

export class InlineResponse2012PayoutInformation {
    'pushFunds'?: InlineResponse2012PayoutInformationPushFunds;
    'pullFunds'?: InlineResponse2012PayoutInformationPullFunds;
    /**
    * This field indicates if the recipient issuer can accept transactions from the originator country. Possible values:   - `Y`   - `N` 
    */
    'geoRestrictionIndicator'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "pushFunds",
            "baseName": "pushFunds",
            "type": "InlineResponse2012PayoutInformationPushFunds"
        },
        {
            "name": "pullFunds",
            "baseName": "pullFunds",
            "type": "InlineResponse2012PayoutInformationPullFunds"
        },
        {
            "name": "geoRestrictionIndicator",
            "baseName": "geoRestrictionIndicator",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse2012PayoutInformation.attributeTypeMap;
    }
}

export class InlineResponse2012PayoutInformationPullFunds {
    /**
    * This field indicates if domestic AFTs (pull funds) are allowed. Note: Supported only in US for domestic transactions involving Push Payments Gateway Service(PPGS). Possible values:   - `true`   - `false` 
    */
    'domesticParticipant'?: string;
    /**
    * This field indicates if cross-border AFTs (pull funds) are allowed. Note: Supported only in US for cross-border transactions involving Push Payments Gateway Service(PPGS). Possible values:   - `true`   - `false` 
    */
    'crossBorderParticipant'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "domesticParticipant",
            "baseName": "domesticParticipant",
            "type": "string"
        },
        {
            "name": "crossBorderParticipant",
            "baseName": "crossBorderParticipant",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse2012PayoutInformationPullFunds.attributeTypeMap;
    }
}

export class InlineResponse2012PayoutInformationPushFunds {
    /**
    * This field indicates if cross-border money transfer OCTs (fast push funds) are allowed. Possible values:   - `Y`   - `N` 
    */
    'moneyTransferFastFundsCrossBorder'?: string;
    /**
    * This field indicates if domestic money transfer OCTs (fast push funds) are allowed. Possible values:   - `Y`   - `N` 
    */
    'moneyTransferFastFundsDomestic'?: string;
    /**
    * This field indicates if cross-border money transfer OCTs (push funds) are allowed. Possible values:   - `Y`   - `N` 
    */
    'moneyTransferCrossBorder'?: string;
    /**
    * This field indicates if domestic money transfer OCTs (push funds) are allowed. Possible values:   - `Y`   - `N` 
    */
    'moneyTransferDomestic'?: string;
    /**
    * This field indicates if cross-border non-money transfer OCTs (fast push funds) are allowed. Possible values:   - `Y`   - `N` 
    */
    'nonMoneyTransferFastFundsCrossBorder'?: string;
    /**
    * This field indicates if domestic non-money transfer OCTs (fast push funds) are allowed. Possible values:   - `Y`   - `N` 
    */
    'nonMoneyTransferFastFundsDomestic'?: string;
    /**
    * This field indicates if cross-border non-money transfer OCTs (push funds) are allowed. Possible values:   - `Y`   - `N` 
    */
    'nonMoneyTransferCrossBorder'?: string;
    /**
    * This field indicates if domestic non-money transfer OCTs (push funds) are allowed. Possible values:   - `Y`   - `N` 
    */
    'nonMoneyTransferDomestic'?: string;
    /**
    * This field indicates if cross-border gambling OCTs (fast push funds) are allowed. Possible values:   - `Y`   - `N` 
    */
    'onlineGamblingFastFundsCrossBorder'?: string;
    /**
    * This field indicates if domestic gambling OCTs (fast push funds) are allowed. Possible values:   - `Y`   - `N` 
    */
    'onlineGamblingFastFundsDomestic'?: string;
    /**
    * This field indicates if cross-border gambling OCTs (push funds) are allowed. Possible values:   - `Y`   - `N` 
    */
    'onlineGamblingCrossBorder'?: string;
    /**
    * This field indicates if domestic gambling OCTs (push funds) are allowed. Possible values:   - `Y`   - `N` 
    */
    'onlineGamblingDomestic'?: string;
    /**
    * This field indicates if domestic OCTs (push funds) are allowed. Note: Supported only in US for domestic transactions involving Push Payments Gateway Service(PPGS). Possible values:   - `true`   - `false` 
    */
    'domesticParticipant'?: string;
    /**
    * This field indicates if cross-border OCTs (push funds) are allowed. Note: Supported only in US for cross-border transactions involving Push Payments Gateway Service(PPGS). Possible values:   - `true`   - `false` 
    */
    'crossBorderParticipant'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "moneyTransferFastFundsCrossBorder",
            "baseName": "moneyTransferFastFundsCrossBorder",
            "type": "string"
        },
        {
            "name": "moneyTransferFastFundsDomestic",
            "baseName": "moneyTransferFastFundsDomestic",
            "type": "string"
        },
        {
            "name": "moneyTransferCrossBorder",
            "baseName": "moneyTransferCrossBorder",
            "type": "string"
        },
        {
            "name": "moneyTransferDomestic",
            "baseName": "moneyTransferDomestic",
            "type": "string"
        },
        {
            "name": "nonMoneyTransferFastFundsCrossBorder",
            "baseName": "nonMoneyTransferFastFundsCrossBorder",
            "type": "string"
        },
        {
            "name": "nonMoneyTransferFastFundsDomestic",
            "baseName": "nonMoneyTransferFastFundsDomestic",
            "type": "string"
        },
        {
            "name": "nonMoneyTransferCrossBorder",
            "baseName": "nonMoneyTransferCrossBorder",
            "type": "string"
        },
        {
            "name": "nonMoneyTransferDomestic",
            "baseName": "nonMoneyTransferDomestic",
            "type": "string"
        },
        {
            "name": "onlineGamblingFastFundsCrossBorder",
            "baseName": "onlineGamblingFastFundsCrossBorder",
            "type": "string"
        },
        {
            "name": "onlineGamblingFastFundsDomestic",
            "baseName": "onlineGamblingFastFundsDomestic",
            "type": "string"
        },
        {
            "name": "onlineGamblingCrossBorder",
            "baseName": "onlineGamblingCrossBorder",
            "type": "string"
        },
        {
            "name": "onlineGamblingDomestic",
            "baseName": "onlineGamblingDomestic",
            "type": "string"
        },
        {
            "name": "domesticParticipant",
            "baseName": "domesticParticipant",
            "type": "string"
        },
        {
            "name": "crossBorderParticipant",
            "baseName": "crossBorderParticipant",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse2012PayoutInformationPushFunds.attributeTypeMap;
    }
}

export class InlineResponse2013 {
    'id'?: string;
    /**
    * Time of request in UTC. `Format: YYYY-MM-DDThh:mm:ssZ`  Example 2016-08-11T22:47:57Z equals August 11, 2016, at 22:47:57 (10:47:57 p.m.). The T separates the date and the time. The Z indicates UTC. 
    */
    'submitTimeUtc'?: Date;
    /**
    * The status of Registration request Possible Values:   - 'INITIALIZED'   - 'RECEIVED'   - 'PROCESSING'   - 'SUCCESS'   - 'FAILURE'   - 'PARTIAL' 
    */
    'status'?: InlineResponse2013.StatusEnum;
    'registrationInformation'?: InlineResponse2013RegistrationInformation;
    'integrationInformation'?: InlineResponse2013IntegrationInformation;
    'organizationInformation'?: InlineResponse2013OrganizationInformation;
    'productInformationSetups'?: Array<InlineResponse2013ProductInformationSetups>;
    'message'?: string;
    'details'?: { [key: string]: Array<any>; };

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "submitTimeUtc",
            "baseName": "submitTimeUtc",
            "type": "Date"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "InlineResponse2013.StatusEnum"
        },
        {
            "name": "registrationInformation",
            "baseName": "registrationInformation",
            "type": "InlineResponse2013RegistrationInformation"
        },
        {
            "name": "integrationInformation",
            "baseName": "integrationInformation",
            "type": "InlineResponse2013IntegrationInformation"
        },
        {
            "name": "organizationInformation",
            "baseName": "organizationInformation",
            "type": "InlineResponse2013OrganizationInformation"
        },
        {
            "name": "productInformationSetups",
            "baseName": "productInformationSetups",
            "type": "Array<InlineResponse2013ProductInformationSetups>"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        },
        {
            "name": "details",
            "baseName": "details",
            "type": "{ [key: string]: Array<any>; }"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse2013.attributeTypeMap;
    }
}

export namespace InlineResponse2013 {
    export enum StatusEnum {
        INITIALIZED = <any> 'INITIALIZED',
        RECEIVED = <any> 'RECEIVED',
        PROCESSING = <any> 'PROCESSING',
        SUCCESS = <any> 'SUCCESS',
        FAILURE = <any> 'FAILURE',
        PARTIAL = <any> 'PARTIAL'
    }
}
export class InlineResponse2013IntegrationInformation {
    /**
    * tenantConfigurations is an array of objects that includes the tenant information this merchant is associated with.
    */
    'tenantConfigurations'?: Array<InlineResponse2013IntegrationInformationTenantConfigurations>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "tenantConfigurations",
            "baseName": "tenantConfigurations",
            "type": "Array<InlineResponse2013IntegrationInformationTenantConfigurations>"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse2013IntegrationInformation.attributeTypeMap;
    }
}

export class InlineResponse2013IntegrationInformationTenantConfigurations {
    /**
    * The solutionId is the unique identifier for this system resource. Partner can use it to reference the specific solution through out the system. 
    */
    'solutionId'?: string;
    /**
    * The tenantConfigurationId is the unique identifier for this system resource. You will see various places where it must be referenced in the URI path, or when querying the hierarchy for ancestors or descendants. 
    */
    'tenantConfigurationId'?: string;
    'status'?: InlineResponse2013IntegrationInformationTenantConfigurations.StatusEnum;
    /**
    * Time of request in UTC.
    */
    'submitTimeUtc'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "solutionId",
            "baseName": "solutionId",
            "type": "string"
        },
        {
            "name": "tenantConfigurationId",
            "baseName": "tenantConfigurationId",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "InlineResponse2013IntegrationInformationTenantConfigurations.StatusEnum"
        },
        {
            "name": "submitTimeUtc",
            "baseName": "submitTimeUtc",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse2013IntegrationInformationTenantConfigurations.attributeTypeMap;
    }
}

export namespace InlineResponse2013IntegrationInformationTenantConfigurations {
    export enum StatusEnum {
        LIVE = <any> 'LIVE',
        INACTIVE = <any> 'INACTIVE',
        TEST = <any> 'TEST'
    }
}
export class InlineResponse2013OrganizationInformation {
    'organizationId'?: string;
    'parentOrganizationId'?: string;
    'childOrganizations'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "organizationId",
            "baseName": "organizationId",
            "type": "string"
        },
        {
            "name": "parentOrganizationId",
            "baseName": "parentOrganizationId",
            "type": "string"
        },
        {
            "name": "childOrganizations",
            "baseName": "childOrganizations",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse2013OrganizationInformation.attributeTypeMap;
    }
}

export class InlineResponse2013ProductInformationSetups {
    'organizationId'?: string;
    'setups'?: InlineResponse2013Setups;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "organizationId",
            "baseName": "organizationId",
            "type": "string"
        },
        {
            "name": "setups",
            "baseName": "setups",
            "type": "InlineResponse2013Setups"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse2013ProductInformationSetups.attributeTypeMap;
    }
}

export class InlineResponse2013RegistrationInformation {
    'boardingPackageId'?: string;
    /**
    * In case mode is not provided the API will use COMPLETE as default Possible Values:   - 'COMPLETE'   - 'PARTIAL' 
    */
    'mode'?: InlineResponse2013RegistrationInformation.ModeEnum;
    'salesRepId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "boardingPackageId",
            "baseName": "boardingPackageId",
            "type": "string"
        },
        {
            "name": "mode",
            "baseName": "mode",
            "type": "InlineResponse2013RegistrationInformation.ModeEnum"
        },
        {
            "name": "salesRepId",
            "baseName": "salesRepId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse2013RegistrationInformation.attributeTypeMap;
    }
}

export namespace InlineResponse2013RegistrationInformation {
    export enum ModeEnum {
        COMPLETE = <any> 'COMPLETE',
        PARTIAL = <any> 'PARTIAL'
    }
}
export class InlineResponse2013Setups {
    'payments'?: InlineResponse2013SetupsPayments;
    'risk'?: InlineResponse2013SetupsRisk;
    'commerceSolutions'?: InlineResponse2013SetupsCommerceSolutions;
    'valueAddedServices'?: InlineResponse2013SetupsValueAddedServices;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "payments",
            "baseName": "payments",
            "type": "InlineResponse2013SetupsPayments"
        },
        {
            "name": "risk",
            "baseName": "risk",
            "type": "InlineResponse2013SetupsRisk"
        },
        {
            "name": "commerceSolutions",
            "baseName": "commerceSolutions",
            "type": "InlineResponse2013SetupsCommerceSolutions"
        },
        {
            "name": "valueAddedServices",
            "baseName": "valueAddedServices",
            "type": "InlineResponse2013SetupsValueAddedServices"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse2013Setups.attributeTypeMap;
    }
}

export class InlineResponse2013SetupsCommerceSolutions {
    'tokenManagement'?: InlineResponse2013SetupsPaymentsCardProcessing;
    'accountUpdater'?: InlineResponse2013SetupsPaymentsCardProcessing;
    'binLookup'?: InlineResponse2013SetupsPaymentsCardProcessing;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "tokenManagement",
            "baseName": "tokenManagement",
            "type": "InlineResponse2013SetupsPaymentsCardProcessing"
        },
        {
            "name": "accountUpdater",
            "baseName": "accountUpdater",
            "type": "InlineResponse2013SetupsPaymentsCardProcessing"
        },
        {
            "name": "binLookup",
            "baseName": "binLookup",
            "type": "InlineResponse2013SetupsPaymentsCardProcessing"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse2013SetupsCommerceSolutions.attributeTypeMap;
    }
}

export class InlineResponse2013SetupsPayments {
    'cardProcessing'?: InlineResponse2013SetupsPaymentsCardProcessing;
    'alternativePaymentMethods'?: InlineResponse2013SetupsPaymentsAlternativePaymentMethods;
    'cardPresentConnect'?: InlineResponse2013SetupsPaymentsCardProcessing;
    'eCheck'?: InlineResponse2013SetupsPaymentsCardProcessing;
    'payerAuthentication'?: InlineResponse2013SetupsPaymentsCardProcessing;
    'digitalPayments'?: InlineResponse2013SetupsPaymentsDigitalPayments;
    'secureAcceptance'?: InlineResponse2013SetupsPaymentsCardProcessing;
    'virtualTerminal'?: InlineResponse2013SetupsPaymentsCardProcessing;
    'currencyConversion'?: InlineResponse2013SetupsPaymentsCardProcessing;
    'tax'?: InlineResponse2013SetupsPaymentsDigitalPayments;
    'customerInvoicing'?: InlineResponse2013SetupsPaymentsDigitalPayments;
    'recurringBilling'?: InlineResponse2013SetupsPaymentsCardProcessing;
    'cybsReadyTerminal'?: InlineResponse2013SetupsPaymentsCardProcessing;
    'paymentOrchestration'?: InlineResponse2013SetupsPaymentsDigitalPayments;
    'payouts'?: InlineResponse2013SetupsPaymentsCardProcessing;
    'payByLink'?: InlineResponse2013SetupsPaymentsDigitalPayments;
    'unifiedCheckout'?: InlineResponse2013SetupsPaymentsDigitalPayments;
    'receivablesManager'?: InlineResponse2013SetupsPaymentsDigitalPayments;
    'serviceFee'?: InlineResponse2013SetupsPaymentsCardProcessing;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "cardProcessing",
            "baseName": "cardProcessing",
            "type": "InlineResponse2013SetupsPaymentsCardProcessing"
        },
        {
            "name": "alternativePaymentMethods",
            "baseName": "alternativePaymentMethods",
            "type": "InlineResponse2013SetupsPaymentsAlternativePaymentMethods"
        },
        {
            "name": "cardPresentConnect",
            "baseName": "cardPresentConnect",
            "type": "InlineResponse2013SetupsPaymentsCardProcessing"
        },
        {
            "name": "eCheck",
            "baseName": "eCheck",
            "type": "InlineResponse2013SetupsPaymentsCardProcessing"
        },
        {
            "name": "payerAuthentication",
            "baseName": "payerAuthentication",
            "type": "InlineResponse2013SetupsPaymentsCardProcessing"
        },
        {
            "name": "digitalPayments",
            "baseName": "digitalPayments",
            "type": "InlineResponse2013SetupsPaymentsDigitalPayments"
        },
        {
            "name": "secureAcceptance",
            "baseName": "secureAcceptance",
            "type": "InlineResponse2013SetupsPaymentsCardProcessing"
        },
        {
            "name": "virtualTerminal",
            "baseName": "virtualTerminal",
            "type": "InlineResponse2013SetupsPaymentsCardProcessing"
        },
        {
            "name": "currencyConversion",
            "baseName": "currencyConversion",
            "type": "InlineResponse2013SetupsPaymentsCardProcessing"
        },
        {
            "name": "tax",
            "baseName": "tax",
            "type": "InlineResponse2013SetupsPaymentsDigitalPayments"
        },
        {
            "name": "customerInvoicing",
            "baseName": "customerInvoicing",
            "type": "InlineResponse2013SetupsPaymentsDigitalPayments"
        },
        {
            "name": "recurringBilling",
            "baseName": "recurringBilling",
            "type": "InlineResponse2013SetupsPaymentsCardProcessing"
        },
        {
            "name": "cybsReadyTerminal",
            "baseName": "cybsReadyTerminal",
            "type": "InlineResponse2013SetupsPaymentsCardProcessing"
        },
        {
            "name": "paymentOrchestration",
            "baseName": "paymentOrchestration",
            "type": "InlineResponse2013SetupsPaymentsDigitalPayments"
        },
        {
            "name": "payouts",
            "baseName": "payouts",
            "type": "InlineResponse2013SetupsPaymentsCardProcessing"
        },
        {
            "name": "payByLink",
            "baseName": "payByLink",
            "type": "InlineResponse2013SetupsPaymentsDigitalPayments"
        },
        {
            "name": "unifiedCheckout",
            "baseName": "unifiedCheckout",
            "type": "InlineResponse2013SetupsPaymentsDigitalPayments"
        },
        {
            "name": "receivablesManager",
            "baseName": "receivablesManager",
            "type": "InlineResponse2013SetupsPaymentsDigitalPayments"
        },
        {
            "name": "serviceFee",
            "baseName": "serviceFee",
            "type": "InlineResponse2013SetupsPaymentsCardProcessing"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse2013SetupsPayments.attributeTypeMap;
    }
}

export class InlineResponse2013SetupsPaymentsAlternativePaymentMethods {
    'configurationStatus'?: InlineResponse2013SetupsPaymentsAlternativePaymentMethodsConfigurationStatus;
    'subscriptionStatus'?: InlineResponse2013SetupsPaymentsAlternativePaymentMethodsConfigurationStatus;
    'status'?: InlineResponse2013SetupsPaymentsAlternativePaymentMethods.StatusEnum;
    /**
    * Time of request in UTC. `Format: YYYY-MM-DDThh:mm:ssZ` Example: 2024-09-08T09:37:38+0000 
    */
    'submitTimeUtc'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "configurationStatus",
            "baseName": "configurationStatus",
            "type": "InlineResponse2013SetupsPaymentsAlternativePaymentMethodsConfigurationStatus"
        },
        {
            "name": "subscriptionStatus",
            "baseName": "subscriptionStatus",
            "type": "InlineResponse2013SetupsPaymentsAlternativePaymentMethodsConfigurationStatus"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "InlineResponse2013SetupsPaymentsAlternativePaymentMethods.StatusEnum"
        },
        {
            "name": "submitTimeUtc",
            "baseName": "submitTimeUtc",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse2013SetupsPaymentsAlternativePaymentMethods.attributeTypeMap;
    }
}

export namespace InlineResponse2013SetupsPaymentsAlternativePaymentMethods {
    export enum StatusEnum {
        PROCESSED = <any> 'PROCESSED',
        PARTIALPROCESSED = <any> 'PARTIAL_PROCESSED'
    }
}
export class InlineResponse2013SetupsPaymentsAlternativePaymentMethodsConfigurationStatus {
    'status'?: InlineResponse2013SetupsPaymentsAlternativePaymentMethodsConfigurationStatus.StatusEnum;
    'message'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "status",
            "baseName": "status",
            "type": "InlineResponse2013SetupsPaymentsAlternativePaymentMethodsConfigurationStatus.StatusEnum"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse2013SetupsPaymentsAlternativePaymentMethodsConfigurationStatus.attributeTypeMap;
    }
}

export namespace InlineResponse2013SetupsPaymentsAlternativePaymentMethodsConfigurationStatus {
    export enum StatusEnum {
        SUCCESS = <any> 'SUCCESS',
        FAILURE = <any> 'FAILURE',
        PARTIAL = <any> 'PARTIAL',
        PENDING = <any> 'PENDING'
    }
}
export class InlineResponse2013SetupsPaymentsCardProcessing {
    'subscriptionStatus'?: InlineResponse2013SetupsPaymentsCardProcessingSubscriptionStatus;
    'configurationStatus'?: InlineResponse2013SetupsPaymentsCardProcessingConfigurationStatus;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "subscriptionStatus",
            "baseName": "subscriptionStatus",
            "type": "InlineResponse2013SetupsPaymentsCardProcessingSubscriptionStatus"
        },
        {
            "name": "configurationStatus",
            "baseName": "configurationStatus",
            "type": "InlineResponse2013SetupsPaymentsCardProcessingConfigurationStatus"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse2013SetupsPaymentsCardProcessing.attributeTypeMap;
    }
}

export class InlineResponse2013SetupsPaymentsCardProcessingConfigurationStatus {
    /**
    * This is NOT for MVP
    */
    'configurationId'?: string;
    'version'?: string;
    /**
    * Time of request in UTC. `Format: YYYY-MM-DDThh:mm:ssZ`  Example 2016-08-11T22:47:57Z equals August 11, 2016, at 22:47:57 (10:47:57 p.m.). The T separates the date and the time. The Z indicates UTC. 
    */
    'submitTimeUtc'?: string;
    'status'?: InlineResponse2013SetupsPaymentsCardProcessingConfigurationStatus.StatusEnum;
    'reason'?: InlineResponse2013SetupsPaymentsCardProcessingConfigurationStatus.ReasonEnum;
    'details'?: Array<{ [key: string]: string; }>;
    'message'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "configurationId",
            "baseName": "configurationId",
            "type": "string"
        },
        {
            "name": "version",
            "baseName": "version",
            "type": "string"
        },
        {
            "name": "submitTimeUtc",
            "baseName": "submitTimeUtc",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "InlineResponse2013SetupsPaymentsCardProcessingConfigurationStatus.StatusEnum"
        },
        {
            "name": "reason",
            "baseName": "reason",
            "type": "InlineResponse2013SetupsPaymentsCardProcessingConfigurationStatus.ReasonEnum"
        },
        {
            "name": "details",
            "baseName": "details",
            "type": "Array<{ [key: string]: string; }>"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse2013SetupsPaymentsCardProcessingConfigurationStatus.attributeTypeMap;
    }
}

export namespace InlineResponse2013SetupsPaymentsCardProcessingConfigurationStatus {
    export enum StatusEnum {
        SUCCESS = <any> 'SUCCESS',
        PARTIAL = <any> 'PARTIAL',
        PENDING = <any> 'PENDING',
        NOTSETUP = <any> 'NOT_SETUP'
    }
    export enum ReasonEnum {
        PENDINGPROVISIONINGPROCESS = <any> 'PENDING_PROVISIONING_PROCESS',
        MISSINGDATA = <any> 'MISSING_DATA',
        INVALIDDATA = <any> 'INVALID_DATA',
        DUPLICATEFIELD = <any> 'DUPLICATE_FIELD',
        NOTAPPLICABLE = <any> 'NOT_APPLICABLE'
    }
}
export class InlineResponse2013SetupsPaymentsCardProcessingSubscriptionStatus {
    /**
    * Time of request in UTC. `Format: YYYY-MM-DDThh:mm:ssZ`  Example 2016-08-11T22:47:57Z equals August 11, 2016, at 22:47:57 (10:47:57 p.m.). The T separates the date and the time. The Z indicates UTC. 
    */
    'submitTimeUtc'?: string;
    'status'?: InlineResponse2013SetupsPaymentsCardProcessingSubscriptionStatus.StatusEnum;
    'reason'?: InlineResponse2013SetupsPaymentsCardProcessingSubscriptionStatus.ReasonEnum;
    'details'?: Array<{ [key: string]: string; }>;
    'message'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "submitTimeUtc",
            "baseName": "submitTimeUtc",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "InlineResponse2013SetupsPaymentsCardProcessingSubscriptionStatus.StatusEnum"
        },
        {
            "name": "reason",
            "baseName": "reason",
            "type": "InlineResponse2013SetupsPaymentsCardProcessingSubscriptionStatus.ReasonEnum"
        },
        {
            "name": "details",
            "baseName": "details",
            "type": "Array<{ [key: string]: string; }>"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse2013SetupsPaymentsCardProcessingSubscriptionStatus.attributeTypeMap;
    }
}

export namespace InlineResponse2013SetupsPaymentsCardProcessingSubscriptionStatus {
    export enum StatusEnum {
        SUCCESS = <any> 'SUCCESS',
        FAILURE = <any> 'FAILURE',
        PARTIAL = <any> 'PARTIAL',
        PENDING = <any> 'PENDING'
    }
    export enum ReasonEnum {
        DEPENDENTPRODUCTNOTCONTRACTED = <any> 'DEPENDENT_PRODUCT_NOT_CONTRACTED',
        DEPENDENTFEATURENOTCHOSEN = <any> 'DEPENDENT_FEATURE_NOT_CHOSEN',
        MISSINGDATA = <any> 'MISSING_DATA',
        INVALIDDATA = <any> 'INVALID_DATA',
        DUPLICATEFIELD = <any> 'DUPLICATE_FIELD'
    }
}
export class InlineResponse2013SetupsPaymentsDigitalPayments {
    'subscriptionStatus'?: InlineResponse2013SetupsPaymentsCardProcessingSubscriptionStatus;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "subscriptionStatus",
            "baseName": "subscriptionStatus",
            "type": "InlineResponse2013SetupsPaymentsCardProcessingSubscriptionStatus"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse2013SetupsPaymentsDigitalPayments.attributeTypeMap;
    }
}

export class InlineResponse2013SetupsRisk {
    'fraudManagementEssentials'?: InlineResponse2013SetupsPaymentsCardProcessing;
    'decisionManager'?: InlineResponse2013SetupsPaymentsCardProcessing;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "fraudManagementEssentials",
            "baseName": "fraudManagementEssentials",
            "type": "InlineResponse2013SetupsPaymentsCardProcessing"
        },
        {
            "name": "decisionManager",
            "baseName": "decisionManager",
            "type": "InlineResponse2013SetupsPaymentsCardProcessing"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse2013SetupsRisk.attributeTypeMap;
    }
}

export class InlineResponse2013SetupsValueAddedServices {
    'reporting'?: InlineResponse2013SetupsPaymentsDigitalPayments;
    'transactionSearch'?: InlineResponse2013SetupsPaymentsDigitalPayments;
    'bankAccountValidation'?: InlineResponse2013SetupsPaymentsDigitalPayments;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "reporting",
            "baseName": "reporting",
            "type": "InlineResponse2013SetupsPaymentsDigitalPayments"
        },
        {
            "name": "transactionSearch",
            "baseName": "transactionSearch",
            "type": "InlineResponse2013SetupsPaymentsDigitalPayments"
        },
        {
            "name": "bankAccountValidation",
            "baseName": "bankAccountValidation",
            "type": "InlineResponse2013SetupsPaymentsDigitalPayments"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse2013SetupsValueAddedServices.attributeTypeMap;
    }
}

/**
* Egress Key Information Response 
*/
export class InlineResponse2014 {
    /**
    * Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ` Example `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.). The `T` separates the date and the time. The `Z` indicates UTC. 
    */
    'submitTimeUtc'?: string;
    /**
    * The status of the submitted transaction. Possible values:  - ACCEPTED 
    */
    'status'?: string;
    'clientReferenceInformation'?: Kmsegressv2keyssymClientReferenceInformation;
    'keyInformation'?: InlineResponse2014KeyInformation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "submitTimeUtc",
            "baseName": "submitTimeUtc",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "clientReferenceInformation",
            "baseName": "clientReferenceInformation",
            "type": "Kmsegressv2keyssymClientReferenceInformation"
        },
        {
            "name": "keyInformation",
            "baseName": "keyInformation",
            "type": "InlineResponse2014KeyInformation"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse2014.attributeTypeMap;
    }
}

/**
* Egress Key Information 
*/
export class InlineResponse2014KeyInformation {
    /**
    * Provider name 
    */
    'provider'?: string;
    /**
    * Tenant name 
    */
    'tenant'?: string;
    /**
    * Organization Id 
    */
    'organizationId'?: string;
    /**
    * Client key Id 
    */
    'clientKeyId'?: string;
    /**
    * Key Serial Number 
    */
    'keyId'?: string;
    /**
    * Value of the key 
    */
    'key'?: string;
    /**
    * Type of the key 
    */
    'keyType'?: string;
    /**
    * The status of the key 
    */
    'status'?: string;
    /**
    * The expiration time in UTC. `Format: YYYY-MM-DDThh:mm:ssZ` Example 2016-08-11T22:47:57Z equals August 11, 2016, at 22:47:57 (10:47:57 p.m.). The T separates the date and the time. The Z indicates UTC. 
    */
    'expirationDate'?: string;
    /**
    * Message in case of failed key 
    */
    'message'?: string;
    'errorInformation'?: InlineResponse2014KeyInformationErrorInformation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "provider",
            "baseName": "provider",
            "type": "string"
        },
        {
            "name": "tenant",
            "baseName": "tenant",
            "type": "string"
        },
        {
            "name": "organizationId",
            "baseName": "organizationId",
            "type": "string"
        },
        {
            "name": "clientKeyId",
            "baseName": "clientKeyId",
            "type": "string"
        },
        {
            "name": "keyId",
            "baseName": "keyId",
            "type": "string"
        },
        {
            "name": "key",
            "baseName": "key",
            "type": "string"
        },
        {
            "name": "keyType",
            "baseName": "keyType",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "expirationDate",
            "baseName": "expirationDate",
            "type": "string"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        },
        {
            "name": "errorInformation",
            "baseName": "errorInformation",
            "type": "InlineResponse2014KeyInformationErrorInformation"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse2014KeyInformation.attributeTypeMap;
    }
}

export class InlineResponse2014KeyInformationErrorInformation {
    /**
    * The reason of the status. Possible values:  - MISSING_FIELD  - INVALID_DATA 
    */
    'reason'?: string;
    'details'?: Array<InlineResponse2014KeyInformationErrorInformationDetails>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "reason",
            "baseName": "reason",
            "type": "string"
        },
        {
            "name": "details",
            "baseName": "details",
            "type": "Array<InlineResponse2014KeyInformationErrorInformationDetails>"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse2014KeyInformationErrorInformation.attributeTypeMap;
    }
}

export class InlineResponse2014KeyInformationErrorInformationDetails {
    /**
    * This is the flattened JSON object field name/path that is either missing or invalid
    */
    'field'?: string;
    /**
    * Possible reasons for the error. Possible values:  - MISSING_FIELD  - INVALID_DATA 
    */
    'reason'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "field",
            "baseName": "field",
            "type": "string"
        },
        {
            "name": "reason",
            "baseName": "reason",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse2014KeyInformationErrorInformationDetails.attributeTypeMap;
    }
}

export class InlineResponse2015 {
    /**
    * Webhook Id. This is generated by the server.
    */
    'webhookId'?: string;
    /**
    * Organization ID.
    */
    'organizationId'?: string;
    'products'?: Array<Notificationsubscriptionsv2webhooksProducts>;
    /**
    * The client's endpoint (URL) to receive webhooks.
    */
    'webhookUrl'?: string;
    /**
    * The client's health check endpoint (URL).
    */
    'healthCheckUrl'?: string;
    /**
    * Webhook status.
    */
    'status'?: string;
    /**
    * Client friendly webhook name.
    */
    'name'?: string;
    /**
    * Client friendly webhook description.
    */
    'description'?: string;
    'retryPolicy'?: Notificationsubscriptionsv2webhooksRetryPolicy;
    'securityPolicy'?: Notificationsubscriptionsv2webhooksSecurityPolicy;
    /**
    * Date on which webhook was created/registered.
    */
    'createdOn'?: string;
    /**
    * The webhook scope. 1. SELF The Webhook is used to deliver webhooks for only this Organization (or Merchant). 2. DESCENDANTS The Webhook is used to deliver webhooks for this Organization and its children. This field is optional.  
    */
    'notificationScope'?: InlineResponse2015.NotificationScopeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "webhookId",
            "baseName": "webhookId",
            "type": "string"
        },
        {
            "name": "organizationId",
            "baseName": "organizationId",
            "type": "string"
        },
        {
            "name": "products",
            "baseName": "products",
            "type": "Array<Notificationsubscriptionsv2webhooksProducts>"
        },
        {
            "name": "webhookUrl",
            "baseName": "webhookUrl",
            "type": "string"
        },
        {
            "name": "healthCheckUrl",
            "baseName": "healthCheckUrl",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "retryPolicy",
            "baseName": "retryPolicy",
            "type": "Notificationsubscriptionsv2webhooksRetryPolicy"
        },
        {
            "name": "securityPolicy",
            "baseName": "securityPolicy",
            "type": "Notificationsubscriptionsv2webhooksSecurityPolicy"
        },
        {
            "name": "createdOn",
            "baseName": "createdOn",
            "type": "string"
        },
        {
            "name": "notificationScope",
            "baseName": "notificationScope",
            "type": "InlineResponse2015.NotificationScopeEnum"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse2015.attributeTypeMap;
    }
}

export namespace InlineResponse2015 {
    export enum NotificationScopeEnum {
        SELF = <any> 'SELF',
        DESCENDANTS = <any> 'DESCENDANTS'
    }
}
export class InlineResponse2016 {
    /**
    * Date that the webhook was delivered
    */
    'eventDate'?: string;
    /**
    * The event name the webhook was delivered for
    */
    'eventType'?: string;
    /**
    * The Organization Identifier.
    */
    'organizationId'?: string;
    'payloads'?: InlineResponse2016Payloads;
    /**
    * The product the webhook was delivered for
    */
    'productId'?: string;
    /**
    * Identifies the the type of request
    */
    'requestType'?: string;
    /**
    * The number of retry attempts for a given webhook
    */
    'retryNumber'?: number;
    /**
    * The identifier for the webhook
    */
    'transactionTraceId'?: string;
    /**
    * The identifier of the subscription
    */
    'webhookId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "eventDate",
            "baseName": "eventDate",
            "type": "string"
        },
        {
            "name": "eventType",
            "baseName": "eventType",
            "type": "string"
        },
        {
            "name": "organizationId",
            "baseName": "organizationId",
            "type": "string"
        },
        {
            "name": "payloads",
            "baseName": "payloads",
            "type": "InlineResponse2016Payloads"
        },
        {
            "name": "productId",
            "baseName": "productId",
            "type": "string"
        },
        {
            "name": "requestType",
            "baseName": "requestType",
            "type": "string"
        },
        {
            "name": "retryNumber",
            "baseName": "retryNumber",
            "type": "number"
        },
        {
            "name": "transactionTraceId",
            "baseName": "transactionTraceId",
            "type": "string"
        },
        {
            "name": "webhookId",
            "baseName": "webhookId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse2016.attributeTypeMap;
    }
}

export class InlineResponse2016Payloads {
    'testPayload'?: InlineResponse2016PayloadsTestPayload;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "testPayload",
            "baseName": "testPayload",
            "type": "InlineResponse2016PayloadsTestPayload"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse2016Payloads.attributeTypeMap;
    }
}

export class InlineResponse2016PayloadsTestPayload {
    /**
    * The test message delivered in the webhook
    */
    'message'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse2016PayloadsTestPayload.attributeTypeMap;
    }
}

/**
* Egress Asymmetric Key Information Response. 
*/
export class InlineResponse2017 {
    /**
    * Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ` Example `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.). The `T` separates the date and the time. The `Z` indicates UTC. 
    */
    'submitTimeUtc'?: string;
    /**
    * The status of the submitted transaction. Possible values:  - ACCEPTED 
    */
    'status'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "submitTimeUtc",
            "baseName": "submitTimeUtc",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse2017.attributeTypeMap;
    }
}

export class InlineResponse2018 {
    /**
    * A globally unique device ID identifying the newly created terminal.
    */
    'id': string;
    /**
    * An identifier in the partner system which is used to setup the terminal firmware, software and configurations.
    */
    'deviceExternalId'?: string;
    /**
    * Key serial identifier of the card encryption BDK that is loaded on this device.
    */
    'cardEncryptionKsi'?: string;
    /**
    * An optional name of the card encryption BDK that is loaded on this device.
    */
    'cardEncryptionKeyName'?: string;
    /**
    * Key serial identifier of the PIN encryption BDK that is loaded on this device.
    */
    'pinEncryptionKsi'?: string;
    /**
    * An optional name of the PIN BDK that is loaded on this device,
    */
    'pinEncryptionKeyName'?: string;
    /**
    * Time of request in UTC. `Format: YYYY-MM-DDThh:mm:ssZ`  Example 2016-08-11T22:47:57Z equals August 11, 2016, at 22:47:57 (10:47:57 p.m.). The T separates the date and the time. The Z indicates UTC. 
    */
    'submitTimeUtc'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "deviceExternalId",
            "baseName": "deviceExternalId",
            "type": "string"
        },
        {
            "name": "cardEncryptionKsi",
            "baseName": "cardEncryptionKsi",
            "type": "string"
        },
        {
            "name": "cardEncryptionKeyName",
            "baseName": "cardEncryptionKeyName",
            "type": "string"
        },
        {
            "name": "pinEncryptionKsi",
            "baseName": "pinEncryptionKsi",
            "type": "string"
        },
        {
            "name": "pinEncryptionKeyName",
            "baseName": "pinEncryptionKeyName",
            "type": "string"
        },
        {
            "name": "submitTimeUtc",
            "baseName": "submitTimeUtc",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse2018.attributeTypeMap;
    }
}

export class InlineResponse2019 {
    /**
    * A collection of activation codes
    */
    'tokens'?: Array<InlineResponse2019Tokens>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "tokens",
            "baseName": "tokens",
            "type": "Array<InlineResponse2019Tokens>"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse2019.attributeTypeMap;
    }
}

export class InlineResponse2019Tokens {
    /**
    * The code that can be used to activate a terminal for the acceptance devices.
    */
    'token'?: string;
    /**
    * Number of milliseconds this code is valid from when it's generated.
    */
    'ttl'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "token",
            "baseName": "token",
            "type": "string"
        },
        {
            "name": "ttl",
            "baseName": "ttl",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse2019Tokens.attributeTypeMap;
    }
}

export class InlineResponse201OrderInformation {
    'shipTo'?: InlineResponse201OrderInformationShipTo;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "shipTo",
            "baseName": "shipTo",
            "type": "InlineResponse201OrderInformationShipTo"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse201OrderInformation.attributeTypeMap;
    }
}

export class InlineResponse201OrderInformationShipTo {
    /**
    * First name of the recipient.  #### Litle Maximum length: 25  #### All other processors Maximum length: 60  Optional field. 
    */
    'firstName'?: string;
    /**
    * Last name of the recipient.  #### Litle Maximum length: 25  #### All other processors Maximum length: 60  Optional field. 
    */
    'lastName'?: string;
    /**
    * First line of the shipping address.  Required field for authorization if any shipping address information is included in the request; otherwise, optional.  #### Tax Calculation Optional field for U.S. and Canadian taxes. Not applicable to international and value added taxes. Billing address objects will be used to determine the cardholder’s location when shipTo objects are not present. 
    */
    'address1'?: string;
    /**
    * Second line of the shipping address.  Optional field.  #### Tax Calculation Optional field for U.S. and Canadian taxes. Not applicable to international and value added taxes. Billing address objects will be used to determine the cardholder’s location when shipTo objects are not present. 
    */
    'address2'?: string;
    /**
    * State or province of the shipping address. Use the [State, Province, and Territory Codes for the United States and Canada](https://developer.cybersource.com/library/documentation/sbc/quickref/states_and_provinces.pdf) (maximum length: 2)   Required field for authorization if any shipping address information is included in the request and shipping to the U.S. or Canada; otherwise, optional.  #### Tax Calculation Optional field for U.S. and Canadian taxes. Not applicable to international and value added taxes. Billing address objects will be used to determine the cardholder’s location when shipTo objects are not present. 
    */
    'administrativeArea'?: string;
    /**
    * City of the shipping address.  Required field for authorization if any shipping address information is included in the request and shipping to the U.S. or Canada; otherwise, optional.  #### Tax Calculation Optional field for U.S. and Canadian taxes. Not applicable to international and value added taxes. Billing address objects will be used to determine the cardholder’s location when shipTo objects are not present. 
    */
    'locality'?: string;
    /**
    * Postal code for the shipping address. The postal code must consist of 5 to 9 digits.  Required field for authorization if any shipping address information is included in the request and shipping to the U.S. or Canada; otherwise, optional.  When the billing country is the U.S., the 9-digit postal code must follow this format: [5 digits][dash][4 digits]  Example 12345-6789  When the billing country is Canada, the 6-digit postal code must follow this format: [alpha][numeric][alpha][space][numeric][alpha][numeric]  Example A1B 2C3  #### American Express Direct Before sending the postal code to the processor, all nonalphanumeric characters are removed and, if the remaining value is longer than nine characters, the value is truncated starting from the right side. #### Tax Calculation Optional field for U.S. and Canadian taxes. Not applicable to international and value added taxes. Billing address objects will be used to determine the cardholder’s location when shipTo objects are not present. 
    */
    'postalCode'?: string;
    /**
    * Country of the shipping address. Use the two-character [ISO Standard Country Codes.](http://apps.cybersource.com/library/documentation/sbc/quickref/countries_alpha_list.pdf)  Required field for authorization if any shipping address information is included in the request; otherwise, optional.  #### Tax Calculation Optional field for U.S., Canadian, international tax, and value added taxes. Billing address objects will be used to determine the cardholder’s location when shipTo objects are not present. 
    */
    'country'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "firstName",
            "baseName": "firstName",
            "type": "string"
        },
        {
            "name": "lastName",
            "baseName": "lastName",
            "type": "string"
        },
        {
            "name": "address1",
            "baseName": "address1",
            "type": "string"
        },
        {
            "name": "address2",
            "baseName": "address2",
            "type": "string"
        },
        {
            "name": "administrativeArea",
            "baseName": "administrativeArea",
            "type": "string"
        },
        {
            "name": "locality",
            "baseName": "locality",
            "type": "string"
        },
        {
            "name": "postalCode",
            "baseName": "postalCode",
            "type": "string"
        },
        {
            "name": "country",
            "baseName": "country",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse201OrderInformationShipTo.attributeTypeMap;
    }
}

export class InlineResponse201PaymentInformation {
    'tokenizedPaymentMethod'?: InlineResponse201PaymentInformationTokenizedPaymentMethod;
    'eWallet'?: InlineResponse201PaymentInformationEWallet;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "tokenizedPaymentMethod",
            "baseName": "tokenizedPaymentMethod",
            "type": "InlineResponse201PaymentInformationTokenizedPaymentMethod"
        },
        {
            "name": "eWallet",
            "baseName": "eWallet",
            "type": "InlineResponse201PaymentInformationEWallet"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse201PaymentInformation.attributeTypeMap;
    }
}

export class InlineResponse201PaymentInformationEWallet {
    /**
    * The unique ID for a customer generated by PayPal.
    */
    'accountId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "accountId",
            "baseName": "accountId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse201PaymentInformationEWallet.attributeTypeMap;
    }
}

export class InlineResponse201PaymentInformationTokenizedPaymentMethod {
    /**
    * The PayPal-generated ID for the token. 
    */
    'id'?: string;
    /**
    * Indicates the type of vaulting relationship. Valid values: - “MERCHANT”: Single merchant relationship. - “PLATFORM”: Platform hosting multiple merchants. 
    */
    'usageType'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "usageType",
            "baseName": "usageType",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse201PaymentInformationTokenizedPaymentMethod.attributeTypeMap;
    }
}

export class InlineResponse202 {
    'links'?: InlineResponse202Links;
    /**
    * Unique identification number assigned to the submitted request.
    */
    'batchId'?: string;
    'batchItemCount'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "InlineResponse202Links"
        },
        {
            "name": "batchId",
            "baseName": "batchId",
            "type": "string"
        },
        {
            "name": "batchItemCount",
            "baseName": "batchItemCount",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse202.attributeTypeMap;
    }
}

export class InlineResponse202Links {
    'self'?: InlineResponse4011LinksSelf;
    'status'?: Array<InlineResponse202LinksStatus>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "self",
            "baseName": "self",
            "type": "InlineResponse4011LinksSelf"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "Array<InlineResponse202LinksStatus>"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse202Links.attributeTypeMap;
    }
}

export class InlineResponse202LinksStatus {
    'href'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "href",
            "baseName": "href",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse202LinksStatus.attributeTypeMap;
    }
}

export class InlineResponse206 {
    'status'?: InlineResponse206.StatusEnum;
    'devices'?: Array<Dmsv3devicesdeassociateDevices>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "status",
            "baseName": "status",
            "type": "InlineResponse206.StatusEnum"
        },
        {
            "name": "devices",
            "baseName": "devices",
            "type": "Array<Dmsv3devicesdeassociateDevices>"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse206.attributeTypeMap;
    }
}

export namespace InlineResponse206 {
    export enum StatusEnum {
        OK = <any> 'OK',
        BADREQUEST = <any> 'BAD_REQUEST'
    }
}
export class InlineResponse2061 {
    'status'?: InlineResponse2061.StatusEnum;
    'details'?: Array<Dmsv2devicetransferDetails1>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "status",
            "baseName": "status",
            "type": "InlineResponse2061.StatusEnum"
        },
        {
            "name": "details",
            "baseName": "details",
            "type": "Array<Dmsv2devicetransferDetails1>"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse2061.attributeTypeMap;
    }
}

export namespace InlineResponse2061 {
    export enum StatusEnum {
        CREATED = <any> 'CREATED',
        ACCEPTED = <any> 'ACCEPTED',
        BADREQUEST = <any> 'BAD_REQUEST'
    }
}
export class InlineResponse400 {
    'errors'?: Array<InlineResponse400Errors>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<InlineResponse400Errors>"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse400.attributeTypeMap;
    }
}

export class InlineResponse4001 {
    /**
    * Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ` **Example** `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.). The `T` separates the date and the time. The `Z` indicates UTC.  Returned by Cybersource for all services. 
    */
    'submitTimeUtc'?: string;
    /**
    * The status of the submitted transaction. Possible values: - `INVALID_REQUEST` 
    */
    'status'?: string;
    /**
    * The reason of the status. Possible Values: - `INVALID_DATA` 
    */
    'reason'?: string;
    /**
    * Input request error.
    */
    'message'?: string;
    'details'?: Array<PtsV2PaymentsPost201ResponseErrorInformationDetails>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "submitTimeUtc",
            "baseName": "submitTimeUtc",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "reason",
            "baseName": "reason",
            "type": "string"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        },
        {
            "name": "details",
            "baseName": "details",
            "type": "Array<PtsV2PaymentsPost201ResponseErrorInformationDetails>"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse4001.attributeTypeMap;
    }
}

export class InlineResponse4002 {
    /**
    * Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ` **Example** `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.). The `T` separates the date and the time. The `Z` indicates UTC.  Returned by Cybersource for all services. 
    */
    'submitTimeUtc'?: string;
    /**
    * The status of the submitted transaction.  Possible values:  - INVALID_REQUEST 
    */
    'status'?: string;
    /**
    * The reason of the status.  Possible values:  - MISSING_FIELD  - INVALID_DATA  - DUPLICATE_REQUEST  - INVALID_MERCHANT_CONFIGURATION 
    */
    'reason'?: string;
    /**
    * The detail message related to the status and reason listed above.
    */
    'message'?: string;
    'details'?: Array<PtsV2PaymentsPost201ResponseErrorInformationDetails>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "submitTimeUtc",
            "baseName": "submitTimeUtc",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "reason",
            "baseName": "reason",
            "type": "string"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        },
        {
            "name": "details",
            "baseName": "details",
            "type": "Array<PtsV2PaymentsPost201ResponseErrorInformationDetails>"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse4002.attributeTypeMap;
    }
}

export class InlineResponse4003 {
    /**
    * Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ` **Example** `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.). The `T` separates the date and the time. The `Z` indicates UTC.  Returned by Cybersource for all services. 
    */
    'submitTimeUtc'?: string;
    /**
    * The status of the submitted transaction.  Possible values:  - INVALID_REQUEST 
    */
    'status'?: string;
    /**
    * The reason of the status.  Possible values:  - MISSING_FIELD  - INVALID_DATA  - DUPLICATE_REQUEST  - INVALID_CARD  - CARD_TYPE_NOT_ACCEPTED  - INVALID_MERCHANT_CONFIGURATION  - PROCESSOR_UNAVAILABLE  - INVALID_CARD_TYPE 
    */
    'reason'?: string;
    /**
    * The detail message related to the status and reason listed above.
    */
    'message'?: string;
    'details'?: Array<PtsV2PaymentsPost201ResponseErrorInformationDetails>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "submitTimeUtc",
            "baseName": "submitTimeUtc",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "reason",
            "baseName": "reason",
            "type": "string"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        },
        {
            "name": "details",
            "baseName": "details",
            "type": "Array<PtsV2PaymentsPost201ResponseErrorInformationDetails>"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse4003.attributeTypeMap;
    }
}

export class InlineResponse4004 {
    /**
    * Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ` **Example** `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.). The `T` separates the date and the time. The `Z` indicates UTC.  Returned by Cybersource for all services. 
    */
    'submitTimeUtc'?: string;
    /**
    * The status of the submitted transaction.  Possible values:  - INVALID_REQUEST 
    */
    'status'?: string;
    /**
    * The reason of the status.  Possible values:  - MISSING_FIELD  - INVALID_DATA  - DUPLICATE_REQUEST  - INVALID_MERCHANT_CONFIGURATION  - PROCESSOR_UNAVAILABLE  - INVALID_FOLLOW_ON_TRANSACTION_STATUS 
    */
    'reason'?: string;
    /**
    * The detail message related to the status and reason listed above.
    */
    'message'?: string;
    'details'?: Array<PtsV2PaymentsPost201ResponseErrorInformationDetails>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "submitTimeUtc",
            "baseName": "submitTimeUtc",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "reason",
            "baseName": "reason",
            "type": "string"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        },
        {
            "name": "details",
            "baseName": "details",
            "type": "Array<PtsV2PaymentsPost201ResponseErrorInformationDetails>"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse4004.attributeTypeMap;
    }
}

/**
* Error Bean
*/
export class InlineResponse4005 {
    /**
    * Error code
    */
    'code': string;
    /**
    * Error message
    */
    'message': string;
    /**
    * Localization Key Name
    */
    'localizationKey'?: string;
    /**
    * Correlation Id
    */
    'correlationId'?: string;
    /**
    * Error Detail
    */
    'detail'?: string;
    /**
    * Error fields List
    */
    'fields'?: Array<InlineResponse4005Fields>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        },
        {
            "name": "localizationKey",
            "baseName": "localizationKey",
            "type": "string"
        },
        {
            "name": "correlationId",
            "baseName": "correlationId",
            "type": "string"
        },
        {
            "name": "detail",
            "baseName": "detail",
            "type": "string"
        },
        {
            "name": "fields",
            "baseName": "fields",
            "type": "Array<InlineResponse4005Fields>"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse4005.attributeTypeMap;
    }
}

/**
* Provide validation failed input field details
*/
export class InlineResponse4005Fields {
    /**
    * Path of the failed property
    */
    'path'?: string;
    /**
    * Error description about validation failed field
    */
    'message'?: string;
    /**
    * Localized Key Name
    */
    'localizationKey'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "path",
            "baseName": "path",
            "type": "string"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        },
        {
            "name": "localizationKey",
            "baseName": "localizationKey",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse4005Fields.attributeTypeMap;
    }
}

export class InlineResponse4006 {
    /**
    * Time of request in UTC. `Format: YYYY-MM-DDThh:mm:ssZ`  Example 2016-08-11T22:47:57Z equals August 11, 2016, at 22:47:57 (10:47:57 p.m.). The T separates the date and the time. The Z indicates UTC. 
    */
    'submitTimeUtc'?: Date;
    /**
    * The http status description of the submitted request.
    */
    'status'?: string;
    /**
    * Documented reason codes. Client should be able to use the key for generating their own error message Possible Values:   - 'INVALID_DATA'   - 'SYSTEM_ERROR'   - 'RESOURCE_NOT_FOUND' 
    */
    'reason'?: string;
    /**
    * Descriptive message for the error.
    */
    'message'?: string;
    'details'?: Array<InlineResponse4006Details>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "submitTimeUtc",
            "baseName": "submitTimeUtc",
            "type": "Date"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "reason",
            "baseName": "reason",
            "type": "string"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        },
        {
            "name": "details",
            "baseName": "details",
            "type": "Array<InlineResponse4006Details>"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse4006.attributeTypeMap;
    }
}

export class InlineResponse4006Details {
    /**
    * This is the flattened JSON object field name/path that is either missing or invalid.
    */
    'field'?: string;
    /**
    * Possible reasons for the error.
    */
    'reason'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "field",
            "baseName": "field",
            "type": "string"
        },
        {
            "name": "reason",
            "baseName": "reason",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse4006Details.attributeTypeMap;
    }
}

export class InlineResponse4007 {
    /**
    * The status of the submitted request.
    */
    'status'?: InlineResponse4007.StatusEnum;
    /**
    * The detail message related to the status and reason listed above.
    */
    'message'?: string;
    /**
    * An optional short string which identifies the exact error.
    */
    'code'?: string;
    /**
    * An optional array which provides more details of the error.
    */
    'details'?: Array<InlineResponse4007Details>;
    /**
    * Time of request in UTC. `Format: YYYY-MM-DDThh:mm:ssZ`  Example 2016-08-11T22:47:57Z equals August 11, 2016, at 22:47:57 (10:47:57 p.m.). The T separates the date and the time. The Z indicates UTC. 
    */
    'submitTimeUtc'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "status",
            "baseName": "status",
            "type": "InlineResponse4007.StatusEnum"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        },
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        },
        {
            "name": "details",
            "baseName": "details",
            "type": "Array<InlineResponse4007Details>"
        },
        {
            "name": "submitTimeUtc",
            "baseName": "submitTimeUtc",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse4007.attributeTypeMap;
    }
}

export namespace InlineResponse4007 {
    export enum StatusEnum {
        BADREQUEST = <any> 'BAD_REQUEST'
    }
}
export class InlineResponse4007Details {
    /**
    * This is the flattened JSON object field name/path that is either missing or invalid.
    */
    'field'?: string;
    /**
    * Possible reasons for the error. 
    */
    'reason'?: string;
    /**
    * An optional short string which identifies the exact field error.
    */
    'code'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "field",
            "baseName": "field",
            "type": "string"
        },
        {
            "name": "reason",
            "baseName": "reason",
            "type": "string"
        },
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse4007Details.attributeTypeMap;
    }
}

export class InlineResponse4008 {
    'correlationId'?: string;
    'details'?: Array<InlineResponse4008Details>;
    'informationLink'?: string;
    'message': string;
    'reason': InlineResponse4008.ReasonEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "correlationId",
            "baseName": "correlationId",
            "type": "string"
        },
        {
            "name": "details",
            "baseName": "details",
            "type": "Array<InlineResponse4008Details>"
        },
        {
            "name": "informationLink",
            "baseName": "informationLink",
            "type": "string"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        },
        {
            "name": "reason",
            "baseName": "reason",
            "type": "InlineResponse4008.ReasonEnum"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse4008.attributeTypeMap;
    }
}

export namespace InlineResponse4008 {
    export enum ReasonEnum {
        INVALIDAPIKEY = <any> 'INVALID_APIKEY',
        INVALIDSHIPPINGINPUTPARAMS = <any> 'INVALID_SHIPPING_INPUT_PARAMS',
        CAPTURECONTEXTINVALID = <any> 'CAPTURE_CONTEXT_INVALID',
        CAPTURECONTEXTEXPIRED = <any> 'CAPTURE_CONTEXT_EXPIRED',
        SDKXHRERROR = <any> 'SDK_XHR_ERROR',
        UNIFIEDPAYMENTSVALIDATIONPARAMS = <any> 'UNIFIEDPAYMENTS_VALIDATION_PARAMS',
        UNIFIEDPAYMENTSVALIDATIONFIELDS = <any> 'UNIFIEDPAYMENTS_VALIDATION_FIELDS',
        UNIFIEDPAYMENTPAYMENTPARAMITERS = <any> 'UNIFIEDPAYMENT_PAYMENT_PARAMITERS',
        CREATETOKENTIMEOUT = <any> 'CREATE_TOKEN_TIMEOUT',
        CREATETOKENXHRERROR = <any> 'CREATE_TOKEN_XHR_ERROR',
        SHOWLOADCONTAINERSELECTOR = <any> 'SHOW_LOAD_CONTAINER_SELECTOR',
        SHOWLOADINVALIDCONTAINER = <any> 'SHOW_LOAD_INVALID_CONTAINER',
        SHOWTOKENTIMEOUT = <any> 'SHOW_TOKEN_TIMEOUT',
        SHOWTOKENXHRERROR = <any> 'SHOW_TOKEN_XHR_ERROR',
        SHOWPAYMENTTIMEOUT = <any> 'SHOW_PAYMENT_TIMEOUT'
    }
}
export class InlineResponse4008Details {
    'location'?: string;
    'message'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "location",
            "baseName": "location",
            "type": "string"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse4008Details.attributeTypeMap;
    }
}

export class InlineResponse400Details {
    /**
    * The name of the field that caused the error.
    */
    'name'?: string;
    /**
    * The location of the field that caused the error.
    */
    'location'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "location",
            "baseName": "location",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse400Details.attributeTypeMap;
    }
}

export class InlineResponse400Errors {
    /**
    * The type of error.  Possible Values:   - invalidHeaders   - missingHeaders   - invalidFields   - missingFields   - unsupportedPaymentMethodModification   - invalidCombination 
    */
    'type'?: string;
    /**
    * The detailed message related to the type.
    */
    'message'?: string;
    'details'?: Array<InlineResponse400Details>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        },
        {
            "name": "details",
            "baseName": "details",
            "type": "Array<InlineResponse400Details>"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse400Errors.attributeTypeMap;
    }
}

export class InlineResponse401 {
    /**
    * The status of the submitted request. 
    */
    'status'?: InlineResponse401.StatusEnum;
    /**
    * The detail message related to the status and reason listed above.
    */
    'message'?: string;
    /**
    * An optional short string which identifies the exact error.
    */
    'code'?: string;
    /**
    * Time of request in UTC. `Format: YYYY-MM-DDThh:mm:ssZ`  Example 2016-08-11T22:47:57Z equals August 11, 2016, at 22:47:57 (10:47:57 p.m.). The T separates the date and the time. The Z indicates UTC. 
    */
    'submitTimeUtc'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "status",
            "baseName": "status",
            "type": "InlineResponse401.StatusEnum"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        },
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        },
        {
            "name": "submitTimeUtc",
            "baseName": "submitTimeUtc",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse401.attributeTypeMap;
    }
}

export namespace InlineResponse401 {
    export enum StatusEnum {
        UNAUTHORIZED = <any> 'UNAUTHORIZED'
    }
}
export class InlineResponse4011 {
    'links'?: InlineResponse4011Links;
    /**
    * Valid Values:   * FORBIDDEN_RESPONSE   * VALIDATION_ERROR   * UNSUPPORTED_MEDIA_TYPE   * MALFORMED_PAYLOAD_ERROR   * SERVER_ERROR 
    */
    'code'?: string;
    'correlationId'?: string;
    'detail'?: string;
    'fields'?: Array<InlineResponse4011Fields>;
    /**
    * Valid Values:   * cybsapi.forbidden.response   * cybsapi.validation.error   * cybsapi.media.notsupported 
    */
    'localizationKey'?: string;
    'message'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "InlineResponse4011Links"
        },
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        },
        {
            "name": "correlationId",
            "baseName": "correlationId",
            "type": "string"
        },
        {
            "name": "detail",
            "baseName": "detail",
            "type": "string"
        },
        {
            "name": "fields",
            "baseName": "fields",
            "type": "Array<InlineResponse4011Fields>"
        },
        {
            "name": "localizationKey",
            "baseName": "localizationKey",
            "type": "string"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse4011.attributeTypeMap;
    }
}

export class InlineResponse4011Fields {
    'path'?: string;
    'message'?: string;
    /**
    * Valid Values:   * cybsapi.ondemand.batch.email.null 
    */
    'localizationKey'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "path",
            "baseName": "path",
            "type": "string"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        },
        {
            "name": "localizationKey",
            "baseName": "localizationKey",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse4011Fields.attributeTypeMap;
    }
}

export class InlineResponse4011Links {
    'self'?: InlineResponse4011LinksSelf;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "self",
            "baseName": "self",
            "type": "InlineResponse4011LinksSelf"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse4011Links.attributeTypeMap;
    }
}

export class InlineResponse4011LinksSelf {
    'href'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "href",
            "baseName": "href",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse4011LinksSelf.attributeTypeMap;
    }
}

export class InlineResponse403 {
    'errors'?: Array<InlineResponse403Errors>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<InlineResponse403Errors>"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse403.attributeTypeMap;
    }
}

export class InlineResponse4031 {
    /**
    * Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ` **Example** `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.). The `T` separates the date and the time. The `Z` indicates UTC.  Returned by Cybersource for all services. 
    */
    'submitTimeUtc'?: string;
    /**
    * The status of the submitted transaction. Possible values: - `INVALID_REQUEST` 
    */
    'status'?: string;
    /**
    * The reason of the status. Possible Values: - `ACCESS_DENIED` 
    */
    'reason'?: string;
    /**
    * The request has an authorization failure.
    */
    'message'?: string;
    'details'?: Array<PtsV2PaymentsPost201ResponseErrorInformationDetails>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "submitTimeUtc",
            "baseName": "submitTimeUtc",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "reason",
            "baseName": "reason",
            "type": "string"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        },
        {
            "name": "details",
            "baseName": "details",
            "type": "Array<PtsV2PaymentsPost201ResponseErrorInformationDetails>"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse4031.attributeTypeMap;
    }
}

export class InlineResponse4032 {
    /**
    * The status of the submitted request. 
    */
    'status'?: InlineResponse4032.StatusEnum;
    /**
    * The detail message related to the status and reason listed above.
    */
    'message'?: string;
    /**
    * An optional short string which identifies the exact error.
    */
    'code'?: string;
    /**
    * Time of request in UTC. `Format: YYYY-MM-DDThh:mm:ssZ`  Example 2016-08-11T22:47:57Z equals August 11, 2016, at 22:47:57 (10:47:57 p.m.). The T separates the date and the time. The Z indicates UTC. 
    */
    'submitTimeUtc'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "status",
            "baseName": "status",
            "type": "InlineResponse4032.StatusEnum"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        },
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        },
        {
            "name": "submitTimeUtc",
            "baseName": "submitTimeUtc",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse4032.attributeTypeMap;
    }
}

export namespace InlineResponse4032 {
    export enum StatusEnum {
        FORBIDDEN = <any> 'FORBIDDEN'
    }
}
export class InlineResponse403Errors {
    /**
    * The type of error.  Possible Values:   - forbidden 
    */
    'type'?: string;
    /**
    * The detailed message related to the type.
    */
    'message'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse403Errors.attributeTypeMap;
    }
}

export class InlineResponse404 {
    /**
    * Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ` **Example** `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.). The `T` separates the date and the time. The `Z` indicates UTC.  Returned by Cybersource for all services. 
    */
    'submitTimeUtc'?: string;
    /**
    * The status of the submitted transaction.  Possible values:  - NOT_FOUND 
    */
    'status'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "submitTimeUtc",
            "baseName": "submitTimeUtc",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse404.attributeTypeMap;
    }
}

export class InlineResponse4041 {
    /**
    * Time of request in UTC. `Format: YYYY-MM-DDThh:mm:ssZ`  Example 2016-08-11T22:47:57Z equals August 11, 2016, at 22:47:57 (10:47:57 p.m.). The T separates the date and the time. The Z indicates UTC. 
    */
    'submitTimeUtc'?: Date;
    /**
    * The http status description of the submitted request.
    */
    'status'?: string;
    /**
    * Documented reason codes. Client should be able to use the key for generating their own error message Possible Values:   - 'RESOURCE_NOT_FOUND' 
    */
    'reason'?: string;
    /**
    * Descriptive message for the error.
    */
    'message'?: string;
    'details'?: Array<InlineResponse4006Details>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "submitTimeUtc",
            "baseName": "submitTimeUtc",
            "type": "Date"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "reason",
            "baseName": "reason",
            "type": "string"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        },
        {
            "name": "details",
            "baseName": "details",
            "type": "Array<InlineResponse4006Details>"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse4041.attributeTypeMap;
    }
}

export class InlineResponse4042 {
    'reason'?: string;
    'message'?: string;
    'details'?: Array<InlineResponse4042Details>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "reason",
            "baseName": "reason",
            "type": "string"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        },
        {
            "name": "details",
            "baseName": "details",
            "type": "Array<InlineResponse4042Details>"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse4042.attributeTypeMap;
    }
}

export class InlineResponse4042Details {
    'field'?: string;
    'reason'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "field",
            "baseName": "field",
            "type": "string"
        },
        {
            "name": "reason",
            "baseName": "reason",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse4042Details.attributeTypeMap;
    }
}

export class InlineResponse4043 {
    /**
    * The status of the submitted request. 
    */
    'status'?: InlineResponse4043.StatusEnum;
    /**
    * The detail message related to the status and reason listed above.
    */
    'message'?: string;
    /**
    * An optional short string which identifies the exact error.
    */
    'code'?: string;
    /**
    * Time of request in UTC. `Format: YYYY-MM-DDThh:mm:ssZ`  Example 2016-08-11T22:47:57Z equals August 11, 2016, at 22:47:57 (10:47:57 p.m.). The T separates the date and the time. The Z indicates UTC. 
    */
    'submitTimeUtc'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "status",
            "baseName": "status",
            "type": "InlineResponse4043.StatusEnum"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        },
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        },
        {
            "name": "submitTimeUtc",
            "baseName": "submitTimeUtc",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse4043.attributeTypeMap;
    }
}

export namespace InlineResponse4043 {
    export enum StatusEnum {
        NOTFOUND = <any> 'NOT_FOUND'
    }
}
export class InlineResponse409 {
    'errors'?: Array<InlineResponse409Errors>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<InlineResponse409Errors>"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse409.attributeTypeMap;
    }
}

export class InlineResponse409Errors {
    /**
    * The type of error.  Possible Values:   - instrumentIdentifierDeletionError   - tokenIdConflict   - conflict 
    */
    'type'?: string;
    /**
    * The detailed message related to the type.
    */
    'message'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse409Errors.attributeTypeMap;
    }
}

export class InlineResponse410 {
    'errors'?: Array<InlineResponse410Errors>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<InlineResponse410Errors>"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse410.attributeTypeMap;
    }
}

export class InlineResponse410Errors {
    /**
    * The type of error.  Possible Values:   - notAvailable 
    */
    'type'?: string;
    /**
    * The detailed message related to the type.
    */
    'message'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse410Errors.attributeTypeMap;
    }
}

export class InlineResponse412 {
    'errors'?: Array<InlineResponse412Errors>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<InlineResponse412Errors>"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse412.attributeTypeMap;
    }
}

export class InlineResponse412Errors {
    /**
    * The type of error.  Possible Values:   - conflict 
    */
    'type'?: string;
    /**
    * The detailed message related to the type.
    */
    'message'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse412Errors.attributeTypeMap;
    }
}

export class InlineResponse422 {
    /**
    * Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ` **Example** `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.). The `T` separates the date and the time. The `Z` indicates UTC.  Returned by Cybersource for all services. 
    */
    'submitTimeUtc'?: string;
    /**
    * The status of the submitted transaction. Possible values: - `INVALID_REQUEST` 
    */
    'status'?: string;
    /**
    * The reason of the status. Possible Values: - `INVALID_REQUEST` 
    */
    'reason'?: string;
    /**
    * Request payload is valid but fails business validations.
    */
    'message'?: string;
    'details'?: Array<PtsV2PaymentsPost201ResponseErrorInformationDetails>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "submitTimeUtc",
            "baseName": "submitTimeUtc",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "reason",
            "baseName": "reason",
            "type": "string"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        },
        {
            "name": "details",
            "baseName": "details",
            "type": "Array<PtsV2PaymentsPost201ResponseErrorInformationDetails>"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse422.attributeTypeMap;
    }
}

export class InlineResponse4221 {
    /**
    * Time of request in UTC. `Format: YYYY-MM-DDThh:mm:ssZ`  Example 2016-08-11T22:47:57Z equals August 11, 2016, at 22:47:57 (10:47:57 p.m.). The T separates the date and the time. The Z indicates UTC. 
    */
    'submitTimeUtc'?: Date;
    /**
    * The http status description of the submitted request.
    */
    'status'?: string;
    /**
    * Documented reason codes. Client should be able to use the key for generating their own error message Possible Values:   - 'INVALID_DATA' 
    */
    'reason'?: string;
    /**
    * Descriptive message for the error.
    */
    'message'?: string;
    'details'?: Array<InlineResponse4006Details>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "submitTimeUtc",
            "baseName": "submitTimeUtc",
            "type": "Date"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "reason",
            "baseName": "reason",
            "type": "string"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        },
        {
            "name": "details",
            "baseName": "details",
            "type": "Array<InlineResponse4006Details>"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse4221.attributeTypeMap;
    }
}

export class InlineResponse424 {
    'errors'?: Array<InlineResponse424Errors>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<InlineResponse424Errors>"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse424.attributeTypeMap;
    }
}

export class InlineResponse424Errors {
    /**
    * The type of error.  Possible Values:   - notFound 
    */
    'type'?: string;
    /**
    * The detailed message related to the type.
    */
    'message'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse424Errors.attributeTypeMap;
    }
}

export class InlineResponse500 {
    'errors'?: Array<InlineResponse500Errors>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "errors",
            "baseName": "errors",
            "type": "Array<InlineResponse500Errors>"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse500.attributeTypeMap;
    }
}

export class InlineResponse5001 {
    /**
    * Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ` **Example** `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.). The `T` separates the date and the time. The `Z` indicates UTC.  Returned by Cybersource for all services. 
    */
    'submitTimeUtc'?: string;
    /**
    * The status of the submitted transaction. Possible values: - `SERVER_ERROR` 
    */
    'status'?: string;
    /**
    * The reason of the status. Possible Values: - `SYSTEM_ERROR` 
    */
    'reason'?: string;
    /**
    * Underlying service error with exception.
    */
    'message'?: string;
    'details'?: Array<PtsV2PaymentsPost201ResponseErrorInformationDetails>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "submitTimeUtc",
            "baseName": "submitTimeUtc",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "reason",
            "baseName": "reason",
            "type": "string"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        },
        {
            "name": "details",
            "baseName": "details",
            "type": "Array<PtsV2PaymentsPost201ResponseErrorInformationDetails>"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse5001.attributeTypeMap;
    }
}

export class InlineResponse5002 {
    /**
    * Time of request in UTC. `Format: YYYY-MM-DDThh:mm:ssZ`  Example 2016-08-11T22:47:57Z equals August 11, 2016, at 22:47:57 (10:47:57 p.m.). The T separates the date and the time. The Z indicates UTC. 
    */
    'submitTimeUtc'?: Date;
    /**
    * The http status description of the submitted request.
    */
    'status'?: string;
    /**
    * Documented reason codes. Client should be able to use the key for generating their own error message Possible Values:   - 'SYSTEM_ERROR' 
    */
    'reason'?: string;
    /**
    * Descriptive message for the error.
    */
    'message'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "submitTimeUtc",
            "baseName": "submitTimeUtc",
            "type": "Date"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "reason",
            "baseName": "reason",
            "type": "string"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse5002.attributeTypeMap;
    }
}

export class InlineResponse5003 {
    /**
    * The status of the submitted request. 
    */
    'status'?: InlineResponse5003.StatusEnum;
    /**
    * The detail message related to the status and reason listed above.
    */
    'message'?: string;
    /**
    * An optional short string which identifies the exact error.
    */
    'code'?: string;
    /**
    * Time of request in UTC. `Format: YYYY-MM-DDThh:mm:ssZ`  Example 2016-08-11T22:47:57Z equals August 11, 2016, at 22:47:57 (10:47:57 p.m.). The T separates the date and the time. The Z indicates UTC. 
    */
    'submitTimeUtc'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "status",
            "baseName": "status",
            "type": "InlineResponse5003.StatusEnum"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        },
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        },
        {
            "name": "submitTimeUtc",
            "baseName": "submitTimeUtc",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse5003.attributeTypeMap;
    }
}

export namespace InlineResponse5003 {
    export enum StatusEnum {
        INTERNALSERVERERROR = <any> 'INTERNAL_SERVER_ERROR'
    }
}
export class InlineResponse500Errors {
    /**
    * The type of error.  Possible Values:   - internalError 
    */
    'type'?: string;
    /**
    * The detailed message related to the type.
    */
    'message'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse500Errors.attributeTypeMap;
    }
}

export class InlineResponse502 {
    /**
    * Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ` **Example** `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.). The `T` separates the date and the time. The `Z` indicates UTC.  Returned by Cybersource for all services. 
    */
    'submitTimeUtc'?: string;
    /**
    * The status of the submitted transaction. Possible values: - `SERVER_ERROR` 
    */
    'status'?: string;
    /**
    * The reason of the status. Possible Values: - `INTERNAL_SERVICE_ERROR` 
    */
    'reason'?: string;
    /**
    * Application failed.
    */
    'message'?: string;
    'details'?: Array<PtsV2PaymentsPost201ResponseErrorInformationDetails>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "submitTimeUtc",
            "baseName": "submitTimeUtc",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "reason",
            "baseName": "reason",
            "type": "string"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        },
        {
            "name": "details",
            "baseName": "details",
            "type": "Array<PtsV2PaymentsPost201ResponseErrorInformationDetails>"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse502.attributeTypeMap;
    }
}

export class InlineResponse503 {
    /**
    * Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ` **Example** `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.). The `T` separates the date and the time. The `Z` indicates UTC.  Returned by Cybersource for all services. 
    */
    'submitTimeUtc'?: string;
    /**
    * The status of the submitted transaction. Possible values: - `SERVER_ERROR` 
    */
    'status'?: string;
    /**
    * The reason of the status. Possible Values: - `INTERNAL_SERVICE_ERROR` 
    */
    'reason'?: string;
    /**
    * Service is unavailable.
    */
    'message'?: string;
    'details'?: Array<PtsV2PaymentsPost201ResponseErrorInformationDetails>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "submitTimeUtc",
            "baseName": "submitTimeUtc",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "reason",
            "baseName": "reason",
            "type": "string"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        },
        {
            "name": "details",
            "baseName": "details",
            "type": "Array<PtsV2PaymentsPost201ResponseErrorInformationDetails>"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponse503.attributeTypeMap;
    }
}

export class InlineResponseDefault {
    'responseStatus'?: InlineResponseDefaultResponseStatus;
    'links'?: InlineResponseDefaultLinks;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "responseStatus",
            "baseName": "responseStatus",
            "type": "InlineResponseDefaultResponseStatus"
        },
        {
            "name": "links",
            "baseName": "_links",
            "type": "InlineResponseDefaultLinks"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponseDefault.attributeTypeMap;
    }
}

export class InlineResponseDefaultLinks {
    'next'?: Array<InlineResponseDefaultLinksNext>;
    'documentation'?: Array<InlineResponseDefaultLinksNext>;
    'self'?: InlineResponseDefaultLinksNext;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "next",
            "baseName": "next",
            "type": "Array<InlineResponseDefaultLinksNext>"
        },
        {
            "name": "documentation",
            "baseName": "documentation",
            "type": "Array<InlineResponseDefaultLinksNext>"
        },
        {
            "name": "self",
            "baseName": "self",
            "type": "InlineResponseDefaultLinksNext"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponseDefaultLinks.attributeTypeMap;
    }
}

export class InlineResponseDefaultLinksNext {
    /**
    * URI of the linked resource.
    */
    'href'?: string;
    /**
    * Label of the linked resource.
    */
    'title'?: string;
    /**
    * HTTP method of the linked resource.
    */
    'method'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "href",
            "baseName": "href",
            "type": "string"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "method",
            "baseName": "method",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponseDefaultLinksNext.attributeTypeMap;
    }
}

export class InlineResponseDefaultResponseStatus {
    /**
    * HTTP Status code.
    */
    'status'?: number;
    /**
    * Error Reason Code.
    */
    'reason'?: string;
    /**
    * Error Message.
    */
    'message'?: string;
    /**
    * API correlation ID.
    */
    'correlationId'?: string;
    'details'?: Array<InlineResponseDefaultResponseStatusDetails>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "status",
            "baseName": "status",
            "type": "number"
        },
        {
            "name": "reason",
            "baseName": "reason",
            "type": "string"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        },
        {
            "name": "correlationId",
            "baseName": "correlationId",
            "type": "string"
        },
        {
            "name": "details",
            "baseName": "details",
            "type": "Array<InlineResponseDefaultResponseStatusDetails>"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponseDefaultResponseStatus.attributeTypeMap;
    }
}

export class InlineResponseDefaultResponseStatusDetails {
    /**
    * Field name referred to for validation issues.
    */
    'location'?: string;
    /**
    * Description or code of any error response.
    */
    'message'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "location",
            "baseName": "location",
            "type": "string"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return InlineResponseDefaultResponseStatusDetails.attributeTypeMap;
    }
}

export class IntimateBillingAgreement {
    'clientReferenceInformation'?: Ptsv2paymentsClientReferenceInformation;
    'installmentInformation'?: Ptsv2billingagreementsInstallmentInformation;
    'merchantInformation'?: Ptsv2billingagreementsMerchantInformation;
    'orderInformation'?: Ptsv2billingagreementsOrderInformation;
    'paymentInformation'?: Ptsv2billingagreementsPaymentInformation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "clientReferenceInformation",
            "baseName": "clientReferenceInformation",
            "type": "Ptsv2paymentsClientReferenceInformation"
        },
        {
            "name": "installmentInformation",
            "baseName": "installmentInformation",
            "type": "Ptsv2billingagreementsInstallmentInformation"
        },
        {
            "name": "merchantInformation",
            "baseName": "merchantInformation",
            "type": "Ptsv2billingagreementsMerchantInformation"
        },
        {
            "name": "orderInformation",
            "baseName": "orderInformation",
            "type": "Ptsv2billingagreementsOrderInformation"
        },
        {
            "name": "paymentInformation",
            "baseName": "paymentInformation",
            "type": "Ptsv2billingagreementsPaymentInformation"
        }    ];

    static getAttributeTypeMap() {
        return IntimateBillingAgreement.attributeTypeMap;
    }
}

export class InvoiceSettingsRequest {
    'invoiceSettingsInformation'?: Invoicingv2invoiceSettingsInvoiceSettingsInformation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "invoiceSettingsInformation",
            "baseName": "invoiceSettingsInformation",
            "type": "Invoicingv2invoiceSettingsInvoiceSettingsInformation"
        }    ];

    static getAttributeTypeMap() {
        return InvoiceSettingsRequest.attributeTypeMap;
    }
}

export class InvoicingV2InvoiceSettingsGet200Response {
    /**
    * Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ` **Example** `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.). The `T` separates the date and the time. The `Z` indicates UTC.  Returned by Cybersource for all services. 
    */
    'submitTimeUtc'?: string;
    'invoiceSettingsInformation'?: InvoicingV2InvoiceSettingsGet200ResponseInvoiceSettingsInformation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "submitTimeUtc",
            "baseName": "submitTimeUtc",
            "type": "string"
        },
        {
            "name": "invoiceSettingsInformation",
            "baseName": "invoiceSettingsInformation",
            "type": "InvoicingV2InvoiceSettingsGet200ResponseInvoiceSettingsInformation"
        }    ];

    static getAttributeTypeMap() {
        return InvoicingV2InvoiceSettingsGet200Response.attributeTypeMap;
    }
}

export class InvoicingV2InvoiceSettingsGet200ResponseInvoiceSettingsInformation {
    /**
    * The image file, which must be encoded in Base64 format. Supported file formats are `png`, `jpg`, and `gif`. The image file size restriction is 1 MB.
    */
    'merchantLogo'?: string;
    /**
    * The merchant's display name shown on the invoice.
    */
    'merchantDisplayName'?: string;
    /**
    * The content of the email message that we send to your customers.
    */
    'customEmailMessage'?: string;
    /**
    * Whether you would like us to send an auto-generated reminder email to your invoice recipients. Currently, this reminder email is sent five days before the invoice is due and one day after it is past due.
    */
    'enableReminders'?: boolean;
    'headerStyle'?: InvoicingV2InvoiceSettingsGet200ResponseInvoiceSettingsInformationHeaderStyle;
    /**
    * The language of the email that we send to your customers. Possible values are `zh-CN`, `zh-TW`, `en-US`, `fr-FR`, `de-DE`, `ja-JP`, `pt-BR`, `ru-RU` and `es-419`.
    */
    'deliveryLanguage'?: string;
    /**
    * Currency used for the order. Use the three-character [ISO Standard Currency Codes.](http://apps.cybersource.com/library/documentation/sbc/quickref/currencies.pdf)  #### Used by **Authorization** Required field.  **Authorization Reversal** For an authorization reversal (`reversalInformation`) or a capture (`processingOptions.capture` is set to `true`), you must use the same currency that you used in your payment authorization request.  #### PIN Debit Currency for the amount you requested for the PIN debit purchase. This value is returned for partial authorizations. The issuing bank can approve a partial amount if the balance on the debit card is less than the requested transaction amount. For the possible values, see the [ISO Standard Currency Codes](https://developer.cybersource.com/library/documentation/sbc/quickref/currencies.pdf). Returned by PIN debit purchase.  For PIN debit reversal requests, you must use the same currency that was used for the PIN debit purchase or PIN debit credit that you are reversing. For the possible values, see the [ISO Standard Currency Codes](https://developer.cybersource.com/library/documentation/sbc/quickref/currencies.pdf).  Required field for PIN Debit purchase and PIN Debit credit requests. Optional field for PIN Debit reversal requests.  #### GPX This field is optional for reversing an authorization or credit.  #### DCC for First Data Your local currency.  #### Tax Calculation Required for international tax and value added tax only. Optional for U.S. and Canadian taxes. Your local currency. 
    */
    'defaultCurrencyCode'?: string;
    /**
    * The 3D Secure payer authentication status for a merchant's invoice payments.
    */
    'payerAuthentication3DSVersion'?: boolean;
    /**
    * Display VAT number on Invoice.
    */
    'showVatNumber'?: boolean;
    /**
    * Your government-assigned tax identification number.  #### Tax Calculation Required field for value added tax only. Not applicable to U.S. and Canadian taxes.  
    */
    'vatRegistrationNumber'?: string;
    /**
    * Collect the payers shipping address.
    */
    'shipTo'?: boolean;
    /**
    * Collect the payers phone number.
    */
    'phoneNumber'?: boolean;
    /**
    * Collect the payers email address when the email address is not known or confirm it if it is known at the time of invoice creation.
    */
    'email'?: boolean;
    /**
    * Whether you would like to receive payment notification for successful transaction
    */
    'enableMerchantEmailNotifications'?: boolean;
    /**
    * A list of custom labels that allows you to override (rename) default field names and control the visibility of specific fields on invoices and items. If the list is empty, the labels will not be overwritten. 
    */
    'customLabels'?: Array<InvoicingV2InvoicesPost201ResponseInvoiceInformationCustomLabels>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "merchantLogo",
            "baseName": "merchantLogo",
            "type": "string"
        },
        {
            "name": "merchantDisplayName",
            "baseName": "merchantDisplayName",
            "type": "string"
        },
        {
            "name": "customEmailMessage",
            "baseName": "customEmailMessage",
            "type": "string"
        },
        {
            "name": "enableReminders",
            "baseName": "enableReminders",
            "type": "boolean"
        },
        {
            "name": "headerStyle",
            "baseName": "headerStyle",
            "type": "InvoicingV2InvoiceSettingsGet200ResponseInvoiceSettingsInformationHeaderStyle"
        },
        {
            "name": "deliveryLanguage",
            "baseName": "deliveryLanguage",
            "type": "string"
        },
        {
            "name": "defaultCurrencyCode",
            "baseName": "defaultCurrencyCode",
            "type": "string"
        },
        {
            "name": "payerAuthentication3DSVersion",
            "baseName": "payerAuthentication3DSVersion",
            "type": "boolean"
        },
        {
            "name": "showVatNumber",
            "baseName": "showVatNumber",
            "type": "boolean"
        },
        {
            "name": "vatRegistrationNumber",
            "baseName": "vatRegistrationNumber",
            "type": "string"
        },
        {
            "name": "shipTo",
            "baseName": "shipTo",
            "type": "boolean"
        },
        {
            "name": "phoneNumber",
            "baseName": "phoneNumber",
            "type": "boolean"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "boolean"
        },
        {
            "name": "enableMerchantEmailNotifications",
            "baseName": "enableMerchantEmailNotifications",
            "type": "boolean"
        },
        {
            "name": "customLabels",
            "baseName": "customLabels",
            "type": "Array<InvoicingV2InvoicesPost201ResponseInvoiceInformationCustomLabels>"
        }    ];

    static getAttributeTypeMap() {
        return InvoicingV2InvoiceSettingsGet200ResponseInvoiceSettingsInformation.attributeTypeMap;
    }
}

export class InvoicingV2InvoiceSettingsGet200ResponseInvoiceSettingsInformationHeaderStyle {
    /**
    * The invoice font color. The format is a valid hexadecimal code prefixed with `#`, such as `#000000` for black.
    */
    'fontColor'?: string;
    /**
    * The invoice background color. The format is a valid hexadecimal code prefixed with `#`, such as `#ffffff` for white.
    */
    'backgroundColor'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "fontColor",
            "baseName": "fontColor",
            "type": "string"
        },
        {
            "name": "backgroundColor",
            "baseName": "backgroundColor",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return InvoicingV2InvoiceSettingsGet200ResponseInvoiceSettingsInformationHeaderStyle.attributeTypeMap;
    }
}

export class InvoicingV2InvoicesAllGet200Response {
    'links'?: InvoicingV2InvoicesAllGet200ResponseLinks;
    /**
    * Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ` **Example** `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.). The `T` separates the date and the time. The `Z` indicates UTC.  Returned by Cybersource for all services. 
    */
    'submitTimeUtc'?: string;
    'totalInvoices'?: number;
    'invoices'?: Array<InvoicingV2InvoicesAllGet200ResponseInvoices>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "InvoicingV2InvoicesAllGet200ResponseLinks"
        },
        {
            "name": "submitTimeUtc",
            "baseName": "submitTimeUtc",
            "type": "string"
        },
        {
            "name": "totalInvoices",
            "baseName": "totalInvoices",
            "type": "number"
        },
        {
            "name": "invoices",
            "baseName": "invoices",
            "type": "Array<InvoicingV2InvoicesAllGet200ResponseInvoices>"
        }    ];

    static getAttributeTypeMap() {
        return InvoicingV2InvoicesAllGet200Response.attributeTypeMap;
    }
}

export class InvoicingV2InvoicesAllGet200ResponseCustomerInformation {
    /**
    * Payer name for the invoice.
    */
    'name'?: string;
    /**
    * Your identifier for the customer.  When a subscription or customer profile is being created, the maximum length for this field for most processors is 30. Otherwise, the maximum length is 100.  #### Comercio Latino For recurring payments in Mexico, the value is the customer’s contract number. Note Before you request the authorization, you must inform the issuer of the customer contract numbers that will be used for recurring transactions.  #### Worldpay VAP For a follow-on credit with Worldpay VAP, CyberSource checks the following locations, in the order given, for a customer account ID value and uses the first value it finds: 1. `customer_account_id` value in the follow-on credit request 2. Customer account ID value that was used for the capture that is being credited 3. Customer account ID value that was used for the original authorization If a customer account ID value cannot be found in any of these locations, then no value is used. 
    */
    'merchantCustomerId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "merchantCustomerId",
            "baseName": "merchantCustomerId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return InvoicingV2InvoicesAllGet200ResponseCustomerInformation.attributeTypeMap;
    }
}

export class InvoicingV2InvoicesAllGet200ResponseInvoiceInformation {
    /**
    * The invoice due date. This field is required for creating an invoice. Format: `YYYY-MM-DD`, where `YYYY` = year, `MM` = month, and `DD` = day 
    */
    'dueDate'?: string;
    /**
    * Define an expiration date for the link.  Format: `YYYY-MM-DD`, where `YYYY` = year, `MM` = month, and `DD` = day 
    */
    'expirationDate'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "dueDate",
            "baseName": "dueDate",
            "type": "string"
        },
        {
            "name": "expirationDate",
            "baseName": "expirationDate",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return InvoicingV2InvoicesAllGet200ResponseInvoiceInformation.attributeTypeMap;
    }
}

/**
* A list of invoices.
*/
export class InvoicingV2InvoicesAllGet200ResponseInvoices {
    'links'?: InvoicingV2InvoicesAllGet200ResponseLinks;
    /**
    * An unique identification number generated by Cybersource to identify the submitted request. Returned by all services. It is also appended to the endpoint of the resource. On incremental authorizations, this value with be the same as the identification number returned in the original authorization response. 
    */
    'id'?: string;
    /**
    * The status of the invoice.  Possible values: - DRAFT - CREATED - SENT - PARTIAL - PAID - CANCELED - PENDING 
    */
    'status'?: string;
    /**
    * Date and time (UTC) the invoice was created.  Format: YYYY-MM-DDThh:mm:ssZ Example 2016-08-11T22:47:57Z equals August 11, 2016, at 22:47:57 (10:47:57 p.m.). The T separates the date and the time. The Z indicates UTC. 
    */
    'createdDate'?: string;
    'customerInformation'?: InvoicingV2InvoicesAllGet200ResponseCustomerInformation;
    'invoiceInformation'?: InvoicingV2InvoicesAllGet200ResponseInvoiceInformation;
    'orderInformation'?: InvoicingV2InvoicesAllGet200ResponseOrderInformation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "InvoicingV2InvoicesAllGet200ResponseLinks"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "createdDate",
            "baseName": "createdDate",
            "type": "string"
        },
        {
            "name": "customerInformation",
            "baseName": "customerInformation",
            "type": "InvoicingV2InvoicesAllGet200ResponseCustomerInformation"
        },
        {
            "name": "invoiceInformation",
            "baseName": "invoiceInformation",
            "type": "InvoicingV2InvoicesAllGet200ResponseInvoiceInformation"
        },
        {
            "name": "orderInformation",
            "baseName": "orderInformation",
            "type": "InvoicingV2InvoicesAllGet200ResponseOrderInformation"
        }    ];

    static getAttributeTypeMap() {
        return InvoicingV2InvoicesAllGet200ResponseInvoices.attributeTypeMap;
    }
}

export class InvoicingV2InvoicesAllGet200ResponseLinks {
    'self'?: PtsV2PaymentsPost201ResponseLinksSelf;
    'update'?: PtsV2PaymentsPost201ResponseLinksSelf;
    'deliver'?: PtsV2PaymentsPost201ResponseLinksSelf;
    'cancel'?: PtsV2PaymentsPost201ResponseLinksSelf;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "self",
            "baseName": "self",
            "type": "PtsV2PaymentsPost201ResponseLinksSelf"
        },
        {
            "name": "update",
            "baseName": "update",
            "type": "PtsV2PaymentsPost201ResponseLinksSelf"
        },
        {
            "name": "deliver",
            "baseName": "deliver",
            "type": "PtsV2PaymentsPost201ResponseLinksSelf"
        },
        {
            "name": "cancel",
            "baseName": "cancel",
            "type": "PtsV2PaymentsPost201ResponseLinksSelf"
        }    ];

    static getAttributeTypeMap() {
        return InvoicingV2InvoicesAllGet200ResponseLinks.attributeTypeMap;
    }
}

/**
* Contains all of the order-related fields, such as the amount and line item details.
*/
export class InvoicingV2InvoicesAllGet200ResponseOrderInformation {
    'amountDetails'?: InvoicingV2InvoicesAllGet200ResponseOrderInformationAmountDetails;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "amountDetails",
            "baseName": "amountDetails",
            "type": "InvoicingV2InvoicesAllGet200ResponseOrderInformationAmountDetails"
        }    ];

    static getAttributeTypeMap() {
        return InvoicingV2InvoicesAllGet200ResponseOrderInformation.attributeTypeMap;
    }
}

/**
* Contains all of the amount-related fields.
*/
export class InvoicingV2InvoicesAllGet200ResponseOrderInformationAmountDetails {
    /**
    * Grand total for the order. This value cannot be negative. You can include a decimal point (.), but no other special characters. CyberSource truncates the amount to the correct number of decimal places.  **Note** For CTV, FDCCompass, Paymentech processors, the maximum length for this field is 12.  **Important** Some processors have specific requirements and limitations, such as maximum amounts and maximum field lengths.  If your processor supports zero amount authorizations, you can set this field to 0 for the authorization to check if the card is lost or stolen.   #### Card Present Required to include either this field or `orderInformation.lineItems[].unitPrice` for the order.  #### Invoicing / Pay By Link Required for creating a new invoice or payment link.  #### PIN Debit Amount you requested for the PIN debit purchase. This value is returned for partial authorizations. The issuing bank can approve a partial amount if the balance on the debit card is less than the requested transaction amount.  Required field for PIN Debit purchase and PIN Debit credit requests. Optional field for PIN Debit reversal requests.  #### GPX This field is optional for reversing an authorization or credit; however, for all other processors, these fields are required.  #### DCC with a Third-Party Provider Set this field to the converted amount that was returned by the DCC provider. You must include either this field or the 1st line item in the order and the specific line-order amount in your request.   #### DCC for First Data Not used. 
    */
    'totalAmount'?: string;
    /**
    * Currency used for the order. Use the three-character [ISO Standard Currency Codes.](http://apps.cybersource.com/library/documentation/sbc/quickref/currencies.pdf)  #### Used by **Authorization** Required field.  **Authorization Reversal** For an authorization reversal (`reversalInformation`) or a capture (`processingOptions.capture` is set to `true`), you must use the same currency that you used in your payment authorization request.  #### PIN Debit Currency for the amount you requested for the PIN debit purchase. This value is returned for partial authorizations. The issuing bank can approve a partial amount if the balance on the debit card is less than the requested transaction amount. For the possible values, see the [ISO Standard Currency Codes](https://developer.cybersource.com/library/documentation/sbc/quickref/currencies.pdf). Returned by PIN debit purchase.  For PIN debit reversal requests, you must use the same currency that was used for the PIN debit purchase or PIN debit credit that you are reversing. For the possible values, see the [ISO Standard Currency Codes](https://developer.cybersource.com/library/documentation/sbc/quickref/currencies.pdf).  Required field for PIN Debit purchase and PIN Debit credit requests. Optional field for PIN Debit reversal requests.  #### GPX This field is optional for reversing an authorization or credit.  #### DCC for First Data Your local currency.  #### Tax Calculation Required for international tax and value added tax only. Optional for U.S. and Canadian taxes. Your local currency. 
    */
    'currency'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "totalAmount",
            "baseName": "totalAmount",
            "type": "string"
        },
        {
            "name": "currency",
            "baseName": "currency",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return InvoicingV2InvoicesAllGet200ResponseOrderInformationAmountDetails.attributeTypeMap;
    }
}

export class InvoicingV2InvoicesAllGet400Response {
    /**
    * Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ` **Example** `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.). The `T` separates the date and the time. The `Z` indicates UTC.  Returned by Cybersource for all services. 
    */
    'submitTimeUtc'?: string;
    /**
    * The status of the invoice.  Possible values:   - BADREQUEST 
    */
    'status'?: string;
    /**
    * The reason of the status.  Possible values: - DUPLICATE_RECORD - ACTION_NOT_ALLOWED - VALIDATION_ERRORS - INVALID_IMAGE - INVALID_TRANSIENT_TOKEN 
    */
    'reason'?: string;
    /**
    * The detail message related to the status and reason listed above.
    */
    'message'?: string;
    'details'?: Array<PtsV2PaymentsPost201ResponseErrorInformationDetails>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "submitTimeUtc",
            "baseName": "submitTimeUtc",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "reason",
            "baseName": "reason",
            "type": "string"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        },
        {
            "name": "details",
            "baseName": "details",
            "type": "Array<PtsV2PaymentsPost201ResponseErrorInformationDetails>"
        }    ];

    static getAttributeTypeMap() {
        return InvoicingV2InvoicesAllGet400Response.attributeTypeMap;
    }
}

export class InvoicingV2InvoicesAllGet404Response {
    /**
    * Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ` **Example** `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.). The `T` separates the date and the time. The `Z` indicates UTC.  Returned by Cybersource for all services. 
    */
    'submitTimeUtc'?: string;
    /**
    * The status of the invoice.  Possible values:  - NOTFOUND 
    */
    'status'?: string;
    /**
    * The reason of the status.  Possible values: - NOTFOUND 
    */
    'reason'?: string;
    /**
    * The detail message related to the status and reason listed above.
    */
    'message'?: string;
    'details'?: Array<PtsV2PaymentsPost201ResponseErrorInformationDetails>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "submitTimeUtc",
            "baseName": "submitTimeUtc",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "reason",
            "baseName": "reason",
            "type": "string"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        },
        {
            "name": "details",
            "baseName": "details",
            "type": "Array<PtsV2PaymentsPost201ResponseErrorInformationDetails>"
        }    ];

    static getAttributeTypeMap() {
        return InvoicingV2InvoicesAllGet404Response.attributeTypeMap;
    }
}

export class InvoicingV2InvoicesAllGet502Response {
    /**
    * Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ` **Example** `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.). The `T` separates the date and the time. The `Z` indicates UTC.  Returned by Cybersource for all services. 
    */
    'submitTimeUtc'?: string;
    /**
    * The status of the submitted transaction.  Possible values:  - SERVER_ERROR 
    */
    'status'?: string;
    /**
    * The reason of the status.  Possible values:  - SYSTEM_ERROR  - SERVER_TIMEOUT  - SERVICE_TIMEOUT 
    */
    'reason'?: string;
    /**
    * The detail message related to the status and reason listed above.
    */
    'message'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "submitTimeUtc",
            "baseName": "submitTimeUtc",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "reason",
            "baseName": "reason",
            "type": "string"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return InvoicingV2InvoicesAllGet502Response.attributeTypeMap;
    }
}

export class InvoicingV2InvoicesCancel200Response {
    'links'?: InvoicingV2InvoicesAllGet200ResponseLinks;
    /**
    * An unique identification number generated by Cybersource to identify the submitted request. Returned by all services. It is also appended to the endpoint of the resource. On incremental authorizations, this value with be the same as the identification number returned in the original authorization response. 
    */
    'id'?: string;
    /**
    * Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ` **Example** `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.). The `T` separates the date and the time. The `Z` indicates UTC.  Returned by Cybersource for all services. 
    */
    'submitTimeUtc'?: string;
    /**
    * The status of the invoice.  Possible values: - DRAFT - CREATED - SENT - PARTIAL - PAID - CANCELED - PENDING 
    */
    'status'?: string;
    'customerInformation'?: Invoicingv2invoicesCustomerInformation;
    'processingInformation'?: Invoicingv2invoicesProcessingInformation;
    'invoiceInformation'?: InvoicingV2InvoicesPost201ResponseInvoiceInformation;
    'orderInformation'?: InvoicingV2InvoicesPost201ResponseOrderInformation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "InvoicingV2InvoicesAllGet200ResponseLinks"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "submitTimeUtc",
            "baseName": "submitTimeUtc",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "customerInformation",
            "baseName": "customerInformation",
            "type": "Invoicingv2invoicesCustomerInformation"
        },
        {
            "name": "processingInformation",
            "baseName": "processingInformation",
            "type": "Invoicingv2invoicesProcessingInformation"
        },
        {
            "name": "invoiceInformation",
            "baseName": "invoiceInformation",
            "type": "InvoicingV2InvoicesPost201ResponseInvoiceInformation"
        },
        {
            "name": "orderInformation",
            "baseName": "orderInformation",
            "type": "InvoicingV2InvoicesPost201ResponseOrderInformation"
        }    ];

    static getAttributeTypeMap() {
        return InvoicingV2InvoicesCancel200Response.attributeTypeMap;
    }
}

export class InvoicingV2InvoicesGet200Response {
    'links'?: InvoicingV2InvoicesAllGet200ResponseLinks;
    /**
    * An unique identification number generated by Cybersource to identify the submitted request. Returned by all services. It is also appended to the endpoint of the resource. On incremental authorizations, this value with be the same as the identification number returned in the original authorization response. 
    */
    'id'?: string;
    /**
    * Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ` **Example** `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.). The `T` separates the date and the time. The `Z` indicates UTC.  Returned by Cybersource for all services. 
    */
    'submitTimeUtc'?: string;
    /**
    * The status of the invoice.  Possible values: - DRAFT - CREATED - SENT - PARTIAL - PAID - CANCELED - PENDING 
    */
    'status'?: string;
    'customerInformation'?: Invoicingv2invoicesCustomerInformation;
    'processingInformation'?: Invoicingv2invoicesProcessingInformation;
    'invoiceInformation'?: InvoicingV2InvoicesPost201ResponseInvoiceInformation;
    'orderInformation'?: InvoicingV2InvoicesPost201ResponseOrderInformation;
    'invoiceHistory'?: Array<InvoicingV2InvoicesGet200ResponseInvoiceHistory>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "InvoicingV2InvoicesAllGet200ResponseLinks"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "submitTimeUtc",
            "baseName": "submitTimeUtc",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "customerInformation",
            "baseName": "customerInformation",
            "type": "Invoicingv2invoicesCustomerInformation"
        },
        {
            "name": "processingInformation",
            "baseName": "processingInformation",
            "type": "Invoicingv2invoicesProcessingInformation"
        },
        {
            "name": "invoiceInformation",
            "baseName": "invoiceInformation",
            "type": "InvoicingV2InvoicesPost201ResponseInvoiceInformation"
        },
        {
            "name": "orderInformation",
            "baseName": "orderInformation",
            "type": "InvoicingV2InvoicesPost201ResponseOrderInformation"
        },
        {
            "name": "invoiceHistory",
            "baseName": "invoiceHistory",
            "type": "Array<InvoicingV2InvoicesGet200ResponseInvoiceHistory>"
        }    ];

    static getAttributeTypeMap() {
        return InvoicingV2InvoicesGet200Response.attributeTypeMap;
    }
}

export class InvoicingV2InvoicesGet200ResponseInvoiceHistory {
    /**
    * The event triggered for the invoice.  Possible values:  - `UNKNOWN`  - `DRAFT`  - `CREATE`  - `UPDATE`  - `SEND`  - `RESEND`  - `REMINDER`  - `PAYMENT`  - `CANCEL`  - `PENDING`  - `REJECTED` 
    */
    'event'?: string;
    /**
    * The date and time when the invoice event was triggered in ISO 8601 format. Format: YYYY-MM-DDThh:mm:ssZ 
    */
    'date'?: Date;
    'transactionDetails'?: InvoicingV2InvoicesGet200ResponseTransactionDetails;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "event",
            "baseName": "event",
            "type": "string"
        },
        {
            "name": "date",
            "baseName": "date",
            "type": "Date"
        },
        {
            "name": "transactionDetails",
            "baseName": "transactionDetails",
            "type": "InvoicingV2InvoicesGet200ResponseTransactionDetails"
        }    ];

    static getAttributeTypeMap() {
        return InvoicingV2InvoicesGet200ResponseInvoiceHistory.attributeTypeMap;
    }
}

/**
* These details are only returned when the invoice event is `payment`.
*/
export class InvoicingV2InvoicesGet200ResponseTransactionDetails {
    /**
    * Payer auth Transaction identifier.
    */
    'transactionId'?: string;
    /**
    * Grand total for the order. This value cannot be negative. You can include a decimal point (.), but no other special characters. CyberSource truncates the amount to the correct number of decimal places.  **Note** For CTV, FDCCompass, Paymentech processors, the maximum length for this field is 12.  **Important** Some processors have specific requirements and limitations, such as maximum amounts and maximum field lengths.  If your processor supports zero amount authorizations, you can set this field to 0 for the authorization to check if the card is lost or stolen.   #### Card Present Required to include either this field or `orderInformation.lineItems[].unitPrice` for the order.  #### Invoicing / Pay By Link Required for creating a new invoice or payment link.  #### PIN Debit Amount you requested for the PIN debit purchase. This value is returned for partial authorizations. The issuing bank can approve a partial amount if the balance on the debit card is less than the requested transaction amount.  Required field for PIN Debit purchase and PIN Debit credit requests. Optional field for PIN Debit reversal requests.  #### GPX This field is optional for reversing an authorization or credit; however, for all other processors, these fields are required.  #### DCC with a Third-Party Provider Set this field to the converted amount that was returned by the DCC provider. You must include either this field or the 1st line item in the order and the specific line-order amount in your request.   #### DCC for First Data Not used. 
    */
    'amount'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "transactionId",
            "baseName": "transactionId",
            "type": "string"
        },
        {
            "name": "amount",
            "baseName": "amount",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return InvoicingV2InvoicesGet200ResponseTransactionDetails.attributeTypeMap;
    }
}

export class InvoicingV2InvoicesPost201Response {
    'links'?: InvoicingV2InvoicesAllGet200ResponseLinks;
    /**
    * An unique identification number generated by Cybersource to identify the submitted request. Returned by all services. It is also appended to the endpoint of the resource. On incremental authorizations, this value with be the same as the identification number returned in the original authorization response. 
    */
    'id'?: string;
    /**
    * Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ` **Example** `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.). The `T` separates the date and the time. The `Z` indicates UTC.  Returned by Cybersource for all services. 
    */
    'submitTimeUtc'?: string;
    /**
    * The status of the invoice.  Possible values: - DRAFT - CREATED - SENT - PARTIAL - PAID - CANCELED - PENDING 
    */
    'status'?: string;
    'customerInformation'?: Invoicingv2invoicesCustomerInformation;
    'processingInformation'?: Invoicingv2invoicesProcessingInformation;
    'invoiceInformation'?: InvoicingV2InvoicesPost201ResponseInvoiceInformation;
    'orderInformation'?: InvoicingV2InvoicesPost201ResponseOrderInformation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "InvoicingV2InvoicesAllGet200ResponseLinks"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "submitTimeUtc",
            "baseName": "submitTimeUtc",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "customerInformation",
            "baseName": "customerInformation",
            "type": "Invoicingv2invoicesCustomerInformation"
        },
        {
            "name": "processingInformation",
            "baseName": "processingInformation",
            "type": "Invoicingv2invoicesProcessingInformation"
        },
        {
            "name": "invoiceInformation",
            "baseName": "invoiceInformation",
            "type": "InvoicingV2InvoicesPost201ResponseInvoiceInformation"
        },
        {
            "name": "orderInformation",
            "baseName": "orderInformation",
            "type": "InvoicingV2InvoicesPost201ResponseOrderInformation"
        }    ];

    static getAttributeTypeMap() {
        return InvoicingV2InvoicesPost201Response.attributeTypeMap;
    }
}

/**
* Contains all of the invoice-specific fields, such as the invoice number and due date.
*/
export class InvoicingV2InvoicesPost201ResponseInvoiceInformation {
    /**
    * Invoice Number.
    */
    'invoiceNumber'?: string;
    /**
    * The description included in the invoice.
    */
    'description'?: string;
    /**
    * The invoice due date. This field is required for creating an invoice. Format: `YYYY-MM-DD`, where `YYYY` = year, `MM` = month, and `DD` = day 
    */
    'dueDate'?: string;
    /**
    * Define an expiration date for the link.  Format: `YYYY-MM-DD`, where `YYYY` = year, `MM` = month, and `DD` = day 
    */
    'expirationDate'?: string;
    /**
    * If set to `true`, the payer can make a partial invoice payment.
    */
    'allowPartialPayments'?: boolean;
    /**
    * Returns the payment link to an invoice when the invoice status is `SENT`, `CREATED`, `PARTIAL`, or `PAID`.
    */
    'paymentLink'?: string;
    /**
    * If this field is set to 'None', an invoice will be generated with the status 'CREATED', but no email will be dispatched.    Possible values:        - `None`   - `Email`    
    */
    'deliveryMode'?: string;
    /**
    * A list of custom labels that allows you to override (rename) default field names and control the visibility of specific fields on invoices and items. If the list is empty, the labels will not be overwritten. 
    */
    'customLabels'?: Array<InvoicingV2InvoicesPost201ResponseInvoiceInformationCustomLabels>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "invoiceNumber",
            "baseName": "invoiceNumber",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "dueDate",
            "baseName": "dueDate",
            "type": "string"
        },
        {
            "name": "expirationDate",
            "baseName": "expirationDate",
            "type": "string"
        },
        {
            "name": "allowPartialPayments",
            "baseName": "allowPartialPayments",
            "type": "boolean"
        },
        {
            "name": "paymentLink",
            "baseName": "paymentLink",
            "type": "string"
        },
        {
            "name": "deliveryMode",
            "baseName": "deliveryMode",
            "type": "string"
        },
        {
            "name": "customLabels",
            "baseName": "customLabels",
            "type": "Array<InvoicingV2InvoicesPost201ResponseInvoiceInformationCustomLabels>"
        }    ];

    static getAttributeTypeMap() {
        return InvoicingV2InvoicesPost201ResponseInvoiceInformation.attributeTypeMap;
    }
}

export class InvoicingV2InvoicesPost201ResponseInvoiceInformationCustomLabels {
    /**
    * The invoice field key. Possible values:   - billTo   - invoiceNumber   - customerId   - companyName   - description   - shipping   - partialPayment   - discount   - tax 
    */
    'key'?: string;
    /**
    * The new (overridden) field name
    */
    'value'?: string;
    /**
    * Hides the specified field. This field is applicable for keys:   - customerId   - companyName   - description   - shipping   - partialPayment 
    */
    'hidden'?: boolean;
    /**
    * Hides the field at invoice level. This field is applicable for keys:   - discount   - tax 
    */
    'hiddenForInvoice'?: boolean;
    /**
    * Hides the field at invoice item level. This field is applicable for keys:   - discount   - tax 
    */
    'hiddenForItem'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "key",
            "baseName": "key",
            "type": "string"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "string"
        },
        {
            "name": "hidden",
            "baseName": "hidden",
            "type": "boolean"
        },
        {
            "name": "hiddenForInvoice",
            "baseName": "hiddenForInvoice",
            "type": "boolean"
        },
        {
            "name": "hiddenForItem",
            "baseName": "hiddenForItem",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return InvoicingV2InvoicesPost201ResponseInvoiceInformationCustomLabels.attributeTypeMap;
    }
}

/**
* Contains all of the order-related fields, such as the amount and line item details.
*/
export class InvoicingV2InvoicesPost201ResponseOrderInformation {
    'amountDetails'?: InvoicingV2InvoicesPost201ResponseOrderInformationAmountDetails;
    /**
    * List of the line items from the order.
    */
    'lineItems'?: Array<Invoicingv2invoicesOrderInformationLineItems>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "amountDetails",
            "baseName": "amountDetails",
            "type": "InvoicingV2InvoicesPost201ResponseOrderInformationAmountDetails"
        },
        {
            "name": "lineItems",
            "baseName": "lineItems",
            "type": "Array<Invoicingv2invoicesOrderInformationLineItems>"
        }    ];

    static getAttributeTypeMap() {
        return InvoicingV2InvoicesPost201ResponseOrderInformation.attributeTypeMap;
    }
}

/**
* Contains all of the amount-related fields.
*/
export class InvoicingV2InvoicesPost201ResponseOrderInformationAmountDetails {
    /**
    * Grand total for the order. This value cannot be negative. You can include a decimal point (.), but no other special characters. CyberSource truncates the amount to the correct number of decimal places.  **Note** For CTV, FDCCompass, Paymentech processors, the maximum length for this field is 12.  **Important** Some processors have specific requirements and limitations, such as maximum amounts and maximum field lengths.  If your processor supports zero amount authorizations, you can set this field to 0 for the authorization to check if the card is lost or stolen.   #### Card Present Required to include either this field or `orderInformation.lineItems[].unitPrice` for the order.  #### Invoicing / Pay By Link Required for creating a new invoice or payment link.  #### PIN Debit Amount you requested for the PIN debit purchase. This value is returned for partial authorizations. The issuing bank can approve a partial amount if the balance on the debit card is less than the requested transaction amount.  Required field for PIN Debit purchase and PIN Debit credit requests. Optional field for PIN Debit reversal requests.  #### GPX This field is optional for reversing an authorization or credit; however, for all other processors, these fields are required.  #### DCC with a Third-Party Provider Set this field to the converted amount that was returned by the DCC provider. You must include either this field or the 1st line item in the order and the specific line-order amount in your request.   #### DCC for First Data Not used. 
    */
    'totalAmount'?: string;
    /**
    * Currency used for the order. Use the three-character [ISO Standard Currency Codes.](http://apps.cybersource.com/library/documentation/sbc/quickref/currencies.pdf)  #### Used by **Authorization** Required field.  **Authorization Reversal** For an authorization reversal (`reversalInformation`) or a capture (`processingOptions.capture` is set to `true`), you must use the same currency that you used in your payment authorization request.  #### PIN Debit Currency for the amount you requested for the PIN debit purchase. This value is returned for partial authorizations. The issuing bank can approve a partial amount if the balance on the debit card is less than the requested transaction amount. For the possible values, see the [ISO Standard Currency Codes](https://developer.cybersource.com/library/documentation/sbc/quickref/currencies.pdf). Returned by PIN debit purchase.  For PIN debit reversal requests, you must use the same currency that was used for the PIN debit purchase or PIN debit credit that you are reversing. For the possible values, see the [ISO Standard Currency Codes](https://developer.cybersource.com/library/documentation/sbc/quickref/currencies.pdf).  Required field for PIN Debit purchase and PIN Debit credit requests. Optional field for PIN Debit reversal requests.  #### GPX This field is optional for reversing an authorization or credit.  #### DCC for First Data Your local currency.  #### Tax Calculation Required for international tax and value added tax only. Optional for U.S. and Canadian taxes. Your local currency. 
    */
    'currency'?: string;
    /**
    * Remaining balance on the account.  Returned by authorization service.  #### PIN debit Remaining balance on the prepaid card.  Returned by PIN debit purchase. 
    */
    'balanceAmount'?: string;
    /**
    * Total discount amount applied to the order. 
    */
    'discountAmount'?: string;
    /**
    * The total discount percentage applied to the order.
    */
    'discountPercent'?: string;
    /**
    * Sub-amount of the order.
    */
    'subAmount'?: string;
    /**
    * The minimum partial amount required to pay the invoice.
    */
    'minimumPartialAmount'?: string;
    'taxDetails'?: Invoicingv2invoicesOrderInformationAmountDetailsTaxDetails;
    'freight'?: Invoicingv2invoicesOrderInformationAmountDetailsFreight;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "totalAmount",
            "baseName": "totalAmount",
            "type": "string"
        },
        {
            "name": "currency",
            "baseName": "currency",
            "type": "string"
        },
        {
            "name": "balanceAmount",
            "baseName": "balanceAmount",
            "type": "string"
        },
        {
            "name": "discountAmount",
            "baseName": "discountAmount",
            "type": "string"
        },
        {
            "name": "discountPercent",
            "baseName": "discountPercent",
            "type": "string"
        },
        {
            "name": "subAmount",
            "baseName": "subAmount",
            "type": "string"
        },
        {
            "name": "minimumPartialAmount",
            "baseName": "minimumPartialAmount",
            "type": "string"
        },
        {
            "name": "taxDetails",
            "baseName": "taxDetails",
            "type": "Invoicingv2invoicesOrderInformationAmountDetailsTaxDetails"
        },
        {
            "name": "freight",
            "baseName": "freight",
            "type": "Invoicingv2invoicesOrderInformationAmountDetailsFreight"
        }    ];

    static getAttributeTypeMap() {
        return InvoicingV2InvoicesPost201ResponseOrderInformationAmountDetails.attributeTypeMap;
    }
}

export class InvoicingV2InvoicesPost202Response {
    /**
    * Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ` **Example** `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.). The `T` separates the date and the time. The `Z` indicates UTC.  Returned by Cybersource for all services. 
    */
    'submitTimeUtc'?: string;
    /**
    * The status of the invoice.  Possible values: - DRAFT - CREATED - SENT - PARTIAL - PAID - CANCELED - PENDING 
    */
    'status'?: string;
    /**
    * The reason of the status.  Possible values: - ACCEPTED 
    */
    'reason'?: string;
    /**
    * The detail message related to the status and reason listed above.
    */
    'message'?: string;
    'details'?: Array<PtsV2PaymentsPost201ResponseErrorInformationDetails>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "submitTimeUtc",
            "baseName": "submitTimeUtc",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "reason",
            "baseName": "reason",
            "type": "string"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        },
        {
            "name": "details",
            "baseName": "details",
            "type": "Array<PtsV2PaymentsPost201ResponseErrorInformationDetails>"
        }    ];

    static getAttributeTypeMap() {
        return InvoicingV2InvoicesPost202Response.attributeTypeMap;
    }
}

export class InvoicingV2InvoicesPublish200Response {
    'links'?: InvoicingV2InvoicesAllGet200ResponseLinks;
    /**
    * An unique identification number generated by Cybersource to identify the submitted request. Returned by all services. It is also appended to the endpoint of the resource. On incremental authorizations, this value with be the same as the identification number returned in the original authorization response. 
    */
    'id'?: string;
    /**
    * Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ` **Example** `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.). The `T` separates the date and the time. The `Z` indicates UTC.  Returned by Cybersource for all services. 
    */
    'submitTimeUtc'?: string;
    /**
    * The status of the invoice.  Possible values: - DRAFT - CREATED - SENT - PARTIAL - PAID - CANCELED - PENDING 
    */
    'status'?: string;
    'customerInformation'?: Invoicingv2invoicesCustomerInformation;
    'processingInformation'?: Invoicingv2invoicesProcessingInformation;
    'invoiceInformation'?: InvoicingV2InvoicesPost201ResponseInvoiceInformation;
    'orderInformation'?: InvoicingV2InvoicesPost201ResponseOrderInformation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "InvoicingV2InvoicesAllGet200ResponseLinks"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "submitTimeUtc",
            "baseName": "submitTimeUtc",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "customerInformation",
            "baseName": "customerInformation",
            "type": "Invoicingv2invoicesCustomerInformation"
        },
        {
            "name": "processingInformation",
            "baseName": "processingInformation",
            "type": "Invoicingv2invoicesProcessingInformation"
        },
        {
            "name": "invoiceInformation",
            "baseName": "invoiceInformation",
            "type": "InvoicingV2InvoicesPost201ResponseInvoiceInformation"
        },
        {
            "name": "orderInformation",
            "baseName": "orderInformation",
            "type": "InvoicingV2InvoicesPost201ResponseOrderInformation"
        }    ];

    static getAttributeTypeMap() {
        return InvoicingV2InvoicesPublish200Response.attributeTypeMap;
    }
}

export class InvoicingV2InvoicesPut200Response {
    'links'?: InvoicingV2InvoicesAllGet200ResponseLinks;
    /**
    * An unique identification number generated by Cybersource to identify the submitted request. Returned by all services. It is also appended to the endpoint of the resource. On incremental authorizations, this value with be the same as the identification number returned in the original authorization response. 
    */
    'id'?: string;
    /**
    * Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ` **Example** `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.). The `T` separates the date and the time. The `Z` indicates UTC.  Returned by Cybersource for all services. 
    */
    'submitTimeUtc'?: string;
    /**
    * The status of the invoice.  Possible values: - DRAFT - CREATED - SENT - PARTIAL - PAID - CANCELED - PENDING 
    */
    'status'?: string;
    'customerInformation'?: Invoicingv2invoicesCustomerInformation;
    'processingInformation'?: Invoicingv2invoicesProcessingInformation;
    'invoiceInformation'?: InvoicingV2InvoicesPost201ResponseInvoiceInformation;
    'orderInformation'?: InvoicingV2InvoicesPost201ResponseOrderInformation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "InvoicingV2InvoicesAllGet200ResponseLinks"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "submitTimeUtc",
            "baseName": "submitTimeUtc",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "customerInformation",
            "baseName": "customerInformation",
            "type": "Invoicingv2invoicesCustomerInformation"
        },
        {
            "name": "processingInformation",
            "baseName": "processingInformation",
            "type": "Invoicingv2invoicesProcessingInformation"
        },
        {
            "name": "invoiceInformation",
            "baseName": "invoiceInformation",
            "type": "InvoicingV2InvoicesPost201ResponseInvoiceInformation"
        },
        {
            "name": "orderInformation",
            "baseName": "orderInformation",
            "type": "InvoicingV2InvoicesPost201ResponseOrderInformation"
        }    ];

    static getAttributeTypeMap() {
        return InvoicingV2InvoicesPut200Response.attributeTypeMap;
    }
}

export class InvoicingV2InvoicesSend200Response {
    'links'?: InvoicingV2InvoicesAllGet200ResponseLinks;
    /**
    * An unique identification number generated by Cybersource to identify the submitted request. Returned by all services. It is also appended to the endpoint of the resource. On incremental authorizations, this value with be the same as the identification number returned in the original authorization response. 
    */
    'id'?: string;
    /**
    * Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ` **Example** `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.). The `T` separates the date and the time. The `Z` indicates UTC.  Returned by Cybersource for all services. 
    */
    'submitTimeUtc'?: string;
    /**
    * The status of the invoice.  Possible values: - DRAFT - CREATED - SENT - PARTIAL - PAID - CANCELED - PENDING 
    */
    'status'?: string;
    'customerInformation'?: Invoicingv2invoicesCustomerInformation;
    'processingInformation'?: Invoicingv2invoicesProcessingInformation;
    'invoiceInformation'?: InvoicingV2InvoicesPost201ResponseInvoiceInformation;
    'orderInformation'?: InvoicingV2InvoicesPost201ResponseOrderInformation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "InvoicingV2InvoicesAllGet200ResponseLinks"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "submitTimeUtc",
            "baseName": "submitTimeUtc",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "customerInformation",
            "baseName": "customerInformation",
            "type": "Invoicingv2invoicesCustomerInformation"
        },
        {
            "name": "processingInformation",
            "baseName": "processingInformation",
            "type": "Invoicingv2invoicesProcessingInformation"
        },
        {
            "name": "invoiceInformation",
            "baseName": "invoiceInformation",
            "type": "InvoicingV2InvoicesPost201ResponseInvoiceInformation"
        },
        {
            "name": "orderInformation",
            "baseName": "orderInformation",
            "type": "InvoicingV2InvoicesPost201ResponseOrderInformation"
        }    ];

    static getAttributeTypeMap() {
        return InvoicingV2InvoicesSend200Response.attributeTypeMap;
    }
}

export class Invoicingv2invoiceSettingsInvoiceSettingsInformation {
    /**
    * The image file, which must be encoded in Base64 format. Supported file formats are `png`, `jpg`, and `gif`. The image file size restriction is 1 MB.
    */
    'merchantLogo'?: string;
    /**
    * The merchant's display name shown on the invoice.
    */
    'merchantDisplayName'?: string;
    /**
    * The content of the email message that we send to your customers.
    */
    'customEmailMessage'?: string;
    /**
    * Whether you would like us to send an auto-generated reminder email to your invoice recipients. Currently, this reminder email is sent five days before the invoice is due and one day after it is past due.
    */
    'enableReminders'?: boolean;
    'headerStyle'?: InvoicingV2InvoiceSettingsGet200ResponseInvoiceSettingsInformationHeaderStyle;
    /**
    * The language of the email that we send to your customers. Possible values are `zh-CN`, `zh-TW`, `en-US`, `fr-FR`, `de-DE`, `ja-JP`, `pt-BR`, `ru-RU` and `es-419`.
    */
    'deliveryLanguage'?: string;
    /**
    * Currency used for the order. Use the three-character [ISO Standard Currency Codes.](http://apps.cybersource.com/library/documentation/sbc/quickref/currencies.pdf)  #### Used by **Authorization** Required field.  **Authorization Reversal** For an authorization reversal (`reversalInformation`) or a capture (`processingOptions.capture` is set to `true`), you must use the same currency that you used in your payment authorization request.  #### PIN Debit Currency for the amount you requested for the PIN debit purchase. This value is returned for partial authorizations. The issuing bank can approve a partial amount if the balance on the debit card is less than the requested transaction amount. For the possible values, see the [ISO Standard Currency Codes](https://developer.cybersource.com/library/documentation/sbc/quickref/currencies.pdf). Returned by PIN debit purchase.  For PIN debit reversal requests, you must use the same currency that was used for the PIN debit purchase or PIN debit credit that you are reversing. For the possible values, see the [ISO Standard Currency Codes](https://developer.cybersource.com/library/documentation/sbc/quickref/currencies.pdf).  Required field for PIN Debit purchase and PIN Debit credit requests. Optional field for PIN Debit reversal requests.  #### GPX This field is optional for reversing an authorization or credit.  #### DCC for First Data Your local currency.  #### Tax Calculation Required for international tax and value added tax only. Optional for U.S. and Canadian taxes. Your local currency. 
    */
    'defaultCurrencyCode'?: string;
    /**
    * For a merchant's invoice payments, enable 3D Secure payer authentication version 1, update to 3D Secure version 2, or disable 3D Secure. Possible values are:  - `enable` - `update` - `disable`  
    */
    'payerAuthenticationInInvoicing'?: string;
    /**
    * Display VAT number on Invoice.
    */
    'showVatNumber'?: boolean;
    /**
    * Your government-assigned tax identification number.  #### Tax Calculation Required field for value added tax only. Not applicable to U.S. and Canadian taxes. 
    */
    'vatRegistrationNumber'?: string;
    /**
    * Collect the payers shipping address.
    */
    'shipTo'?: boolean;
    /**
    * Collect the payers phone number.
    */
    'phoneNumber'?: boolean;
    /**
    * Collect the payers email address when the email address is not known or confirm it if it is known at the time of invoice creation.
    */
    'email'?: boolean;
    /**
    * Whether you would like to receive payment notification for successful transaction
    */
    'enableMerchantEmailNotifications'?: boolean;
    /**
    * A list of custom labels that allows you to override (rename) default field names and control the visibility of specific fields on invoices and items. If the list is empty, the labels will not be overwritten. 
    */
    'customLabels'?: Array<InvoicingV2InvoicesPost201ResponseInvoiceInformationCustomLabels>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "merchantLogo",
            "baseName": "merchantLogo",
            "type": "string"
        },
        {
            "name": "merchantDisplayName",
            "baseName": "merchantDisplayName",
            "type": "string"
        },
        {
            "name": "customEmailMessage",
            "baseName": "customEmailMessage",
            "type": "string"
        },
        {
            "name": "enableReminders",
            "baseName": "enableReminders",
            "type": "boolean"
        },
        {
            "name": "headerStyle",
            "baseName": "headerStyle",
            "type": "InvoicingV2InvoiceSettingsGet200ResponseInvoiceSettingsInformationHeaderStyle"
        },
        {
            "name": "deliveryLanguage",
            "baseName": "deliveryLanguage",
            "type": "string"
        },
        {
            "name": "defaultCurrencyCode",
            "baseName": "defaultCurrencyCode",
            "type": "string"
        },
        {
            "name": "payerAuthenticationInInvoicing",
            "baseName": "payerAuthenticationInInvoicing",
            "type": "string"
        },
        {
            "name": "showVatNumber",
            "baseName": "showVatNumber",
            "type": "boolean"
        },
        {
            "name": "vatRegistrationNumber",
            "baseName": "vatRegistrationNumber",
            "type": "string"
        },
        {
            "name": "shipTo",
            "baseName": "shipTo",
            "type": "boolean"
        },
        {
            "name": "phoneNumber",
            "baseName": "phoneNumber",
            "type": "boolean"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "boolean"
        },
        {
            "name": "enableMerchantEmailNotifications",
            "baseName": "enableMerchantEmailNotifications",
            "type": "boolean"
        },
        {
            "name": "customLabels",
            "baseName": "customLabels",
            "type": "Array<InvoicingV2InvoicesPost201ResponseInvoiceInformationCustomLabels>"
        }    ];

    static getAttributeTypeMap() {
        return Invoicingv2invoiceSettingsInvoiceSettingsInformation.attributeTypeMap;
    }
}

export class Invoicingv2invoicesClientReferenceInformation {
    'partner'?: Invoicingv2invoicesClientReferenceInformationPartner;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "partner",
            "baseName": "partner",
            "type": "Invoicingv2invoicesClientReferenceInformationPartner"
        }    ];

    static getAttributeTypeMap() {
        return Invoicingv2invoicesClientReferenceInformation.attributeTypeMap;
    }
}

export class Invoicingv2invoicesClientReferenceInformationPartner {
    /**
    * Identifier for the developer that integrated a partner solution with Cybersource. Send this value with all requests that are sent through a partner solution built by that developer. Cybersource assigns the ID to the developer.  **Note** A developerId set to 999 means the submitted developer ID is incorrect. 
    */
    'developerId'?: string;
    /**
    * Identifier for the partner that integrated with Cybersource. Send this value with all requests sent through the partner solution. Cybersource assigns the ID to the partner.  **Note** A solutionId set to 999 means the submitted solutionId is incorrect. 
    */
    'solutionId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "developerId",
            "baseName": "developerId",
            "type": "string"
        },
        {
            "name": "solutionId",
            "baseName": "solutionId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Invoicingv2invoicesClientReferenceInformationPartner.attributeTypeMap;
    }
}

/**
* Contains all of the customer-related fields for the invoice.
*/
export class Invoicingv2invoicesCustomerInformation {
    /**
    * Payer name for the invoice.
    */
    'name'?: string;
    /**
    * Customer's email address, including the full domain name.  #### CyberSource through VisaNet Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.  **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.  #### Invoicing Email address for the customer for sending the invoice. If the invoice is in SENT status and email is updated, the old email customer payment link won't work and you must resend the invoice with the new payment link.  #### Chase Paymentech Solutions Optional field.  ####  Credit Mutuel-CIC Optional field.  #### OmniPay Direct Optional field.  #### SIX Optional field.  #### TSYS Acquiring Solutions Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.  #### Worldpay VAP Optional field.  #### All other processors Not used. 
    */
    'email'?: string;
    /**
    * Your identifier for the customer.  When a subscription or customer profile is being created, the maximum length for this field for most processors is 30. Otherwise, the maximum length is 100.  #### Comercio Latino For recurring payments in Mexico, the value is the customer’s contract number. Note Before you request the authorization, you must inform the issuer of the customer contract numbers that will be used for recurring transactions.  #### Worldpay VAP For a follow-on credit with Worldpay VAP, CyberSource checks the following locations, in the order given, for a customer account ID value and uses the first value it finds: 1. `customer_account_id` value in the follow-on credit request 2. Customer account ID value that was used for the capture that is being credited 3. Customer account ID value that was used for the original authorization If a customer account ID value cannot be found in any of these locations, then no value is used. 
    */
    'merchantCustomerId'?: string;
    'company'?: Invoicingv2invoicesCustomerInformationCompany;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "merchantCustomerId",
            "baseName": "merchantCustomerId",
            "type": "string"
        },
        {
            "name": "company",
            "baseName": "company",
            "type": "Invoicingv2invoicesCustomerInformationCompany"
        }    ];

    static getAttributeTypeMap() {
        return Invoicingv2invoicesCustomerInformation.attributeTypeMap;
    }
}

export class Invoicingv2invoicesCustomerInformationCompany {
    /**
    * Name of the customer’s company.  **CyberSource through VisaNet** Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks. 
    */
    'name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Invoicingv2invoicesCustomerInformationCompany.attributeTypeMap;
    }
}

/**
* Contains all of the invoice-specific fields, such as the invoice number and due date.
*/
export class Invoicingv2invoicesInvoiceInformation {
    /**
    * Invoice Number.
    */
    'invoiceNumber'?: string;
    /**
    * The description included in the invoice.
    */
    'description': string;
    /**
    * The invoice due date. This field is required for creating an invoice. Format: `YYYY-MM-DD`, where `YYYY` = year, `MM` = month, and `DD` = day 
    */
    'dueDate': string;
    /**
    * Define an expiration date for the link.  Format: `YYYY-MM-DD`, where `YYYY` = year, `MM` = month, and `DD` = day 
    */
    'expirationDate'?: string;
    /**
    * If set to `true`, we send the invoice immediately. If set to `false`, the invoice remains in draft mode.
    */
    'sendImmediately'?: boolean;
    /**
    * If set to `true`, the payer can make a partial invoice payment.
    */
    'allowPartialPayments'?: boolean;
    /**
    * If this field is set to 'None', an invoice will be generated with the status 'CREATED', but no email will be dispatched.    Possible values:        - `None`   - `Email`    
    */
    'deliveryMode'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "invoiceNumber",
            "baseName": "invoiceNumber",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "dueDate",
            "baseName": "dueDate",
            "type": "string"
        },
        {
            "name": "expirationDate",
            "baseName": "expirationDate",
            "type": "string"
        },
        {
            "name": "sendImmediately",
            "baseName": "sendImmediately",
            "type": "boolean"
        },
        {
            "name": "allowPartialPayments",
            "baseName": "allowPartialPayments",
            "type": "boolean"
        },
        {
            "name": "deliveryMode",
            "baseName": "deliveryMode",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Invoicingv2invoicesInvoiceInformation.attributeTypeMap;
    }
}

/**
* Contains all of the order-related fields, such as the amount and line item details.
*/
export class Invoicingv2invoicesOrderInformation {
    'amountDetails': Invoicingv2invoicesOrderInformationAmountDetails;
    /**
    * List of the line items from the order.
    */
    'lineItems'?: Array<Invoicingv2invoicesOrderInformationLineItems>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "amountDetails",
            "baseName": "amountDetails",
            "type": "Invoicingv2invoicesOrderInformationAmountDetails"
        },
        {
            "name": "lineItems",
            "baseName": "lineItems",
            "type": "Array<Invoicingv2invoicesOrderInformationLineItems>"
        }    ];

    static getAttributeTypeMap() {
        return Invoicingv2invoicesOrderInformation.attributeTypeMap;
    }
}

/**
* Contains all of the amount-related fields.
*/
export class Invoicingv2invoicesOrderInformationAmountDetails {
    /**
    * Grand total for the order. This value cannot be negative. You can include a decimal point (.), but no other special characters. CyberSource truncates the amount to the correct number of decimal places.  **Note** For CTV, FDCCompass, Paymentech processors, the maximum length for this field is 12.  **Important** Some processors have specific requirements and limitations, such as maximum amounts and maximum field lengths.  If your processor supports zero amount authorizations, you can set this field to 0 for the authorization to check if the card is lost or stolen.   #### Card Present Required to include either this field or `orderInformation.lineItems[].unitPrice` for the order.  #### Invoicing / Pay By Link Required for creating a new invoice or payment link.  #### PIN Debit Amount you requested for the PIN debit purchase. This value is returned for partial authorizations. The issuing bank can approve a partial amount if the balance on the debit card is less than the requested transaction amount.  Required field for PIN Debit purchase and PIN Debit credit requests. Optional field for PIN Debit reversal requests.  #### GPX This field is optional for reversing an authorization or credit; however, for all other processors, these fields are required.  #### DCC with a Third-Party Provider Set this field to the converted amount that was returned by the DCC provider. You must include either this field or the 1st line item in the order and the specific line-order amount in your request.   #### DCC for First Data Not used. 
    */
    'totalAmount': string;
    /**
    * Currency used for the order. Use the three-character [ISO Standard Currency Codes.](http://apps.cybersource.com/library/documentation/sbc/quickref/currencies.pdf)  #### Used by **Authorization** Required field.  **Authorization Reversal** For an authorization reversal (`reversalInformation`) or a capture (`processingOptions.capture` is set to `true`), you must use the same currency that you used in your payment authorization request.  #### PIN Debit Currency for the amount you requested for the PIN debit purchase. This value is returned for partial authorizations. The issuing bank can approve a partial amount if the balance on the debit card is less than the requested transaction amount. For the possible values, see the [ISO Standard Currency Codes](https://developer.cybersource.com/library/documentation/sbc/quickref/currencies.pdf). Returned by PIN debit purchase.  For PIN debit reversal requests, you must use the same currency that was used for the PIN debit purchase or PIN debit credit that you are reversing. For the possible values, see the [ISO Standard Currency Codes](https://developer.cybersource.com/library/documentation/sbc/quickref/currencies.pdf).  Required field for PIN Debit purchase and PIN Debit credit requests. Optional field for PIN Debit reversal requests.  #### GPX This field is optional for reversing an authorization or credit.  #### DCC for First Data Your local currency.  #### Tax Calculation Required for international tax and value added tax only. Optional for U.S. and Canadian taxes. Your local currency. 
    */
    'currency': string;
    /**
    * Total discount amount applied to the order. 
    */
    'discountAmount'?: string;
    /**
    * The total discount percentage applied to the order.
    */
    'discountPercent'?: string;
    /**
    * Sub-amount of the order.
    */
    'subAmount'?: string;
    /**
    * The minimum partial amount required to pay the invoice.
    */
    'minimumPartialAmount'?: string;
    'taxDetails'?: Invoicingv2invoicesOrderInformationAmountDetailsTaxDetails;
    'freight'?: Invoicingv2invoicesOrderInformationAmountDetailsFreight;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "totalAmount",
            "baseName": "totalAmount",
            "type": "string"
        },
        {
            "name": "currency",
            "baseName": "currency",
            "type": "string"
        },
        {
            "name": "discountAmount",
            "baseName": "discountAmount",
            "type": "string"
        },
        {
            "name": "discountPercent",
            "baseName": "discountPercent",
            "type": "string"
        },
        {
            "name": "subAmount",
            "baseName": "subAmount",
            "type": "string"
        },
        {
            "name": "minimumPartialAmount",
            "baseName": "minimumPartialAmount",
            "type": "string"
        },
        {
            "name": "taxDetails",
            "baseName": "taxDetails",
            "type": "Invoicingv2invoicesOrderInformationAmountDetailsTaxDetails"
        },
        {
            "name": "freight",
            "baseName": "freight",
            "type": "Invoicingv2invoicesOrderInformationAmountDetailsFreight"
        }    ];

    static getAttributeTypeMap() {
        return Invoicingv2invoicesOrderInformationAmountDetails.attributeTypeMap;
    }
}

/**
* Contains all of the shipping-related fields for the order.
*/
export class Invoicingv2invoicesOrderInformationAmountDetailsFreight {
    /**
    * Total freight or shipping and handling charges for the order. When you include this field in your request, you must also include the **totalAmount** field. 
    */
    'amount'?: string;
    /**
    * Flag that indicates whether an order is taxable. This value must be true if the sum of all _lineItems[].taxAmount_ values > 0.  If you do not include any `lineItems[].taxAmount` values in your request, CyberSource does not include `invoiceDetails.taxable` in the data it sends to the processor.  Possible values:  - **true**  - **false** 
    */
    'taxable'?: boolean;
    /**
    * Shipping Tax rate applied to the freight amount.  **Visa**: Valid range is 0.01 to 0.99 (1% to 99%, with only whole percentage values accepted; values with additional decimal places will be truncated).  **Mastercard**: Valid range is 0.00001 to 0.99999 (0.001% to 99.999%). 
    */
    'taxRate'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "amount",
            "baseName": "amount",
            "type": "string"
        },
        {
            "name": "taxable",
            "baseName": "taxable",
            "type": "boolean"
        },
        {
            "name": "taxRate",
            "baseName": "taxRate",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Invoicingv2invoicesOrderInformationAmountDetailsFreight.attributeTypeMap;
    }
}

/**
* Contains all of the tax-related fields for the order.
*/
export class Invoicingv2invoicesOrderInformationAmountDetailsTaxDetails {
    /**
    * Indicates the type of tax data for the _taxDetails_ object.  Possible values:  - `alternate` - `local` - `national` - `vat` - `other` - `green` 
    */
    'type'?: string;
    /**
    * Indicates the amount of tax based on the `type` field as described in the table below:  | type      | type description | | ------------- |:-------------:| | `alternate` | Total amount of alternate tax for the order. | | `local`     | Sales tax for the order. | | `national`  | National tax for the order. | | `vat`       | Total amount of value added tax (VAT) included in the order. | | `other`     | Other tax. | | `green`     | Green tax amount for Korean Processing. | 
    */
    'amount'?: string;
    /**
    * Rate of VAT or other tax for the order.  Example 0.040 (=4%)  Valid range: 0.01 to 0.99 (1% to 99%, with only whole percentage values accepted; values with additional decimal places will be truncated) 
    */
    'rate'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "amount",
            "baseName": "amount",
            "type": "string"
        },
        {
            "name": "rate",
            "baseName": "rate",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Invoicingv2invoicesOrderInformationAmountDetailsTaxDetails.attributeTypeMap;
    }
}

/**
* Line item from the order.
*/
export class Invoicingv2invoicesOrderInformationLineItems {
    /**
    * Product identifier code. Also known as the Stock Keeping Unit (SKU) code for the product.  For an authorization or capture transaction (`processingOptions.capture` is set to `true` or `false`), this field is required when `orderInformation.lineItems[].productCode` is not set to **default** or one of the other values that are related to shipping and/or handling.  #### Tax Calculation Optional field for U.S. and Canadian taxes. Not applicable to international and value added taxes. For an authorization or capture transaction (`processingOptions.capture` is set to `true` or `false`), this field is required when `orderInformation.lineItems[].productCode` is not `default` or one of the values related to shipping and/or handling. 
    */
    'productSku'?: string;
    /**
    * For an authorization or capture transaction (`processingOptions.capture` is `true` or `false`), this field is required when `orderInformation.lineItems[].productCode` is not `default` or one of the other values that are related to shipping and/or handling.  #### Tax Calculation Optional field for U.S., Canadian, international tax, and value added taxes. 
    */
    'productName'?: string;
    /**
    * Number of units for this order. Must be a non-negative integer.  The default is `1`. For an authorization or capture transaction (`processingOptions.capture` is set to `true` or `false`), this field is required when `orderInformation.lineItems[].productCode` is not `default` or one of the other values related to shipping and/or handling.  #### Tax Calculation Optional field for U.S., Canadian, international tax, and value added taxes. 
    */
    'quantity'?: number;
    /**
    * Per-item price of the product. This value for this field cannot be negative.  You must include either this field or the request-level field `orderInformation.amountDetails.totalAmount` in your request.  You can include a decimal point (.), but you cannot include any other special characters. The value is truncated to the correct number of decimal places.  #### DCC with a Third-Party Provider Set this field to the converted amount that was returned by the DCC provider. You must include either the 1st line item in the order and this field, or the request-level field `orderInformation.amountDetails.totalAmount` in your request.  #### Tax Calculation Required field for U.S., Canadian, international and value added taxes.  #### Zero Amount Authorizations If your processor supports zero amount authorizations, you can set this field to 0 for the authorization to check if the card is lost or stolen.  #### Maximum Field Lengths For GPN and JCN Gateway: Decimal (10) All other processors: Decimal (15) 
    */
    'unitPrice'?: string;
    /**
    * Discount applied to the item.
    */
    'discountAmount'?: string;
    /**
    * Rate the item is discounted. Maximum of 2 decimal places.  Example 5.25 (=5.25%) 
    */
    'discountPercent'?: string;
    /**
    * Total tax to apply to the product. This value cannot be negative. The tax amount and the offer amount must be in the same currency. The tax amount field is additive.  The following example uses a two-exponent currency such as USD:   1. You include each line item in your request.  ..- 1st line item has amount=10.00, quantity=1, and taxAmount=0.80  ..- 2nd line item has amount=20.00, quantity=1, and taxAmount=1.60  2. The total amount authorized will be 32.40, not 30.00 with 2.40 of tax included.  Optional field.  #### Airlines processing Tax portion of the order amount. This value cannot exceed 99999999999999 (fourteen 9s). Format: English characters only. Optional request field for a line item.  #### Tax Calculation Optional field for U.S., Canadian, international tax, and value added taxes.  Note if you send this field in your tax request, the value in the field will override the tax engine 
    */
    'taxAmount'?: string;
    /**
    * Valid range: 1% to 99%, with only whole percentage values accepted; values with additional  decimal places will be truncated  For processor-specific details, see the alternate_tax_amount, vat_rate, vat_tax_rate, local_tax, national_tax, vat_tax_amount or other_tax#_rate field descriptions in the Level II and Level III Processing Using the SCMP API Guide. 
    */
    'taxRate'?: string;
    /**
    * Total amount for the item. Normally calculated as the unit price times quantity.  When `orderInformation.lineItems[].productCode` is \"gift_card\", this is the purchase amount total for prepaid gift cards in major units.  Example: 123.45 USD = 123 
    */
    'totalAmount'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "productSku",
            "baseName": "productSku",
            "type": "string"
        },
        {
            "name": "productName",
            "baseName": "productName",
            "type": "string"
        },
        {
            "name": "quantity",
            "baseName": "quantity",
            "type": "number"
        },
        {
            "name": "unitPrice",
            "baseName": "unitPrice",
            "type": "string"
        },
        {
            "name": "discountAmount",
            "baseName": "discountAmount",
            "type": "string"
        },
        {
            "name": "discountPercent",
            "baseName": "discountPercent",
            "type": "string"
        },
        {
            "name": "taxAmount",
            "baseName": "taxAmount",
            "type": "string"
        },
        {
            "name": "taxRate",
            "baseName": "taxRate",
            "type": "string"
        },
        {
            "name": "totalAmount",
            "baseName": "totalAmount",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Invoicingv2invoicesOrderInformationLineItems.attributeTypeMap;
    }
}

/**
* Contains processing information, such as collection details.
*/
export class Invoicingv2invoicesProcessingInformation {
    /**
    * Collect the payers phone number during the payment.
    */
    'requestPhone'?: boolean;
    /**
    * Collect the payers shipping address during the payment.
    */
    'requestShipping'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "requestPhone",
            "baseName": "requestPhone",
            "type": "boolean"
        },
        {
            "name": "requestShipping",
            "baseName": "requestShipping",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return Invoicingv2invoicesProcessingInformation.attributeTypeMap;
    }
}

/**
* Contains the updatable invoice information.
*/
export class Invoicingv2invoicesidInvoiceInformation {
    /**
    * The description included in the invoice.
    */
    'description': string;
    /**
    * The invoice due date. This field is required for creating an invoice. Format: `YYYY-MM-DD`, where `YYYY` = year, `MM` = month, and `DD` = day 
    */
    'dueDate': string;
    /**
    * Define an expiration date for the link.  Format: `YYYY-MM-DD`, where `YYYY` = year, `MM` = month, and `DD` = day 
    */
    'expirationDate'?: string;
    /**
    * If set to `true`, we send the invoice immediately. If set to `false`, the invoice remains in draft mode.
    */
    'sendImmediately'?: boolean;
    /**
    * If set to `true`, the payer can make a partial invoice payment.
    */
    'allowPartialPayments'?: boolean;
    /**
    * If this field is set to 'None', an invoice will be generated with the status 'CREATED', but no email will be dispatched.    Possible values:        - `None`   - `Email`    
    */
    'deliveryMode'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "dueDate",
            "baseName": "dueDate",
            "type": "string"
        },
        {
            "name": "expirationDate",
            "baseName": "expirationDate",
            "type": "string"
        },
        {
            "name": "sendImmediately",
            "baseName": "sendImmediately",
            "type": "boolean"
        },
        {
            "name": "allowPartialPayments",
            "baseName": "allowPartialPayments",
            "type": "boolean"
        },
        {
            "name": "deliveryMode",
            "baseName": "deliveryMode",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Invoicingv2invoicesidInvoiceInformation.attributeTypeMap;
    }
}

/**
* Contains all of the order-related fields, such as the amount and line item details.
*/
export class Iplv2paymentlinksOrderInformation {
    'amountDetails': Iplv2paymentlinksOrderInformationAmountDetails;
    /**
    * List of the line items from the order.
    */
    'lineItems': Array<Iplv2paymentlinksOrderInformationLineItems>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "amountDetails",
            "baseName": "amountDetails",
            "type": "Iplv2paymentlinksOrderInformationAmountDetails"
        },
        {
            "name": "lineItems",
            "baseName": "lineItems",
            "type": "Array<Iplv2paymentlinksOrderInformationLineItems>"
        }    ];

    static getAttributeTypeMap() {
        return Iplv2paymentlinksOrderInformation.attributeTypeMap;
    }
}

/**
* Contains all of the amount-related fields.
*/
export class Iplv2paymentlinksOrderInformationAmountDetails {
    /**
    * Grand total for the order. This value cannot be negative. You can include a decimal point (.), but no other special characters. CyberSource truncates the amount to the correct number of decimal places.  **Note** For CTV, FDCCompass, Paymentech processors, the maximum length for this field is 12.  **Important** Some processors have specific requirements and limitations, such as maximum amounts and maximum field lengths.  If your processor supports zero amount authorizations, you can set this field to 0 for the authorization to check if the card is lost or stolen.   #### Card Present Required to include either this field or `orderInformation.lineItems[].unitPrice` for the order.  #### Invoicing / Pay By Link Required for creating a new invoice or payment link.  #### PIN Debit Amount you requested for the PIN debit purchase. This value is returned for partial authorizations. The issuing bank can approve a partial amount if the balance on the debit card is less than the requested transaction amount.  Required field for PIN Debit purchase and PIN Debit credit requests. Optional field for PIN Debit reversal requests.  #### GPX This field is optional for reversing an authorization or credit; however, for all other processors, these fields are required.  #### DCC with a Third-Party Provider Set this field to the converted amount that was returned by the DCC provider. You must include either this field or the 1st line item in the order and the specific line-order amount in your request.   #### DCC for First Data Not used. 
    */
    'totalAmount'?: string;
    /**
    * Currency used for the order. Use the three-character [ISO Standard Currency Codes.](http://apps.cybersource.com/library/documentation/sbc/quickref/currencies.pdf)  #### Used by **Authorization** Required field.  **Authorization Reversal** For an authorization reversal (`reversalInformation`) or a capture (`processingOptions.capture` is set to `true`), you must use the same currency that you used in your payment authorization request.  #### PIN Debit Currency for the amount you requested for the PIN debit purchase. This value is returned for partial authorizations. The issuing bank can approve a partial amount if the balance on the debit card is less than the requested transaction amount. For the possible values, see the [ISO Standard Currency Codes](https://developer.cybersource.com/library/documentation/sbc/quickref/currencies.pdf). Returned by PIN debit purchase.  For PIN debit reversal requests, you must use the same currency that was used for the PIN debit purchase or PIN debit credit that you are reversing. For the possible values, see the [ISO Standard Currency Codes](https://developer.cybersource.com/library/documentation/sbc/quickref/currencies.pdf).  Required field for PIN Debit purchase and PIN Debit credit requests. Optional field for PIN Debit reversal requests.  #### GPX This field is optional for reversing an authorization or credit.  #### DCC for First Data Your local currency.  #### Tax Calculation Required for international tax and value added tax only. Optional for U.S. and Canadian taxes. Your local currency. 
    */
    'currency': string;
    /**
    * Maximum custom amount allowed for Donation. The customer cannot enter more than maxAmount on payment checkout page.
    */
    'maxAmount'?: string;
    /**
    * Minimum custom amount allowed for Donation. The customer cannot enter less than minAmount on payment checkout page. Required for DONATION links.
    */
    'minAmount'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "totalAmount",
            "baseName": "totalAmount",
            "type": "string"
        },
        {
            "name": "currency",
            "baseName": "currency",
            "type": "string"
        },
        {
            "name": "maxAmount",
            "baseName": "maxAmount",
            "type": "string"
        },
        {
            "name": "minAmount",
            "baseName": "minAmount",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Iplv2paymentlinksOrderInformationAmountDetails.attributeTypeMap;
    }
}

/**
* Line item from the order.
*/
export class Iplv2paymentlinksOrderInformationLineItems {
    /**
    * Product identifier code. Also known as the Stock Keeping Unit (SKU) code for the product.  For an authorization or capture transaction (`processingOptions.capture` is set to `true` or `false`), this field is required when `orderInformation.lineItems[].productCode` is not set to **default** or one of the other values that are related to shipping and/or handling.  #### Tax Calculation Optional field for U.S. and Canadian taxes. Not applicable to international and value added taxes. For an authorization or capture transaction (`processingOptions.capture` is set to `true` or `false`), this field is required when `orderInformation.lineItems[].productCode` is not `default` or one of the values related to shipping and/or handling. 
    */
    'productSku'?: string;
    /**
    * For an authorization or capture transaction (`processingOptions.capture` is `true` or `false`), this field is required when `orderInformation.lineItems[].productCode` is not `default` or one of the other values that are related to shipping and/or handling.  #### Tax Calculation Optional field for U.S., Canadian, international tax, and value added taxes. 
    */
    'productName': string;
    /**
    * Number of units for this order. Must be a non-negative integer.  The default is `1`. For an authorization or capture transaction (`processingOptions.capture` is set to `true` or `false`), this field is required when `orderInformation.lineItems[].productCode` is not `default` or one of the other values related to shipping and/or handling.  #### Tax Calculation Optional field for U.S., Canadian, international tax, and value added taxes. 
    */
    'quantity'?: number;
    /**
    * Per-item price of the product. This value for this field cannot be negative.  You must include either this field or the request-level field `orderInformation.amountDetails.totalAmount` in your request.  You can include a decimal point (.), but you cannot include any other special characters. The value is truncated to the correct number of decimal places.  #### DCC with a Third-Party Provider Set this field to the converted amount that was returned by the DCC provider. You must include either the 1st line item in the order and this field, or the request-level field `orderInformation.amountDetails.totalAmount` in your request.  #### Tax Calculation Required field for U.S., Canadian, international and value added taxes.  #### Zero Amount Authorizations If your processor supports zero amount authorizations, you can set this field to 0 for the authorization to check if the card is lost or stolen.  #### Maximum Field Lengths For GPN and JCN Gateway: Decimal (10) All other processors: Decimal (15) 
    */
    'unitPrice'?: string;
    /**
    * Brief description of item.
    */
    'productDescription'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "productSku",
            "baseName": "productSku",
            "type": "string"
        },
        {
            "name": "productName",
            "baseName": "productName",
            "type": "string"
        },
        {
            "name": "quantity",
            "baseName": "quantity",
            "type": "number"
        },
        {
            "name": "unitPrice",
            "baseName": "unitPrice",
            "type": "string"
        },
        {
            "name": "productDescription",
            "baseName": "productDescription",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Iplv2paymentlinksOrderInformationLineItems.attributeTypeMap;
    }
}

/**
* Contains processing information, such as the type and collection details.
*/
export class Iplv2paymentlinksProcessingInformation {
    /**
    * linkType defines what type of link you want to create.  Possible Values:   - `PURCHASE`   - `DONATION` 
    */
    'linkType': Iplv2paymentlinksProcessingInformation.LinkTypeEnum;
    /**
    * Collect the payers phone number during the payment.
    */
    'requestPhone'?: boolean;
    /**
    * Collect the payers shipping address during the payment.
    */
    'requestShipping'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "linkType",
            "baseName": "linkType",
            "type": "Iplv2paymentlinksProcessingInformation.LinkTypeEnum"
        },
        {
            "name": "requestPhone",
            "baseName": "requestPhone",
            "type": "boolean"
        },
        {
            "name": "requestShipping",
            "baseName": "requestShipping",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return Iplv2paymentlinksProcessingInformation.attributeTypeMap;
    }
}

export namespace Iplv2paymentlinksProcessingInformation {
    export enum LinkTypeEnum {
        PURCHASE = <any> 'PURCHASE',
        DONATION = <any> 'DONATION'
    }
}
/**
* Contains link specific detail.
*/
export class Iplv2paymentlinksPurchaseInformation {
    /**
    * The purchase number
    */
    'purchaseNumber': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "purchaseNumber",
            "baseName": "purchaseNumber",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Iplv2paymentlinksPurchaseInformation.attributeTypeMap;
    }
}

/**
* Contains all of the order-related fields, such as the amount and line item details.
*/
export class Iplv2paymentlinksidOrderInformation {
    'amountDetails'?: PblPaymentLinksAllGet200ResponseOrderInformationAmountDetails;
    /**
    * List of the line items from the order.
    */
    'lineItems': Array<Iplv2paymentlinksOrderInformationLineItems>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "amountDetails",
            "baseName": "amountDetails",
            "type": "PblPaymentLinksAllGet200ResponseOrderInformationAmountDetails"
        },
        {
            "name": "lineItems",
            "baseName": "lineItems",
            "type": "Array<Iplv2paymentlinksOrderInformationLineItems>"
        }    ];

    static getAttributeTypeMap() {
        return Iplv2paymentlinksidOrderInformation.attributeTypeMap;
    }
}

/**
* Contains processing information, such as the type and collection details.
*/
export class Iplv2paymentlinksidProcessingInformation {
    /**
    * linkType defines what type of link you want to create.  Possible Values:   - `PURCHASE`   - `DONATION` 
    */
    'linkType'?: Iplv2paymentlinksidProcessingInformation.LinkTypeEnum;
    /**
    * Collect the payers phone number during the payment.
    */
    'requestPhone'?: boolean;
    /**
    * Collect the payers shipping address during the payment.
    */
    'requestShipping'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "linkType",
            "baseName": "linkType",
            "type": "Iplv2paymentlinksidProcessingInformation.LinkTypeEnum"
        },
        {
            "name": "requestPhone",
            "baseName": "requestPhone",
            "type": "boolean"
        },
        {
            "name": "requestShipping",
            "baseName": "requestShipping",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return Iplv2paymentlinksidProcessingInformation.attributeTypeMap;
    }
}

export namespace Iplv2paymentlinksidProcessingInformation {
    export enum LinkTypeEnum {
        PURCHASE = <any> 'PURCHASE',
        DONATION = <any> 'DONATION'
    }
}
/**
* Contains link specific detail.
*/
export class Iplv2paymentlinksidPurchaseInformation {
    /**
    * The purchase number
    */
    'purchaseNumber'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "purchaseNumber",
            "baseName": "purchaseNumber",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Iplv2paymentlinksidPurchaseInformation.attributeTypeMap;
    }
}

/**
* Client object
*/
export class Kmsegressv2keysasymClientReferenceInformation {
    /**
    * Client generated order reference or tracking number. CyberSource recommends that you send a unique value for each transaction so that you can perform meaningful searches for the transaction. 
    */
    'code'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Kmsegressv2keysasymClientReferenceInformation.attributeTypeMap;
    }
}

/**
* Egress Asymmetric  Key Information Request 
*/
export class Kmsegressv2keysasymKeyInformation {
    /**
    * Provider name 
    */
    'provider'?: string;
    /**
    * Tenant name 
    */
    'tenant'?: string;
    /**
    * Type of the key 
    */
    'keyType'?: string;
    /**
    * Organization Id 
    */
    'organizationId'?: string;
    /**
    * Public certificate with only base64 encoded payload and not the header (BEGIN CERTIFICATE) and footer (END CERTIFICATE) 
    */
    'pub'?: string;
    /**
    * Key Serial Number 
    */
    'keyId'?: string;
    /**
    * Private certificate with only base64 encoded payload and not header (BEGIN CERTIFICATE) and footer (END CERTIFICATE) 
    */
    'pvt'?: string;
    /**
    * The status of the key 
    */
    'status'?: string;
    /**
    * Key expiry duration in days 
    */
    'expiryDuration'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "provider",
            "baseName": "provider",
            "type": "string"
        },
        {
            "name": "tenant",
            "baseName": "tenant",
            "type": "string"
        },
        {
            "name": "keyType",
            "baseName": "keyType",
            "type": "string"
        },
        {
            "name": "organizationId",
            "baseName": "organizationId",
            "type": "string"
        },
        {
            "name": "pub",
            "baseName": "pub",
            "type": "string"
        },
        {
            "name": "keyId",
            "baseName": "keyId",
            "type": "string"
        },
        {
            "name": "pvt",
            "baseName": "pvt",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "expiryDuration",
            "baseName": "expiryDuration",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Kmsegressv2keysasymKeyInformation.attributeTypeMap;
    }
}

/**
* Object for client references.
*/
export class Kmsegressv2keyssymClientReferenceInformation {
    /**
    * Client generated order reference or tracking number. CyberSource recommends that you send a unique value for each transaction so that you can perform meaningful searches for the transaction. 
    */
    'code'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Kmsegressv2keyssymClientReferenceInformation.attributeTypeMap;
    }
}

/**
* Egress Key Information Request 
*/
export class Kmsegressv2keyssymKeyInformation {
    /**
    * Provider name 
    */
    'provider'?: string;
    /**
    * Tenant name 
    */
    'tenant'?: string;
    /**
    * Type of the key 
    */
    'keyType'?: string;
    /**
    * Organization Id 
    */
    'organizationId'?: string;
    /**
    * Client key Id 
    */
    'clientKeyId'?: string;
    /**
    * Key Serial Number 
    */
    'keyId'?: string;
    /**
    * Value of the key 
    */
    'key'?: string;
    /**
    * The status of the key 
    */
    'status'?: string;
    /**
    * Key expiry duration in days 
    */
    'expiryDuration'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "provider",
            "baseName": "provider",
            "type": "string"
        },
        {
            "name": "tenant",
            "baseName": "tenant",
            "type": "string"
        },
        {
            "name": "keyType",
            "baseName": "keyType",
            "type": "string"
        },
        {
            "name": "organizationId",
            "baseName": "organizationId",
            "type": "string"
        },
        {
            "name": "clientKeyId",
            "baseName": "clientKeyId",
            "type": "string"
        },
        {
            "name": "keyId",
            "baseName": "keyId",
            "type": "string"
        },
        {
            "name": "key",
            "baseName": "key",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "expiryDuration",
            "baseName": "expiryDuration",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Kmsegressv2keyssymKeyInformation.attributeTypeMap;
    }
}

export class MerchantInitiatedTransactionObject {
    /**
    * Reason for the merchant-initiated transaction or incremental authorization. Possible values: - `1`: Resubmission - `2`: Delayed charge - `3`: Reauthorization for split shipment - `4`: No show - `5`: Account top up This field is required only for the five kinds of transactions in the preceding list. This field is supported only for merchant-initiated transactions and incremental authorizations.  #### CyberSource through VisaNet The value for this field corresponds to the following data in the TC 33 capture file5: - Record: CP01 TCR0 - Position: 160-163 - Field: Message Reason Code 
    */
    'reason'?: string;
    /**
    * Network transaction identifier that was returned in the payment response field _processorInformation.transactionID_ in the reply message for either the original merchant-initiated payment in the series or the previous merchant-initiated payment in the series.  If the current payment request includes a token instead of an account number, the following time limits apply for the value of this field: - For a **resubmission**, the transaction ID must be less than 14 days old. - For a **delayed charge** or **reauthorization**, the transaction ID must be less than 30 days old.  **NOTE**: The value for this field does not correspond to any data in the TC 33 capture file5. This field is supported only for Visa transactions on CyberSource through VisaNet. 
    */
    'previousTransactionId'?: string;
    /**
    * Amount of the original authorization.  This field is supported only for Apple Pay, Google Pay, and Samsung Pay transactions with Discover on FDC Nashville Global and Chase Paymentech. 
    */
    'originalAuthorizedAmount'?: string;
    /**
    * This field contains the predetermined agrement id with the merchant 
    */
    'agreementId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "reason",
            "baseName": "reason",
            "type": "string"
        },
        {
            "name": "previousTransactionId",
            "baseName": "previousTransactionId",
            "type": "string"
        },
        {
            "name": "originalAuthorizedAmount",
            "baseName": "originalAuthorizedAmount",
            "type": "string"
        },
        {
            "name": "agreementId",
            "baseName": "agreementId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return MerchantInitiatedTransactionObject.attributeTypeMap;
    }
}

export class Microformv2sessionsTransientTokenResponseOptions {
    /**
    * Use the transientTokenResponseOptions.includeCardPrefix field to choose your preferred card number prefix length: 6-digit, 8-digit, or no card number prefix.  Possible values: - True - False<br><br>  To select the type of card number prefix: - No field included: A 6-digit prefix is returned (default) - True: An 8-digit prefix is returned - False: No prefix is returned<br><br>  The following conditions apply: - 8-digit card number prefixes only apply to Discover, JCB, Mastercard, UnionPay, and Visa brands with 16-digit card numbers or more. - Any card with less than 16-digit numbers will return a 6-digit prefix even when the transientTokenResponseOptions.includeCardPrefix field is set to true. - Any card brand other than Discover, JCB, Mastercard, UnionPay, or Visa will return a 6-digit prefix even when the transientTokenResponseOptions.includeCardPrefix field is set to true. - If any card brand is co-branded with Discover, JCB, Mastercard, UnionPay, or Visa, an 8-digit prefix will be returned if the transientTokenResponseOptions.includeCardPrefix field is set to true.<br><br>  **Important:**  If your application does NOT require a card number prefix for routing or identification purposes, set the transientTokenResponseOptions.includeCardPrefix field to False.  This will minimize your personal data exposure. 
    */
    'includeCardPrefix'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "includeCardPrefix",
            "baseName": "includeCardPrefix",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return Microformv2sessionsTransientTokenResponseOptions.attributeTypeMap;
    }
}

export class MitReversalRequest {
    'clientReferenceInformation'?: Ptsv2paymentsClientReferenceInformation;
    'reversalInformation'?: Ptsv2paymentsidreversalsReversalInformation;
    'processingInformation'?: Ptsv2paymentsidreversalsProcessingInformation;
    'orderInformation'?: Ptsv2paymentsidreversalsOrderInformation;
    'pointOfSaleInformation'?: Ptsv2paymentsidreversalsPointOfSaleInformation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "clientReferenceInformation",
            "baseName": "clientReferenceInformation",
            "type": "Ptsv2paymentsClientReferenceInformation"
        },
        {
            "name": "reversalInformation",
            "baseName": "reversalInformation",
            "type": "Ptsv2paymentsidreversalsReversalInformation"
        },
        {
            "name": "processingInformation",
            "baseName": "processingInformation",
            "type": "Ptsv2paymentsidreversalsProcessingInformation"
        },
        {
            "name": "orderInformation",
            "baseName": "orderInformation",
            "type": "Ptsv2paymentsidreversalsOrderInformation"
        },
        {
            "name": "pointOfSaleInformation",
            "baseName": "pointOfSaleInformation",
            "type": "Ptsv2paymentsidreversalsPointOfSaleInformation"
        }    ];

    static getAttributeTypeMap() {
        return MitReversalRequest.attributeTypeMap;
    }
}

export class MitVoidRequest {
    'clientReferenceInformation'?: Ptsv2paymentsClientReferenceInformation;
    'paymentInformation'?: Ptsv2paymentsidvoidsPaymentInformation;
    'orderInformation'?: Ptsv2paymentsidvoidsOrderInformation;
    'processingInformation'?: Ptsv2voidsProcessingInformation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "clientReferenceInformation",
            "baseName": "clientReferenceInformation",
            "type": "Ptsv2paymentsClientReferenceInformation"
        },
        {
            "name": "paymentInformation",
            "baseName": "paymentInformation",
            "type": "Ptsv2paymentsidvoidsPaymentInformation"
        },
        {
            "name": "orderInformation",
            "baseName": "orderInformation",
            "type": "Ptsv2paymentsidvoidsOrderInformation"
        },
        {
            "name": "processingInformation",
            "baseName": "processingInformation",
            "type": "Ptsv2voidsProcessingInformation"
        }    ];

    static getAttributeTypeMap() {
        return MitVoidRequest.attributeTypeMap;
    }
}

export class ModifyBillingAgreement {
    'agreementInformation'?: Ptsv2billingagreementsidAgreementInformation;
    'clientReferenceInformation'?: Ptsv2billingagreementsClientReferenceInformation;
    'aggregatorInformation'?: Ptsv2billingagreementsAggregatorInformation;
    'consumerAuthenticationInformation'?: Ptsv2billingagreementsConsumerAuthenticationInformation;
    'deviceInformation'?: Ptsv2billingagreementsDeviceInformation;
    'installmentInformation'?: Ptsv2billingagreementsInstallmentInformation;
    'merchantInformation'?: Ptsv2billingagreementsMerchantInformation;
    'orderInformation'?: Ptsv2billingagreementsOrderInformation;
    'paymentInformation'?: Ptsv2billingagreementsPaymentInformation;
    'processingInformation'?: Ptsv2billingagreementsidProcessingInformation;
    'buyerInformation'?: Ptsv2billingagreementsidBuyerInformation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "agreementInformation",
            "baseName": "agreementInformation",
            "type": "Ptsv2billingagreementsidAgreementInformation"
        },
        {
            "name": "clientReferenceInformation",
            "baseName": "clientReferenceInformation",
            "type": "Ptsv2billingagreementsClientReferenceInformation"
        },
        {
            "name": "aggregatorInformation",
            "baseName": "aggregatorInformation",
            "type": "Ptsv2billingagreementsAggregatorInformation"
        },
        {
            "name": "consumerAuthenticationInformation",
            "baseName": "consumerAuthenticationInformation",
            "type": "Ptsv2billingagreementsConsumerAuthenticationInformation"
        },
        {
            "name": "deviceInformation",
            "baseName": "deviceInformation",
            "type": "Ptsv2billingagreementsDeviceInformation"
        },
        {
            "name": "installmentInformation",
            "baseName": "installmentInformation",
            "type": "Ptsv2billingagreementsInstallmentInformation"
        },
        {
            "name": "merchantInformation",
            "baseName": "merchantInformation",
            "type": "Ptsv2billingagreementsMerchantInformation"
        },
        {
            "name": "orderInformation",
            "baseName": "orderInformation",
            "type": "Ptsv2billingagreementsOrderInformation"
        },
        {
            "name": "paymentInformation",
            "baseName": "paymentInformation",
            "type": "Ptsv2billingagreementsPaymentInformation"
        },
        {
            "name": "processingInformation",
            "baseName": "processingInformation",
            "type": "Ptsv2billingagreementsidProcessingInformation"
        },
        {
            "name": "buyerInformation",
            "baseName": "buyerInformation",
            "type": "Ptsv2billingagreementsidBuyerInformation"
        }    ];

    static getAttributeTypeMap() {
        return ModifyBillingAgreement.attributeTypeMap;
    }
}

export class NetworkTokenEnrollment {
    'businessInformation'?: TmsBusinessInformation;
    'networkTokenServices'?: NetworkTokenServicesEnablement;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "businessInformation",
            "baseName": "businessInformation",
            "type": "TmsBusinessInformation"
        },
        {
            "name": "networkTokenServices",
            "baseName": "networkTokenServices",
            "type": "NetworkTokenServicesEnablement"
        }    ];

    static getAttributeTypeMap() {
        return NetworkTokenEnrollment.attributeTypeMap;
    }
}

export class NetworkTokenServicesEnablement {
    'visaTokenService'?: NetworkTokenServicesEnablementVisaTokenService;
    'mastercardDigitalEnablementService'?: NetworkTokenServicesEnablementMastercardDigitalEnablementService;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "visaTokenService",
            "baseName": "visaTokenService",
            "type": "NetworkTokenServicesEnablementVisaTokenService"
        },
        {
            "name": "mastercardDigitalEnablementService",
            "baseName": "mastercardDigitalEnablementService",
            "type": "NetworkTokenServicesEnablementMastercardDigitalEnablementService"
        }    ];

    static getAttributeTypeMap() {
        return NetworkTokenServicesEnablement.attributeTypeMap;
    }
}

export class NetworkTokenServicesEnablementMastercardDigitalEnablementService {
    /**
    * Indicates if an enrollment to create a TRID for the MasterCard card association should be attempted
    */
    'enrollment'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "enrollment",
            "baseName": "enrollment",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return NetworkTokenServicesEnablementMastercardDigitalEnablementService.attributeTypeMap;
    }
}

export class NetworkTokenServicesEnablementVisaTokenService {
    /**
    * Indicates if an enrollment to create a TRID for the Visa card association should be attempted
    */
    'enrollment'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "enrollment",
            "baseName": "enrollment",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return NetworkTokenServicesEnablementVisaTokenService.attributeTypeMap;
    }
}

export class Notificationsubscriptionsv2productsorganizationIdEventTypes {
    'eventName'?: string;
    'displayName'?: string;
    'frequency'?: number;
    'timeSensitivity'?: boolean;
    'payloadEncryption'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "eventName",
            "baseName": "eventName",
            "type": "string"
        },
        {
            "name": "displayName",
            "baseName": "displayName",
            "type": "string"
        },
        {
            "name": "frequency",
            "baseName": "frequency",
            "type": "number"
        },
        {
            "name": "timeSensitivity",
            "baseName": "timeSensitivity",
            "type": "boolean"
        },
        {
            "name": "payloadEncryption",
            "baseName": "payloadEncryption",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return Notificationsubscriptionsv2productsorganizationIdEventTypes.attributeTypeMap;
    }
}

export class Notificationsubscriptionsv2webhooksProducts {
    /**
    * Product ID.
    */
    'productId'?: string;
    'eventTypes'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "productId",
            "baseName": "productId",
            "type": "string"
        },
        {
            "name": "eventTypes",
            "baseName": "eventTypes",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return Notificationsubscriptionsv2webhooksProducts.attributeTypeMap;
    }
}

export class Notificationsubscriptionsv2webhooksProducts1 {
    /**
    * Product ID.
    */
    'productId'?: string;
    'eventTypes'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "productId",
            "baseName": "productId",
            "type": "string"
        },
        {
            "name": "eventTypes",
            "baseName": "eventTypes",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return Notificationsubscriptionsv2webhooksProducts1.attributeTypeMap;
    }
}

/**
* Retry policy for the individual webhooks that are a part of your subscription. If a message fails to deliver, it will execute through this retry policy.  Automatic suspend and resume:  If you experience downtime and have `deactivateFlag = true` any new messages will be held in a \"SUSPENDED\" status. When your healthCheckUrl returns healthy again, the subscription will automatically be re-enabled and your messages will be sent. We will ping your healthCheckUrl routinely using a POST call with an empty payload to check availability. If your endpoint returns an unhealthy status of != 200, we will check the healthCheckUrl at a more frequent rate until it is healthy again.  If you experience downtime and have `deactivateFlag = false` and your message exhausts all retry attempts the message will go to a \"FAILED\" status. Support will be notified and will reach out to suggest you execute the \"REPLAY\" endpoint at a later date when your server is healthy.   Reference the below values for formulas and calculations related to the frequency of retries depending on algorithm and configuration. 
*/
export class Notificationsubscriptionsv2webhooksRetryPolicy {
    /**
    * This is used to calculate the Retry Sequence.  Sample calculations using firstRetry=10, interval=30, maxNumberOfRetries=3 Arithmetic = a+r(n-1) Retry 1 - 10 minutes Retry 2 - 10+30x1 = 40 minutes Retry 3 - 10+30x2 = 70 minutes  Geometric = ar^(n-1) Retry 1 - 10 minutes Retry 2 - 10x30^1 = 300 minutes Retry 3 - 10x30^2 = 9,000 minutes 
    */
    'algorithm'?: string;
    /**
    * When to initiate first retry, after the initial call failed. (in mins).
    */
    'firstRetry'?: number;
    /**
    * The interval between retries (in mins).
    */
    'interval'?: number;
    /**
    * The number of retries per sequence.
    */
    'numberOfRetries'?: number;
    /**
    * Deactivate the subscription if your retries fail to deliver.  If this is set to `true`, the automatic suspend and resume feature will occur. This would prevent new webhooks from attempting to deliver and to queue up until your healthCheckUrl returns 200 again, then all messages will be sent.  If this is set to `false`, new individual messages will continue to retry and exhaust all failures, but the subscription will stay active. 
    */
    'deactivateFlag'?: string;
    /**
    * The number of times to repeat the complete retry sequence. 0 => don't repeat the retry sequence 1 => repeat the retry sequence once (R1, R2, R3)+ (R1, R2, R3) 2 => repeat the retry sequence twice (R1, R2, R3) + (R1, R2, R3) + (R1, R2, R3) 
    */
    'repeatSequenceCount'?: number;
    /**
    * The time to wait to before repeating the complete retry sequence. Amount of time to wait between each sequence. Sample calculation using repeatSequenceWaitTime=10 (R1, R2, R3) + (10) + (R1, R2, R3) + (10) + (R1, R2, R3) 
    */
    'repeatSequenceWaitTime'?: number;
    /**
    * Additional data, if any.
    */
    'additionalAttributes'?: Array<{ [key: string]: string; }>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "algorithm",
            "baseName": "algorithm",
            "type": "string"
        },
        {
            "name": "firstRetry",
            "baseName": "firstRetry",
            "type": "number"
        },
        {
            "name": "interval",
            "baseName": "interval",
            "type": "number"
        },
        {
            "name": "numberOfRetries",
            "baseName": "numberOfRetries",
            "type": "number"
        },
        {
            "name": "deactivateFlag",
            "baseName": "deactivateFlag",
            "type": "string"
        },
        {
            "name": "repeatSequenceCount",
            "baseName": "repeatSequenceCount",
            "type": "number"
        },
        {
            "name": "repeatSequenceWaitTime",
            "baseName": "repeatSequenceWaitTime",
            "type": "number"
        },
        {
            "name": "additionalAttributes",
            "baseName": "additionalAttributes",
            "type": "Array<{ [key: string]: string; }>"
        }    ];

    static getAttributeTypeMap() {
        return Notificationsubscriptionsv2webhooksRetryPolicy.attributeTypeMap;
    }
}

/**
* The security option to authenticate with your API or client server.
*/
export class Notificationsubscriptionsv2webhooksSecurityPolicy {
    /**
    * Security Policy of the client server.
    */
    'securityType'?: Notificationsubscriptionsv2webhooksSecurityPolicy.SecurityTypeEnum;
    'config'?: Notificationsubscriptionsv2webhooksSecurityPolicyConfig;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "securityType",
            "baseName": "securityType",
            "type": "Notificationsubscriptionsv2webhooksSecurityPolicy.SecurityTypeEnum"
        },
        {
            "name": "config",
            "baseName": "config",
            "type": "Notificationsubscriptionsv2webhooksSecurityPolicyConfig"
        }    ];

    static getAttributeTypeMap() {
        return Notificationsubscriptionsv2webhooksSecurityPolicy.attributeTypeMap;
    }
}

export namespace Notificationsubscriptionsv2webhooksSecurityPolicy {
    export enum SecurityTypeEnum {
        Key = <any> 'key',
        OAuth = <any> 'oAuth',
        OAuthJWT = <any> 'oAuth_JWT'
    }
}
/**
* Optional configuration object for if your API or server requires oAuth for an incoming webhook.
*/
export class Notificationsubscriptionsv2webhooksSecurityPolicyConfig {
    /**
    * Client direct endpoint to the oAuth server.
    */
    'oAuthURL'?: string;
    /**
    * Token type for the oAuth config.
    */
    'oAuthTokenType'?: Notificationsubscriptionsv2webhooksSecurityPolicyConfig.OAuthTokenTypeEnum;
    'additionalConfig'?: Notificationsubscriptionsv2webhooksSecurityPolicyConfigAdditionalConfig;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "oAuthURL",
            "baseName": "oAuthURL",
            "type": "string"
        },
        {
            "name": "oAuthTokenType",
            "baseName": "oAuthTokenType",
            "type": "Notificationsubscriptionsv2webhooksSecurityPolicyConfig.OAuthTokenTypeEnum"
        },
        {
            "name": "additionalConfig",
            "baseName": "additionalConfig",
            "type": "Notificationsubscriptionsv2webhooksSecurityPolicyConfigAdditionalConfig"
        }    ];

    static getAttributeTypeMap() {
        return Notificationsubscriptionsv2webhooksSecurityPolicyConfig.attributeTypeMap;
    }
}

export namespace Notificationsubscriptionsv2webhooksSecurityPolicyConfig {
    export enum OAuthTokenTypeEnum {
        Bearer = <any> 'Bearer'
    }
}
/**
* Additional, free form configuration data.
*/
export class Notificationsubscriptionsv2webhooksSecurityPolicyConfigAdditionalConfig {
    'aud'?: string;
    'clientId'?: string;
    'keyId'?: string;
    'scope'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "aud",
            "baseName": "aud",
            "type": "string"
        },
        {
            "name": "clientId",
            "baseName": "client_id",
            "type": "string"
        },
        {
            "name": "keyId",
            "baseName": "keyId",
            "type": "string"
        },
        {
            "name": "scope",
            "baseName": "scope",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Notificationsubscriptionsv2webhooksSecurityPolicyConfigAdditionalConfig.attributeTypeMap;
    }
}

export class OctCreatePaymentRequest {
    'clientReferenceInformation'?: Ptsv2payoutsClientReferenceInformation;
    'orderInformation'?: Ptsv2payoutsOrderInformation;
    'merchantInformation'?: Ptsv2payoutsMerchantInformation;
    'recipientInformation'?: Ptsv2payoutsRecipientInformation;
    'senderInformation'?: Ptsv2payoutsSenderInformation;
    'processingInformation'?: Ptsv2payoutsProcessingInformation;
    'paymentInformation'?: Ptsv2payoutsPaymentInformation;
    'aggregatorInformation'?: Ptsv2payoutsAggregatorInformation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "clientReferenceInformation",
            "baseName": "clientReferenceInformation",
            "type": "Ptsv2payoutsClientReferenceInformation"
        },
        {
            "name": "orderInformation",
            "baseName": "orderInformation",
            "type": "Ptsv2payoutsOrderInformation"
        },
        {
            "name": "merchantInformation",
            "baseName": "merchantInformation",
            "type": "Ptsv2payoutsMerchantInformation"
        },
        {
            "name": "recipientInformation",
            "baseName": "recipientInformation",
            "type": "Ptsv2payoutsRecipientInformation"
        },
        {
            "name": "senderInformation",
            "baseName": "senderInformation",
            "type": "Ptsv2payoutsSenderInformation"
        },
        {
            "name": "processingInformation",
            "baseName": "processingInformation",
            "type": "Ptsv2payoutsProcessingInformation"
        },
        {
            "name": "paymentInformation",
            "baseName": "paymentInformation",
            "type": "Ptsv2payoutsPaymentInformation"
        },
        {
            "name": "aggregatorInformation",
            "baseName": "aggregatorInformation",
            "type": "Ptsv2payoutsAggregatorInformation"
        }    ];

    static getAttributeTypeMap() {
        return OctCreatePaymentRequest.attributeTypeMap;
    }
}

export class OrderPaymentRequest {
    'clientReferenceInformation'?: PtsV2IncrementalAuthorizationPatch201ResponseClientReferenceInformation;
    'processingInformation'?: Ptsv2paymentreferencesidintentsProcessingInformation;
    'paymentInformation'?: Ptsv2paymentreferencesidintentsPaymentInformation;
    'orderInformation'?: Ptsv2paymentreferencesidintentsOrderInformation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "clientReferenceInformation",
            "baseName": "clientReferenceInformation",
            "type": "PtsV2IncrementalAuthorizationPatch201ResponseClientReferenceInformation"
        },
        {
            "name": "processingInformation",
            "baseName": "processingInformation",
            "type": "Ptsv2paymentreferencesidintentsProcessingInformation"
        },
        {
            "name": "paymentInformation",
            "baseName": "paymentInformation",
            "type": "Ptsv2paymentreferencesidintentsPaymentInformation"
        },
        {
            "name": "orderInformation",
            "baseName": "orderInformation",
            "type": "Ptsv2paymentreferencesidintentsOrderInformation"
        }    ];

    static getAttributeTypeMap() {
        return OrderPaymentRequest.attributeTypeMap;
    }
}

export class PatchCustomerPaymentInstrumentRequest {
    'links'?: Tmsv2customersEmbeddedDefaultPaymentInstrumentLinks;
    /**
    * The Id of the Payment Instrument Token.
    */
    'id'?: string;
    /**
    * The type.  Possible Values: - paymentInstrument 
    */
    'object'?: string;
    /**
    * Flag that indicates whether customer payment instrument is the dafault. Possible Values:  - `true`: Payment instrument is customer's default.  - `false`: Payment instrument is not customer's default. 
    */
    '_default'?: boolean;
    /**
    * Issuers state for the card number. Possible Values: - ACTIVE - CLOSED : The account has been closed. 
    */
    'state'?: string;
    /**
    * The type of Payment Instrument. Possible Values: - cardHash 
    */
    'type'?: string;
    'bankAccount'?: Tmsv2customersEmbeddedDefaultPaymentInstrumentBankAccount;
    'card'?: Tmsv2customersEmbeddedDefaultPaymentInstrumentCard;
    'buyerInformation'?: Tmsv2customersEmbeddedDefaultPaymentInstrumentBuyerInformation;
    'billTo'?: Tmsv2customersEmbeddedDefaultPaymentInstrumentBillTo;
    'processingInformation'?: TmsPaymentInstrumentProcessingInfo;
    'merchantInformation'?: Tmsv2customersEmbeddedDefaultPaymentInstrumentMerchantInformation;
    'instrumentIdentifier'?: Tmsv2customersEmbeddedDefaultPaymentInstrumentInstrumentIdentifier;
    'metadata'?: Tmsv2customersEmbeddedDefaultPaymentInstrumentMetadata;
    'embedded'?: Tmsv2customersEmbeddedDefaultPaymentInstrumentEmbedded;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "Tmsv2customersEmbeddedDefaultPaymentInstrumentLinks"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "object",
            "baseName": "object",
            "type": "string"
        },
        {
            "name": "_default",
            "baseName": "default",
            "type": "boolean"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "bankAccount",
            "baseName": "bankAccount",
            "type": "Tmsv2customersEmbeddedDefaultPaymentInstrumentBankAccount"
        },
        {
            "name": "card",
            "baseName": "card",
            "type": "Tmsv2customersEmbeddedDefaultPaymentInstrumentCard"
        },
        {
            "name": "buyerInformation",
            "baseName": "buyerInformation",
            "type": "Tmsv2customersEmbeddedDefaultPaymentInstrumentBuyerInformation"
        },
        {
            "name": "billTo",
            "baseName": "billTo",
            "type": "Tmsv2customersEmbeddedDefaultPaymentInstrumentBillTo"
        },
        {
            "name": "processingInformation",
            "baseName": "processingInformation",
            "type": "TmsPaymentInstrumentProcessingInfo"
        },
        {
            "name": "merchantInformation",
            "baseName": "merchantInformation",
            "type": "Tmsv2customersEmbeddedDefaultPaymentInstrumentMerchantInformation"
        },
        {
            "name": "instrumentIdentifier",
            "baseName": "instrumentIdentifier",
            "type": "Tmsv2customersEmbeddedDefaultPaymentInstrumentInstrumentIdentifier"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "Tmsv2customersEmbeddedDefaultPaymentInstrumentMetadata"
        },
        {
            "name": "embedded",
            "baseName": "_embedded",
            "type": "Tmsv2customersEmbeddedDefaultPaymentInstrumentEmbedded"
        }    ];

    static getAttributeTypeMap() {
        return PatchCustomerPaymentInstrumentRequest.attributeTypeMap;
    }
}

export class PatchCustomerRequest {
    'links'?: Tmsv2customersLinks;
    /**
    * The Id of the Customer Token.
    */
    'id'?: string;
    'objectInformation'?: Tmsv2customersObjectInformation;
    'buyerInformation'?: Tmsv2customersBuyerInformation;
    'clientReferenceInformation'?: Tmsv2customersClientReferenceInformation;
    /**
    * Object containing the custom data that the merchant defines. 
    */
    'merchantDefinedInformation'?: Array<Tmsv2customersMerchantDefinedInformation>;
    'defaultPaymentInstrument'?: Tmsv2customersDefaultPaymentInstrument;
    'defaultShippingAddress'?: Tmsv2customersDefaultShippingAddress;
    'metadata'?: Tmsv2customersMetadata;
    'embedded'?: Tmsv2customersEmbedded;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "Tmsv2customersLinks"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "objectInformation",
            "baseName": "objectInformation",
            "type": "Tmsv2customersObjectInformation"
        },
        {
            "name": "buyerInformation",
            "baseName": "buyerInformation",
            "type": "Tmsv2customersBuyerInformation"
        },
        {
            "name": "clientReferenceInformation",
            "baseName": "clientReferenceInformation",
            "type": "Tmsv2customersClientReferenceInformation"
        },
        {
            "name": "merchantDefinedInformation",
            "baseName": "merchantDefinedInformation",
            "type": "Array<Tmsv2customersMerchantDefinedInformation>"
        },
        {
            "name": "defaultPaymentInstrument",
            "baseName": "defaultPaymentInstrument",
            "type": "Tmsv2customersDefaultPaymentInstrument"
        },
        {
            "name": "defaultShippingAddress",
            "baseName": "defaultShippingAddress",
            "type": "Tmsv2customersDefaultShippingAddress"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "Tmsv2customersMetadata"
        },
        {
            "name": "embedded",
            "baseName": "_embedded",
            "type": "Tmsv2customersEmbedded"
        }    ];

    static getAttributeTypeMap() {
        return PatchCustomerRequest.attributeTypeMap;
    }
}

export class PatchCustomerShippingAddressRequest {
    'links'?: Tmsv2customersEmbeddedDefaultShippingAddressLinks;
    /**
    * The Id of the Shipping Address Token.
    */
    'id'?: string;
    /**
    * Flag that indicates whether customer shipping address is the dafault. Possible Values:  - `true`: Shipping Address is customer's default.  - `false`: Shipping Address is not customer's default. 
    */
    '_default'?: boolean;
    'shipTo'?: Tmsv2customersEmbeddedDefaultShippingAddressShipTo;
    'metadata'?: Tmsv2customersEmbeddedDefaultShippingAddressMetadata;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "Tmsv2customersEmbeddedDefaultShippingAddressLinks"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "_default",
            "baseName": "default",
            "type": "boolean"
        },
        {
            "name": "shipTo",
            "baseName": "shipTo",
            "type": "Tmsv2customersEmbeddedDefaultShippingAddressShipTo"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "Tmsv2customersEmbeddedDefaultShippingAddressMetadata"
        }    ];

    static getAttributeTypeMap() {
        return PatchCustomerShippingAddressRequest.attributeTypeMap;
    }
}

export class PatchInstrumentIdentifierRequest {
    'links'?: TmsEmbeddedInstrumentIdentifierLinks;
    /**
    * The Id of the Instrument Identifier Token. 
    */
    'id'?: string;
    /**
    * The type.  Possible Values: - instrumentIdentifier 
    */
    'object'?: string;
    /**
    * Issuers state for the card number. Possible Values: - ACTIVE - CLOSED : The account has been closed. 
    */
    'state'?: string;
    /**
    * The type of Instrument Identifier. Possible Values: - enrollable card - enrollable token 
    */
    'type'?: string;
    'tokenProvisioningInformation'?: Ptsv2paymentsTokenInformationTokenProvisioningInformation;
    'card'?: TmsEmbeddedInstrumentIdentifierCard;
    'bankAccount'?: TmsEmbeddedInstrumentIdentifierBankAccount;
    'tokenizedCard'?: Tmsv2TokenizedCard;
    'issuer'?: TmsEmbeddedInstrumentIdentifierIssuer;
    'processingInformation'?: TmsEmbeddedInstrumentIdentifierProcessingInformation;
    'billTo'?: TmsEmbeddedInstrumentIdentifierBillTo;
    'metadata'?: TmsEmbeddedInstrumentIdentifierMetadata;
    'embedded'?: TmsEmbeddedInstrumentIdentifierEmbedded;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "TmsEmbeddedInstrumentIdentifierLinks"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "object",
            "baseName": "object",
            "type": "string"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "tokenProvisioningInformation",
            "baseName": "tokenProvisioningInformation",
            "type": "Ptsv2paymentsTokenInformationTokenProvisioningInformation"
        },
        {
            "name": "card",
            "baseName": "card",
            "type": "TmsEmbeddedInstrumentIdentifierCard"
        },
        {
            "name": "bankAccount",
            "baseName": "bankAccount",
            "type": "TmsEmbeddedInstrumentIdentifierBankAccount"
        },
        {
            "name": "tokenizedCard",
            "baseName": "tokenizedCard",
            "type": "Tmsv2TokenizedCard"
        },
        {
            "name": "issuer",
            "baseName": "issuer",
            "type": "TmsEmbeddedInstrumentIdentifierIssuer"
        },
        {
            "name": "processingInformation",
            "baseName": "processingInformation",
            "type": "TmsEmbeddedInstrumentIdentifierProcessingInformation"
        },
        {
            "name": "billTo",
            "baseName": "billTo",
            "type": "TmsEmbeddedInstrumentIdentifierBillTo"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "TmsEmbeddedInstrumentIdentifierMetadata"
        },
        {
            "name": "embedded",
            "baseName": "_embedded",
            "type": "TmsEmbeddedInstrumentIdentifierEmbedded"
        }    ];

    static getAttributeTypeMap() {
        return PatchInstrumentIdentifierRequest.attributeTypeMap;
    }
}

export class PatchPaymentInstrumentRequest {
    'links'?: Tmsv2customersEmbeddedDefaultPaymentInstrumentLinks;
    /**
    * The Id of the Payment Instrument Token.
    */
    'id'?: string;
    /**
    * The type.  Possible Values: - paymentInstrument 
    */
    'object'?: string;
    /**
    * Flag that indicates whether customer payment instrument is the dafault. Possible Values:  - `true`: Payment instrument is customer's default.  - `false`: Payment instrument is not customer's default. 
    */
    '_default'?: boolean;
    /**
    * Issuers state for the card number. Possible Values: - ACTIVE - CLOSED : The account has been closed. 
    */
    'state'?: string;
    /**
    * The type of Payment Instrument. Possible Values: - cardHash 
    */
    'type'?: string;
    'bankAccount'?: Tmsv2customersEmbeddedDefaultPaymentInstrumentBankAccount;
    'card'?: Tmsv2customersEmbeddedDefaultPaymentInstrumentCard;
    'buyerInformation'?: Tmsv2customersEmbeddedDefaultPaymentInstrumentBuyerInformation;
    'billTo'?: Tmsv2customersEmbeddedDefaultPaymentInstrumentBillTo;
    'processingInformation'?: TmsPaymentInstrumentProcessingInfo;
    'merchantInformation'?: Tmsv2customersEmbeddedDefaultPaymentInstrumentMerchantInformation;
    'instrumentIdentifier'?: Tmsv2customersEmbeddedDefaultPaymentInstrumentInstrumentIdentifier;
    'metadata'?: Tmsv2customersEmbeddedDefaultPaymentInstrumentMetadata;
    'embedded'?: Tmsv2customersEmbeddedDefaultPaymentInstrumentEmbedded;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "Tmsv2customersEmbeddedDefaultPaymentInstrumentLinks"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "object",
            "baseName": "object",
            "type": "string"
        },
        {
            "name": "_default",
            "baseName": "default",
            "type": "boolean"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "bankAccount",
            "baseName": "bankAccount",
            "type": "Tmsv2customersEmbeddedDefaultPaymentInstrumentBankAccount"
        },
        {
            "name": "card",
            "baseName": "card",
            "type": "Tmsv2customersEmbeddedDefaultPaymentInstrumentCard"
        },
        {
            "name": "buyerInformation",
            "baseName": "buyerInformation",
            "type": "Tmsv2customersEmbeddedDefaultPaymentInstrumentBuyerInformation"
        },
        {
            "name": "billTo",
            "baseName": "billTo",
            "type": "Tmsv2customersEmbeddedDefaultPaymentInstrumentBillTo"
        },
        {
            "name": "processingInformation",
            "baseName": "processingInformation",
            "type": "TmsPaymentInstrumentProcessingInfo"
        },
        {
            "name": "merchantInformation",
            "baseName": "merchantInformation",
            "type": "Tmsv2customersEmbeddedDefaultPaymentInstrumentMerchantInformation"
        },
        {
            "name": "instrumentIdentifier",
            "baseName": "instrumentIdentifier",
            "type": "Tmsv2customersEmbeddedDefaultPaymentInstrumentInstrumentIdentifier"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "Tmsv2customersEmbeddedDefaultPaymentInstrumentMetadata"
        },
        {
            "name": "embedded",
            "baseName": "_embedded",
            "type": "Tmsv2customersEmbeddedDefaultPaymentInstrumentEmbedded"
        }    ];

    static getAttributeTypeMap() {
        return PatchPaymentInstrumentRequest.attributeTypeMap;
    }
}

export class PayerAuthConfig {
    'cardTypes'?: PayerAuthConfigCardTypes;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "cardTypes",
            "baseName": "cardTypes",
            "type": "PayerAuthConfigCardTypes"
        }    ];

    static getAttributeTypeMap() {
        return PayerAuthConfig.attributeTypeMap;
    }
}

export class PayerAuthConfigCardTypes {
    'verifiedByVisa'?: PayerAuthConfigCardTypesVerifiedByVisa;
    'masterCardSecureCode'?: PayerAuthConfigCardTypesVerifiedByVisa;
    'amexSafeKey'?: PayerAuthConfigCardTypesVerifiedByVisa;
    'jCBJSecure'?: PayerAuthConfigCardTypesJCBJSecure;
    'dinersClubInternationalProtectBuy'?: PayerAuthConfigCardTypesVerifiedByVisa;
    'ELO'?: PayerAuthConfigCardTypesVerifiedByVisa;
    'UPI'?: PayerAuthConfigCardTypesVerifiedByVisa;
    'CB'?: PayerAuthConfigCardTypesCB;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "verifiedByVisa",
            "baseName": "verifiedByVisa",
            "type": "PayerAuthConfigCardTypesVerifiedByVisa"
        },
        {
            "name": "masterCardSecureCode",
            "baseName": "masterCardSecureCode",
            "type": "PayerAuthConfigCardTypesVerifiedByVisa"
        },
        {
            "name": "amexSafeKey",
            "baseName": "amexSafeKey",
            "type": "PayerAuthConfigCardTypesVerifiedByVisa"
        },
        {
            "name": "jCBJSecure",
            "baseName": "jCBJSecure",
            "type": "PayerAuthConfigCardTypesJCBJSecure"
        },
        {
            "name": "dinersClubInternationalProtectBuy",
            "baseName": "dinersClubInternationalProtectBuy",
            "type": "PayerAuthConfigCardTypesVerifiedByVisa"
        },
        {
            "name": "ELO",
            "baseName": "ELO",
            "type": "PayerAuthConfigCardTypesVerifiedByVisa"
        },
        {
            "name": "UPI",
            "baseName": "UPI",
            "type": "PayerAuthConfigCardTypesVerifiedByVisa"
        },
        {
            "name": "CB",
            "baseName": "CB",
            "type": "PayerAuthConfigCardTypesCB"
        }    ];

    static getAttributeTypeMap() {
        return PayerAuthConfigCardTypes.attributeTypeMap;
    }
}

export class PayerAuthConfigCardTypesCB {
    /**
    * The value is for 3DS2.0 and is a Directory Server assigned 3DS Requestor ID value. If this field is passed in request, it will override Requestor Id value that is configured on the Merchant's profile.
    */
    'requestorId'?: string;
    'enabled'?: boolean;
    'currencies'?: Array<PayerAuthConfigCardTypesVerifiedByVisaCurrencies>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "requestorId",
            "baseName": "requestorId",
            "type": "string"
        },
        {
            "name": "enabled",
            "baseName": "enabled",
            "type": "boolean"
        },
        {
            "name": "currencies",
            "baseName": "currencies",
            "type": "Array<PayerAuthConfigCardTypesVerifiedByVisaCurrencies>"
        }    ];

    static getAttributeTypeMap() {
        return PayerAuthConfigCardTypesCB.attributeTypeMap;
    }
}

export class PayerAuthConfigCardTypesJCBJSecure {
    /**
    * JSecure currency password for Japan Credit Bureau
    */
    'securePasswordForJCB'?: string;
    'enabled'?: boolean;
    'currencies'?: Array<PayerAuthConfigCardTypesVerifiedByVisaCurrencies>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "securePasswordForJCB",
            "baseName": "securePasswordForJCB",
            "type": "string"
        },
        {
            "name": "enabled",
            "baseName": "enabled",
            "type": "boolean"
        },
        {
            "name": "currencies",
            "baseName": "currencies",
            "type": "Array<PayerAuthConfigCardTypesVerifiedByVisaCurrencies>"
        }    ];

    static getAttributeTypeMap() {
        return PayerAuthConfigCardTypesJCBJSecure.attributeTypeMap;
    }
}

export class PayerAuthConfigCardTypesVerifiedByVisa {
    'enabled'?: boolean;
    'currencies'?: Array<PayerAuthConfigCardTypesVerifiedByVisaCurrencies>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "enabled",
            "baseName": "enabled",
            "type": "boolean"
        },
        {
            "name": "currencies",
            "baseName": "currencies",
            "type": "Array<PayerAuthConfigCardTypesVerifiedByVisaCurrencies>"
        }    ];

    static getAttributeTypeMap() {
        return PayerAuthConfigCardTypesVerifiedByVisa.attributeTypeMap;
    }
}

export class PayerAuthConfigCardTypesVerifiedByVisaCurrencies {
    /**
    * Supported currency codes are numeric ISO 4217 codes, such as 840 for US Dollar and 978 for Euro.  For backward compatibility, we also support the 'ALL' code, which represents all currencies.  In the UI, 'ALL' is displayed as 'Default'. 
    */
    'currencyCodes'?: Array<string>;
    /**
    * The Acquirer ID value, often referred to as the Acquirer BIN, is specific to an Acquirer. The value is created by Cardinal in their system and the Acquirer may not know that the Acquirer ID is different from their Acquiring BIN. It is most often the Acquiring BIN + \"-1000\" but the trailing character can be different. **Note** We will need to double check with Cardinal before setting up the Portfolio Template in production. 
    */
    'acquirerId'?: string;
    /**
    * Processor Merchant ID is the Merchant ID assigned by your acquiring bank. This Merchant ID should also be used by your bank to register your account to the card scheme Directory Server for processing Payer Authentication services. 
    */
    'processorMerchantId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "currencyCodes",
            "baseName": "currencyCodes",
            "type": "Array<string>"
        },
        {
            "name": "acquirerId",
            "baseName": "acquirerId",
            "type": "string"
        },
        {
            "name": "processorMerchantId",
            "baseName": "processorMerchantId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PayerAuthConfigCardTypesVerifiedByVisaCurrencies.attributeTypeMap;
    }
}

export class PayerAuthSetupRequest {
    'clientReferenceInformation'?: Riskv1authenticationsetupsClientReferenceInformation;
    'paymentInformation'?: Riskv1authenticationsetupsPaymentInformation;
    'processingInformation'?: Riskv1authenticationsetupsProcessingInformation;
    'tokenInformation'?: Riskv1authenticationsetupsTokenInformation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "clientReferenceInformation",
            "baseName": "clientReferenceInformation",
            "type": "Riskv1authenticationsetupsClientReferenceInformation"
        },
        {
            "name": "paymentInformation",
            "baseName": "paymentInformation",
            "type": "Riskv1authenticationsetupsPaymentInformation"
        },
        {
            "name": "processingInformation",
            "baseName": "processingInformation",
            "type": "Riskv1authenticationsetupsProcessingInformation"
        },
        {
            "name": "tokenInformation",
            "baseName": "tokenInformation",
            "type": "Riskv1authenticationsetupsTokenInformation"
        }    ];

    static getAttributeTypeMap() {
        return PayerAuthSetupRequest.attributeTypeMap;
    }
}

export class PaymentInstrumentList {
    'links'?: PaymentInstrumentListLinks;
    /**
    * The offset parameter supplied in the request.
    */
    'offset'?: number;
    /**
    * The limit parameter supplied in the request.
    */
    'limit'?: number;
    /**
    * The number of Payment Instruments returned in the array.
    */
    'count'?: number;
    /**
    * The total number of Payment Instruments associated with the Customer or Instrument Identifier.
    */
    'total'?: number;
    'embedded'?: PaymentInstrumentListEmbedded;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "PaymentInstrumentListLinks"
        },
        {
            "name": "offset",
            "baseName": "offset",
            "type": "number"
        },
        {
            "name": "limit",
            "baseName": "limit",
            "type": "number"
        },
        {
            "name": "count",
            "baseName": "count",
            "type": "number"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "number"
        },
        {
            "name": "embedded",
            "baseName": "_embedded",
            "type": "PaymentInstrumentListEmbedded"
        }    ];

    static getAttributeTypeMap() {
        return PaymentInstrumentList.attributeTypeMap;
    }
}

export class PaymentInstrumentList1 {
    'links'?: PaymentInstrumentListLinks;
    /**
    * The offset parameter supplied in the request.
    */
    'offset'?: number;
    /**
    * The limit parameter supplied in the request.
    */
    'limit'?: number;
    /**
    * The number of Payment Instruments returned in the array.
    */
    'count'?: number;
    /**
    * The total number of Payment Instruments associated with the Customer or Instrument Identifier.
    */
    'total'?: number;
    'embedded'?: PaymentInstrumentList1Embedded;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "PaymentInstrumentListLinks"
        },
        {
            "name": "offset",
            "baseName": "offset",
            "type": "number"
        },
        {
            "name": "limit",
            "baseName": "limit",
            "type": "number"
        },
        {
            "name": "count",
            "baseName": "count",
            "type": "number"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "number"
        },
        {
            "name": "embedded",
            "baseName": "_embedded",
            "type": "PaymentInstrumentList1Embedded"
        }    ];

    static getAttributeTypeMap() {
        return PaymentInstrumentList1.attributeTypeMap;
    }
}

/**
* Payment Instrument Resources. 
*/
export class PaymentInstrumentList1Embedded {
    'paymentInstruments'?: Array<PaymentInstrumentList1EmbeddedPaymentInstruments>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "paymentInstruments",
            "baseName": "paymentInstruments",
            "type": "Array<PaymentInstrumentList1EmbeddedPaymentInstruments>"
        }    ];

    static getAttributeTypeMap() {
        return PaymentInstrumentList1Embedded.attributeTypeMap;
    }
}

/**
* Additional resources for the Payment Instrument. 
*/
export class PaymentInstrumentList1EmbeddedEmbedded {
    'instrumentIdentifier'?: PatchInstrumentIdentifierRequest;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "instrumentIdentifier",
            "baseName": "instrumentIdentifier",
            "type": "PatchInstrumentIdentifierRequest"
        }    ];

    static getAttributeTypeMap() {
        return PaymentInstrumentList1EmbeddedEmbedded.attributeTypeMap;
    }
}

export class PaymentInstrumentList1EmbeddedPaymentInstruments {
    'links'?: Tmsv2customersEmbeddedDefaultPaymentInstrumentLinks;
    /**
    * The Id of the Payment Instrument Token.
    */
    'id'?: string;
    /**
    * The type.  Possible Values: - paymentInstrument 
    */
    'object'?: string;
    /**
    * Flag that indicates whether customer payment instrument is the dafault. Possible Values:  - `true`: Payment instrument is customer's default.  - `false`: Payment instrument is not customer's default. 
    */
    '_default'?: boolean;
    /**
    * Issuers state for the card number. Possible Values: - ACTIVE - CLOSED : The account has been closed. 
    */
    'state'?: string;
    /**
    * The type of Payment Instrument. Possible Values: - cardHash 
    */
    'type'?: string;
    'bankAccount'?: Tmsv2customersEmbeddedDefaultPaymentInstrumentBankAccount;
    'card'?: Tmsv2customersEmbeddedDefaultPaymentInstrumentCard;
    'buyerInformation'?: Tmsv2customersEmbeddedDefaultPaymentInstrumentBuyerInformation;
    'billTo'?: Tmsv2customersEmbeddedDefaultPaymentInstrumentBillTo;
    'processingInformation'?: TmsPaymentInstrumentProcessingInfo;
    'merchantInformation'?: Tmsv2customersEmbeddedDefaultPaymentInstrumentMerchantInformation;
    'instrumentIdentifier'?: Tmsv2customersEmbeddedDefaultPaymentInstrumentInstrumentIdentifier;
    'metadata'?: Tmsv2customersEmbeddedDefaultPaymentInstrumentMetadata;
    'embedded'?: PaymentInstrumentList1EmbeddedEmbedded;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "Tmsv2customersEmbeddedDefaultPaymentInstrumentLinks"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "object",
            "baseName": "object",
            "type": "string"
        },
        {
            "name": "_default",
            "baseName": "default",
            "type": "boolean"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "bankAccount",
            "baseName": "bankAccount",
            "type": "Tmsv2customersEmbeddedDefaultPaymentInstrumentBankAccount"
        },
        {
            "name": "card",
            "baseName": "card",
            "type": "Tmsv2customersEmbeddedDefaultPaymentInstrumentCard"
        },
        {
            "name": "buyerInformation",
            "baseName": "buyerInformation",
            "type": "Tmsv2customersEmbeddedDefaultPaymentInstrumentBuyerInformation"
        },
        {
            "name": "billTo",
            "baseName": "billTo",
            "type": "Tmsv2customersEmbeddedDefaultPaymentInstrumentBillTo"
        },
        {
            "name": "processingInformation",
            "baseName": "processingInformation",
            "type": "TmsPaymentInstrumentProcessingInfo"
        },
        {
            "name": "merchantInformation",
            "baseName": "merchantInformation",
            "type": "Tmsv2customersEmbeddedDefaultPaymentInstrumentMerchantInformation"
        },
        {
            "name": "instrumentIdentifier",
            "baseName": "instrumentIdentifier",
            "type": "Tmsv2customersEmbeddedDefaultPaymentInstrumentInstrumentIdentifier"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "Tmsv2customersEmbeddedDefaultPaymentInstrumentMetadata"
        },
        {
            "name": "embedded",
            "baseName": "_embedded",
            "type": "PaymentInstrumentList1EmbeddedEmbedded"
        }    ];

    static getAttributeTypeMap() {
        return PaymentInstrumentList1EmbeddedPaymentInstruments.attributeTypeMap;
    }
}

/**
* Payment Instrument Resources. 
*/
export class PaymentInstrumentListEmbedded {
    'paymentInstruments'?: Array<Tmsv2customersEmbeddedDefaultPaymentInstrument>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "paymentInstruments",
            "baseName": "paymentInstruments",
            "type": "Array<Tmsv2customersEmbeddedDefaultPaymentInstrument>"
        }    ];

    static getAttributeTypeMap() {
        return PaymentInstrumentListEmbedded.attributeTypeMap;
    }
}

export class PaymentInstrumentListLinks {
    'self'?: PaymentInstrumentListLinksSelf;
    'first'?: PaymentInstrumentListLinksFirst;
    'prev'?: PaymentInstrumentListLinksPrev;
    'next'?: PaymentInstrumentListLinksNext;
    'last'?: PaymentInstrumentListLinksLast;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "self",
            "baseName": "self",
            "type": "PaymentInstrumentListLinksSelf"
        },
        {
            "name": "first",
            "baseName": "first",
            "type": "PaymentInstrumentListLinksFirst"
        },
        {
            "name": "prev",
            "baseName": "prev",
            "type": "PaymentInstrumentListLinksPrev"
        },
        {
            "name": "next",
            "baseName": "next",
            "type": "PaymentInstrumentListLinksNext"
        },
        {
            "name": "last",
            "baseName": "last",
            "type": "PaymentInstrumentListLinksLast"
        }    ];

    static getAttributeTypeMap() {
        return PaymentInstrumentListLinks.attributeTypeMap;
    }
}

export class PaymentInstrumentListLinksFirst {
    /**
    * Link to the first page. 
    */
    'href'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "href",
            "baseName": "href",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PaymentInstrumentListLinksFirst.attributeTypeMap;
    }
}

export class PaymentInstrumentListLinksLast {
    /**
    * Link to the last page. 
    */
    'href'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "href",
            "baseName": "href",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PaymentInstrumentListLinksLast.attributeTypeMap;
    }
}

export class PaymentInstrumentListLinksNext {
    /**
    * Link to the next page. 
    */
    'href'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "href",
            "baseName": "href",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PaymentInstrumentListLinksNext.attributeTypeMap;
    }
}

export class PaymentInstrumentListLinksPrev {
    /**
    * Link to the previous page. 
    */
    'href'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "href",
            "baseName": "href",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PaymentInstrumentListLinksPrev.attributeTypeMap;
    }
}

export class PaymentInstrumentListLinksSelf {
    /**
    * Link to the current page. 
    */
    'href'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "href",
            "baseName": "href",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PaymentInstrumentListLinksSelf.attributeTypeMap;
    }
}

export class PaymentsProducts {
    'cardProcessing'?: PaymentsProductsCardProcessing;
    'alternativePaymentMethods'?: PaymentsProductsAlternativePaymentMethods;
    'cardPresentConnect'?: PaymentsProductsCardPresentConnect;
    'cybsReadyTerminal'?: PaymentsProductsCybsReadyTerminal;
    'eCheck'?: PaymentsProductsECheck;
    'payerAuthentication'?: PaymentsProductsPayerAuthentication;
    'digitalPayments'?: PaymentsProductsDigitalPayments;
    'secureAcceptance'?: PaymentsProductsSecureAcceptance;
    'virtualTerminal'?: PaymentsProductsVirtualTerminal;
    'currencyConversion'?: PaymentsProductsCurrencyConversion;
    'tax'?: PaymentsProductsTax;
    'customerInvoicing'?: PaymentsProductsTax;
    'recurringBilling'?: PaymentsProductsTax;
    'paymentOrchestration'?: PaymentsProductsTax;
    'payouts'?: PaymentsProductsPayouts;
    'differentialFee'?: PaymentsProductsDifferentialFee;
    'payByLink'?: PaymentsProductsTax;
    'unifiedCheckout'?: PaymentsProductsUnifiedCheckout;
    'receivablesManager'?: PaymentsProductsTax;
    'serviceFee'?: PaymentsProductsServiceFee;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "cardProcessing",
            "baseName": "cardProcessing",
            "type": "PaymentsProductsCardProcessing"
        },
        {
            "name": "alternativePaymentMethods",
            "baseName": "alternativePaymentMethods",
            "type": "PaymentsProductsAlternativePaymentMethods"
        },
        {
            "name": "cardPresentConnect",
            "baseName": "cardPresentConnect",
            "type": "PaymentsProductsCardPresentConnect"
        },
        {
            "name": "cybsReadyTerminal",
            "baseName": "cybsReadyTerminal",
            "type": "PaymentsProductsCybsReadyTerminal"
        },
        {
            "name": "eCheck",
            "baseName": "eCheck",
            "type": "PaymentsProductsECheck"
        },
        {
            "name": "payerAuthentication",
            "baseName": "payerAuthentication",
            "type": "PaymentsProductsPayerAuthentication"
        },
        {
            "name": "digitalPayments",
            "baseName": "digitalPayments",
            "type": "PaymentsProductsDigitalPayments"
        },
        {
            "name": "secureAcceptance",
            "baseName": "secureAcceptance",
            "type": "PaymentsProductsSecureAcceptance"
        },
        {
            "name": "virtualTerminal",
            "baseName": "virtualTerminal",
            "type": "PaymentsProductsVirtualTerminal"
        },
        {
            "name": "currencyConversion",
            "baseName": "currencyConversion",
            "type": "PaymentsProductsCurrencyConversion"
        },
        {
            "name": "tax",
            "baseName": "tax",
            "type": "PaymentsProductsTax"
        },
        {
            "name": "customerInvoicing",
            "baseName": "customerInvoicing",
            "type": "PaymentsProductsTax"
        },
        {
            "name": "recurringBilling",
            "baseName": "recurringBilling",
            "type": "PaymentsProductsTax"
        },
        {
            "name": "paymentOrchestration",
            "baseName": "paymentOrchestration",
            "type": "PaymentsProductsTax"
        },
        {
            "name": "payouts",
            "baseName": "payouts",
            "type": "PaymentsProductsPayouts"
        },
        {
            "name": "differentialFee",
            "baseName": "differentialFee",
            "type": "PaymentsProductsDifferentialFee"
        },
        {
            "name": "payByLink",
            "baseName": "payByLink",
            "type": "PaymentsProductsTax"
        },
        {
            "name": "unifiedCheckout",
            "baseName": "unifiedCheckout",
            "type": "PaymentsProductsUnifiedCheckout"
        },
        {
            "name": "receivablesManager",
            "baseName": "receivablesManager",
            "type": "PaymentsProductsTax"
        },
        {
            "name": "serviceFee",
            "baseName": "serviceFee",
            "type": "PaymentsProductsServiceFee"
        }    ];

    static getAttributeTypeMap() {
        return PaymentsProducts.attributeTypeMap;
    }
}

export class PaymentsProductsAlternativePaymentMethods {
    'subscriptionInformation'?: PaymentsProductsAlternativePaymentMethodsSubscriptionInformation;
    'configurationInformation'?: PaymentsProductsAlternativePaymentMethodsConfigurationInformation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "subscriptionInformation",
            "baseName": "subscriptionInformation",
            "type": "PaymentsProductsAlternativePaymentMethodsSubscriptionInformation"
        },
        {
            "name": "configurationInformation",
            "baseName": "configurationInformation",
            "type": "PaymentsProductsAlternativePaymentMethodsConfigurationInformation"
        }    ];

    static getAttributeTypeMap() {
        return PaymentsProductsAlternativePaymentMethods.attributeTypeMap;
    }
}

export class PaymentsProductsAlternativePaymentMethodsConfigurationInformation {
    'configurations'?: PaymentsProductsAlternativePaymentMethodsConfigurationInformationConfigurations;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "configurations",
            "baseName": "configurations",
            "type": "PaymentsProductsAlternativePaymentMethodsConfigurationInformationConfigurations"
        }    ];

    static getAttributeTypeMap() {
        return PaymentsProductsAlternativePaymentMethodsConfigurationInformation.attributeTypeMap;
    }
}

export class PaymentsProductsAlternativePaymentMethodsConfigurationInformationConfigurations {
    /**
    * Merchant Category Code (MCC) is a four-digit number assigned to a business by credit card companies when the business first starts accepting credit cards as a form of payment. The MCC is used to classify the business by the type of goods or services it provides. 
    */
    'merchantCategoryCode'?: string;
    /**
    * This is a map. The allowed keys are below. Value should be an object containing a sole boolean property - enabled. <table>   <tr>     <td>klarna</td>   </tr>   <tr>     <td>payPal</td>   </tr>   <tr>     <td>alipay</td>   </tr>   <tr>     <td>bancontact</td>   </tr>   <tr>     <td>giropay</td>   </tr>   <tr>     <td>ideal</td>   </tr> </table> 
    */
    'processors'?: { [key: string]: PaymentsProductsAlternativePaymentMethodsConfigurationInformationConfigurationsProcessors; };

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "merchantCategoryCode",
            "baseName": "merchantCategoryCode",
            "type": "string"
        },
        {
            "name": "processors",
            "baseName": "processors",
            "type": "{ [key: string]: PaymentsProductsAlternativePaymentMethodsConfigurationInformationConfigurationsProcessors; }"
        }    ];

    static getAttributeTypeMap() {
        return PaymentsProductsAlternativePaymentMethodsConfigurationInformationConfigurations.attributeTypeMap;
    }
}

/**
* Additional configuration for the payment method. 
*/
export class PaymentsProductsAlternativePaymentMethodsConfigurationInformationConfigurationsAdditionalConfigurations {
    /**
    * Key for the additional configuration. This is used to identify the specific setting. example: serviceProviderId 
    */
    'key'?: string;
    /**
    * Value for the additional configuration. This is the actual setting being configured. example: svcId 
    */
    'value'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "key",
            "baseName": "key",
            "type": "string"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PaymentsProductsAlternativePaymentMethodsConfigurationInformationConfigurationsAdditionalConfigurations.attributeTypeMap;
    }
}

/**
* Payment method configuration for the product. 
*/
export class PaymentsProductsAlternativePaymentMethodsConfigurationInformationConfigurationsPaymentMethods {
    /**
    * Merchant ID for the payment method. This is a unique identifier for the merchant. example. mid12345678 
    */
    'merchantId'?: string;
    /**
    * URL of the logo for the payment method. This is used for branding purposes. example: http://www.test.com 
    */
    'logoUrl'?: string;
    /**
    * URL to redirect to after a successful transaction. This is where the user will be sent after completing the payment. example: http://www.test.com/success 
    */
    'redirectSuccessUrl'?: string;
    /**
    * URL to redirect to if the user cancels the transaction. This is where the user will be sent if they choose to cancel the payment. example: http://www.test.com/cancel 
    */
    'redirectCancelUrl'?: string;
    /**
    * URL to redirect to if the transaction fails. This is where the user will be sent if there is an error during the payment process. example: http://www.test.com/failure 
    */
    'redirectFailureUrl'?: string;
    /**
    * Additional configurations for the payment method. This can include various settings specific to the payment method. 
    */
    'additionalConfigurations'?: Array<PaymentsProductsAlternativePaymentMethodsConfigurationInformationConfigurationsAdditionalConfigurations>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "merchantId",
            "baseName": "merchantId",
            "type": "string"
        },
        {
            "name": "logoUrl",
            "baseName": "logoUrl",
            "type": "string"
        },
        {
            "name": "redirectSuccessUrl",
            "baseName": "redirectSuccessUrl",
            "type": "string"
        },
        {
            "name": "redirectCancelUrl",
            "baseName": "redirectCancelUrl",
            "type": "string"
        },
        {
            "name": "redirectFailureUrl",
            "baseName": "redirectFailureUrl",
            "type": "string"
        },
        {
            "name": "additionalConfigurations",
            "baseName": "additionalConfigurations",
            "type": "Array<PaymentsProductsAlternativePaymentMethodsConfigurationInformationConfigurationsAdditionalConfigurations>"
        }    ];

    static getAttributeTypeMap() {
        return PaymentsProductsAlternativePaymentMethodsConfigurationInformationConfigurationsPaymentMethods.attributeTypeMap;
    }
}

/**
* Processor configuration for the product. 
*/
export class PaymentsProductsAlternativePaymentMethodsConfigurationInformationConfigurationsProcessors {
    /**
    * Payment methods supported by the processor. The following values are supported: - klarna - CREDIT_CARD - DEBIT_CARD 
    */
    'paymentMethods'?: { [key: string]: PaymentsProductsAlternativePaymentMethodsConfigurationInformationConfigurationsPaymentMethods; };

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "paymentMethods",
            "baseName": "paymentMethods",
            "type": "{ [key: string]: PaymentsProductsAlternativePaymentMethodsConfigurationInformationConfigurationsPaymentMethods; }"
        }    ];

    static getAttributeTypeMap() {
        return PaymentsProductsAlternativePaymentMethodsConfigurationInformationConfigurationsProcessors.attributeTypeMap;
    }
}

export class PaymentsProductsAlternativePaymentMethodsSubscriptionInformation {
    'enabled'?: boolean;
    /**
    * Indicates if the organization can enable this product using self service.
    */
    'selfServiceability'?: PaymentsProductsAlternativePaymentMethodsSubscriptionInformation.SelfServiceabilityEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "enabled",
            "baseName": "enabled",
            "type": "boolean"
        },
        {
            "name": "selfServiceability",
            "baseName": "selfServiceability",
            "type": "PaymentsProductsAlternativePaymentMethodsSubscriptionInformation.SelfServiceabilityEnum"
        }    ];

    static getAttributeTypeMap() {
        return PaymentsProductsAlternativePaymentMethodsSubscriptionInformation.attributeTypeMap;
    }
}

export namespace PaymentsProductsAlternativePaymentMethodsSubscriptionInformation {
    export enum SelfServiceabilityEnum {
        SELFSERVICEABLE = <any> 'SELF_SERVICEABLE',
        NOTSELFSERVICEABLE = <any> 'NOT_SELF_SERVICEABLE',
        SELFSERVICEONLY = <any> 'SELF_SERVICE_ONLY'
    }
}
export class PaymentsProductsCardPresentConnect {
    'subscriptionInformation'?: PaymentsProductsCardPresentConnectSubscriptionInformation;
    'configurationInformation'?: PaymentsProductsCardPresentConnectConfigurationInformation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "subscriptionInformation",
            "baseName": "subscriptionInformation",
            "type": "PaymentsProductsCardPresentConnectSubscriptionInformation"
        },
        {
            "name": "configurationInformation",
            "baseName": "configurationInformation",
            "type": "PaymentsProductsCardPresentConnectConfigurationInformation"
        }    ];

    static getAttributeTypeMap() {
        return PaymentsProductsCardPresentConnect.attributeTypeMap;
    }
}

export class PaymentsProductsCardPresentConnectConfigurationInformation {
    'templateId'?: string;
    'configurations'?: PaymentsProductsCardPresentConnectConfigurationInformationConfigurations;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "templateId",
            "baseName": "templateId",
            "type": "string"
        },
        {
            "name": "configurations",
            "baseName": "configurations",
            "type": "PaymentsProductsCardPresentConnectConfigurationInformationConfigurations"
        }    ];

    static getAttributeTypeMap() {
        return PaymentsProductsCardPresentConnectConfigurationInformation.attributeTypeMap;
    }
}

export class PaymentsProductsCardPresentConnectConfigurationInformationConfigurations {
    /**
    * Solution identifier used to associate a partner organization with the Merchant that is on-boarded.
    */
    'partnerSolutionIdentifier'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "partnerSolutionIdentifier",
            "baseName": "partnerSolutionIdentifier",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PaymentsProductsCardPresentConnectConfigurationInformationConfigurations.attributeTypeMap;
    }
}

export class PaymentsProductsCardPresentConnectSubscriptionInformation {
    'enabled'?: boolean;
    /**
    * Indicates if the organization can enable this product using self service.
    */
    'selfServiceability'?: PaymentsProductsCardPresentConnectSubscriptionInformation.SelfServiceabilityEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "enabled",
            "baseName": "enabled",
            "type": "boolean"
        },
        {
            "name": "selfServiceability",
            "baseName": "selfServiceability",
            "type": "PaymentsProductsCardPresentConnectSubscriptionInformation.SelfServiceabilityEnum"
        }    ];

    static getAttributeTypeMap() {
        return PaymentsProductsCardPresentConnectSubscriptionInformation.attributeTypeMap;
    }
}

export namespace PaymentsProductsCardPresentConnectSubscriptionInformation {
    export enum SelfServiceabilityEnum {
        NOTSELFSERVICEABLE = <any> 'NOT_SELF_SERVICEABLE'
    }
}
export class PaymentsProductsCardProcessing {
    'subscriptionInformation'?: PaymentsProductsCardProcessingSubscriptionInformation;
    'configurationInformation'?: PaymentsProductsCardProcessingConfigurationInformation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "subscriptionInformation",
            "baseName": "subscriptionInformation",
            "type": "PaymentsProductsCardProcessingSubscriptionInformation"
        },
        {
            "name": "configurationInformation",
            "baseName": "configurationInformation",
            "type": "PaymentsProductsCardProcessingConfigurationInformation"
        }    ];

    static getAttributeTypeMap() {
        return PaymentsProductsCardProcessing.attributeTypeMap;
    }
}

export class PaymentsProductsCardProcessingConfigurationInformation {
    'templateId'?: string;
    'configurations'?: CardProcessingConfig;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "templateId",
            "baseName": "templateId",
            "type": "string"
        },
        {
            "name": "configurations",
            "baseName": "configurations",
            "type": "CardProcessingConfig"
        }    ];

    static getAttributeTypeMap() {
        return PaymentsProductsCardProcessingConfigurationInformation.attributeTypeMap;
    }
}

export class PaymentsProductsCardProcessingSubscriptionInformation {
    'enabled'?: boolean;
    /**
    * Indicates if the organization can enable this product using self service.
    */
    'selfServiceability'?: PaymentsProductsCardProcessingSubscriptionInformation.SelfServiceabilityEnum;
    /**
    * This is a map. The allowed keys are below. Value should be an object containing a sole boolean property - enabled. <table>    <tr>       <td>cardPresent</td>    </tr>    <tr>       <td>cardNotPresent</td>    </tr> </table> 
    */
    'features'?: { [key: string]: PaymentsProductsCardProcessingSubscriptionInformationFeatures; };

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "enabled",
            "baseName": "enabled",
            "type": "boolean"
        },
        {
            "name": "selfServiceability",
            "baseName": "selfServiceability",
            "type": "PaymentsProductsCardProcessingSubscriptionInformation.SelfServiceabilityEnum"
        },
        {
            "name": "features",
            "baseName": "features",
            "type": "{ [key: string]: PaymentsProductsCardProcessingSubscriptionInformationFeatures; }"
        }    ];

    static getAttributeTypeMap() {
        return PaymentsProductsCardProcessingSubscriptionInformation.attributeTypeMap;
    }
}

export namespace PaymentsProductsCardProcessingSubscriptionInformation {
    export enum SelfServiceabilityEnum {
        SELFSERVICEABLE = <any> 'SELF_SERVICEABLE',
        NOTSELFSERVICEABLE = <any> 'NOT_SELF_SERVICEABLE',
        SELFSERVICEONLY = <any> 'SELF_SERVICE_ONLY'
    }
}
export class PaymentsProductsCardProcessingSubscriptionInformationFeatures {
    'enabled'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "enabled",
            "baseName": "enabled",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return PaymentsProductsCardProcessingSubscriptionInformationFeatures.attributeTypeMap;
    }
}

export class PaymentsProductsCurrencyConversion {
    'subscriptionInformation'?: PaymentsProductsAlternativePaymentMethodsSubscriptionInformation;
    'configurationInformation'?: PaymentsProductsCurrencyConversionConfigurationInformation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "subscriptionInformation",
            "baseName": "subscriptionInformation",
            "type": "PaymentsProductsAlternativePaymentMethodsSubscriptionInformation"
        },
        {
            "name": "configurationInformation",
            "baseName": "configurationInformation",
            "type": "PaymentsProductsCurrencyConversionConfigurationInformation"
        }    ];

    static getAttributeTypeMap() {
        return PaymentsProductsCurrencyConversion.attributeTypeMap;
    }
}

export class PaymentsProductsCurrencyConversionConfigurationInformation {
    'templateId'?: string;
    'configurations'?: PaymentsProductsCurrencyConversionConfigurationInformationConfigurations;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "templateId",
            "baseName": "templateId",
            "type": "string"
        },
        {
            "name": "configurations",
            "baseName": "configurations",
            "type": "PaymentsProductsCurrencyConversionConfigurationInformationConfigurations"
        }    ];

    static getAttributeTypeMap() {
        return PaymentsProductsCurrencyConversionConfigurationInformation.attributeTypeMap;
    }
}

export class PaymentsProductsCurrencyConversionConfigurationInformationConfigurations {
    'processors'?: { [key: string]: PaymentsProductsCurrencyConversionConfigurationInformationConfigurationsProcessors; };

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "processors",
            "baseName": "processors",
            "type": "{ [key: string]: PaymentsProductsCurrencyConversionConfigurationInformationConfigurationsProcessors; }"
        }    ];

    static getAttributeTypeMap() {
        return PaymentsProductsCurrencyConversionConfigurationInformationConfigurations.attributeTypeMap;
    }
}

export class PaymentsProductsCurrencyConversionConfigurationInformationConfigurationsProcessors {
    /**
    * The merchant identifier for the Currency Conversion service. Check with your Currency Conversion Provider for details.
    */
    'merchantId'?: string;
    'acquirerId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "merchantId",
            "baseName": "merchantId",
            "type": "string"
        },
        {
            "name": "acquirerId",
            "baseName": "acquirerId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PaymentsProductsCurrencyConversionConfigurationInformationConfigurationsProcessors.attributeTypeMap;
    }
}

export class PaymentsProductsCybsReadyTerminal {
    'subscriptionInformation'?: PaymentsProductsCardPresentConnectSubscriptionInformation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "subscriptionInformation",
            "baseName": "subscriptionInformation",
            "type": "PaymentsProductsCardPresentConnectSubscriptionInformation"
        }    ];

    static getAttributeTypeMap() {
        return PaymentsProductsCybsReadyTerminal.attributeTypeMap;
    }
}

export class PaymentsProductsDifferentialFee {
    'subscriptionInformation'?: PaymentsProductsDifferentialFeeSubscriptionInformation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "subscriptionInformation",
            "baseName": "subscriptionInformation",
            "type": "PaymentsProductsDifferentialFeeSubscriptionInformation"
        }    ];

    static getAttributeTypeMap() {
        return PaymentsProductsDifferentialFee.attributeTypeMap;
    }
}

export class PaymentsProductsDifferentialFeeSubscriptionInformation {
    'enabled'?: boolean;
    /**
    * Indicates if the organization can enable this product using self service.
    */
    'selfServiceability'?: PaymentsProductsDifferentialFeeSubscriptionInformation.SelfServiceabilityEnum;
    'features'?: PaymentsProductsDifferentialFeeSubscriptionInformationFeatures;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "enabled",
            "baseName": "enabled",
            "type": "boolean"
        },
        {
            "name": "selfServiceability",
            "baseName": "selfServiceability",
            "type": "PaymentsProductsDifferentialFeeSubscriptionInformation.SelfServiceabilityEnum"
        },
        {
            "name": "features",
            "baseName": "features",
            "type": "PaymentsProductsDifferentialFeeSubscriptionInformationFeatures"
        }    ];

    static getAttributeTypeMap() {
        return PaymentsProductsDifferentialFeeSubscriptionInformation.attributeTypeMap;
    }
}

export namespace PaymentsProductsDifferentialFeeSubscriptionInformation {
    export enum SelfServiceabilityEnum {
        SELFSERVICEABLE = <any> 'SELF_SERVICEABLE',
        NOTSELFSERVICEABLE = <any> 'NOT_SELF_SERVICEABLE',
        SELFSERVICEONLY = <any> 'SELF_SERVICE_ONLY'
    }
}
export class PaymentsProductsDifferentialFeeSubscriptionInformationFeatures {
    'surcharge'?: PaymentsProductsDifferentialFeeSubscriptionInformationFeaturesSurcharge;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "surcharge",
            "baseName": "surcharge",
            "type": "PaymentsProductsDifferentialFeeSubscriptionInformationFeaturesSurcharge"
        }    ];

    static getAttributeTypeMap() {
        return PaymentsProductsDifferentialFeeSubscriptionInformationFeatures.attributeTypeMap;
    }
}

export class PaymentsProductsDifferentialFeeSubscriptionInformationFeaturesSurcharge {
    'enabled'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "enabled",
            "baseName": "enabled",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return PaymentsProductsDifferentialFeeSubscriptionInformationFeaturesSurcharge.attributeTypeMap;
    }
}

export class PaymentsProductsDigitalPayments {
    'subscriptionInformation'?: PaymentsProductsDigitalPaymentsSubscriptionInformation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "subscriptionInformation",
            "baseName": "subscriptionInformation",
            "type": "PaymentsProductsDigitalPaymentsSubscriptionInformation"
        }    ];

    static getAttributeTypeMap() {
        return PaymentsProductsDigitalPayments.attributeTypeMap;
    }
}

export class PaymentsProductsDigitalPaymentsSubscriptionInformation {
    'enabled'?: boolean;
    /**
    * Indicates if the organization can enable this product using self service.
    */
    'selfServiceability'?: PaymentsProductsDigitalPaymentsSubscriptionInformation.SelfServiceabilityEnum;
    /**
    * Allowed values are; <table>    <tr>       <td>visaCheckout</td>    </tr>    <tr>       <td>applePay</td>    </tr>    <tr>       <td>samsungPay</td>    </tr>    <tr>        <td>googlePay</td>     </tr> </table> 
    */
    'features'?: { [key: string]: PaymentsProductsDigitalPaymentsSubscriptionInformationFeatures; };

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "enabled",
            "baseName": "enabled",
            "type": "boolean"
        },
        {
            "name": "selfServiceability",
            "baseName": "selfServiceability",
            "type": "PaymentsProductsDigitalPaymentsSubscriptionInformation.SelfServiceabilityEnum"
        },
        {
            "name": "features",
            "baseName": "features",
            "type": "{ [key: string]: PaymentsProductsDigitalPaymentsSubscriptionInformationFeatures; }"
        }    ];

    static getAttributeTypeMap() {
        return PaymentsProductsDigitalPaymentsSubscriptionInformation.attributeTypeMap;
    }
}

export namespace PaymentsProductsDigitalPaymentsSubscriptionInformation {
    export enum SelfServiceabilityEnum {
        SELFSERVICEABLE = <any> 'SELF_SERVICEABLE',
        NOTSELFSERVICEABLE = <any> 'NOT_SELF_SERVICEABLE',
        SELFSERVICEONLY = <any> 'SELF_SERVICE_ONLY'
    }
}
export class PaymentsProductsDigitalPaymentsSubscriptionInformationFeatures {
    'enabled'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "enabled",
            "baseName": "enabled",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return PaymentsProductsDigitalPaymentsSubscriptionInformationFeatures.attributeTypeMap;
    }
}

export class PaymentsProductsECheck {
    'subscriptionInformation'?: PaymentsProductsECheckSubscriptionInformation;
    'configurationInformation'?: PaymentsProductsECheckConfigurationInformation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "subscriptionInformation",
            "baseName": "subscriptionInformation",
            "type": "PaymentsProductsECheckSubscriptionInformation"
        },
        {
            "name": "configurationInformation",
            "baseName": "configurationInformation",
            "type": "PaymentsProductsECheckConfigurationInformation"
        }    ];

    static getAttributeTypeMap() {
        return PaymentsProductsECheck.attributeTypeMap;
    }
}

export class PaymentsProductsECheckConfigurationInformation {
    'templateId'?: string;
    'configurations'?: ECheckConfig;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "templateId",
            "baseName": "templateId",
            "type": "string"
        },
        {
            "name": "configurations",
            "baseName": "configurations",
            "type": "ECheckConfig"
        }    ];

    static getAttributeTypeMap() {
        return PaymentsProductsECheckConfigurationInformation.attributeTypeMap;
    }
}

export class PaymentsProductsECheckSubscriptionInformation {
    'enabled'?: boolean;
    /**
    * Indicates if the organization can enable this product using self service.
    */
    'selfServiceability'?: PaymentsProductsECheckSubscriptionInformation.SelfServiceabilityEnum;
    /**
    * Indicates what mode the product is expected to behave at boarding and transaction flows. Ex, Acquirer/Gateway/Other.
    */
    'mode'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "enabled",
            "baseName": "enabled",
            "type": "boolean"
        },
        {
            "name": "selfServiceability",
            "baseName": "selfServiceability",
            "type": "PaymentsProductsECheckSubscriptionInformation.SelfServiceabilityEnum"
        },
        {
            "name": "mode",
            "baseName": "mode",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return PaymentsProductsECheckSubscriptionInformation.attributeTypeMap;
    }
}

export namespace PaymentsProductsECheckSubscriptionInformation {
    export enum SelfServiceabilityEnum {
        SELFSERVICEABLE = <any> 'SELF_SERVICEABLE',
        NOTSELFSERVICEABLE = <any> 'NOT_SELF_SERVICEABLE',
        SELFSERVICEONLY = <any> 'SELF_SERVICE_ONLY'
    }
}
export class PaymentsProductsPayerAuthentication {
    'subscriptionInformation'?: PaymentsProductsAlternativePaymentMethodsSubscriptionInformation;
    'configurationInformation'?: PaymentsProductsPayerAuthenticationConfigurationInformation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "subscriptionInformation",
            "baseName": "subscriptionInformation",
            "type": "PaymentsProductsAlternativePaymentMethodsSubscriptionInformation"
        },
        {
            "name": "configurationInformation",
            "baseName": "configurationInformation",
            "type": "PaymentsProductsPayerAuthenticationConfigurationInformation"
        }    ];

    static getAttributeTypeMap() {
        return PaymentsProductsPayerAuthentication.attributeTypeMap;
    }
}

export class PaymentsProductsPayerAuthenticationConfigurationInformation {
    'templateId'?: string;
    'configurations'?: PayerAuthConfig;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "templateId",
            "baseName": "templateId",
            "type": "string"
        },
        {
            "name": "configurations",
            "baseName": "configurations",
            "type": "PayerAuthConfig"
        }    ];

    static getAttributeTypeMap() {
        return PaymentsProductsPayerAuthenticationConfigurationInformation.attributeTypeMap;
    }
}

export class PaymentsProductsPayouts {
    'subscriptionInformation'?: PaymentsProductsAlternativePaymentMethodsSubscriptionInformation;
    'configurationInformation'?: PaymentsProductsPayoutsConfigurationInformation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "subscriptionInformation",
            "baseName": "subscriptionInformation",
            "type": "PaymentsProductsAlternativePaymentMethodsSubscriptionInformation"
        },
        {
            "name": "configurationInformation",
            "baseName": "configurationInformation",
            "type": "PaymentsProductsPayoutsConfigurationInformation"
        }    ];

    static getAttributeTypeMap() {
        return PaymentsProductsPayouts.attributeTypeMap;
    }
}

export class PaymentsProductsPayoutsConfigurationInformation {
    'configurations'?: PaymentsProductsPayoutsConfigurationInformationConfigurations;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "configurations",
            "baseName": "configurations",
            "type": "PaymentsProductsPayoutsConfigurationInformationConfigurations"
        }    ];

    static getAttributeTypeMap() {
        return PaymentsProductsPayoutsConfigurationInformation.attributeTypeMap;
    }
}

export class PaymentsProductsPayoutsConfigurationInformationConfigurations {
    'pullfunds'?: { [key: string]: PaymentsProductsPayoutsConfigurationInformationConfigurationsPullfunds; };
    'pushfunds'?: { [key: string]: PaymentsProductsPayoutsConfigurationInformationConfigurationsPushfunds; };

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "pullfunds",
            "baseName": "pullfunds",
            "type": "{ [key: string]: PaymentsProductsPayoutsConfigurationInformationConfigurationsPullfunds; }"
        },
        {
            "name": "pushfunds",
            "baseName": "pushfunds",
            "type": "{ [key: string]: PaymentsProductsPayoutsConfigurationInformationConfigurationsPushfunds; }"
        }    ];

    static getAttributeTypeMap() {
        return PaymentsProductsPayoutsConfigurationInformationConfigurations.attributeTypeMap;
    }
}

export class PaymentsProductsPayoutsConfigurationInformationConfigurationsProcessorAccount {
    /**
    * TBD
    */
    'originatorMerchantId': string;
    /**
    * TBD
    */
    'originatorTerminalId': Array<string>;
    /**
    * Three-character [ISO Standard Currency Codes.](http://apps.cybersource.com/library/documentation/sbc/quickref/currencies.pdf)
    */
    'supportedCurrencies'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "originatorMerchantId",
            "baseName": "originatorMerchantId",
            "type": "string"
        },
        {
            "name": "originatorTerminalId",
            "baseName": "originatorTerminalId",
            "type": "Array<string>"
        },
        {
            "name": "supportedCurrencies",
            "baseName": "supportedCurrencies",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return PaymentsProductsPayoutsConfigurationInformationConfigurationsProcessorAccount.attributeTypeMap;
    }
}

/**
* Formatted as *{payoutsAcquirerName}. The property name field should be the same as the processor name for which the pull funds or push funds feature is being configured. Here is the list of valid processor names [TBD]
*/
export class PaymentsProductsPayoutsConfigurationInformationConfigurationsPullfunds {
    /**
    * Valid organization in OMS with an organizationInformation.type as \"acquirer\".
    */
    'acquirerOrganizationId'?: string;
    /**
    * This code identifies the financial institution acting as the acquirer of this transaction. The acquirer is the client or system user that signed the originator or installed the unattended cardholder- activated environment. When a processing center operates for multiple acquirers, this code is for the individual client or system user, not a code for the center.
    */
    'acquiringBIN': number;
    /**
    * This configuration allows a transaction to be flagged for cryptocurrency funds transfer.
    */
    'allowCryptoCurrencyPurchase'?: boolean;
    /**
    * A unique identifier number for the originator of transfers that is unique to the processor or acquirer.
    */
    'cardAcceptorId': string;
    /**
    * Merchant Verification Value (MVV) is used to identify originators that participate in a variety of programs. The MVV is unique to the merchant.
    */
    'originatorMvv'?: string;
    /**
    * A 4 character max name abbreviation for the originator.
    */
    'originatorNameAbbreviation'?: string;
    /**
    * This field contains a code that identifies a terminal at the card acceptor location. This field is used in all messages related to a transaction. If sending transactions from a card not present environment, use the same value for all transactions.
    */
    'cardTerminalId': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "acquirerOrganizationId",
            "baseName": "acquirerOrganizationId",
            "type": "string"
        },
        {
            "name": "acquiringBIN",
            "baseName": "acquiringBIN",
            "type": "number"
        },
        {
            "name": "allowCryptoCurrencyPurchase",
            "baseName": "allowCryptoCurrencyPurchase",
            "type": "boolean"
        },
        {
            "name": "cardAcceptorId",
            "baseName": "cardAcceptorId",
            "type": "string"
        },
        {
            "name": "originatorMvv",
            "baseName": "originatorMvv",
            "type": "string"
        },
        {
            "name": "originatorNameAbbreviation",
            "baseName": "originatorNameAbbreviation",
            "type": "string"
        },
        {
            "name": "cardTerminalId",
            "baseName": "cardTerminalId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PaymentsProductsPayoutsConfigurationInformationConfigurationsPullfunds.attributeTypeMap;
    }
}

/**
* Formatted as *{payoutsAcquirerName}. The property name field should be the same as the processor name for which the pull funds or push funds feature is being configured. Here is the list of valid processor names [TBD]
*/
export class PaymentsProductsPayoutsConfigurationInformationConfigurationsPushfunds {
    /**
    * TBD
    */
    'acquirerCountryCode': number;
    /**
    * TBD
    */
    'acquiringBIN': number;
    /**
    * This configuration allows a transaction to be flagged for cryptocurrency funds transfer.
    */
    'allowCryptoCurrencyPurchase'?: boolean;
    /**
    * TBD
    */
    'financialInstitutionId'?: string;
    /**
    * TBD
    */
    'networkOrder'?: string;
    /**
    * TBD
    */
    'nationalReimbursementFee'?: string;
    /**
    * TBD
    */
    'originatorBusinessApplicationId': string;
    /**
    * TBD
    */
    'originatorPseudoAbaNumber'?: string;
    /**
    * TBD
    */
    'processorAccount': Array<PaymentsProductsPayoutsConfigurationInformationConfigurationsProcessorAccount>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "acquirerCountryCode",
            "baseName": "acquirerCountryCode",
            "type": "number"
        },
        {
            "name": "acquiringBIN",
            "baseName": "acquiringBIN",
            "type": "number"
        },
        {
            "name": "allowCryptoCurrencyPurchase",
            "baseName": "allowCryptoCurrencyPurchase",
            "type": "boolean"
        },
        {
            "name": "financialInstitutionId",
            "baseName": "financialInstitutionId",
            "type": "string"
        },
        {
            "name": "networkOrder",
            "baseName": "networkOrder",
            "type": "string"
        },
        {
            "name": "nationalReimbursementFee",
            "baseName": "nationalReimbursementFee",
            "type": "string"
        },
        {
            "name": "originatorBusinessApplicationId",
            "baseName": "originatorBusinessApplicationId",
            "type": "string"
        },
        {
            "name": "originatorPseudoAbaNumber",
            "baseName": "originatorPseudoAbaNumber",
            "type": "string"
        },
        {
            "name": "processorAccount",
            "baseName": "processorAccount",
            "type": "Array<PaymentsProductsPayoutsConfigurationInformationConfigurationsProcessorAccount>"
        }    ];

    static getAttributeTypeMap() {
        return PaymentsProductsPayoutsConfigurationInformationConfigurationsPushfunds.attributeTypeMap;
    }
}

export class PaymentsProductsSecureAcceptance {
    'subscriptionInformation'?: PaymentsProductsAlternativePaymentMethodsSubscriptionInformation;
    'configurationInformation'?: PaymentsProductsSecureAcceptanceConfigurationInformation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "subscriptionInformation",
            "baseName": "subscriptionInformation",
            "type": "PaymentsProductsAlternativePaymentMethodsSubscriptionInformation"
        },
        {
            "name": "configurationInformation",
            "baseName": "configurationInformation",
            "type": "PaymentsProductsSecureAcceptanceConfigurationInformation"
        }    ];

    static getAttributeTypeMap() {
        return PaymentsProductsSecureAcceptance.attributeTypeMap;
    }
}

export class PaymentsProductsSecureAcceptanceConfigurationInformation {
    'templateId'?: string;
    'configurations'?: SAConfig;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "templateId",
            "baseName": "templateId",
            "type": "string"
        },
        {
            "name": "configurations",
            "baseName": "configurations",
            "type": "SAConfig"
        }    ];

    static getAttributeTypeMap() {
        return PaymentsProductsSecureAcceptanceConfigurationInformation.attributeTypeMap;
    }
}

export class PaymentsProductsServiceFee {
    'subscriptionInformation'?: PaymentsProductsAlternativePaymentMethodsSubscriptionInformation;
    'configurationInformation'?: PaymentsProductsServiceFeeConfigurationInformation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "subscriptionInformation",
            "baseName": "subscriptionInformation",
            "type": "PaymentsProductsAlternativePaymentMethodsSubscriptionInformation"
        },
        {
            "name": "configurationInformation",
            "baseName": "configurationInformation",
            "type": "PaymentsProductsServiceFeeConfigurationInformation"
        }    ];

    static getAttributeTypeMap() {
        return PaymentsProductsServiceFee.attributeTypeMap;
    }
}

export class PaymentsProductsServiceFeeConfigurationInformation {
    'configurations'?: PaymentsProductsServiceFeeConfigurationInformationConfigurations;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "configurations",
            "baseName": "configurations",
            "type": "PaymentsProductsServiceFeeConfigurationInformationConfigurations"
        }    ];

    static getAttributeTypeMap() {
        return PaymentsProductsServiceFeeConfigurationInformation.attributeTypeMap;
    }
}

export class PaymentsProductsServiceFeeConfigurationInformationConfigurations {
    /**
    * Products enabled for this account. The following values are supported: virtualTerminal paymentTokenizationOtp subscriptionsOtp virtualTerminalCp eCheck 
    */
    'products'?: { [key: string]: PaymentsProductsServiceFeeConfigurationInformationConfigurationsProducts; };
    /**
    * Identifier of the terminal at the retail location.
    */
    'terminalId'?: string;
    /**
    * Identifier of a merchant account.
    */
    'merchantId'?: string;
    'merchantInformation'?: PaymentsProductsServiceFeeConfigurationInformationConfigurationsMerchantInformation;
    'paymentInformation'?: Array<PaymentsProductsServiceFeeConfigurationInformationConfigurationsPaymentInformation>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "products",
            "baseName": "products",
            "type": "{ [key: string]: PaymentsProductsServiceFeeConfigurationInformationConfigurationsProducts; }"
        },
        {
            "name": "terminalId",
            "baseName": "terminalId",
            "type": "string"
        },
        {
            "name": "merchantId",
            "baseName": "merchantId",
            "type": "string"
        },
        {
            "name": "merchantInformation",
            "baseName": "merchantInformation",
            "type": "PaymentsProductsServiceFeeConfigurationInformationConfigurationsMerchantInformation"
        },
        {
            "name": "paymentInformation",
            "baseName": "paymentInformation",
            "type": "Array<PaymentsProductsServiceFeeConfigurationInformationConfigurationsPaymentInformation>"
        }    ];

    static getAttributeTypeMap() {
        return PaymentsProductsServiceFeeConfigurationInformationConfigurations.attributeTypeMap;
    }
}

export class PaymentsProductsServiceFeeConfigurationInformationConfigurationsMerchantInformation {
    /**
    * Name of the merchant account.
    */
    'name'?: string;
    /**
    * Phone number of the primary contact for the merchant account.
    */
    'contact'?: string;
    /**
    * 2-character ISO code for the U.S. state in which the merchant is registered
    */
    'state'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "contact",
            "baseName": "contact",
            "type": "string"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PaymentsProductsServiceFeeConfigurationInformationConfigurationsMerchantInformation.attributeTypeMap;
    }
}

export class PaymentsProductsServiceFeeConfigurationInformationConfigurationsPaymentInformation {
    /**
    * Payment types accepted by this merchant. The supported values are: MASTERDEBIT, MASTERCREDIT, VISACREDIT, VISADEBIT, DISCOVERCREDIT, AMEXCREDIT, ECHECK
    */
    'paymentType'?: PaymentsProductsServiceFeeConfigurationInformationConfigurationsPaymentInformation.PaymentTypeEnum;
    /**
    * Fee type for the selected payment type. Supported values are: Flat or Percentage. 
    */
    'feeType'?: PaymentsProductsServiceFeeConfigurationInformationConfigurationsPaymentInformation.FeeTypeEnum;
    /**
    * Fee Amount of the selected payment type if you chose Flat fee type. 
    */
    'feeAmount'?: number;
    /**
    * Percentage of the selected payment type if you chose Percentage Fee type. Supported values use numbers with decimals. For example, 1.0 
    */
    'percentage'?: number;
    /**
    * Fee cap for the selected payment type. Supported values use numbers with decimals. For example, 1.0 
    */
    'feeCap'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "paymentType",
            "baseName": "paymentType",
            "type": "PaymentsProductsServiceFeeConfigurationInformationConfigurationsPaymentInformation.PaymentTypeEnum"
        },
        {
            "name": "feeType",
            "baseName": "feeType",
            "type": "PaymentsProductsServiceFeeConfigurationInformationConfigurationsPaymentInformation.FeeTypeEnum"
        },
        {
            "name": "feeAmount",
            "baseName": "feeAmount",
            "type": "number"
        },
        {
            "name": "percentage",
            "baseName": "percentage",
            "type": "number"
        },
        {
            "name": "feeCap",
            "baseName": "feeCap",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PaymentsProductsServiceFeeConfigurationInformationConfigurationsPaymentInformation.attributeTypeMap;
    }
}

export namespace PaymentsProductsServiceFeeConfigurationInformationConfigurationsPaymentInformation {
    export enum PaymentTypeEnum {
        MASTERDEBIT = <any> 'MASTERDEBIT',
        MASTERCREDIT = <any> 'MASTERCREDIT',
        VISACREDIT = <any> 'VISACREDIT',
        VISADEBIT = <any> 'VISADEBIT',
        DISCOVERCREDIT = <any> 'DISCOVERCREDIT',
        AMEXCREDIT = <any> 'AMEXCREDIT',
        ECHECK = <any> 'ECHECK'
    }
    export enum FeeTypeEnum {
        FLAT = <any> 'FLAT',
        PERCENTAGE = <any> 'PERCENTAGE'
    }
}
export class PaymentsProductsServiceFeeConfigurationInformationConfigurationsProducts {
    /**
    * Boolean flag to determine if service fee will be applied to the Product.
    */
    'serviceFeeEnabled'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "serviceFeeEnabled",
            "baseName": "serviceFeeEnabled",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return PaymentsProductsServiceFeeConfigurationInformationConfigurationsProducts.attributeTypeMap;
    }
}

export class PaymentsProductsTax {
    'subscriptionInformation'?: PaymentsProductsAlternativePaymentMethodsSubscriptionInformation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "subscriptionInformation",
            "baseName": "subscriptionInformation",
            "type": "PaymentsProductsAlternativePaymentMethodsSubscriptionInformation"
        }    ];

    static getAttributeTypeMap() {
        return PaymentsProductsTax.attributeTypeMap;
    }
}

export class PaymentsProductsUnifiedCheckout {
    'subscriptionInformation'?: PaymentsProductsUnifiedCheckoutSubscriptionInformation;
    'configurationInformation'?: PaymentsProductsUnifiedCheckoutConfigurationInformation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "subscriptionInformation",
            "baseName": "subscriptionInformation",
            "type": "PaymentsProductsUnifiedCheckoutSubscriptionInformation"
        },
        {
            "name": "configurationInformation",
            "baseName": "configurationInformation",
            "type": "PaymentsProductsUnifiedCheckoutConfigurationInformation"
        }    ];

    static getAttributeTypeMap() {
        return PaymentsProductsUnifiedCheckout.attributeTypeMap;
    }
}

export class PaymentsProductsUnifiedCheckoutConfigurationInformation {
    'configurations'?: PaymentsProductsUnifiedCheckoutConfigurationInformationConfigurations;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "configurations",
            "baseName": "configurations",
            "type": "PaymentsProductsUnifiedCheckoutConfigurationInformationConfigurations"
        }    ];

    static getAttributeTypeMap() {
        return PaymentsProductsUnifiedCheckoutConfigurationInformation.attributeTypeMap;
    }
}

export class PaymentsProductsUnifiedCheckoutConfigurationInformationConfigurations {
    'features'?: PaymentsProductsUnifiedCheckoutConfigurationInformationConfigurationsFeatures;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "features",
            "baseName": "features",
            "type": "PaymentsProductsUnifiedCheckoutConfigurationInformationConfigurationsFeatures"
        }    ];

    static getAttributeTypeMap() {
        return PaymentsProductsUnifiedCheckoutConfigurationInformationConfigurations.attributeTypeMap;
    }
}

export class PaymentsProductsUnifiedCheckoutConfigurationInformationConfigurationsFeatures {
    'paze'?: PaymentsProductsUnifiedCheckoutConfigurationInformationConfigurationsFeaturesPaze;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "paze",
            "baseName": "paze",
            "type": "PaymentsProductsUnifiedCheckoutConfigurationInformationConfigurationsFeaturesPaze"
        }    ];

    static getAttributeTypeMap() {
        return PaymentsProductsUnifiedCheckoutConfigurationInformationConfigurationsFeatures.attributeTypeMap;
    }
}

/**
* Paze specific required configuration details under unified checkout
*/
export class PaymentsProductsUnifiedCheckoutConfigurationInformationConfigurationsFeaturesPaze {
    /**
    * Indicates the financial institution with whom the contract has been signed
    */
    'financialInstitution'?: PaymentsProductsUnifiedCheckoutConfigurationInformationConfigurationsFeaturesPaze.FinancialInstitutionEnum;
    /**
    * Indicates if the contract has been signed with the selected bank
    */
    'financialInstitutionContract'?: boolean;
    /**
    * Paze enabled in the profile for the merchants
    */
    'pazeEnabledInProfile'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "financialInstitution",
            "baseName": "financialInstitution",
            "type": "PaymentsProductsUnifiedCheckoutConfigurationInformationConfigurationsFeaturesPaze.FinancialInstitutionEnum"
        },
        {
            "name": "financialInstitutionContract",
            "baseName": "financialInstitutionContract",
            "type": "boolean"
        },
        {
            "name": "pazeEnabledInProfile",
            "baseName": "pazeEnabledInProfile",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return PaymentsProductsUnifiedCheckoutConfigurationInformationConfigurationsFeaturesPaze.attributeTypeMap;
    }
}

export namespace PaymentsProductsUnifiedCheckoutConfigurationInformationConfigurationsFeaturesPaze {
    export enum FinancialInstitutionEnum {
        BANKOFAMERICA = <any> 'BANKOFAMERICA',
        WELLSFARGO = <any> 'WELLSFARGO'
    }
}
export class PaymentsProductsUnifiedCheckoutSubscriptionInformation {
    'enabled'?: boolean;
    'enablementStatus'?: PaymentsProductsUnifiedCheckoutSubscriptionInformation.EnablementStatusEnum;
    /**
    * Indicates if the organization can enable this product using self service.
    */
    'selfServiceability'?: PaymentsProductsUnifiedCheckoutSubscriptionInformation.SelfServiceabilityEnum;
    'features'?: PaymentsProductsUnifiedCheckoutSubscriptionInformationFeatures;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "enabled",
            "baseName": "enabled",
            "type": "boolean"
        },
        {
            "name": "enablementStatus",
            "baseName": "enablementStatus",
            "type": "PaymentsProductsUnifiedCheckoutSubscriptionInformation.EnablementStatusEnum"
        },
        {
            "name": "selfServiceability",
            "baseName": "selfServiceability",
            "type": "PaymentsProductsUnifiedCheckoutSubscriptionInformation.SelfServiceabilityEnum"
        },
        {
            "name": "features",
            "baseName": "features",
            "type": "PaymentsProductsUnifiedCheckoutSubscriptionInformationFeatures"
        }    ];

    static getAttributeTypeMap() {
        return PaymentsProductsUnifiedCheckoutSubscriptionInformation.attributeTypeMap;
    }
}

export namespace PaymentsProductsUnifiedCheckoutSubscriptionInformation {
    export enum EnablementStatusEnum {
        PENDING = <any> 'PENDING',
        ENABLEDANDUSABLE = <any> 'ENABLED_AND_USABLE',
        ENABLEDNOTUSABLE = <any> 'ENABLED_NOT_USABLE',
        DISABLED = <any> 'DISABLED'
    }
    export enum SelfServiceabilityEnum {
        SELFSERVICEABLE = <any> 'SELF_SERVICEABLE',
        NOTSELFSERVICEABLE = <any> 'NOT_SELF_SERVICEABLE',
        SELFSERVICEONLY = <any> 'SELF_SERVICE_ONLY'
    }
}
export class PaymentsProductsUnifiedCheckoutSubscriptionInformationFeatures {
    'pazeForUnifiedCheckout'?: PaymentsProductsUnifiedCheckoutSubscriptionInformationFeaturesPazeForUnifiedCheckout;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "pazeForUnifiedCheckout",
            "baseName": "pazeForUnifiedCheckout",
            "type": "PaymentsProductsUnifiedCheckoutSubscriptionInformationFeaturesPazeForUnifiedCheckout"
        }    ];

    static getAttributeTypeMap() {
        return PaymentsProductsUnifiedCheckoutSubscriptionInformationFeatures.attributeTypeMap;
    }
}

/**
* Enabling Paze under unified checkout
*/
export class PaymentsProductsUnifiedCheckoutSubscriptionInformationFeaturesPazeForUnifiedCheckout {
    'enabled'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "enabled",
            "baseName": "enabled",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return PaymentsProductsUnifiedCheckoutSubscriptionInformationFeaturesPazeForUnifiedCheckout.attributeTypeMap;
    }
}

export class PaymentsProductsVirtualTerminal {
    'subscriptionInformation'?: PaymentsProductsAlternativePaymentMethodsSubscriptionInformation;
    'configurationInformation'?: PaymentsProductsVirtualTerminalConfigurationInformation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "subscriptionInformation",
            "baseName": "subscriptionInformation",
            "type": "PaymentsProductsAlternativePaymentMethodsSubscriptionInformation"
        },
        {
            "name": "configurationInformation",
            "baseName": "configurationInformation",
            "type": "PaymentsProductsVirtualTerminalConfigurationInformation"
        }    ];

    static getAttributeTypeMap() {
        return PaymentsProductsVirtualTerminal.attributeTypeMap;
    }
}

export class PaymentsProductsVirtualTerminalConfigurationInformation {
    'templateId'?: string;
    'configurations'?: VTConfig;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "templateId",
            "baseName": "templateId",
            "type": "string"
        },
        {
            "name": "configurations",
            "baseName": "configurations",
            "type": "VTConfig"
        }    ];

    static getAttributeTypeMap() {
        return PaymentsProductsVirtualTerminalConfigurationInformation.attributeTypeMap;
    }
}

export class PaymentsStrongAuthIssuerInformation {
    /**
    * Possible values: Visa Platform Connect - `8401` Merchant not participating in Visa Trusted Listing Program. - `8402` Issuer not participating in Visa Trusted Listing Program. - `8403` Cardholder has not trusted the merchant (supplied by Visa Net). - `8404` Indeterminate or invalid issuer response. - `8473` Cardholder has not trusted the merchant (issuer-supplied). - `8474` Did not meet the exemption criteria (issuer-supplied).  Upto 20 Values may be received in a transaction. 
    */
    'riskAnalysisExemptionResult'?: string;
    /**
    * Possible values: Visa Platform Connect - `2` Trusted merchant exemption validated/honored. - `3` Trusted merchant exemption failed validation/not honored. 
    */
    'trustedMerchantExemptionResult'?: string;
    /**
    * This will be the value returned by Visanet when low value exemption has been requested.  Valid values: Visa Platform Connect - `2` Low value exemption validated/honored - `3` Low value exemption failed validation/not honored 
    */
    'lowValueExemptionResult'?: string;
    /**
    * This will be the value returned by Visanet when secure corporate payment (scp) exemption has been requested.  Valid values: Visa Platform Connect - `2` Secure corporate payment exemption validated/honored - `3` Secure corporate payment exemption failed validation/not honored 
    */
    'secureCorporatePaymentResult'?: string;
    /**
    * This will be the value returned by Visanet when transaction risk analysis (TRA) exemption has been requested.    Valid values: Visa Platform Connect   - `2` transaction risk analysis (TRA) exemption validated/honored   - `3` transaction risk analysis (TRA) exemption failed validation/not honored 
    */
    'transactionRiskAnalysisExemptionResult'?: string;
    /**
    * This will be the value returned by Visanet when delegated authentication has been requested. 
    */
    'delegatedAuthenticationResult'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "riskAnalysisExemptionResult",
            "baseName": "riskAnalysisExemptionResult",
            "type": "string"
        },
        {
            "name": "trustedMerchantExemptionResult",
            "baseName": "trustedMerchantExemptionResult",
            "type": "string"
        },
        {
            "name": "lowValueExemptionResult",
            "baseName": "lowValueExemptionResult",
            "type": "string"
        },
        {
            "name": "secureCorporatePaymentResult",
            "baseName": "secureCorporatePaymentResult",
            "type": "string"
        },
        {
            "name": "transactionRiskAnalysisExemptionResult",
            "baseName": "transactionRiskAnalysisExemptionResult",
            "type": "string"
        },
        {
            "name": "delegatedAuthenticationResult",
            "baseName": "delegatedAuthenticationResult",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PaymentsStrongAuthIssuerInformation.attributeTypeMap;
    }
}

export class PblPaymentLinksAllGet200Response {
    'links'?: GetAllPlansResponseLinks;
    /**
    * Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ` **Example** `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.). The `T` separates the date and the time. The `Z` indicates UTC.  Returned by Cybersource for all services. 
    */
    'submitTimeUtc'?: string;
    'totalLinks'?: number;
    'links'?: Array<PblPaymentLinksAllGet200ResponseLinks>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "GetAllPlansResponseLinks"
        },
        {
            "name": "submitTimeUtc",
            "baseName": "submitTimeUtc",
            "type": "string"
        },
        {
            "name": "totalLinks",
            "baseName": "totalLinks",
            "type": "number"
        },
        {
            "name": "links",
            "baseName": "links",
            "type": "Array<PblPaymentLinksAllGet200ResponseLinks>"
        }    ];

    static getAttributeTypeMap() {
        return PblPaymentLinksAllGet200Response.attributeTypeMap;
    }
}

/**
* A list of purchase or donation links.
*/
export class PblPaymentLinksAllGet200ResponseLinks {
    'links'?: GetAllPlansResponseLinks;
    /**
    * An unique identification number generated by Cybersource to identify the submitted request. Returned by all services. It is also appended to the endpoint of the resource. On incremental authorizations, this value with be the same as the identification number returned in the original authorization response. 
    */
    'id'?: string;
    /**
    * The status of the purchase or donation link.  Possible values: - ACTIVE - INACTIVE 
    */
    'status'?: string;
    /**
    * Date and time (UTC) the invoice was created.  Format: YYYY-MM-DDThh:mm:ssZ Example 2016-08-11T22:47:57Z equals August 11, 2016, at 22:47:57 (10:47:57 p.m.). The T separates the date and the time. The Z indicates UTC. 
    */
    'createdDate'?: string;
    'processingInformation'?: PblPaymentLinksAllGet200ResponseProcessingInformation;
    'purchaseInformation'?: PblPaymentLinksAllGet200ResponsePurchaseInformation;
    'orderInformation'?: PblPaymentLinksAllGet200ResponseOrderInformation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "GetAllPlansResponseLinks"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "createdDate",
            "baseName": "createdDate",
            "type": "string"
        },
        {
            "name": "processingInformation",
            "baseName": "processingInformation",
            "type": "PblPaymentLinksAllGet200ResponseProcessingInformation"
        },
        {
            "name": "purchaseInformation",
            "baseName": "purchaseInformation",
            "type": "PblPaymentLinksAllGet200ResponsePurchaseInformation"
        },
        {
            "name": "orderInformation",
            "baseName": "orderInformation",
            "type": "PblPaymentLinksAllGet200ResponseOrderInformation"
        }    ];

    static getAttributeTypeMap() {
        return PblPaymentLinksAllGet200ResponseLinks.attributeTypeMap;
    }
}

/**
* Contains all of the order-related fields, such as the amount and line item details.
*/
export class PblPaymentLinksAllGet200ResponseOrderInformation {
    'amountDetails'?: PblPaymentLinksAllGet200ResponseOrderInformationAmountDetails;
    /**
    * List of the line items from the order.
    */
    'lineItems'?: Array<PblPaymentLinksAllGet200ResponseOrderInformationLineItems>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "amountDetails",
            "baseName": "amountDetails",
            "type": "PblPaymentLinksAllGet200ResponseOrderInformationAmountDetails"
        },
        {
            "name": "lineItems",
            "baseName": "lineItems",
            "type": "Array<PblPaymentLinksAllGet200ResponseOrderInformationLineItems>"
        }    ];

    static getAttributeTypeMap() {
        return PblPaymentLinksAllGet200ResponseOrderInformation.attributeTypeMap;
    }
}

/**
* Contains all of the amount-related fields.
*/
export class PblPaymentLinksAllGet200ResponseOrderInformationAmountDetails {
    /**
    * Grand total for the order. This value cannot be negative. You can include a decimal point (.), but no other special characters. CyberSource truncates the amount to the correct number of decimal places.  **Note** For CTV, FDCCompass, Paymentech processors, the maximum length for this field is 12.  **Important** Some processors have specific requirements and limitations, such as maximum amounts and maximum field lengths.  If your processor supports zero amount authorizations, you can set this field to 0 for the authorization to check if the card is lost or stolen.   #### Card Present Required to include either this field or `orderInformation.lineItems[].unitPrice` for the order.  #### Invoicing / Pay By Link Required for creating a new invoice or payment link.  #### PIN Debit Amount you requested for the PIN debit purchase. This value is returned for partial authorizations. The issuing bank can approve a partial amount if the balance on the debit card is less than the requested transaction amount.  Required field for PIN Debit purchase and PIN Debit credit requests. Optional field for PIN Debit reversal requests.  #### GPX This field is optional for reversing an authorization or credit; however, for all other processors, these fields are required.  #### DCC with a Third-Party Provider Set this field to the converted amount that was returned by the DCC provider. You must include either this field or the 1st line item in the order and the specific line-order amount in your request.   #### DCC for First Data Not used. 
    */
    'totalAmount'?: string;
    /**
    * Currency used for the order. Use the three-character [ISO Standard Currency Codes.](http://apps.cybersource.com/library/documentation/sbc/quickref/currencies.pdf)  #### Used by **Authorization** Required field.  **Authorization Reversal** For an authorization reversal (`reversalInformation`) or a capture (`processingOptions.capture` is set to `true`), you must use the same currency that you used in your payment authorization request.  #### PIN Debit Currency for the amount you requested for the PIN debit purchase. This value is returned for partial authorizations. The issuing bank can approve a partial amount if the balance on the debit card is less than the requested transaction amount. For the possible values, see the [ISO Standard Currency Codes](https://developer.cybersource.com/library/documentation/sbc/quickref/currencies.pdf). Returned by PIN debit purchase.  For PIN debit reversal requests, you must use the same currency that was used for the PIN debit purchase or PIN debit credit that you are reversing. For the possible values, see the [ISO Standard Currency Codes](https://developer.cybersource.com/library/documentation/sbc/quickref/currencies.pdf).  Required field for PIN Debit purchase and PIN Debit credit requests. Optional field for PIN Debit reversal requests.  #### GPX This field is optional for reversing an authorization or credit.  #### DCC for First Data Your local currency.  #### Tax Calculation Required for international tax and value added tax only. Optional for U.S. and Canadian taxes. Your local currency. 
    */
    'currency'?: string;
    /**
    * Maximum custom amount allowed for Donation. The customer cannot enter more than maxAmount on payment checkout page.
    */
    'maxAmount'?: string;
    /**
    * Minimum custom amount allowed for Donation. The customer cannot enter less than minAmount on payment checkout page. Required for DONATION links.
    */
    'minAmount'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "totalAmount",
            "baseName": "totalAmount",
            "type": "string"
        },
        {
            "name": "currency",
            "baseName": "currency",
            "type": "string"
        },
        {
            "name": "maxAmount",
            "baseName": "maxAmount",
            "type": "string"
        },
        {
            "name": "minAmount",
            "baseName": "minAmount",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PblPaymentLinksAllGet200ResponseOrderInformationAmountDetails.attributeTypeMap;
    }
}

/**
* Line item from the order.
*/
export class PblPaymentLinksAllGet200ResponseOrderInformationLineItems {
    /**
    * For an authorization or capture transaction (`processingOptions.capture` is `true` or `false`), this field is required when `orderInformation.lineItems[].productCode` is not `default` or one of the other values that are related to shipping and/or handling.  #### Tax Calculation Optional field for U.S., Canadian, international tax, and value added taxes. 
    */
    'productName'?: string;
    /**
    * Per-item price of the product. This value for this field cannot be negative.  You must include either this field or the request-level field `orderInformation.amountDetails.totalAmount` in your request.  You can include a decimal point (.), but you cannot include any other special characters. The value is truncated to the correct number of decimal places.  #### DCC with a Third-Party Provider Set this field to the converted amount that was returned by the DCC provider. You must include either the 1st line item in the order and this field, or the request-level field `orderInformation.amountDetails.totalAmount` in your request.  #### Tax Calculation Required field for U.S., Canadian, international and value added taxes.  #### Zero Amount Authorizations If your processor supports zero amount authorizations, you can set this field to 0 for the authorization to check if the card is lost or stolen.  #### Maximum Field Lengths For GPN and JCN Gateway: Decimal (10) All other processors: Decimal (15) 
    */
    'unitPrice'?: string;
    /**
    * Brief description of item.
    */
    'productDescription'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "productName",
            "baseName": "productName",
            "type": "string"
        },
        {
            "name": "unitPrice",
            "baseName": "unitPrice",
            "type": "string"
        },
        {
            "name": "productDescription",
            "baseName": "productDescription",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PblPaymentLinksAllGet200ResponseOrderInformationLineItems.attributeTypeMap;
    }
}

/**
* Contains processing information, such as the type and collection details.
*/
export class PblPaymentLinksAllGet200ResponseProcessingInformation {
    /**
    * linkType defines what type of link you want to create.  Possible Values:   - `PURCHASE`   - `DONATION` 
    */
    'linkType'?: PblPaymentLinksAllGet200ResponseProcessingInformation.LinkTypeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "linkType",
            "baseName": "linkType",
            "type": "PblPaymentLinksAllGet200ResponseProcessingInformation.LinkTypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return PblPaymentLinksAllGet200ResponseProcessingInformation.attributeTypeMap;
    }
}

export namespace PblPaymentLinksAllGet200ResponseProcessingInformation {
    export enum LinkTypeEnum {
        PURCHASE = <any> 'PURCHASE',
        DONATION = <any> 'DONATION'
    }
}
/**
* Contains link specific detail.
*/
export class PblPaymentLinksAllGet200ResponsePurchaseInformation {
    /**
    * The purchase number
    */
    'purchaseNumber'?: string;
    /**
    * Returns the link to a purchase or donation link when the status is `ACTIVE`.
    */
    'paymentLink'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "purchaseNumber",
            "baseName": "purchaseNumber",
            "type": "string"
        },
        {
            "name": "paymentLink",
            "baseName": "paymentLink",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PblPaymentLinksAllGet200ResponsePurchaseInformation.attributeTypeMap;
    }
}

export class PblPaymentLinksAllGet400Response {
    /**
    * Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ` **Example** `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.). The `T` separates the date and the time. The `Z` indicates UTC.  Returned by Cybersource for all services. 
    */
    'submitTimeUtc'?: string;
    /**
    * The status of the purchase or donation link.  Possible values:   - BADREQUEST   
    */
    'status'?: string;
    /**
    * The reason of the status.  Possible values: - DUPLICATE_RECORD - ACTION_NOT_ALLOWED - VALIDATION_ERRORS - INVALID_TRANSIENT_TOKEN 
    */
    'reason'?: string;
    /**
    * The detail message related to the status and reason listed above.
    */
    'message'?: string;
    'details'?: Array<PtsV2PaymentsPost201ResponseErrorInformationDetails>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "submitTimeUtc",
            "baseName": "submitTimeUtc",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "reason",
            "baseName": "reason",
            "type": "string"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        },
        {
            "name": "details",
            "baseName": "details",
            "type": "Array<PtsV2PaymentsPost201ResponseErrorInformationDetails>"
        }    ];

    static getAttributeTypeMap() {
        return PblPaymentLinksAllGet400Response.attributeTypeMap;
    }
}

export class PblPaymentLinksAllGet404Response {
    /**
    * Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ` **Example** `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.). The `T` separates the date and the time. The `Z` indicates UTC.  Returned by Cybersource for all services. 
    */
    'submitTimeUtc'?: string;
    /**
    * The status of the purchase or donation link.  Possible values:   - NOTFOUND   
    */
    'status'?: string;
    /**
    * The reason of the status.  Possible values: - NOTFOUND 
    */
    'reason'?: string;
    /**
    * The detail message related to the status and reason listed above.
    */
    'message'?: string;
    'details'?: Array<PtsV2PaymentsPost201ResponseErrorInformationDetails>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "submitTimeUtc",
            "baseName": "submitTimeUtc",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "reason",
            "baseName": "reason",
            "type": "string"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        },
        {
            "name": "details",
            "baseName": "details",
            "type": "Array<PtsV2PaymentsPost201ResponseErrorInformationDetails>"
        }    ];

    static getAttributeTypeMap() {
        return PblPaymentLinksAllGet404Response.attributeTypeMap;
    }
}

export class PblPaymentLinksGet200Response {
    'links'?: PblPaymentLinksPost201ResponseLinks;
    /**
    * An unique identification number generated by Cybersource to identify the submitted request. Returned by all services. It is also appended to the endpoint of the resource. On incremental authorizations, this value with be the same as the identification number returned in the original authorization response. 
    */
    'id'?: string;
    /**
    * Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ` **Example** `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.). The `T` separates the date and the time. The `Z` indicates UTC.  Returned by Cybersource for all services. 
    */
    'submitTimeUtc'?: string;
    /**
    * The status of the purchase or donation link.  Possible values: - ACTIVE - INACTIVE 
    */
    'status'?: string;
    'processingInformation'?: Iplv2paymentlinksProcessingInformation;
    'purchaseInformation'?: PblPaymentLinksPost201ResponsePurchaseInformation;
    'orderInformation'?: PblPaymentLinksPost201ResponseOrderInformation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "PblPaymentLinksPost201ResponseLinks"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "submitTimeUtc",
            "baseName": "submitTimeUtc",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "processingInformation",
            "baseName": "processingInformation",
            "type": "Iplv2paymentlinksProcessingInformation"
        },
        {
            "name": "purchaseInformation",
            "baseName": "purchaseInformation",
            "type": "PblPaymentLinksPost201ResponsePurchaseInformation"
        },
        {
            "name": "orderInformation",
            "baseName": "orderInformation",
            "type": "PblPaymentLinksPost201ResponseOrderInformation"
        }    ];

    static getAttributeTypeMap() {
        return PblPaymentLinksGet200Response.attributeTypeMap;
    }
}

export class PblPaymentLinksPost201Response {
    'links'?: PblPaymentLinksPost201ResponseLinks;
    /**
    * An unique identification number generated by Cybersource to identify the submitted request. Returned by all services. It is also appended to the endpoint of the resource. On incremental authorizations, this value with be the same as the identification number returned in the original authorization response. 
    */
    'id'?: string;
    /**
    * Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ` **Example** `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.). The `T` separates the date and the time. The `Z` indicates UTC.  Returned by Cybersource for all services. 
    */
    'submitTimeUtc'?: string;
    /**
    * The status of the purchase or donation link.  Possible values: - ACTIVE - INACTIVE 
    */
    'status'?: string;
    'processingInformation'?: Iplv2paymentlinksProcessingInformation;
    'purchaseInformation'?: PblPaymentLinksPost201ResponsePurchaseInformation;
    'orderInformation'?: PblPaymentLinksPost201ResponseOrderInformation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "PblPaymentLinksPost201ResponseLinks"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "submitTimeUtc",
            "baseName": "submitTimeUtc",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "processingInformation",
            "baseName": "processingInformation",
            "type": "Iplv2paymentlinksProcessingInformation"
        },
        {
            "name": "purchaseInformation",
            "baseName": "purchaseInformation",
            "type": "PblPaymentLinksPost201ResponsePurchaseInformation"
        },
        {
            "name": "orderInformation",
            "baseName": "orderInformation",
            "type": "PblPaymentLinksPost201ResponseOrderInformation"
        }    ];

    static getAttributeTypeMap() {
        return PblPaymentLinksPost201Response.attributeTypeMap;
    }
}

export class PblPaymentLinksPost201ResponseLinks {
    'self'?: PtsV2PaymentsPost201ResponseLinksSelf;
    'update'?: PtsV2PaymentsPost201ResponseLinksSelf;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "self",
            "baseName": "self",
            "type": "PtsV2PaymentsPost201ResponseLinksSelf"
        },
        {
            "name": "update",
            "baseName": "update",
            "type": "PtsV2PaymentsPost201ResponseLinksSelf"
        }    ];

    static getAttributeTypeMap() {
        return PblPaymentLinksPost201ResponseLinks.attributeTypeMap;
    }
}

/**
* Contains all of the order-related fields, such as the amount and line item details.
*/
export class PblPaymentLinksPost201ResponseOrderInformation {
    'amountDetails'?: PblPaymentLinksAllGet200ResponseOrderInformationAmountDetails;
    /**
    * List of the line items from the order.
    */
    'lineItems'?: Array<Iplv2paymentlinksOrderInformationLineItems>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "amountDetails",
            "baseName": "amountDetails",
            "type": "PblPaymentLinksAllGet200ResponseOrderInformationAmountDetails"
        },
        {
            "name": "lineItems",
            "baseName": "lineItems",
            "type": "Array<Iplv2paymentlinksOrderInformationLineItems>"
        }    ];

    static getAttributeTypeMap() {
        return PblPaymentLinksPost201ResponseOrderInformation.attributeTypeMap;
    }
}

/**
* Contains link specific detail.
*/
export class PblPaymentLinksPost201ResponsePurchaseInformation {
    /**
    * The purchase number
    */
    'purchaseNumber'?: string;
    /**
    * Date and time (UTC) the invoice was created.  Format: YYYY-MM-DDThh:mm:ssZ Example 2016-08-11T22:47:57Z equals August 11, 2016, at 22:47:57 (10:47:57 p.m.). The T separates the date and the time. The Z indicates UTC. 
    */
    'createdDate'?: string;
    /**
    * Returns the link to a purchase or donation link when the status is `ACTIVE`.
    */
    'paymentLink'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "purchaseNumber",
            "baseName": "purchaseNumber",
            "type": "string"
        },
        {
            "name": "createdDate",
            "baseName": "createdDate",
            "type": "string"
        },
        {
            "name": "paymentLink",
            "baseName": "paymentLink",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PblPaymentLinksPost201ResponsePurchaseInformation.attributeTypeMap;
    }
}

export class PostCustomerPaymentInstrumentRequest {
    'links'?: Tmsv2customersEmbeddedDefaultPaymentInstrumentLinks;
    /**
    * The Id of the Payment Instrument Token.
    */
    'id'?: string;
    /**
    * The type.  Possible Values: - paymentInstrument 
    */
    'object'?: string;
    /**
    * Flag that indicates whether customer payment instrument is the dafault. Possible Values:  - `true`: Payment instrument is customer's default.  - `false`: Payment instrument is not customer's default. 
    */
    '_default'?: boolean;
    /**
    * Issuers state for the card number. Possible Values: - ACTIVE - CLOSED : The account has been closed. 
    */
    'state'?: string;
    /**
    * The type of Payment Instrument. Possible Values: - cardHash 
    */
    'type'?: string;
    'bankAccount'?: Tmsv2customersEmbeddedDefaultPaymentInstrumentBankAccount;
    'card'?: Tmsv2customersEmbeddedDefaultPaymentInstrumentCard;
    'buyerInformation'?: Tmsv2customersEmbeddedDefaultPaymentInstrumentBuyerInformation;
    'billTo'?: Tmsv2customersEmbeddedDefaultPaymentInstrumentBillTo;
    'processingInformation'?: TmsPaymentInstrumentProcessingInfo;
    'merchantInformation'?: Tmsv2customersEmbeddedDefaultPaymentInstrumentMerchantInformation;
    'instrumentIdentifier'?: Tmsv2customersEmbeddedDefaultPaymentInstrumentInstrumentIdentifier;
    'metadata'?: Tmsv2customersEmbeddedDefaultPaymentInstrumentMetadata;
    'embedded'?: Tmsv2customersEmbeddedDefaultPaymentInstrumentEmbedded;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "Tmsv2customersEmbeddedDefaultPaymentInstrumentLinks"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "object",
            "baseName": "object",
            "type": "string"
        },
        {
            "name": "_default",
            "baseName": "default",
            "type": "boolean"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "bankAccount",
            "baseName": "bankAccount",
            "type": "Tmsv2customersEmbeddedDefaultPaymentInstrumentBankAccount"
        },
        {
            "name": "card",
            "baseName": "card",
            "type": "Tmsv2customersEmbeddedDefaultPaymentInstrumentCard"
        },
        {
            "name": "buyerInformation",
            "baseName": "buyerInformation",
            "type": "Tmsv2customersEmbeddedDefaultPaymentInstrumentBuyerInformation"
        },
        {
            "name": "billTo",
            "baseName": "billTo",
            "type": "Tmsv2customersEmbeddedDefaultPaymentInstrumentBillTo"
        },
        {
            "name": "processingInformation",
            "baseName": "processingInformation",
            "type": "TmsPaymentInstrumentProcessingInfo"
        },
        {
            "name": "merchantInformation",
            "baseName": "merchantInformation",
            "type": "Tmsv2customersEmbeddedDefaultPaymentInstrumentMerchantInformation"
        },
        {
            "name": "instrumentIdentifier",
            "baseName": "instrumentIdentifier",
            "type": "Tmsv2customersEmbeddedDefaultPaymentInstrumentInstrumentIdentifier"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "Tmsv2customersEmbeddedDefaultPaymentInstrumentMetadata"
        },
        {
            "name": "embedded",
            "baseName": "_embedded",
            "type": "Tmsv2customersEmbeddedDefaultPaymentInstrumentEmbedded"
        }    ];

    static getAttributeTypeMap() {
        return PostCustomerPaymentInstrumentRequest.attributeTypeMap;
    }
}

export class PostCustomerRequest {
    'links'?: Tmsv2customersLinks;
    /**
    * The Id of the Customer Token.
    */
    'id'?: string;
    'objectInformation'?: Tmsv2customersObjectInformation;
    'buyerInformation'?: Tmsv2customersBuyerInformation;
    'clientReferenceInformation'?: Tmsv2customersClientReferenceInformation;
    /**
    * Object containing the custom data that the merchant defines. 
    */
    'merchantDefinedInformation'?: Array<Tmsv2customersMerchantDefinedInformation>;
    'defaultPaymentInstrument'?: Tmsv2customersDefaultPaymentInstrument;
    'defaultShippingAddress'?: Tmsv2customersDefaultShippingAddress;
    'metadata'?: Tmsv2customersMetadata;
    'embedded'?: Tmsv2customersEmbedded;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "Tmsv2customersLinks"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "objectInformation",
            "baseName": "objectInformation",
            "type": "Tmsv2customersObjectInformation"
        },
        {
            "name": "buyerInformation",
            "baseName": "buyerInformation",
            "type": "Tmsv2customersBuyerInformation"
        },
        {
            "name": "clientReferenceInformation",
            "baseName": "clientReferenceInformation",
            "type": "Tmsv2customersClientReferenceInformation"
        },
        {
            "name": "merchantDefinedInformation",
            "baseName": "merchantDefinedInformation",
            "type": "Array<Tmsv2customersMerchantDefinedInformation>"
        },
        {
            "name": "defaultPaymentInstrument",
            "baseName": "defaultPaymentInstrument",
            "type": "Tmsv2customersDefaultPaymentInstrument"
        },
        {
            "name": "defaultShippingAddress",
            "baseName": "defaultShippingAddress",
            "type": "Tmsv2customersDefaultShippingAddress"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "Tmsv2customersMetadata"
        },
        {
            "name": "embedded",
            "baseName": "_embedded",
            "type": "Tmsv2customersEmbedded"
        }    ];

    static getAttributeTypeMap() {
        return PostCustomerRequest.attributeTypeMap;
    }
}

export class PostCustomerShippingAddressRequest {
    'links'?: Tmsv2customersEmbeddedDefaultShippingAddressLinks;
    /**
    * The Id of the Shipping Address Token.
    */
    'id'?: string;
    /**
    * Flag that indicates whether customer shipping address is the dafault. Possible Values:  - `true`: Shipping Address is customer's default.  - `false`: Shipping Address is not customer's default. 
    */
    '_default'?: boolean;
    'shipTo'?: Tmsv2customersEmbeddedDefaultShippingAddressShipTo;
    'metadata'?: Tmsv2customersEmbeddedDefaultShippingAddressMetadata;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "Tmsv2customersEmbeddedDefaultShippingAddressLinks"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "_default",
            "baseName": "default",
            "type": "boolean"
        },
        {
            "name": "shipTo",
            "baseName": "shipTo",
            "type": "Tmsv2customersEmbeddedDefaultShippingAddressShipTo"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "Tmsv2customersEmbeddedDefaultShippingAddressMetadata"
        }    ];

    static getAttributeTypeMap() {
        return PostCustomerShippingAddressRequest.attributeTypeMap;
    }
}

export class PostDeviceSearchRequestV3 {
    /**
    * The Search Query to retrieve the Terminals.(Example :- serialNumber:456345234 AND readerId:509353f0-86ca-4af4-a1c9-c2702bfd7431  AND terminalId:7854922 AND status:Inactive AND statusChangeReason:Other AND organizationId:London Store)
    */
    'query'?: string;
    /**
    * terminalCreationDate:desc (default) or serialNumber or terminalUpdationDate
    */
    'sort'?: string;
    /**
    * The offset or page number.
    */
    'offset'?: number;
    /**
    * Number of devices to retrieve in one request.
    */
    'limit'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "query",
            "baseName": "query",
            "type": "string"
        },
        {
            "name": "sort",
            "baseName": "sort",
            "type": "string"
        },
        {
            "name": "offset",
            "baseName": "offset",
            "type": "number"
        },
        {
            "name": "limit",
            "baseName": "limit",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PostDeviceSearchRequestV3.attributeTypeMap;
    }
}

export class PostInstrumentIdentifierEnrollmentRequest {
    'links'?: TmsEmbeddedInstrumentIdentifierLinks;
    /**
    * The Id of the Instrument Identifier Token. 
    */
    'id'?: string;
    /**
    * The type.  Possible Values: - instrumentIdentifier 
    */
    'object'?: string;
    /**
    * Issuers state for the card number. Possible Values: - ACTIVE - CLOSED : The account has been closed. 
    */
    'state'?: string;
    /**
    * The type of Instrument Identifier. Possible Values: - enrollable card - enrollable token 
    */
    'type'?: string;
    'tokenProvisioningInformation'?: Ptsv2paymentsTokenInformationTokenProvisioningInformation;
    'card'?: TmsEmbeddedInstrumentIdentifierCard;
    'bankAccount'?: TmsEmbeddedInstrumentIdentifierBankAccount;
    'tokenizedCard'?: Tmsv2TokenizedCard;
    'issuer'?: TmsEmbeddedInstrumentIdentifierIssuer;
    'processingInformation'?: TmsEmbeddedInstrumentIdentifierProcessingInformation;
    'billTo'?: TmsEmbeddedInstrumentIdentifierBillTo;
    'metadata'?: TmsEmbeddedInstrumentIdentifierMetadata;
    'embedded'?: TmsEmbeddedInstrumentIdentifierEmbedded;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "TmsEmbeddedInstrumentIdentifierLinks"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "object",
            "baseName": "object",
            "type": "string"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "tokenProvisioningInformation",
            "baseName": "tokenProvisioningInformation",
            "type": "Ptsv2paymentsTokenInformationTokenProvisioningInformation"
        },
        {
            "name": "card",
            "baseName": "card",
            "type": "TmsEmbeddedInstrumentIdentifierCard"
        },
        {
            "name": "bankAccount",
            "baseName": "bankAccount",
            "type": "TmsEmbeddedInstrumentIdentifierBankAccount"
        },
        {
            "name": "tokenizedCard",
            "baseName": "tokenizedCard",
            "type": "Tmsv2TokenizedCard"
        },
        {
            "name": "issuer",
            "baseName": "issuer",
            "type": "TmsEmbeddedInstrumentIdentifierIssuer"
        },
        {
            "name": "processingInformation",
            "baseName": "processingInformation",
            "type": "TmsEmbeddedInstrumentIdentifierProcessingInformation"
        },
        {
            "name": "billTo",
            "baseName": "billTo",
            "type": "TmsEmbeddedInstrumentIdentifierBillTo"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "TmsEmbeddedInstrumentIdentifierMetadata"
        },
        {
            "name": "embedded",
            "baseName": "_embedded",
            "type": "TmsEmbeddedInstrumentIdentifierEmbedded"
        }    ];

    static getAttributeTypeMap() {
        return PostInstrumentIdentifierEnrollmentRequest.attributeTypeMap;
    }
}

export class PostInstrumentIdentifierRequest {
    'links'?: TmsEmbeddedInstrumentIdentifierLinks;
    /**
    * The Id of the Instrument Identifier Token. 
    */
    'id'?: string;
    /**
    * The type.  Possible Values: - instrumentIdentifier 
    */
    'object'?: string;
    /**
    * Issuers state for the card number. Possible Values: - ACTIVE - CLOSED : The account has been closed. 
    */
    'state'?: string;
    /**
    * The type of Instrument Identifier. Possible Values: - enrollable card - enrollable token 
    */
    'type'?: string;
    'tokenProvisioningInformation'?: Ptsv2paymentsTokenInformationTokenProvisioningInformation;
    'card'?: TmsEmbeddedInstrumentIdentifierCard;
    'bankAccount'?: TmsEmbeddedInstrumentIdentifierBankAccount;
    'tokenizedCard'?: Tmsv2TokenizedCard;
    'issuer'?: TmsEmbeddedInstrumentIdentifierIssuer;
    'processingInformation'?: TmsEmbeddedInstrumentIdentifierProcessingInformation;
    'billTo'?: TmsEmbeddedInstrumentIdentifierBillTo;
    'metadata'?: TmsEmbeddedInstrumentIdentifierMetadata;
    'embedded'?: TmsEmbeddedInstrumentIdentifierEmbedded;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "TmsEmbeddedInstrumentIdentifierLinks"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "object",
            "baseName": "object",
            "type": "string"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "tokenProvisioningInformation",
            "baseName": "tokenProvisioningInformation",
            "type": "Ptsv2paymentsTokenInformationTokenProvisioningInformation"
        },
        {
            "name": "card",
            "baseName": "card",
            "type": "TmsEmbeddedInstrumentIdentifierCard"
        },
        {
            "name": "bankAccount",
            "baseName": "bankAccount",
            "type": "TmsEmbeddedInstrumentIdentifierBankAccount"
        },
        {
            "name": "tokenizedCard",
            "baseName": "tokenizedCard",
            "type": "Tmsv2TokenizedCard"
        },
        {
            "name": "issuer",
            "baseName": "issuer",
            "type": "TmsEmbeddedInstrumentIdentifierIssuer"
        },
        {
            "name": "processingInformation",
            "baseName": "processingInformation",
            "type": "TmsEmbeddedInstrumentIdentifierProcessingInformation"
        },
        {
            "name": "billTo",
            "baseName": "billTo",
            "type": "TmsEmbeddedInstrumentIdentifierBillTo"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "TmsEmbeddedInstrumentIdentifierMetadata"
        },
        {
            "name": "embedded",
            "baseName": "_embedded",
            "type": "TmsEmbeddedInstrumentIdentifierEmbedded"
        }    ];

    static getAttributeTypeMap() {
        return PostInstrumentIdentifierRequest.attributeTypeMap;
    }
}

export class PostPaymentCredentialsRequest {
    /**
    * The type of payment credentials to be returned. By default, payment credentials include network token and cryptogram or dynamic CVV. If \"NETWORK_TOKEN\" is supplied then only network token card number will be returned and no cryptogram or dynamic CVV will be requested. If \"SECURITY_CODE\" is supplied then dynamic CVV will be requested and returned with the network token card number. Dynamic CVV is only supported for Amex and SCOF. If \"CRYPTOGRAM\" is supplied then cryptogram will be requested and returned with the network token card number. Cryptogram is NOT supported for Amex.  Possible Values:   - NETWORK_TOKEN   - SECURITY_CODE   - CRYPTOGRAM 
    */
    'paymentCredentialType'?: string;
    /**
    * Specifies the type of transaction for which the network token credentials are required. Possible Values:   - ECOM: Ecommerce transaction. If transactionType is not provided, ECOM is set as the default.   - AFT: Account Funding Transaction. This is only supported for VISA and paymentCredentialType of CRYPTOGRAM. 
    */
    'transactionType'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "paymentCredentialType",
            "baseName": "paymentCredentialType",
            "type": "string"
        },
        {
            "name": "transactionType",
            "baseName": "transactionType",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PostPaymentCredentialsRequest.attributeTypeMap;
    }
}

export class PostPaymentInstrumentRequest {
    'links'?: Tmsv2customersEmbeddedDefaultPaymentInstrumentLinks;
    /**
    * The Id of the Payment Instrument Token.
    */
    'id'?: string;
    /**
    * The type.  Possible Values: - paymentInstrument 
    */
    'object'?: string;
    /**
    * Flag that indicates whether customer payment instrument is the dafault. Possible Values:  - `true`: Payment instrument is customer's default.  - `false`: Payment instrument is not customer's default. 
    */
    '_default'?: boolean;
    /**
    * Issuers state for the card number. Possible Values: - ACTIVE - CLOSED : The account has been closed. 
    */
    'state'?: string;
    /**
    * The type of Payment Instrument. Possible Values: - cardHash 
    */
    'type'?: string;
    'bankAccount'?: Tmsv2customersEmbeddedDefaultPaymentInstrumentBankAccount;
    'card'?: Tmsv2customersEmbeddedDefaultPaymentInstrumentCard;
    'buyerInformation'?: Tmsv2customersEmbeddedDefaultPaymentInstrumentBuyerInformation;
    'billTo'?: Tmsv2customersEmbeddedDefaultPaymentInstrumentBillTo;
    'processingInformation'?: TmsPaymentInstrumentProcessingInfo;
    'merchantInformation'?: Tmsv2customersEmbeddedDefaultPaymentInstrumentMerchantInformation;
    'instrumentIdentifier'?: Tmsv2customersEmbeddedDefaultPaymentInstrumentInstrumentIdentifier;
    'metadata'?: Tmsv2customersEmbeddedDefaultPaymentInstrumentMetadata;
    'embedded'?: Tmsv2customersEmbeddedDefaultPaymentInstrumentEmbedded;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "Tmsv2customersEmbeddedDefaultPaymentInstrumentLinks"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "object",
            "baseName": "object",
            "type": "string"
        },
        {
            "name": "_default",
            "baseName": "default",
            "type": "boolean"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "bankAccount",
            "baseName": "bankAccount",
            "type": "Tmsv2customersEmbeddedDefaultPaymentInstrumentBankAccount"
        },
        {
            "name": "card",
            "baseName": "card",
            "type": "Tmsv2customersEmbeddedDefaultPaymentInstrumentCard"
        },
        {
            "name": "buyerInformation",
            "baseName": "buyerInformation",
            "type": "Tmsv2customersEmbeddedDefaultPaymentInstrumentBuyerInformation"
        },
        {
            "name": "billTo",
            "baseName": "billTo",
            "type": "Tmsv2customersEmbeddedDefaultPaymentInstrumentBillTo"
        },
        {
            "name": "processingInformation",
            "baseName": "processingInformation",
            "type": "TmsPaymentInstrumentProcessingInfo"
        },
        {
            "name": "merchantInformation",
            "baseName": "merchantInformation",
            "type": "Tmsv2customersEmbeddedDefaultPaymentInstrumentMerchantInformation"
        },
        {
            "name": "instrumentIdentifier",
            "baseName": "instrumentIdentifier",
            "type": "Tmsv2customersEmbeddedDefaultPaymentInstrumentInstrumentIdentifier"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "Tmsv2customersEmbeddedDefaultPaymentInstrumentMetadata"
        },
        {
            "name": "embedded",
            "baseName": "_embedded",
            "type": "Tmsv2customersEmbeddedDefaultPaymentInstrumentEmbedded"
        }    ];

    static getAttributeTypeMap() {
        return PostPaymentInstrumentRequest.attributeTypeMap;
    }
}

export class PostRegistrationBody {
    'registrationInformation'?: Boardingv1registrationsRegistrationInformation;
    'integrationInformation'?: Boardingv1registrationsIntegrationInformation;
    'organizationInformation': Boardingv1registrationsOrganizationInformation;
    'productInformation'?: Boardingv1registrationsProductInformation;
    'documentInformation'?: Boardingv1registrationsDocumentInformation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "registrationInformation",
            "baseName": "registrationInformation",
            "type": "Boardingv1registrationsRegistrationInformation"
        },
        {
            "name": "integrationInformation",
            "baseName": "integrationInformation",
            "type": "Boardingv1registrationsIntegrationInformation"
        },
        {
            "name": "organizationInformation",
            "baseName": "organizationInformation",
            "type": "Boardingv1registrationsOrganizationInformation"
        },
        {
            "name": "productInformation",
            "baseName": "productInformation",
            "type": "Boardingv1registrationsProductInformation"
        },
        {
            "name": "documentInformation",
            "baseName": "documentInformation",
            "type": "Boardingv1registrationsDocumentInformation"
        }    ];

    static getAttributeTypeMap() {
        return PostRegistrationBody.attributeTypeMap;
    }
}

export class PredefinedSubscriptionRequestBean {
    /**
    * Valid Report Definition Name
    */
    'reportDefinitionName': string;
    /**
    * The subscription type for which report definition is required. Valid values are CLASSIC and STANDARD. Valid Values:   - CLASSIC   - STANDARD 
    */
    'subscriptionType': string;
    'reportName'?: string;
    /**
    * Report Format             Valid Values:   - application/xml   - text/csv 
    */
    'reportMimeType'?: string;
    /**
    * 'The frequency for which subscription is created. For Standard we can have DAILY, WEEKLY and MONTHLY. But for Classic we will have only DAILY.' **NOTE: Do not document USER_DEFINED Frequency field in developer center** Valid Values: - 'DAILY' - 'WEEKLY' - 'MONTHLY' - 'USER_DEFINED' 
    */
    'reportFrequency'?: string;
    /**
    * If the reportFrequency is User-defined, reportInterval should be in **ISO 8601 time format** Please refer the following link to know more about ISO 8601 format.[Rfc Time Format](https://en.wikipedia.org/wiki/ISO_8601#Durations)  **Example time format for 2 hours and 30 Mins:**   - PT2H30M **NOTE: Do not document reportInterval field in developer center** 
    */
    'reportInterval'?: string;
    /**
    * By Default the timezone for Standard subscription is PST. And for Classic subscription it will be GMT. If user provides any other time zone apart from PST for Standard subscription api should error out.
    */
    'timezone'?: string;
    /**
    * The hour at which the report generation should start. It should be in hhmm format. By Default it will be 0000. The format is 24 hours format.
    */
    'startTime'?: string;
    /**
    * This is the start day if the frequency is WEEKLY or MONTHLY. The value varies from 1-7 for WEEKLY and 1-31 for MONTHLY. For WEEKLY 1 means Sunday and 7 means Saturday. By default the value is 1.
    */
    'startDay'?: number;
    /**
    * The status for subscription which is either created or updated. By default it is ACTIVE. Valid Values:   - ACTIVE   - INACTIVE 
    */
    'subscriptionStatus'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "reportDefinitionName",
            "baseName": "reportDefinitionName",
            "type": "string"
        },
        {
            "name": "subscriptionType",
            "baseName": "subscriptionType",
            "type": "string"
        },
        {
            "name": "reportName",
            "baseName": "reportName",
            "type": "string"
        },
        {
            "name": "reportMimeType",
            "baseName": "reportMimeType",
            "type": "string"
        },
        {
            "name": "reportFrequency",
            "baseName": "reportFrequency",
            "type": "string"
        },
        {
            "name": "reportInterval",
            "baseName": "reportInterval",
            "type": "string"
        },
        {
            "name": "timezone",
            "baseName": "timezone",
            "type": "string"
        },
        {
            "name": "startTime",
            "baseName": "startTime",
            "type": "string"
        },
        {
            "name": "startDay",
            "baseName": "startDay",
            "type": "number"
        },
        {
            "name": "subscriptionStatus",
            "baseName": "subscriptionStatus",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PredefinedSubscriptionRequestBean.attributeTypeMap;
    }
}

export class PtsV1TransactionBatchesGet200Response {
    'transactionBatches'?: Array<PtsV1TransactionBatchesGet200ResponseTransactionBatches>;
    'links'?: PtsV1TransactionBatchesGet200ResponseLinks;
    /**
    * Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ` **Example** `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.). The `T` separates the date and the time. The `Z` indicates UTC.  Returned by Cybersource for all services. 
    */
    'submitTimeUtc'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "transactionBatches",
            "baseName": "transactionBatches",
            "type": "Array<PtsV1TransactionBatchesGet200ResponseTransactionBatches>"
        },
        {
            "name": "links",
            "baseName": "_links",
            "type": "PtsV1TransactionBatchesGet200ResponseLinks"
        },
        {
            "name": "submitTimeUtc",
            "baseName": "submitTimeUtc",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PtsV1TransactionBatchesGet200Response.attributeTypeMap;
    }
}

export class PtsV1TransactionBatchesGet200ResponseLinks {
    'self'?: PtsV1TransactionBatchesGet200ResponseLinksSelf;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "self",
            "baseName": "self",
            "type": "PtsV1TransactionBatchesGet200ResponseLinksSelf"
        }    ];

    static getAttributeTypeMap() {
        return PtsV1TransactionBatchesGet200ResponseLinks.attributeTypeMap;
    }
}

export class PtsV1TransactionBatchesGet200ResponseLinksSelf {
    'href'?: string;
    'method'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "href",
            "baseName": "href",
            "type": "string"
        },
        {
            "name": "method",
            "baseName": "method",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PtsV1TransactionBatchesGet200ResponseLinksSelf.attributeTypeMap;
    }
}

export class PtsV1TransactionBatchesGet200ResponseTransactionBatches {
    /**
    * Unique identifier assigned to the batch file.
    */
    'id'?: string;
    /**
    * Date when the batch template was update.
    */
    'uploadDate'?: string;
    /**
    * The date when the batch template processing completed.
    */
    'completionDate'?: string;
    /**
    * Number of transactions in the transaction.
    */
    'transactionCount'?: number;
    /**
    * Number of transactions accepted.
    */
    'acceptedTransactionCount'?: number;
    /**
    * Number of transactions rejected.
    */
    'rejectedTransactionCount'?: string;
    /**
    * The status of you batch template processing.
    */
    'status'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "uploadDate",
            "baseName": "uploadDate",
            "type": "string"
        },
        {
            "name": "completionDate",
            "baseName": "completionDate",
            "type": "string"
        },
        {
            "name": "transactionCount",
            "baseName": "transactionCount",
            "type": "number"
        },
        {
            "name": "acceptedTransactionCount",
            "baseName": "acceptedTransactionCount",
            "type": "number"
        },
        {
            "name": "rejectedTransactionCount",
            "baseName": "rejectedTransactionCount",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PtsV1TransactionBatchesGet200ResponseTransactionBatches.attributeTypeMap;
    }
}

export class PtsV1TransactionBatchesGet400Response {
    'errorInformation'?: PtsV1TransactionBatchesGet400ResponseErrorInformation;
    /**
    * Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ` **Example** `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.). The `T` separates the date and the time. The `Z` indicates UTC.  Returned by Cybersource for all services. 
    */
    'submitTimeUtc'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "errorInformation",
            "baseName": "errorInformation",
            "type": "PtsV1TransactionBatchesGet400ResponseErrorInformation"
        },
        {
            "name": "submitTimeUtc",
            "baseName": "submitTimeUtc",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PtsV1TransactionBatchesGet400Response.attributeTypeMap;
    }
}

export class PtsV1TransactionBatchesGet400ResponseErrorInformation {
    'reason'?: string;
    'message'?: string;
    'details'?: Array<PtsV1TransactionBatchesGet400ResponseErrorInformationDetails>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "reason",
            "baseName": "reason",
            "type": "string"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        },
        {
            "name": "details",
            "baseName": "details",
            "type": "Array<PtsV1TransactionBatchesGet400ResponseErrorInformationDetails>"
        }    ];

    static getAttributeTypeMap() {
        return PtsV1TransactionBatchesGet400ResponseErrorInformation.attributeTypeMap;
    }
}

export class PtsV1TransactionBatchesGet400ResponseErrorInformationDetails {
    /**
    * This is the flattened JSON object field name/path that is either missing or invalid. 
    */
    'field'?: string;
    /**
    * The detailed message related to the status and reason listed above. 
    */
    'message'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "field",
            "baseName": "field",
            "type": "string"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PtsV1TransactionBatchesGet400ResponseErrorInformationDetails.attributeTypeMap;
    }
}

export class PtsV1TransactionBatchesGet500Response {
    'errorInformation'?: PtsV1TransactionBatchesGet500ResponseErrorInformation;
    /**
    * Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ` **Example** `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.). The `T` separates the date and the time. The `Z` indicates UTC.  Returned by Cybersource for all services. 
    */
    'submitTimeUtc'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "errorInformation",
            "baseName": "errorInformation",
            "type": "PtsV1TransactionBatchesGet500ResponseErrorInformation"
        },
        {
            "name": "submitTimeUtc",
            "baseName": "submitTimeUtc",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PtsV1TransactionBatchesGet500Response.attributeTypeMap;
    }
}

export class PtsV1TransactionBatchesGet500ResponseErrorInformation {
    /**
    * The reason of status
    */
    'reason'?: string;
    /**
    * The detailed message related to the status and reason listed above.
    */
    'message'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "reason",
            "baseName": "reason",
            "type": "string"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PtsV1TransactionBatchesGet500ResponseErrorInformation.attributeTypeMap;
    }
}

export class PtsV1TransactionBatchesIdGet200Response {
    /**
    * Unique identifier assigned to the batch file.
    */
    'id'?: string;
    /**
    * Date when the batch template was update.
    */
    'uploadDate'?: string;
    /**
    * The date when the batch template processing completed.
    */
    'completionDate'?: string;
    /**
    * Number of transactions in the transaction.
    */
    'transactionCount'?: number;
    /**
    * Number of transactions accepted.
    */
    'acceptedTransactionCount'?: number;
    /**
    * Number of transactions rejected.
    */
    'rejectedTransactionCount'?: string;
    /**
    * The status of you batch template processing.
    */
    'status'?: string;
    'links'?: PtsV1TransactionBatchesIdGet200ResponseLinks;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "uploadDate",
            "baseName": "uploadDate",
            "type": "string"
        },
        {
            "name": "completionDate",
            "baseName": "completionDate",
            "type": "string"
        },
        {
            "name": "transactionCount",
            "baseName": "transactionCount",
            "type": "number"
        },
        {
            "name": "acceptedTransactionCount",
            "baseName": "acceptedTransactionCount",
            "type": "number"
        },
        {
            "name": "rejectedTransactionCount",
            "baseName": "rejectedTransactionCount",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "links",
            "baseName": "_links",
            "type": "PtsV1TransactionBatchesIdGet200ResponseLinks"
        }    ];

    static getAttributeTypeMap() {
        return PtsV1TransactionBatchesIdGet200Response.attributeTypeMap;
    }
}

export class PtsV1TransactionBatchesIdGet200ResponseLinks {
    'transactions'?: Array<PtsV1TransactionBatchesIdGet200ResponseLinksTransactions>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "transactions",
            "baseName": "transactions",
            "type": "Array<PtsV1TransactionBatchesIdGet200ResponseLinksTransactions>"
        }    ];

    static getAttributeTypeMap() {
        return PtsV1TransactionBatchesIdGet200ResponseLinks.attributeTypeMap;
    }
}

export class PtsV1TransactionBatchesIdGet200ResponseLinksTransactions {
    /**
    * Self link for this request
    */
    'href'?: string;
    'method'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "href",
            "baseName": "href",
            "type": "string"
        },
        {
            "name": "method",
            "baseName": "method",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PtsV1TransactionBatchesIdGet200ResponseLinksTransactions.attributeTypeMap;
    }
}

export class PtsV2CreateBillingAgreementPost201Response {
    'links'?: PtsV2CreateBillingAgreementPost201ResponseLinks;
    /**
    * An unique identification number generated by Cybersource to identify the submitted request. Returned by all services. It is also appended to the endpoint of the resource. On incremental authorizations, this value with be the same as the identification number returned in the original authorization response. 
    */
    'id'?: string;
    /**
    * Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ` **Example** `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.). The `T` separates the date and the time. The `Z` indicates UTC.  Returned by Cybersource for all services. 
    */
    'submitTimeUtc'?: string;
    /**
    * The status of the billing agreement. Possible value is:   - PENDING   - REVOKED   - ACTIVE   - FAILED   - EXPIRED   - INACTIVE 
    */
    'status'?: string;
    'processorInformation'?: PtsV2CreateBillingAgreementPost201ResponseProcessorInformation;
    'installmentInformation'?: PtsV2CreateBillingAgreementPost201ResponseInstallmentInformation;
    'agreementInformation'?: PtsV2CreateBillingAgreementPost201ResponseAgreementInformation;
    'clientReferenceInformation'?: PtsV2CreateBillingAgreementPost201ResponseClientReferenceInformation;
    'riskInformation'?: PtsV2CreateBillingAgreementPost201ResponseRiskInformation;
    /**
    * Reference number for the transaction. Depending on how your Cybersource account is configured, this value could either be provided in the API request or generated by CyberSource. The actual value used in the request to the processor is provided back to you by Cybersource in the response. 
    */
    'reconciliationId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "PtsV2CreateBillingAgreementPost201ResponseLinks"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "submitTimeUtc",
            "baseName": "submitTimeUtc",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "processorInformation",
            "baseName": "processorInformation",
            "type": "PtsV2CreateBillingAgreementPost201ResponseProcessorInformation"
        },
        {
            "name": "installmentInformation",
            "baseName": "installmentInformation",
            "type": "PtsV2CreateBillingAgreementPost201ResponseInstallmentInformation"
        },
        {
            "name": "agreementInformation",
            "baseName": "agreementInformation",
            "type": "PtsV2CreateBillingAgreementPost201ResponseAgreementInformation"
        },
        {
            "name": "clientReferenceInformation",
            "baseName": "clientReferenceInformation",
            "type": "PtsV2CreateBillingAgreementPost201ResponseClientReferenceInformation"
        },
        {
            "name": "riskInformation",
            "baseName": "riskInformation",
            "type": "PtsV2CreateBillingAgreementPost201ResponseRiskInformation"
        },
        {
            "name": "reconciliationId",
            "baseName": "reconciliationId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2CreateBillingAgreementPost201Response.attributeTypeMap;
    }
}

export class PtsV2CreateBillingAgreementPost201ResponseAgreementInformation {
    /**
    * Identifier for the mandate. 
    */
    'id'?: string;
    /**
    * Date the mandate has been signed.  Format YYYYMMdd
    */
    'dateSigned'?: string;
    /**
    * Date the mandate has been created.  Format YYYYMMdd
    */
    'dateCreated'?: string;
    /**
    * Base64 encoded html string
    */
    'encodedHtml'?: string;
    /**
    * Base64 encoded popup html string
    */
    'encodedHtmlPopup'?: string;
    /**
    * URL for redirecting the customer for creating the mandate. 
    */
    'url'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "dateSigned",
            "baseName": "dateSigned",
            "type": "string"
        },
        {
            "name": "dateCreated",
            "baseName": "dateCreated",
            "type": "string"
        },
        {
            "name": "encodedHtml",
            "baseName": "encodedHtml",
            "type": "string"
        },
        {
            "name": "encodedHtmlPopup",
            "baseName": "encodedHtmlPopup",
            "type": "string"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2CreateBillingAgreementPost201ResponseAgreementInformation.attributeTypeMap;
    }
}

export class PtsV2CreateBillingAgreementPost201ResponseClientReferenceInformation {
    /**
    * Merchant-generated order reference or tracking number. It is recommended that you send a unique value for each transaction so that you can perform meaningful searches for the transaction. 
    */
    'code'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2CreateBillingAgreementPost201ResponseClientReferenceInformation.attributeTypeMap;
    }
}

export class PtsV2CreateBillingAgreementPost201ResponseInstallmentInformation {
    /**
    * Identifier 
    */
    'identifier'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "identifier",
            "baseName": "identifier",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2CreateBillingAgreementPost201ResponseInstallmentInformation.attributeTypeMap;
    }
}

export class PtsV2CreateBillingAgreementPost201ResponseLinks {
    'self'?: PtsV2PaymentsPost201ResponseLinksSelf;
    'updateAgreement'?: PtsV2PaymentsPost201ResponseLinksSelf;
    'revokeAgreement'?: PtsV2PaymentsPost201ResponseLinksSelf;
    'status'?: PtsV2PaymentsPost201ResponseLinksSelf;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "self",
            "baseName": "self",
            "type": "PtsV2PaymentsPost201ResponseLinksSelf"
        },
        {
            "name": "updateAgreement",
            "baseName": "updateAgreement",
            "type": "PtsV2PaymentsPost201ResponseLinksSelf"
        },
        {
            "name": "revokeAgreement",
            "baseName": "revokeAgreement",
            "type": "PtsV2PaymentsPost201ResponseLinksSelf"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "PtsV2PaymentsPost201ResponseLinksSelf"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2CreateBillingAgreementPost201ResponseLinks.attributeTypeMap;
    }
}

export class PtsV2CreateBillingAgreementPost201ResponseProcessorInformation {
    /**
    * Authorization code. Returned only when the processor returns this value.  The length of this value depends on your processor.  Returned by authorization service.  #### PIN debit Authorization code that is returned by the processor.  Returned by PIN debit credit.  #### Elavon Encrypted Account Number Program The returned value is OFFLINE.  #### TSYS Acquiring Solutions The returned value for a successful zero amount authorization is 000000. 
    */
    'approvalCode'?: string;
    /**
    * For most processors, this is the error message sent directly from the bank. Returned only when the processor returns this value.  **Important** Do not use this field to evaluate the result of the authorization. #### SEPA/BACS Response code from the processor. Possible values: 00000–99999. See Appendix C, \"Reason Codes and Processor Response Codes,\" on page 42.  #### PIN debit Response value that is returned by the processor or bank. **Important** Do not use this field to evaluate the results of the transaction request.  Returned by PIN debit credit, PIN debit purchase, and PIN debit reversal.  #### AIBMS If this value is `08`, you can accept the transaction if the customer provides you with identification.  #### Atos This value is the response code sent from Atos and it might also include the response code from the bank. Format: `aa,bb` with the two values separated by a comma and where: - `aa` is the two-digit error message from Atos. - `bb` is the optional two-digit error message from the bank.  #### Comercio Latino This value is the status code and the error or response code received from the processor separated by a colon. Format: [status code]:E[error code] or [status code]:R[response code] Example `2:R06`  #### JCN Gateway Processor-defined detail error code. The associated response category code is in the `processorInformation.responseCategoryCode` field. String (3) 
    */
    'responseCode'?: string;
    /**
    * Transaction ID assigned by the processor. 
    */
    'transactionId'?: string;
    /**
    * Response code indicating that creating the agreement failed 
    */
    'responseDetails'?: string;
    /**
    * Numeric value corresponding to the result of the request. 
    */
    'reasonCode'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "approvalCode",
            "baseName": "approvalCode",
            "type": "string"
        },
        {
            "name": "responseCode",
            "baseName": "responseCode",
            "type": "string"
        },
        {
            "name": "transactionId",
            "baseName": "transactionId",
            "type": "string"
        },
        {
            "name": "responseDetails",
            "baseName": "responseDetails",
            "type": "string"
        },
        {
            "name": "reasonCode",
            "baseName": "reasonCode",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2CreateBillingAgreementPost201ResponseProcessorInformation.attributeTypeMap;
    }
}

export class PtsV2CreateBillingAgreementPost201ResponseRiskInformation {
    'processorResults'?: PtsV2CreateBillingAgreementPost201ResponseRiskInformationProcessorResults;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "processorResults",
            "baseName": "processorResults",
            "type": "PtsV2CreateBillingAgreementPost201ResponseRiskInformationProcessorResults"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2CreateBillingAgreementPost201ResponseRiskInformation.attributeTypeMap;
    }
}

export class PtsV2CreateBillingAgreementPost201ResponseRiskInformationProcessorResults {
    /**
    * Risk score returned by the processor. Possible values of 0-10. A value of 10 indicates a high risk. 
    */
    'riskScore'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "riskScore",
            "baseName": "riskScore",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2CreateBillingAgreementPost201ResponseRiskInformationProcessorResults.attributeTypeMap;
    }
}

export class PtsV2CreateBillingAgreementPost400Response {
    /**
    * An unique identification number generated by Cybersource to identify the submitted request. Returned by all services. It is also appended to the endpoint of the resource. On incremental authorizations, this value with be the same as the identification number returned in the original authorization response. 
    */
    'id'?: string;
    /**
    * Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ` **Example** `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.). The `T` separates the date and the time. The `Z` indicates UTC.  Returned by Cybersource for all services. 
    */
    'submitTimeUtc'?: string;
    /**
    * The status of the submitted transaction.  Possible values:  - INVALID_REQUEST 
    */
    'status'?: string;
    /**
    * The reason of the status.  Possible values:  - MISSING_FIELD  - INVALID_DATA  - DUPLICATE_REQUEST  - INVALID_MERCHANT_CONFIGURATION  - PROCESSOR_UNAVAILABLE 
    */
    'reason'?: string;
    /**
    * The detail message related to the status and reason listed above.
    */
    'message'?: string;
    'details'?: Array<PtsV2PaymentsPost201ResponseErrorInformationDetails>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "submitTimeUtc",
            "baseName": "submitTimeUtc",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "reason",
            "baseName": "reason",
            "type": "string"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        },
        {
            "name": "details",
            "baseName": "details",
            "type": "Array<PtsV2PaymentsPost201ResponseErrorInformationDetails>"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2CreateBillingAgreementPost400Response.attributeTypeMap;
    }
}

export class PtsV2CreateBillingAgreementPost502Response {
    /**
    * An unique identification number generated by Cybersource to identify the submitted request. Returned by all services. It is also appended to the endpoint of the resource. On incremental authorizations, this value with be the same as the identification number returned in the original authorization response. 
    */
    'id'?: string;
    /**
    * Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ` **Example** `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.). The `T` separates the date and the time. The `Z` indicates UTC.  Returned by Cybersource for all services. 
    */
    'submitTimeUtc'?: string;
    /**
    * The status of the submitted transaction.  Possible values:  - SERVER_ERROR 
    */
    'status'?: string;
    /**
    * The reason of the status.  Possible values:  - SYSTEM_ERROR  - SERVER_TIMEOUT  - SERVICE_TIMEOUT 
    */
    'reason'?: string;
    /**
    * The detail message related to the status and reason listed above.
    */
    'message'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "submitTimeUtc",
            "baseName": "submitTimeUtc",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "reason",
            "baseName": "reason",
            "type": "string"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2CreateBillingAgreementPost502Response.attributeTypeMap;
    }
}

export class PtsV2CreateOrderPost201Response {
    /**
    * Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ` **Example** `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.). The `T` separates the date and the time. The `Z` indicates UTC.  Returned by Cybersource for all services. 
    */
    'submitTimeUtc'?: string;
    /**
    * The date and time when the request was last updated. **Example** `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.). 
    */
    'updateTimeUtc'?: string;
    /**
    * The status of the submitted transaction. Possible values:   - CREATED   - SAVED   - APPROVED   - VOIDED   - COMPLETED   - PAYER_ACTION_REQUIRED 
    */
    'status'?: string;
    /**
    * Reference number for the transaction. Depending on how your Cybersource account is configured, this value could either be provided in the API request or generated by CyberSource. The actual value used in the request to the processor is provided back to you by Cybersource in the response. 
    */
    'reconciliationId'?: string;
    'clientReferenceInformation'?: PtsV2IncrementalAuthorizationPatch201ResponseClientReferenceInformation;
    'processorInformation'?: PtsV2CreateOrderPost201ResponseProcessorInformation;
    'paymentInformation'?: PtsV2PaymentsOrderPost201ResponsePaymentInformation;
    'buyerInformation'?: PtsV2CreateOrderPost201ResponseBuyerInformation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "submitTimeUtc",
            "baseName": "submitTimeUtc",
            "type": "string"
        },
        {
            "name": "updateTimeUtc",
            "baseName": "updateTimeUtc",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "reconciliationId",
            "baseName": "reconciliationId",
            "type": "string"
        },
        {
            "name": "clientReferenceInformation",
            "baseName": "clientReferenceInformation",
            "type": "PtsV2IncrementalAuthorizationPatch201ResponseClientReferenceInformation"
        },
        {
            "name": "processorInformation",
            "baseName": "processorInformation",
            "type": "PtsV2CreateOrderPost201ResponseProcessorInformation"
        },
        {
            "name": "paymentInformation",
            "baseName": "paymentInformation",
            "type": "PtsV2PaymentsOrderPost201ResponsePaymentInformation"
        },
        {
            "name": "buyerInformation",
            "baseName": "buyerInformation",
            "type": "PtsV2CreateOrderPost201ResponseBuyerInformation"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2CreateOrderPost201Response.attributeTypeMap;
    }
}

export class PtsV2CreateOrderPost201ResponseBuyerInformation {
    /**
    * Your identifier for the customer.  When a subscription or customer profile is being created, the maximum length for this field for most processors is 30. Otherwise, the maximum length is 100.  #### Comercio Latino For recurring payments in Mexico, the value is the customer’s contract number. Note Before you request the authorization, you must inform the issuer of the customer contract numbers that will be used for recurring transactions.  #### Worldpay VAP For a follow-on credit with Worldpay VAP, CyberSource checks the following locations, in the order given, for a customer account ID value and uses the first value it finds: 1. `customer_account_id` value in the follow-on credit request 2. Customer account ID value that was used for the capture that is being credited 3. Customer account ID value that was used for the original authorization If a customer account ID value cannot be found in any of these locations, then no value is used. 
    */
    'merchantCustomerId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "merchantCustomerId",
            "baseName": "merchantCustomerId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2CreateOrderPost201ResponseBuyerInformation.attributeTypeMap;
    }
}

export class PtsV2CreateOrderPost201ResponseProcessorInformation {
    /**
    * Network transaction identifier (TID). You can use this value to identify a specific transaction when you are discussing the transaction with your processor. Not all processors provide this value.  Returned by the authorization service.  #### PIN debit Transaction identifier generated by the processor.  Returned by PIN debit credit.  #### GPX Processor transaction ID.  #### Cielo For Cielo, this value is the non-sequential unit (NSU) and is supported for all transactions. The value is generated by Cielo or the issuing bank.  #### Comercio Latino For Comercio Latino, this value is the proof of sale or non-sequential unit (NSU) number generated by the acquirers Cielo and Rede, or the issuing bank.  #### CyberSource through VisaNet and GPN For details about this value for CyberSource through VisaNet and GPN, see \"processorInformation.networkTransactionId\" in [REST API Fields](https://developer.cybersource.com/content/dam/docs/cybs/en-us/apifields/reference/all/rest/api-fields.pdf)  #### Moneris This value identifies the transaction on a host system. It contains the following information: - Terminal used to process the transaction - Shift during which the transaction took place - Batch number - Transaction number within the batch You must store this value. If you give the customer a receipt, display this value on the receipt.  **Example** For the value 66012345001069003: - Terminal ID = 66012345 - Shift number = 001 - Batch number = 069 - Transaction number = 003 
    */
    'transactionId'?: string;
    /**
    * Same value as `processorInformation.transactionId`
    */
    'networkTransactionId'?: string;
    /**
    * Direct the customer to this URL to complete the payment.
    */
    'paymentUrl'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "transactionId",
            "baseName": "transactionId",
            "type": "string"
        },
        {
            "name": "networkTransactionId",
            "baseName": "networkTransactionId",
            "type": "string"
        },
        {
            "name": "paymentUrl",
            "baseName": "paymentUrl",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2CreateOrderPost201ResponseProcessorInformation.attributeTypeMap;
    }
}

export class PtsV2CreateOrderPost400Response {
    /**
    * Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ` **Example** `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.). The `T` separates the date and the time. The `Z` indicates UTC.  Returned by Cybersource for all services. 
    */
    'submitTimeUtc'?: string;
    /**
    * The status of the submitted transaction.  Possible values:  - INVALID_REQUEST 
    */
    'status'?: string;
    /**
    * The detail message related to the status and reason listed above.
    */
    'message'?: string;
    'details'?: Array<PtsV2PaymentsPost201ResponseErrorInformationDetails>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "submitTimeUtc",
            "baseName": "submitTimeUtc",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        },
        {
            "name": "details",
            "baseName": "details",
            "type": "Array<PtsV2PaymentsPost201ResponseErrorInformationDetails>"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2CreateOrderPost400Response.attributeTypeMap;
    }
}

export class PtsV2CreditsPost201Response {
    'links'?: PtsV2PaymentsRefundPost201ResponseLinks;
    /**
    * An unique identification number generated by Cybersource to identify the submitted request. Returned by all services. It is also appended to the endpoint of the resource. On incremental authorizations, this value with be the same as the identification number returned in the original authorization response. 
    */
    'id'?: string;
    /**
    * Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ` **Example** `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.). The `T` separates the date and the time. The `Z` indicates UTC.  Returned by Cybersource for all services. 
    */
    'submitTimeUtc'?: string;
    /**
    * The status of the submitted transaction.  Possible values:  - PENDING  - COMPLETED (as in the case of PIN Debit Full Financial Credit) 
    */
    'status'?: string;
    /**
    * Reference number for the transaction. Depending on how your Cybersource account is configured, this value could either be provided in the API request or generated by CyberSource. The actual value used in the request to the processor is provided back to you by Cybersource in the response. 
    */
    'reconciliationId'?: string;
    'clientReferenceInformation'?: PtsV2PaymentsPost201ResponseClientReferenceInformation;
    'creditAmountDetails'?: PtsV2CreditsPost201ResponseCreditAmountDetails;
    'processingInformation'?: PtsV2CreditsPost201ResponseProcessingInformation;
    'processorInformation'?: PtsV2PaymentsRefundPost201ResponseProcessorInformation;
    'paymentInformation'?: PtsV2CreditsPost201ResponsePaymentInformation;
    'orderInformation'?: PtsV2PaymentsRefundPost201ResponseOrderInformation;
    'pointOfSaleInformation'?: PtsV2PaymentsCapturesPost201ResponsePointOfSaleInformation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "PtsV2PaymentsRefundPost201ResponseLinks"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "submitTimeUtc",
            "baseName": "submitTimeUtc",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "reconciliationId",
            "baseName": "reconciliationId",
            "type": "string"
        },
        {
            "name": "clientReferenceInformation",
            "baseName": "clientReferenceInformation",
            "type": "PtsV2PaymentsPost201ResponseClientReferenceInformation"
        },
        {
            "name": "creditAmountDetails",
            "baseName": "creditAmountDetails",
            "type": "PtsV2CreditsPost201ResponseCreditAmountDetails"
        },
        {
            "name": "processingInformation",
            "baseName": "processingInformation",
            "type": "PtsV2CreditsPost201ResponseProcessingInformation"
        },
        {
            "name": "processorInformation",
            "baseName": "processorInformation",
            "type": "PtsV2PaymentsRefundPost201ResponseProcessorInformation"
        },
        {
            "name": "paymentInformation",
            "baseName": "paymentInformation",
            "type": "PtsV2CreditsPost201ResponsePaymentInformation"
        },
        {
            "name": "orderInformation",
            "baseName": "orderInformation",
            "type": "PtsV2PaymentsRefundPost201ResponseOrderInformation"
        },
        {
            "name": "pointOfSaleInformation",
            "baseName": "pointOfSaleInformation",
            "type": "PtsV2PaymentsCapturesPost201ResponsePointOfSaleInformation"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2CreditsPost201Response.attributeTypeMap;
    }
}

export class PtsV2CreditsPost201Response1 {
    /**
    * An unique identification number generated by Cybersource to identify the submitted request. Returned by all services. It is also appended to the endpoint of the resource. On incremental authorizations, this value with be the same as the identification number returned in the original authorization response. 
    */
    'id'?: string;
    /**
    * Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ` **Example** `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.). The `T` separates the date and the time. The `Z` indicates UTC.  Returned by Cybersource for all services. 
    */
    'submitTimeUtc'?: string;
    /**
    * The status of the submitted transaction.
    */
    'status'?: string;
    'processorInformation'?: PtsV2CreditsPost201Response1ProcessorInformation;
    'installmentInformation'?: PtsV2CreateBillingAgreementPost201ResponseInstallmentInformation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "submitTimeUtc",
            "baseName": "submitTimeUtc",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "processorInformation",
            "baseName": "processorInformation",
            "type": "PtsV2CreditsPost201Response1ProcessorInformation"
        },
        {
            "name": "installmentInformation",
            "baseName": "installmentInformation",
            "type": "PtsV2CreateBillingAgreementPost201ResponseInstallmentInformation"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2CreditsPost201Response1.attributeTypeMap;
    }
}

export class PtsV2CreditsPost201Response1ProcessorInformation {
    /**
    * Authorization code. Returned only when the processor returns this value.  The length of this value depends on your processor.  Returned by authorization service.  #### PIN debit Authorization code that is returned by the processor.  Returned by PIN debit credit.  #### Elavon Encrypted Account Number Program The returned value is OFFLINE.  #### TSYS Acquiring Solutions The returned value for a successful zero amount authorization is 000000. 
    */
    'approvalCode'?: string;
    /**
    * For most processors, this is the error message sent directly from the bank. Returned only when the processor returns this value.  **Important** Do not use this field to evaluate the result of the authorization.  #### PIN debit Response value that is returned by the processor or bank. **Important** Do not use this field to evaluate the results of the transaction request.  Returned by PIN debit credit, PIN debit purchase, and PIN debit reversal.  #### AIBMS If this value is `08`, you can accept the transaction if the customer provides you with identification.  #### Atos This value is the response code sent from Atos and it might also include the response code from the bank. Format: `aa,bb` with the two values separated by a comma and where: - `aa` is the two-digit error message from Atos. - `bb` is the optional two-digit error message from the bank.  #### Comercio Latino This value is the status code and the error or response code received from the processor separated by a colon. Format: [status code]:E[error code] or [status code]:R[response code] Example `2:R06`  #### JCN Gateway Processor-defined detail error code. The associated response category code is in the `processorInformation.responseCategoryCode` field. String (3)  #### paypalgateway Processor generated ID for the itemized detail. 
    */
    'responseCode'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "approvalCode",
            "baseName": "approvalCode",
            "type": "string"
        },
        {
            "name": "responseCode",
            "baseName": "responseCode",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2CreditsPost201Response1ProcessorInformation.attributeTypeMap;
    }
}

export class PtsV2CreditsPost201ResponseCreditAmountDetails {
    /**
    * Amount that was credited to the cardholder’s account.  Returned by PIN debit credit. 
    */
    'creditAmount'?: string;
    /**
    * Currency used for the order. Use the three-character [ISO Standard Currency Codes.](http://apps.cybersource.com/library/documentation/sbc/quickref/currencies.pdf)  #### Used by **Authorization** Required field.  **Authorization Reversal** For an authorization reversal (`reversalInformation`) or a capture (`processingOptions.capture` is set to `true`), you must use the same currency that you used in your payment authorization request.  #### PIN Debit Currency for the amount you requested for the PIN debit purchase. This value is returned for partial authorizations. The issuing bank can approve a partial amount if the balance on the debit card is less than the requested transaction amount. For the possible values, see the [ISO Standard Currency Codes](https://developer.cybersource.com/library/documentation/sbc/quickref/currencies.pdf). Returned by PIN debit purchase.  For PIN debit reversal requests, you must use the same currency that was used for the PIN debit purchase or PIN debit credit that you are reversing. For the possible values, see the [ISO Standard Currency Codes](https://developer.cybersource.com/library/documentation/sbc/quickref/currencies.pdf).  Required field for PIN Debit purchase and PIN Debit credit requests. Optional field for PIN Debit reversal requests.  #### GPX This field is optional for reversing an authorization or credit.  #### DCC for First Data Your local currency.  #### Tax Calculation Required for international tax and value added tax only. Optional for U.S. and Canadian taxes. Your local currency. 
    */
    'currency'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "creditAmount",
            "baseName": "creditAmount",
            "type": "string"
        },
        {
            "name": "currency",
            "baseName": "currency",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2CreditsPost201ResponseCreditAmountDetails.attributeTypeMap;
    }
}

export class PtsV2CreditsPost201ResponsePaymentInformation {
    'bank'?: PtsV2PaymentsPost201ResponsePaymentInformationBank;
    'customer'?: Ptsv2paymentsPaymentInformationCustomer;
    'paymentInstrument'?: Ptsv2paymentsPaymentInformationPaymentInstrument;
    'instrumentIdentifier'?: PtsV2PaymentsPost201ResponsePaymentInformationInstrumentIdentifier;
    'shippingAddress'?: Ptsv2paymentsPaymentInformationShippingAddress;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "bank",
            "baseName": "bank",
            "type": "PtsV2PaymentsPost201ResponsePaymentInformationBank"
        },
        {
            "name": "customer",
            "baseName": "customer",
            "type": "Ptsv2paymentsPaymentInformationCustomer"
        },
        {
            "name": "paymentInstrument",
            "baseName": "paymentInstrument",
            "type": "Ptsv2paymentsPaymentInformationPaymentInstrument"
        },
        {
            "name": "instrumentIdentifier",
            "baseName": "instrumentIdentifier",
            "type": "PtsV2PaymentsPost201ResponsePaymentInformationInstrumentIdentifier"
        },
        {
            "name": "shippingAddress",
            "baseName": "shippingAddress",
            "type": "Ptsv2paymentsPaymentInformationShippingAddress"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2CreditsPost201ResponsePaymentInformation.attributeTypeMap;
    }
}

export class PtsV2CreditsPost201ResponseProcessingInformation {
    'bankTransferOptions'?: PtsV2CreditsPost201ResponseProcessingInformationBankTransferOptions;
    /**
    * The possible values for the reply field are: - `true` : the airline data was included in the request to the processor. - `false` : the airline data was not included in the request to the processor.  Returned by authorization, capture, or credit services. 
    */
    'enhancedDataEnabled'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "bankTransferOptions",
            "baseName": "bankTransferOptions",
            "type": "PtsV2CreditsPost201ResponseProcessingInformationBankTransferOptions"
        },
        {
            "name": "enhancedDataEnabled",
            "baseName": "enhancedDataEnabled",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2CreditsPost201ResponseProcessingInformation.attributeTypeMap;
    }
}

export class PtsV2CreditsPost201ResponseProcessingInformationBankTransferOptions {
    /**
    * Method used for settlement.  Possible values: - `A`: Automated Clearing House (default for credits and for transactions using Canadian dollars) - `F`: Facsimile draft (U.S. dollars only) - `B`: Best possible (U.S. dollars only) (default if the field has not already been configured for your merchant ID) 
    */
    'settlementMethod'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "settlementMethod",
            "baseName": "settlementMethod",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2CreditsPost201ResponseProcessingInformationBankTransferOptions.attributeTypeMap;
    }
}

export class PtsV2IncrementalAuthorizationPatch201Response {
    'links'?: PtsV2IncrementalAuthorizationPatch201ResponseLinks;
    /**
    * An unique identification number generated by Cybersource to identify the submitted request. Returned by all services. It is also appended to the endpoint of the resource. On incremental authorizations, this value with be the same as the identification number returned in the original authorization response. 
    */
    'id'?: string;
    /**
    * Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ` **Example** `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.). The `T` separates the date and the time. The `Z` indicates UTC.  Returned by Cybersource for all services. 
    */
    'submitTimeUtc'?: string;
    /**
    * The status of the submitted transaction.  Possible values:  - AUTHORIZED  - AUTHORIZED_PENDING_REVIEW  - DECLINED 
    */
    'status'?: string;
    /**
    * Reference number for the transaction. Depending on how your Cybersource account is configured, this value could either be provided in the API request or generated by CyberSource. The actual value used in the request to the processor is provided back to you by Cybersource in the response. 
    */
    'reconciliationId'?: string;
    'errorInformation'?: PtsV2IncrementalAuthorizationPatch201ResponseErrorInformation;
    'clientReferenceInformation'?: PtsV2IncrementalAuthorizationPatch201ResponseClientReferenceInformation;
    'processorInformation'?: PtsV2IncrementalAuthorizationPatch201ResponseProcessorInformation;
    'paymentInformation'?: PtsV2IncrementalAuthorizationPatch201ResponsePaymentInformation;
    'orderInformation'?: PtsV2IncrementalAuthorizationPatch201ResponseOrderInformation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "PtsV2IncrementalAuthorizationPatch201ResponseLinks"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "submitTimeUtc",
            "baseName": "submitTimeUtc",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "reconciliationId",
            "baseName": "reconciliationId",
            "type": "string"
        },
        {
            "name": "errorInformation",
            "baseName": "errorInformation",
            "type": "PtsV2IncrementalAuthorizationPatch201ResponseErrorInformation"
        },
        {
            "name": "clientReferenceInformation",
            "baseName": "clientReferenceInformation",
            "type": "PtsV2IncrementalAuthorizationPatch201ResponseClientReferenceInformation"
        },
        {
            "name": "processorInformation",
            "baseName": "processorInformation",
            "type": "PtsV2IncrementalAuthorizationPatch201ResponseProcessorInformation"
        },
        {
            "name": "paymentInformation",
            "baseName": "paymentInformation",
            "type": "PtsV2IncrementalAuthorizationPatch201ResponsePaymentInformation"
        },
        {
            "name": "orderInformation",
            "baseName": "orderInformation",
            "type": "PtsV2IncrementalAuthorizationPatch201ResponseOrderInformation"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2IncrementalAuthorizationPatch201Response.attributeTypeMap;
    }
}

export class PtsV2IncrementalAuthorizationPatch201ResponseClientReferenceInformation {
    /**
    * Merchant-generated order reference or tracking number. It is recommended that you send a unique value for each transaction so that you can perform meaningful searches for the transaction.  #### Used by **Authorization** Required field.  #### PIN Debit Requests for PIN debit reversals need to use the same merchant reference number that was used in the transaction that is being reversed.  Required field for all PIN Debit requests (purchase, credit, and reversal).  #### FDC Nashville Global Certain circumstances can cause the processor to truncate this value to 15 or 17 characters for Level II and Level III processing, which can cause a discrepancy between the value you submit and the value included in some processor reports. 
    */
    'code'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2IncrementalAuthorizationPatch201ResponseClientReferenceInformation.attributeTypeMap;
    }
}

export class PtsV2IncrementalAuthorizationPatch201ResponseErrorInformation {
    /**
    * The reason of the status.  Possible values:   - AVS_FAILED   - CONTACT_PROCESSOR   - EXPIRED_CARD   - PROCESSOR_DECLINED   - INSUFFICIENT_FUND   - STOLEN_LOST_CARD   - ISSUER_UNAVAILABLE   - UNAUTHORIZED_CARD   - CVN_NOT_MATCH   - EXCEEDS_CREDIT_LIMIT   - INVALID_CVN   - BLOCKED_BY_CARDHOLDER   - BLACKLISTED_CUSTOMER   - SUSPENDED_ACCOUNT   - PAYMENT_REFUSED   - CV_FAILED   - INVALID_ACCOUNT   - GENERAL_DECLINE   - INVALID_MERCHANT_CONFIGURATION   - DECISION_PROFILE_REJECT   - SCORE_EXCEEDS_THRESHOLD   - CONSUMER_AUTHENTICATION_REQUIRED   - ALLOWABLE_PIN_RETRIES_EXCEEDED   - PROCESSOR_ERROR 
    */
    'reason'?: string;
    /**
    * The detail message related to the status and reason listed above.
    */
    'message'?: string;
    'details'?: Array<PtsV2PaymentsPost201ResponseErrorInformationDetails>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "reason",
            "baseName": "reason",
            "type": "string"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        },
        {
            "name": "details",
            "baseName": "details",
            "type": "Array<PtsV2PaymentsPost201ResponseErrorInformationDetails>"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2IncrementalAuthorizationPatch201ResponseErrorInformation.attributeTypeMap;
    }
}

export class PtsV2IncrementalAuthorizationPatch201ResponseLinks {
    'self'?: PtsV2PaymentsPost201ResponseLinksSelf;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "self",
            "baseName": "self",
            "type": "PtsV2PaymentsPost201ResponseLinksSelf"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2IncrementalAuthorizationPatch201ResponseLinks.attributeTypeMap;
    }
}

export class PtsV2IncrementalAuthorizationPatch201ResponseOrderInformation {
    'amountDetails'?: PtsV2PaymentsPost201ResponseOrderInformationAmountDetails;
    'invoiceDetails'?: PtsV2IncrementalAuthorizationPatch201ResponseOrderInformationInvoiceDetails;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "amountDetails",
            "baseName": "amountDetails",
            "type": "PtsV2PaymentsPost201ResponseOrderInformationAmountDetails"
        },
        {
            "name": "invoiceDetails",
            "baseName": "invoiceDetails",
            "type": "PtsV2IncrementalAuthorizationPatch201ResponseOrderInformationInvoiceDetails"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2IncrementalAuthorizationPatch201ResponseOrderInformation.attributeTypeMap;
    }
}

export class PtsV2IncrementalAuthorizationPatch201ResponseOrderInformationInvoiceDetails {
    /**
    * Product identifier code. Also known as the Stock Keeping Unit (SKU) code for the product. 
    */
    'productId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "productId",
            "baseName": "productId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2IncrementalAuthorizationPatch201ResponseOrderInformationInvoiceDetails.attributeTypeMap;
    }
}

export class PtsV2IncrementalAuthorizationPatch201ResponsePaymentInformation {
    'accountFeatures'?: PtsV2IncrementalAuthorizationPatch201ResponsePaymentInformationAccountFeatures;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "accountFeatures",
            "baseName": "accountFeatures",
            "type": "PtsV2IncrementalAuthorizationPatch201ResponsePaymentInformationAccountFeatures"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2IncrementalAuthorizationPatch201ResponsePaymentInformation.attributeTypeMap;
    }
}

export class PtsV2IncrementalAuthorizationPatch201ResponsePaymentInformationAccountFeatures {
    /**
    * #### GPX Mastercard product ID associated with the primary account number (PAN). Returned by authorization service.  #### CyberSource through VisaNet Visa or Mastercard product ID that is associated with the primary account number (PAN). For descriptions of the Visa product IDs, see the Product ID table on the [Visa Request & Response Codes web page.](https://developer.visa.com/guides/request_response_codes)  Data Length: String (3)  #### GPN Visa or Mastercard product ID that is associated with the primary account number (PAN). For descriptions of the Visa product IDs, see the Product ID table on the [Visa Request & Response Codes web page.](https://developer.visa.com/guides/request_response_codes)  Data Length: String (3)  #### Worldpay VAP **Important** Before using this field on Worldpay VAP, you must contact CyberSource Customer Support to have your account configured for this feature.  Type of card used in the transaction. The only possible value is: - `PREPAID`: Prepaid Card  Data Length: String (7)  #### RBS WorldPay Atlanta Type of card used in the transaction. Possible values: - `B`: Business Card - `O`: Noncommercial Card - `R`: Corporate Card - `S`: Purchase Card - `Blank`: Purchase card not supported  Data Length: String (1) 
    */
    'category'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "category",
            "baseName": "category",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2IncrementalAuthorizationPatch201ResponsePaymentInformationAccountFeatures.attributeTypeMap;
    }
}

export class PtsV2IncrementalAuthorizationPatch201ResponseProcessorInformation {
    /**
    * Authorization code. Returned only when the processor returns this value.  The length of this value depends on your processor.  Returned by authorization service.  #### PIN debit Authorization code that is returned by the processor.  Returned by PIN debit credit.  #### Elavon Encrypted Account Number Program The returned value is OFFLINE.  #### TSYS Acquiring Solutions The returned value for a successful zero amount authorization is 000000. 
    */
    'approvalCode'?: string;
    /**
    * Network transaction identifier (TID). You can use this value to identify a specific transaction when you are discussing the transaction with your processor. Not all processors provide this value.  Returned by the authorization service.  #### PIN debit Transaction identifier generated by the processor.  Returned by PIN debit credit.  #### GPX Processor transaction ID.  #### Cielo For Cielo, this value is the non-sequential unit (NSU) and is supported for all transactions. The value is generated by Cielo or the issuing bank.  #### Comercio Latino For Comercio Latino, this value is the proof of sale or non-sequential unit (NSU) number generated by the acquirers Cielo and Rede, or the issuing bank.  #### CyberSource through VisaNet and GPN For details about this value for CyberSource through VisaNet and GPN, see \"processorInformation.networkTransactionId\" in [REST API Fields](https://developer.cybersource.com/content/dam/docs/cybs/en-us/apifields/reference/all/rest/api-fields.pdf)  #### Moneris This value identifies the transaction on a host system. It contains the following information: - Terminal used to process the transaction - Shift during which the transaction took place - Batch number - Transaction number within the batch You must store this value. If you give the customer a receipt, display this value on the receipt.  **Example** For the value 66012345001069003: - Terminal ID = 66012345 - Shift number = 001 - Batch number = 069 - Transaction number = 003 
    */
    'transactionId'?: string;
    /**
    * Same value as `processorInformation.transactionId`
    */
    'networkTransactionId'?: string;
    /**
    * For most processors, this is the error message sent directly from the bank. Returned only when the processor returns this value.  **Important** Do not use this field to evaluate the result of the authorization.  #### PIN debit Response value that is returned by the processor or bank. **Important** Do not use this field to evaluate the results of the transaction request.  Returned by PIN debit credit, PIN debit purchase, and PIN debit reversal.  #### AIBMS If this value is `08`, you can accept the transaction if the customer provides you with identification.  #### Atos This value is the response code sent from Atos and it might also include the response code from the bank. Format: `aa,bb` with the two values separated by a comma and where: - `aa` is the two-digit error message from Atos. - `bb` is the optional two-digit error message from the bank.  #### Comercio Latino This value is the status code and the error or response code received from the processor separated by a colon. Format: [status code]:E[error code] or [status code]:R[response code] Example `2:R06`  #### JCN Gateway Processor-defined detail error code. The associated response category code is in the `processorInformation.responseCategoryCode` field. String (3)  #### paypalgateway Processor generated ID for the itemized detail. 
    */
    'responseCode'?: string;
    /**
    * This field is returned only for **American Express Direct** and **CyberSource through VisaNet**. Returned by authorization and incremental authorization services.  #### American Express Direct  System trace audit number (STAN). This value identifies the transaction and is useful when investigating a chargeback dispute.  #### CyberSource through VisaNet  System trace number that must be printed on the customer’s receipt. 
    */
    'systemTraceAuditNumber'?: string;
    /**
    * This field might contain information about a decline. This field is supported only for **CyberSource through VisaNet**. 
    */
    'responseDetails'?: string;
    'merchantAdvice'?: PtsV2PaymentsPost201ResponseProcessorInformationMerchantAdvice;
    /**
    * Mastercard is introducing the Merchant Risk Predict Service in the middle East/Africa Region. A newly launched service comprised of seven independent artificial intelligence (AI)-powered scores intended to augment existing merchant risk management practices. 
    */
    'merchantRiskPrediction'?: string;
    'sellerProtection'?: PtsV2PaymentsPost201ResponseProcessorInformationSellerProtection;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "approvalCode",
            "baseName": "approvalCode",
            "type": "string"
        },
        {
            "name": "transactionId",
            "baseName": "transactionId",
            "type": "string"
        },
        {
            "name": "networkTransactionId",
            "baseName": "networkTransactionId",
            "type": "string"
        },
        {
            "name": "responseCode",
            "baseName": "responseCode",
            "type": "string"
        },
        {
            "name": "systemTraceAuditNumber",
            "baseName": "systemTraceAuditNumber",
            "type": "string"
        },
        {
            "name": "responseDetails",
            "baseName": "responseDetails",
            "type": "string"
        },
        {
            "name": "merchantAdvice",
            "baseName": "merchantAdvice",
            "type": "PtsV2PaymentsPost201ResponseProcessorInformationMerchantAdvice"
        },
        {
            "name": "merchantRiskPrediction",
            "baseName": "merchantRiskPrediction",
            "type": "string"
        },
        {
            "name": "sellerProtection",
            "baseName": "sellerProtection",
            "type": "PtsV2PaymentsPost201ResponseProcessorInformationSellerProtection"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2IncrementalAuthorizationPatch201ResponseProcessorInformation.attributeTypeMap;
    }
}

export class PtsV2IncrementalAuthorizationPatch400Response {
    /**
    * Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ` **Example** `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.). The `T` separates the date and the time. The `Z` indicates UTC.  Returned by Cybersource for all services. 
    */
    'submitTimeUtc'?: string;
    /**
    * The status of the submitted transaction.  Possible values:  - INVALID_REQUEST 
    */
    'status'?: string;
    /**
    * The reason of the status.  Possible values:  - MISSING_FIELD  - INVALID_DATA  - DUPLICATE_REQUEST  - INVALID_CARD  - CARD_TYPE_NOT_ACCEPTED  - INVALID_MERCHANT_CONFIGURATION  - PROCESSOR_UNAVAILABLE  - INVALID_PAYMENT_ID  - NOT_SUPPORTED 
    */
    'reason'?: string;
    /**
    * The detail message related to the status and reason listed above.
    */
    'message'?: string;
    'details'?: Array<PtsV2PaymentsPost201ResponseErrorInformationDetails>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "submitTimeUtc",
            "baseName": "submitTimeUtc",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "reason",
            "baseName": "reason",
            "type": "string"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        },
        {
            "name": "details",
            "baseName": "details",
            "type": "Array<PtsV2PaymentsPost201ResponseErrorInformationDetails>"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2IncrementalAuthorizationPatch400Response.attributeTypeMap;
    }
}

export class PtsV2ModifyBillingAgreementPost201Response {
    'links'?: PtsV2ModifyBillingAgreementPost201ResponseLinks;
    /**
    * An unique identification number generated by Cybersource to identify the submitted request. Returned by all services. It is also appended to the endpoint of the resource. On incremental authorizations, this value with be the same as the identification number returned in the original authorization response. 
    */
    'id'?: string;
    /**
    * Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ` **Example** `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.). The `T` separates the date and the time. The `Z` indicates UTC.  Returned by Cybersource for all services. 
    */
    'submitTimeUtc'?: string;
    /**
    * The status of the billing agreement. Possible value is:   - PENDING   - REVOKED   - ACTIVE   - FAILED   - EXPIRED   - INACTIVE 
    */
    'status'?: string;
    'processorInformation'?: PtsV2CreateBillingAgreementPost201ResponseProcessorInformation;
    'installmentInformation'?: PtsV2CreateBillingAgreementPost201ResponseInstallmentInformation;
    'clientReferenceInformation'?: PtsV2CreateBillingAgreementPost201ResponseClientReferenceInformation;
    'riskInformation'?: PtsV2CreateBillingAgreementPost201ResponseRiskInformation;
    'agreementInformation'?: PtsV2ModifyBillingAgreementPost201ResponseAgreementInformation;
    'orderInformation'?: PtsV2ModifyBillingAgreementPost201ResponseOrderInformation;
    'paymentInformation'?: PtsV2ModifyBillingAgreementPost201ResponsePaymentInformation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "PtsV2ModifyBillingAgreementPost201ResponseLinks"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "submitTimeUtc",
            "baseName": "submitTimeUtc",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "processorInformation",
            "baseName": "processorInformation",
            "type": "PtsV2CreateBillingAgreementPost201ResponseProcessorInformation"
        },
        {
            "name": "installmentInformation",
            "baseName": "installmentInformation",
            "type": "PtsV2CreateBillingAgreementPost201ResponseInstallmentInformation"
        },
        {
            "name": "clientReferenceInformation",
            "baseName": "clientReferenceInformation",
            "type": "PtsV2CreateBillingAgreementPost201ResponseClientReferenceInformation"
        },
        {
            "name": "riskInformation",
            "baseName": "riskInformation",
            "type": "PtsV2CreateBillingAgreementPost201ResponseRiskInformation"
        },
        {
            "name": "agreementInformation",
            "baseName": "agreementInformation",
            "type": "PtsV2ModifyBillingAgreementPost201ResponseAgreementInformation"
        },
        {
            "name": "orderInformation",
            "baseName": "orderInformation",
            "type": "PtsV2ModifyBillingAgreementPost201ResponseOrderInformation"
        },
        {
            "name": "paymentInformation",
            "baseName": "paymentInformation",
            "type": "PtsV2ModifyBillingAgreementPost201ResponsePaymentInformation"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2ModifyBillingAgreementPost201Response.attributeTypeMap;
    }
}

export class PtsV2ModifyBillingAgreementPost201ResponseAgreementInformation {
    /**
    * Identifier for the mandate. 
    */
    'id'?: string;
    /**
    * Date the mandate has been signed.  Format YYYYMMdd
    */
    'dateSigned'?: string;
    /**
    * Date the mandate has been created.  Format YYYYMMdd
    */
    'dateCreated'?: string;
    /**
    * Date the mandate has been revoked.  Format YYYYMMdd
    */
    'dateRevoked'?: string;
    /**
    * Base64 encoded html string
    */
    'encodedHtml'?: string;
    /**
    * Base64 encoded popup html string
    */
    'encodedHtmlPopup'?: string;
    /**
    * URL for redirecting the customer for creating the mandate. 
    */
    'url'?: string;
    /**
    * The Billing Agreement ID returned by processor (PayPal). 
    */
    'transactionId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "dateSigned",
            "baseName": "dateSigned",
            "type": "string"
        },
        {
            "name": "dateCreated",
            "baseName": "dateCreated",
            "type": "string"
        },
        {
            "name": "dateRevoked",
            "baseName": "dateRevoked",
            "type": "string"
        },
        {
            "name": "encodedHtml",
            "baseName": "encodedHtml",
            "type": "string"
        },
        {
            "name": "encodedHtmlPopup",
            "baseName": "encodedHtmlPopup",
            "type": "string"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        },
        {
            "name": "transactionId",
            "baseName": "transactionId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2ModifyBillingAgreementPost201ResponseAgreementInformation.attributeTypeMap;
    }
}

export class PtsV2ModifyBillingAgreementPost201ResponseLinks {
    'self'?: PtsV2PaymentsPost201ResponseLinksSelf;
    'status'?: PtsV2PaymentsPost201ResponseLinksSelf;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "self",
            "baseName": "self",
            "type": "PtsV2PaymentsPost201ResponseLinksSelf"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "PtsV2PaymentsPost201ResponseLinksSelf"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2ModifyBillingAgreementPost201ResponseLinks.attributeTypeMap;
    }
}

export class PtsV2ModifyBillingAgreementPost201ResponseOrderInformation {
    'billTo'?: PtsV2ModifyBillingAgreementPost201ResponseOrderInformationBillTo;
    'shipTo'?: PtsV2ModifyBillingAgreementPost201ResponseOrderInformationShipTo;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "billTo",
            "baseName": "billTo",
            "type": "PtsV2ModifyBillingAgreementPost201ResponseOrderInformationBillTo"
        },
        {
            "name": "shipTo",
            "baseName": "shipTo",
            "type": "PtsV2ModifyBillingAgreementPost201ResponseOrderInformationShipTo"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2ModifyBillingAgreementPost201ResponseOrderInformation.attributeTypeMap;
    }
}

export class PtsV2ModifyBillingAgreementPost201ResponseOrderInformationBillTo {
    /**
    * Customer’s first name. 
    */
    'firstName'?: string;
    /**
    * Customer’s last name. 
    */
    'lastName'?: string;
    /**
    * First line of the billing street address. 
    */
    'address1'?: string;
    /**
    * Additional address information. Example: Attention - Accounts Payable 
    */
    'address2'?: string;
    /**
    * City of the billing address. 
    */
    'locality'?: string;
    /**
    * State of the billing address in the U.S. 
    */
    'administrativeArea'?: string;
    /**
    * Postal code for the billing address. The postal code must consist of 5 to 9 digits. A 9-digit postal code must follow this format: [5 digits][dash][4 digits]  Example: 12345-6789\" 
    */
    'postalCode'?: string;
    /**
    * Billing country. Use the two character ISO Standard Country Codes. 
    */
    'country'?: string;
    /**
    * Customer’s email address, including the full domain name. 
    */
    'email'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "firstName",
            "baseName": "firstName",
            "type": "string"
        },
        {
            "name": "lastName",
            "baseName": "lastName",
            "type": "string"
        },
        {
            "name": "address1",
            "baseName": "address1",
            "type": "string"
        },
        {
            "name": "address2",
            "baseName": "address2",
            "type": "string"
        },
        {
            "name": "locality",
            "baseName": "locality",
            "type": "string"
        },
        {
            "name": "administrativeArea",
            "baseName": "administrativeArea",
            "type": "string"
        },
        {
            "name": "postalCode",
            "baseName": "postalCode",
            "type": "string"
        },
        {
            "name": "country",
            "baseName": "country",
            "type": "string"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2ModifyBillingAgreementPost201ResponseOrderInformationBillTo.attributeTypeMap;
    }
}

export class PtsV2ModifyBillingAgreementPost201ResponseOrderInformationShipTo {
    /**
    * First name of the recipient. 
    */
    'firstName'?: string;
    /**
    * Last name of the recipient. 
    */
    'lastName'?: string;
    /**
    * First line of the shipping address. 
    */
    'address1'?: string;
    /**
    * Second line of the shipping address. 
    */
    'address2'?: string;
    /**
    * City of the shipping address. 
    */
    'locality'?: string;
    /**
    * State or province of the shipping address. Use the [State, Province, and Territory Codes for the United States and Canada](https://developer.cybersource.com/library/documentation/sbc/quickref/states_and_provinces.pdf) (maximum length: 2) 
    */
    'administrativeArea'?: string;
    /**
    * Postal code for the shipping address. The postal code must consist of 5 to 9 digits. 
    */
    'postalCode'?: string;
    /**
    * Country of the shipping address. Use the two-character [ISO Standard Country Codes.](http://apps.cybersource.com/library/documentation/sbc/quickref/countries_alpha_list.pdf) 
    */
    'country'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "firstName",
            "baseName": "firstName",
            "type": "string"
        },
        {
            "name": "lastName",
            "baseName": "lastName",
            "type": "string"
        },
        {
            "name": "address1",
            "baseName": "address1",
            "type": "string"
        },
        {
            "name": "address2",
            "baseName": "address2",
            "type": "string"
        },
        {
            "name": "locality",
            "baseName": "locality",
            "type": "string"
        },
        {
            "name": "administrativeArea",
            "baseName": "administrativeArea",
            "type": "string"
        },
        {
            "name": "postalCode",
            "baseName": "postalCode",
            "type": "string"
        },
        {
            "name": "country",
            "baseName": "country",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2ModifyBillingAgreementPost201ResponseOrderInformationShipTo.attributeTypeMap;
    }
}

export class PtsV2ModifyBillingAgreementPost201ResponsePaymentInformation {
    'eWallet'?: PtsV2ModifyBillingAgreementPost201ResponsePaymentInformationEWallet;
    'bank'?: PtsV2ModifyBillingAgreementPost201ResponsePaymentInformationBank;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "eWallet",
            "baseName": "eWallet",
            "type": "PtsV2ModifyBillingAgreementPost201ResponsePaymentInformationEWallet"
        },
        {
            "name": "bank",
            "baseName": "bank",
            "type": "PtsV2ModifyBillingAgreementPost201ResponsePaymentInformationBank"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2ModifyBillingAgreementPost201ResponsePaymentInformation.attributeTypeMap;
    }
}

export class PtsV2ModifyBillingAgreementPost201ResponsePaymentInformationBank {
    /**
    * International Bank Account Number (IBAN). 
    */
    'iban'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "iban",
            "baseName": "iban",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2ModifyBillingAgreementPost201ResponsePaymentInformationBank.attributeTypeMap;
    }
}

export class PtsV2ModifyBillingAgreementPost201ResponsePaymentInformationEWallet {
    /**
    * The ID of the customer, passed in the return_url field by PayPal after customer approval. 
    */
    'accountId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "accountId",
            "baseName": "accountId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2ModifyBillingAgreementPost201ResponsePaymentInformationEWallet.attributeTypeMap;
    }
}

export class PtsV2PaymentsCapturesPost201Response {
    'links'?: PtsV2PaymentsCapturesPost201ResponseLinks;
    /**
    * An unique identification number generated by Cybersource to identify the submitted request. Returned by all services. It is also appended to the endpoint of the resource. On incremental authorizations, this value with be the same as the identification number returned in the original authorization response. 
    */
    'id'?: string;
    /**
    * Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ` **Example** `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.). The `T` separates the date and the time. The `Z` indicates UTC.  Returned by Cybersource for all services. 
    */
    'submitTimeUtc'?: string;
    /**
    * The status of the submitted transaction.  Possible values:  - PENDING  - TRANSMITTED (Only for Online Capture enabled merchants) 
    */
    'status'?: string;
    /**
    * Reference number for the transaction. Depending on how your Cybersource account is configured, this value could either be provided in the API request or generated by CyberSource. The actual value used in the request to the processor is provided back to you by Cybersource in the response. 
    */
    'reconciliationId'?: string;
    'clientReferenceInformation'?: PtsV2PaymentsPost201ResponseClientReferenceInformation;
    'processorInformation'?: PtsV2PaymentsCapturesPost201ResponseProcessorInformation;
    'orderInformation'?: PtsV2PaymentsCapturesPost201ResponseOrderInformation;
    'pointOfSaleInformation'?: PtsV2PaymentsCapturesPost201ResponsePointOfSaleInformation;
    'processingInformation'?: PtsV2PaymentsCapturesPost201ResponseProcessingInformation;
    'embeddedActions'?: PtsV2PaymentsCapturesPost201ResponseEmbeddedActions;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "PtsV2PaymentsCapturesPost201ResponseLinks"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "submitTimeUtc",
            "baseName": "submitTimeUtc",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "reconciliationId",
            "baseName": "reconciliationId",
            "type": "string"
        },
        {
            "name": "clientReferenceInformation",
            "baseName": "clientReferenceInformation",
            "type": "PtsV2PaymentsPost201ResponseClientReferenceInformation"
        },
        {
            "name": "processorInformation",
            "baseName": "processorInformation",
            "type": "PtsV2PaymentsCapturesPost201ResponseProcessorInformation"
        },
        {
            "name": "orderInformation",
            "baseName": "orderInformation",
            "type": "PtsV2PaymentsCapturesPost201ResponseOrderInformation"
        },
        {
            "name": "pointOfSaleInformation",
            "baseName": "pointOfSaleInformation",
            "type": "PtsV2PaymentsCapturesPost201ResponsePointOfSaleInformation"
        },
        {
            "name": "processingInformation",
            "baseName": "processingInformation",
            "type": "PtsV2PaymentsCapturesPost201ResponseProcessingInformation"
        },
        {
            "name": "embeddedActions",
            "baseName": "embeddedActions",
            "type": "PtsV2PaymentsCapturesPost201ResponseEmbeddedActions"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsCapturesPost201Response.attributeTypeMap;
    }
}

export class PtsV2PaymentsCapturesPost201ResponseEmbeddedActions {
    'apCapture'?: PtsV2PaymentsCapturesPost201ResponseEmbeddedActionsApCapture;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "apCapture",
            "baseName": "ap_capture",
            "type": "PtsV2PaymentsCapturesPost201ResponseEmbeddedActionsApCapture"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsCapturesPost201ResponseEmbeddedActions.attributeTypeMap;
    }
}

export class PtsV2PaymentsCapturesPost201ResponseEmbeddedActionsApCapture {
    /**
    * The reason why the captured payment status is PENDING or DENIED. BUYER_COMPLAINT The payer initiated a dispute for this captured payment with processor. CHARGEBACK The captured funds were reversed in response to the payer disputing this captured payment with the issuer of the financial instrument used to pay for this captured payment. ECHECK The payer paid by an eCheck that has not yet cleared. INTERNATIONAL_WITHDRAWAL Visit your online account. In your Account Overview, accept and deny this payment. OTHER No additional specific reason can be provided. For more information about this captured payment, visit your account online or contact processor. PENDING_REVIEW The captured payment is pending manual review. RECEIVING_PREFERENCE_MANDATES_MANUAL_ACTION The payee has not yet set up appropriate receiving preferences for their account. For more information about how to accept or deny this payment, visit your account online. This reason is typically offered in scenarios such as when the currency of the captured payment is different from the primary holding currency of the payee. REFUNDED The captured funds were refunded. TRANSACTION_APPROVED_AWAITING_FUNDING The payer must send the funds for this captured payment. This code generally appears for manual EFTs. UNILATERAL The payee does not have a processor account. VERIFICATION_REQUIRED The payee's processor account is not verified. String with values,  `BUYER_COMPLAINT`  `CHARGEBACK`  `ECHECK`  `INTERNATIONAL_WITHDRAWAL`  `OTHER`  `PENDING_REVIEW`  `RECEIVING_PREFERENCE_MANDATES_MANUAL_ACTION`  `REFUNDED`  `TRANSACTION_APPROVED_AWAITING_FUNDING`  `UNILATERAL`  `VERIFICATION_REQUIRED` 
    */
    'reason'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "reason",
            "baseName": "reason",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsCapturesPost201ResponseEmbeddedActionsApCapture.attributeTypeMap;
    }
}

export class PtsV2PaymentsCapturesPost201ResponseLinks {
    'self'?: PtsV2PaymentsPost201ResponseLinksSelf;
    '_void'?: PtsV2PaymentsPost201ResponseLinksSelf;
    'refund'?: PtsV2PaymentsPost201ResponseLinksSelf;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "self",
            "baseName": "self",
            "type": "PtsV2PaymentsPost201ResponseLinksSelf"
        },
        {
            "name": "_void",
            "baseName": "void",
            "type": "PtsV2PaymentsPost201ResponseLinksSelf"
        },
        {
            "name": "refund",
            "baseName": "refund",
            "type": "PtsV2PaymentsPost201ResponseLinksSelf"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsCapturesPost201ResponseLinks.attributeTypeMap;
    }
}

export class PtsV2PaymentsCapturesPost201ResponseOrderInformation {
    'amountDetails'?: PtsV2PaymentsCapturesPost201ResponseOrderInformationAmountDetails;
    'invoiceDetails'?: PtsV2PaymentsCapturesPost201ResponseOrderInformationInvoiceDetails;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "amountDetails",
            "baseName": "amountDetails",
            "type": "PtsV2PaymentsCapturesPost201ResponseOrderInformationAmountDetails"
        },
        {
            "name": "invoiceDetails",
            "baseName": "invoiceDetails",
            "type": "PtsV2PaymentsCapturesPost201ResponseOrderInformationInvoiceDetails"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsCapturesPost201ResponseOrderInformation.attributeTypeMap;
    }
}

export class PtsV2PaymentsCapturesPost201ResponseOrderInformationAmountDetails {
    /**
    * Amount you requested for the capture. 
    */
    'totalAmount'?: string;
    /**
    * Currency used for the order. Use the three-character [ISO Standard Currency Codes.](http://apps.cybersource.com/library/documentation/sbc/quickref/currencies.pdf)  #### Used by **Authorization** Required field.  **Authorization Reversal** For an authorization reversal (`reversalInformation`) or a capture (`processingOptions.capture` is set to `true`), you must use the same currency that you used in your payment authorization request.  #### PIN Debit Currency for the amount you requested for the PIN debit purchase. This value is returned for partial authorizations. The issuing bank can approve a partial amount if the balance on the debit card is less than the requested transaction amount. For the possible values, see the [ISO Standard Currency Codes](https://developer.cybersource.com/library/documentation/sbc/quickref/currencies.pdf). Returned by PIN debit purchase.  For PIN debit reversal requests, you must use the same currency that was used for the PIN debit purchase or PIN debit credit that you are reversing. For the possible values, see the [ISO Standard Currency Codes](https://developer.cybersource.com/library/documentation/sbc/quickref/currencies.pdf).  Required field for PIN Debit purchase and PIN Debit credit requests. Optional field for PIN Debit reversal requests.  #### GPX This field is optional for reversing an authorization or credit.  #### DCC for First Data Your local currency.  #### Tax Calculation Required for international tax and value added tax only. Optional for U.S. and Canadian taxes. Your local currency. 
    */
    'currency'?: string;
    /**
    * The fee decided by the PSP/Processor per transaction.
    */
    'processorTransactionFee'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "totalAmount",
            "baseName": "totalAmount",
            "type": "string"
        },
        {
            "name": "currency",
            "baseName": "currency",
            "type": "string"
        },
        {
            "name": "processorTransactionFee",
            "baseName": "processorTransactionFee",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsCapturesPost201ResponseOrderInformationAmountDetails.attributeTypeMap;
    }
}

export class PtsV2PaymentsCapturesPost201ResponseOrderInformationInvoiceDetails {
    /**
    * Indicates whether CyberSource sent the Level III information to the processor. The possible values are:  If your account is not enabled for Level III data or if you did not include the purchasing level field in your request, CyberSource does not include the Level III data in the request sent to the processor.  Possible values: - **true** - **false** 
    */
    'level3TransmissionStatus'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "level3TransmissionStatus",
            "baseName": "level3TransmissionStatus",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsCapturesPost201ResponseOrderInformationInvoiceDetails.attributeTypeMap;
    }
}

export class PtsV2PaymentsCapturesPost201ResponsePointOfSaleInformation {
    /**
    * Identifier for the terminal at your retail location. You can define this value yourself, but consult the processor for requirements.  #### CyberSource through VisaNet A list of all possible values is stored in your CyberSource account. If terminal ID validation is enabled for your CyberSource account, the value you send for this field is validated against the list each time you include the field in a request. To enable or disable terminal ID validation, contact CyberSource Customer Support.  When you do not include this field in a request, CyberSource uses the default value that is defined in your CyberSource account.  #### FDC Nashville Global To have your account configured to support this field, contact CyberSource Customer Support. This value must be a value that FDC Nashville Global issued to you.  #### For Payouts This field is applicable for CyberSource through VisaNet.  #### GPX Identifier for the terminal at your retail location. A list of all possible values is stored in your account. If terminal ID validation is enabled for your account, the value you send for this field is validated against the list each time you include the field in a request. To enable or disable terminal ID validation, contact customer support.  When you do not include this field in a request, the default value that is defined in your account is used.  Optional for authorizations.  #### Used by **Authorization** Optional for the following processors. When you do not include this field in a request, the default value that is defined in your account is used.   - American Express Direct   - Credit Mutuel-CIC   - FDC Nashville Global   - SIX - Chase Paymentech Solutions: Optional field. If you include this field in your request, you must also include `pointOfSaleInformation.catLevel`. - FDMS Nashville: The default value that is defined in your account is used. - GPX - OmniPay Direct: Optional field.  For the following processors, this field is not used. - GPN - JCN Gateway - RBS WorldPay Atlanta - TSYS Acquiring Solutions - Worldpay VAP  #### Card Present reply Terminal identifier assigned by the acquirer. This value must be printed on the receipt. 
    */
    'terminalId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "terminalId",
            "baseName": "terminalId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsCapturesPost201ResponsePointOfSaleInformation.attributeTypeMap;
    }
}

export class PtsV2PaymentsCapturesPost201ResponseProcessingInformation {
    /**
    * The possible values for the reply field are: - `true` : the airline data was included in the request to the processor. - `false` : the airline data was not included in the request to the processor.  Returned by authorization, capture, or credit services. 
    */
    'enhancedDataEnabled'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "enhancedDataEnabled",
            "baseName": "enhancedDataEnabled",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsCapturesPost201ResponseProcessingInformation.attributeTypeMap;
    }
}

export class PtsV2PaymentsCapturesPost201ResponseProcessorInformation {
    /**
    * Processor transaction ID.  This value identifies the transaction on a host system. This value is supported only for Moneris. It contains this information:   - Terminal used to process the transaction  - Shift during which the transaction took place  - Batch number  - Transaction number within the batch  You must store this value. If you give the customer a receipt, display this value on the receipt.  Example For the value 66012345001069003:   - Terminal ID = 66012345  - Shift number = 001  - Batch number = 069  - Transaction number = 003 
    */
    'transactionId'?: string;
    /**
    * Network Transaction Identifier Applicable for online capture transactions only. 
    */
    'networkTransactionId'?: string;
    /**
    * The processor code that describes why the transaction state is pending or reversed. 
    */
    'responseDetails'?: string;
    /**
    * For most processors, this is the error message sent directly from the bank. Returned only when the processor returns this value.  **Important** Do not use this field to evaluate the result of the authorization.  #### PIN debit Response value that is returned by the processor or bank. **Important** Do not use this field to evaluate the results of the transaction request.  Returned by PIN debit credit, PIN debit purchase, and PIN debit reversal.  #### AIBMS If this value is `08`, you can accept the transaction if the customer provides you with identification.  #### Atos This value is the response code sent from Atos and it might also include the response code from the bank. Format: `aa,bb` with the two values separated by a comma and where: - `aa` is the two-digit error message from Atos. - `bb` is the optional two-digit error message from the bank.  #### Comercio Latino This value is the status code and the error or response code received from the processor separated by a colon. Format: [status code]:E[error code] or [status code]:R[response code] Example `2:R06`  #### JCN Gateway Processor-defined detail error code. The associated response category code is in the `processorInformation.responseCategoryCode` field. String (3)  #### paypalgateway Processor generated ID for the itemized detail. 
    */
    'responseCode'?: string;
    /**
    * Processor response to the API request. 
    */
    'providerResponse'?: string;
    /**
    * The date and time when the transaction was last updated, in Internet date and time format. 
    */
    'updateTimeUtc'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "transactionId",
            "baseName": "transactionId",
            "type": "string"
        },
        {
            "name": "networkTransactionId",
            "baseName": "networkTransactionId",
            "type": "string"
        },
        {
            "name": "responseDetails",
            "baseName": "responseDetails",
            "type": "string"
        },
        {
            "name": "responseCode",
            "baseName": "responseCode",
            "type": "string"
        },
        {
            "name": "providerResponse",
            "baseName": "providerResponse",
            "type": "string"
        },
        {
            "name": "updateTimeUtc",
            "baseName": "updateTimeUtc",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsCapturesPost201ResponseProcessorInformation.attributeTypeMap;
    }
}

export class PtsV2PaymentsCapturesPost400Response {
    /**
    * Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ` **Example** `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.). The `T` separates the date and the time. The `Z` indicates UTC.  Returned by Cybersource for all services. 
    */
    'submitTimeUtc'?: string;
    /**
    * The status of the submitted transaction.  Possible values:  - INVALID_REQUEST 
    */
    'status'?: string;
    /**
    * The reason of the status.  Possible values:  - MISSING_FIELD  - INVALID_DATA  - DUPLICATE_REQUEST  - INVALID_MERCHANT_CONFIGURATION  - EXCEEDS_AUTH_AMOUNT  - AUTH_ALREADY_REVERSED  - TRANSACTION_ALREADY_SETTLED  - INVALID_AMOUNT  - MISSING_AUTH  - TRANSACTION_ALREADY_REVERSED_OR_SETTLED  - NOT_SUPPORTED 
    */
    'reason'?: string;
    /**
    * The detail message related to the status and reason listed above.
    */
    'message'?: string;
    'details'?: Array<PtsV2PaymentsPost201ResponseErrorInformationDetails>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "submitTimeUtc",
            "baseName": "submitTimeUtc",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "reason",
            "baseName": "reason",
            "type": "string"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        },
        {
            "name": "details",
            "baseName": "details",
            "type": "Array<PtsV2PaymentsPost201ResponseErrorInformationDetails>"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsCapturesPost400Response.attributeTypeMap;
    }
}

export class PtsV2PaymentsOrderPost201Response {
    /**
    * An unique identification number generated by Cybersource to identify the submitted request. Returned by all services. It is also appended to the endpoint of the resource. On incremental authorizations, this value with be the same as the identification number returned in the original authorization response. 
    */
    'id'?: string;
    'clientReferenceInformation'?: PtsV2IncrementalAuthorizationPatch201ResponseClientReferenceInformation;
    'processorInformation'?: PtsV2PaymentsOrderPost201ResponseProcessorInformation;
    'orderInformation'?: PtsV2PaymentsOrderPost201ResponseOrderInformation;
    'paymentInformation'?: PtsV2PaymentsOrderPost201ResponsePaymentInformation;
    'processingInformation'?: PtsV2PaymentsOrderPost201ResponseProcessingInformation;
    'buyerInformation'?: PtsV2PaymentsOrderPost201ResponseBuyerInformation;
    /**
    * Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ` **Example** `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.). The `T` separates the date and the time. The `Z` indicates UTC.  Returned by Cybersource for all services. 
    */
    'submitTimeUtc'?: string;
    /**
    * The status of the submitted transaction. Possible values:   - CREATED   - SAVED   - APPROVED   - VOIDED   - COMPLETED   - PAYER_ACTION_REQUIRED 
    */
    'status'?: string;
    /**
    * Reference number for the transaction. Depending on how your Cybersource account is configured, this value could either be provided in the API request or generated by CyberSource. The actual value used in the request to the processor is provided back to you by Cybersource in the response. 
    */
    'reconciliationId'?: string;
    'riskInformation'?: PtsV2PaymentsPost201ResponseRiskInformationProcessorResults;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "clientReferenceInformation",
            "baseName": "clientReferenceInformation",
            "type": "PtsV2IncrementalAuthorizationPatch201ResponseClientReferenceInformation"
        },
        {
            "name": "processorInformation",
            "baseName": "processorInformation",
            "type": "PtsV2PaymentsOrderPost201ResponseProcessorInformation"
        },
        {
            "name": "orderInformation",
            "baseName": "orderInformation",
            "type": "PtsV2PaymentsOrderPost201ResponseOrderInformation"
        },
        {
            "name": "paymentInformation",
            "baseName": "paymentInformation",
            "type": "PtsV2PaymentsOrderPost201ResponsePaymentInformation"
        },
        {
            "name": "processingInformation",
            "baseName": "processingInformation",
            "type": "PtsV2PaymentsOrderPost201ResponseProcessingInformation"
        },
        {
            "name": "buyerInformation",
            "baseName": "buyerInformation",
            "type": "PtsV2PaymentsOrderPost201ResponseBuyerInformation"
        },
        {
            "name": "submitTimeUtc",
            "baseName": "submitTimeUtc",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "reconciliationId",
            "baseName": "reconciliationId",
            "type": "string"
        },
        {
            "name": "riskInformation",
            "baseName": "riskInformation",
            "type": "PtsV2PaymentsPost201ResponseRiskInformationProcessorResults"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsOrderPost201Response.attributeTypeMap;
    }
}

export class PtsV2PaymentsOrderPost201ResponseBuyerInformation {
    'personalIdentification'?: Array<PtsV2PaymentsOrderPost201ResponseBuyerInformationPersonalIdentification>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "personalIdentification",
            "baseName": "personalIdentification",
            "type": "Array<PtsV2PaymentsOrderPost201ResponseBuyerInformationPersonalIdentification>"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsOrderPost201ResponseBuyerInformation.attributeTypeMap;
    }
}

export class PtsV2PaymentsOrderPost201ResponseBuyerInformationPersonalIdentification {
    /**
    * The type of the identification.  Possible values:   - `NATIONAL`   - `CPF`   - `CPNJ`   - `CURP`   - `SSN`   - `DRIVER_LICENSE`   - `PASSPORT_NUMBER`   - `PERSONAL_ID`   - `TAX_ID`   - `BR_CPF`     The individual tax ID type, typically is 11 characters long   - `BR_CNPJ`    The business tax ID type, typically is 14 characters long.  This field is supported only on the following processors.  #### ComercioLatino Set this field to the Cadastro de Pessoas Fisicas (CPF).  #### CyberSource Latin American Processing Supported for Redecard in Brazil. Set this field to the Cadastro de Pessoas Fisicas (CPF), which is required for AVS for Redecard in Brazil. **Note** CyberSource Latin American Processing is the name of a specific processing connection that CyberSource supports. In the CyberSource API documentation, CyberSource Latin American Processing does not refer to the general topic of processing in Latin America. The information in this field description is for the specific processing connection called CyberSource Latin American Processing. It is not for any other Latin American processors that CyberSource supports. 
    */
    'type'?: string;
    /**
    * The value of the identification type. This field is supported only on the following processors.  #### ComercioLatino Set this field to the Cadastro de Pessoas Fisicas (CPF).  #### CyberSource Latin American Processing Supported for Redecard in Brazil. Set this field to the Cadastro de Pessoas Fisicas (CPF), which is required for AVS for Redecard in Brazil. **Note** CyberSource Latin American Processing is the name of a specific processing connection that CyberSource supports. In the CyberSource API documentation, CyberSource Latin American Processing does not refer to the general topic of processing in Latin America. The information in this field description is for the specific processing connection called CyberSource Latin American Processing. It is not for any other Latin American processors that CyberSource supports.               If `type = PASSPORT`, this is the cardholder's passport number. Recommended for Discover ProtectBuy. 
    */
    'id'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsOrderPost201ResponseBuyerInformationPersonalIdentification.attributeTypeMap;
    }
}

export class PtsV2PaymentsOrderPost201ResponseOrderInformation {
    'billTo'?: PtsV2PaymentsOrderPost201ResponseOrderInformationBillTo;
    'shipTo'?: PtsV2PaymentsOrderPost201ResponseOrderInformationShipTo;
    'amountDetails'?: PtsV2PaymentsOrderPost201ResponseOrderInformationAmountDetails;
    'shippingDetails'?: PtsV2PaymentsOrderPost201ResponseOrderInformationShippingDetails;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "billTo",
            "baseName": "billTo",
            "type": "PtsV2PaymentsOrderPost201ResponseOrderInformationBillTo"
        },
        {
            "name": "shipTo",
            "baseName": "shipTo",
            "type": "PtsV2PaymentsOrderPost201ResponseOrderInformationShipTo"
        },
        {
            "name": "amountDetails",
            "baseName": "amountDetails",
            "type": "PtsV2PaymentsOrderPost201ResponseOrderInformationAmountDetails"
        },
        {
            "name": "shippingDetails",
            "baseName": "shippingDetails",
            "type": "PtsV2PaymentsOrderPost201ResponseOrderInformationShippingDetails"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsOrderPost201ResponseOrderInformation.attributeTypeMap;
    }
}

export class PtsV2PaymentsOrderPost201ResponseOrderInformationAmountDetails {
    /**
    * Grand total for the order. This value cannot be negative. You can include a decimal point (.), but no other special characters. CyberSource truncates the amount to the correct number of decimal places.  **Note** For CTV, FDCCompass, Paymentech processors, the maximum length for this field is 12.  **Important** Some processors have specific requirements and limitations, such as maximum amounts and maximum field lengths.  If your processor supports zero amount authorizations, you can set this field to 0 for the authorization to check if the card is lost or stolen.   #### Card Present Required to include either this field or `orderInformation.lineItems[].unitPrice` for the order.  #### Invoicing / Pay By Link Required for creating a new invoice or payment link.  #### PIN Debit Amount you requested for the PIN debit purchase. This value is returned for partial authorizations. The issuing bank can approve a partial amount if the balance on the debit card is less than the requested transaction amount.  Required field for PIN Debit purchase and PIN Debit credit requests. Optional field for PIN Debit reversal requests.  #### GPX This field is optional for reversing an authorization or credit; however, for all other processors, these fields are required.  #### DCC with a Third-Party Provider Set this field to the converted amount that was returned by the DCC provider. You must include either this field or the 1st line item in the order and the specific line-order amount in your request.   #### DCC for First Data Not used. 
    */
    'totalAmount'?: string;
    /**
    * Currency used for the order 
    */
    'currency'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "totalAmount",
            "baseName": "totalAmount",
            "type": "string"
        },
        {
            "name": "currency",
            "baseName": "currency",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsOrderPost201ResponseOrderInformationAmountDetails.attributeTypeMap;
    }
}

export class PtsV2PaymentsOrderPost201ResponseOrderInformationBillTo {
    /**
    * Title. 
    */
    'title'?: string;
    /**
    * Customer’s first name. This name must be the same as the name on the card.  **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.  #### SEPA Required for Create Mandate and Import Mandate #### BACS Required for Import Mandate  #### CyberSource Latin American Processing **Important** For an authorization request, CyberSource Latin American Processing concatenates `orderInformation.billTo.firstName` and `orderInformation.billTo.lastName`. If the concatenated value exceeds 30 characters, CyberSource Latin American Processing declines the authorization request.\\ **Note** CyberSource Latin American Processing is the name of a specific processing connection that CyberSource supports. In the CyberSource API documentation, CyberSource Latin American Processing does not refer to the general topic of processing in Latin America. The information in this field description is for the specific processing connection called _CyberSource Latin American Processing_. It is not for any other Latin American processors that CyberSource supports.  #### CyberSource through VisaNet Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.  #### For Payouts: This field may be sent only for FDC Compass.  #### Chase Paymentech Solutions Optional field.  ####  Credit Mutuel-CIC Optional field.  #### OmniPay Direct Optional field.  #### SIX Optional field.  #### TSYS Acquiring Solutions Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.  #### Worldpay VAP Optional field.  #### All other processors Not used. 
    */
    'firstName'?: string;
    /**
    * Customer’s middle name. 
    */
    'middleName'?: string;
    /**
    * Customer’s last name. This name must be the same as the name on the card.  **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.  #### SEPA Required for Create Mandate and Import Mandate #### BACS Required for Import Mandate #### Chase Paymentech Solutions Optional field.  ####  Credit Mutuel-CIC Optional field.  #### CyberSource Latin American Processing **Important** For an authorization request, CyberSource Latin American Processing concatenates `orderInformation.billTo.firstName` and `orderInformation.billTo.lastName`. If the concatenated value exceeds 30 characters, CyberSource Latin American Processing declines the authorization request.\\ **Note** CyberSource Latin American Processing is the name of a specific processing connection that CyberSource supports. In the CyberSource API documentation, CyberSource Latin American Processing does not refer to the general topic of processing in Latin America. The information in this field description is for the specific processing connection called CyberSource Latin American Processing. It is not for any other Latin American processors that CyberSource supports.  #### CyberSource through VisaNet Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.  #### For Payouts: This field may be sent only for FDC Compass.  #### OmniPay Direct Optional field.  #### RBS WorldPay Atlanta Optional field.  #### SIX Optional field.  #### TSYS Acquiring Solutions Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.  #### Worldpay VAP Optional field.  #### All other processors Not used. 
    */
    'lastName'?: string;
    /**
    * Customer’s name suffix. 
    */
    'nameSuffix'?: string;
    /**
    * First line of the billing street address. 
    */
    'address1'?: string;
    /**
    * Second line of the billing street address. 
    */
    'address2'?: string;
    /**
    * City of the billing address. 
    */
    'locality'?: string;
    /**
    * Postal code for the billing address. The postal code must consist of 5 to 9 digits. When the billing country is the U.S., the 9-digit postal code must follow this format: [5 digits][dash][4 digits] Example: 12345-6789 When the billing country is Canada, the 6-digit postal code must follow this format: [alpha][numeric][alpha][space][numeric][alpha][numeric] Example: A1B 2C3 
    */
    'postalCode'?: string;
    /**
    * State or province of the billing address. Use the State, Province, and Territory Codes for the United States and Canada. 
    */
    'administrativeArea'?: string;
    /**
    * Country of the billing address. Use the two-character ISO Standard Country Codes. 
    */
    'country'?: string;
    /**
    * Customer's email address. 
    */
    'email'?: string;
    /**
    * Customer’s phone number.  It is recommended that you include the country code when the order is from outside the U.S.  #### Chase Paymentech Solutions Optional field.  ####  Credit Mutuel-CIC Optional field.  #### CyberSource through VisaNet Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.  #### For Payouts: This field may be sent only for FDC Compass.  #### OmniPay Direct Optional field.  #### SIX Optional field.  #### TSYS Acquiring Solutions Optional field.  #### Worldpay VAP Optional field.  #### All other processors Not used. 
    */
    'phoneNumber'?: string;
    /**
    * Whether buyer has verified their identity. Used in case of PayPal transactions.  Possible Values: * VERIFIED * UNVERIFIED 
    */
    'verificationStatus'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "firstName",
            "baseName": "firstName",
            "type": "string"
        },
        {
            "name": "middleName",
            "baseName": "middleName",
            "type": "string"
        },
        {
            "name": "lastName",
            "baseName": "lastName",
            "type": "string"
        },
        {
            "name": "nameSuffix",
            "baseName": "nameSuffix",
            "type": "string"
        },
        {
            "name": "address1",
            "baseName": "address1",
            "type": "string"
        },
        {
            "name": "address2",
            "baseName": "address2",
            "type": "string"
        },
        {
            "name": "locality",
            "baseName": "locality",
            "type": "string"
        },
        {
            "name": "postalCode",
            "baseName": "postalCode",
            "type": "string"
        },
        {
            "name": "administrativeArea",
            "baseName": "administrativeArea",
            "type": "string"
        },
        {
            "name": "country",
            "baseName": "country",
            "type": "string"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "phoneNumber",
            "baseName": "phoneNumber",
            "type": "string"
        },
        {
            "name": "verificationStatus",
            "baseName": "verificationStatus",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsOrderPost201ResponseOrderInformationBillTo.attributeTypeMap;
    }
}

export class PtsV2PaymentsOrderPost201ResponseOrderInformationShipTo {
    /**
    * shipping method for the product. Possible values are: - `sameday` - `oneday` - `twoday` - `threeday` - `lowcost` - `pickup` - `other` - `none` 
    */
    'method'?: string;
    /**
    * First name of the recipient. 
    */
    'firstName'?: string;
    /**
    * Last name of the recipient. 
    */
    'lastName'?: string;
    /**
    * First line of the shipping address. 
    */
    'address1'?: string;
    /**
    * Second line of the shipping address 
    */
    'address2'?: string;
    /**
    * City of the shipping address. 
    */
    'locality'?: string;
    /**
    * Postal code of shipping address. Consists of 5 to 9 digits. 
    */
    'postalCode'?: string;
    /**
    * State or province of shipping address. This is a State, Province, and Territory Codes for the United States and Canada. 
    */
    'administrativeArea'?: string;
    /**
    * Country of shipping address. This is a two-character ISO Standard Country Codes. 
    */
    'country'?: string;
    /**
    * Phone number of shipping address. 
    */
    'phoneNumber'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "method",
            "baseName": "method",
            "type": "string"
        },
        {
            "name": "firstName",
            "baseName": "firstName",
            "type": "string"
        },
        {
            "name": "lastName",
            "baseName": "lastName",
            "type": "string"
        },
        {
            "name": "address1",
            "baseName": "address1",
            "type": "string"
        },
        {
            "name": "address2",
            "baseName": "address2",
            "type": "string"
        },
        {
            "name": "locality",
            "baseName": "locality",
            "type": "string"
        },
        {
            "name": "postalCode",
            "baseName": "postalCode",
            "type": "string"
        },
        {
            "name": "administrativeArea",
            "baseName": "administrativeArea",
            "type": "string"
        },
        {
            "name": "country",
            "baseName": "country",
            "type": "string"
        },
        {
            "name": "phoneNumber",
            "baseName": "phoneNumber",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsOrderPost201ResponseOrderInformationShipTo.attributeTypeMap;
    }
}

export class PtsV2PaymentsOrderPost201ResponseOrderInformationShippingDetails {
    /**
    * Shipping method for the product. Possible values:   - `lowcost`: Lowest-cost service  - `sameday`: Courier or same-day service  - `oneday`: Next-day or overnight service  - `twoday`: Two-day service  - `threeday`: Three-day service  - `pickup`: Store pick-up  - `other`: Other shipping method  - `none`: No shipping method because product is a service or subscription 
    */
    'shippingMethod'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "shippingMethod",
            "baseName": "shippingMethod",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsOrderPost201ResponseOrderInformationShippingDetails.attributeTypeMap;
    }
}

export class PtsV2PaymentsOrderPost201ResponsePaymentInformation {
    'eWallet'?: PtsV2PaymentsOrderPost201ResponsePaymentInformationEWallet;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "eWallet",
            "baseName": "eWallet",
            "type": "PtsV2PaymentsOrderPost201ResponsePaymentInformationEWallet"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsOrderPost201ResponsePaymentInformation.attributeTypeMap;
    }
}

export class PtsV2PaymentsOrderPost201ResponsePaymentInformationEWallet {
    /**
    * The ID of the customer, passed in the return_url field by PayPal after customer approval.
    */
    'accountId'?: string;
    /**
    * Payment mode for the authorization or order transaction.  INSTANT_TRANSFER  MANUAL_BANK_TRANSFER  DELAYED_TRANSFER  ECHECK  UNRESTRICTED (default)—this value is available only when configured by PayPal for the merchant. INSTANT
    */
    'fundingSource'?: string;
    /**
    * Payment method for the unit purchase. Possible values: - `UNRESTRICTED (default)—this value is only available if configured by PayPal for the merchant.` - `INSTANT` 
    */
    'fundingSourceSale'?: string;
    /**
    * The Venmo user name chosen by the user, also know as a Venmo handle. 
    */
    'userName'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "accountId",
            "baseName": "accountId",
            "type": "string"
        },
        {
            "name": "fundingSource",
            "baseName": "fundingSource",
            "type": "string"
        },
        {
            "name": "fundingSourceSale",
            "baseName": "fundingSourceSale",
            "type": "string"
        },
        {
            "name": "userName",
            "baseName": "userName",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsOrderPost201ResponsePaymentInformationEWallet.attributeTypeMap;
    }
}

export class PtsV2PaymentsOrderPost201ResponseProcessingInformation {
    /**
    * Set to the value of the requestID field returned in the order service response.
    */
    'intentsId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "intentsId",
            "baseName": "intentsId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsOrderPost201ResponseProcessingInformation.attributeTypeMap;
    }
}

export class PtsV2PaymentsOrderPost201ResponseProcessorInformation {
    'sellerProtection'?: PtsV2PaymentsOrderPost201ResponseProcessorInformationSellerProtection;
    'avs'?: PtsV2PaymentsPost201Response1ProcessorInformationAvs;
    /**
    * Network transaction identifier (TID). You can use this value to identify a specific transaction when you are discussing the transaction with your processor. Not all processors provide this value.  Returned by the authorization service.  #### PIN debit Transaction identifier generated by the processor.  Returned by PIN debit credit.  #### GPX Processor transaction ID.  #### Cielo For Cielo, this value is the non-sequential unit (NSU) and is supported for all transactions. The value is generated by Cielo or the issuing bank.  #### Comercio Latino For Comercio Latino, this value is the proof of sale or non-sequential unit (NSU) number generated by the acquirers Cielo and Rede, or the issuing bank.  #### CyberSource through VisaNet and GPN For details about this value for CyberSource through VisaNet and GPN, see \"processorInformation.networkTransactionId\" in [REST API Fields](https://developer.cybersource.com/content/dam/docs/cybs/en-us/apifields/reference/all/rest/api-fields.pdf)  #### Moneris This value identifies the transaction on a host system. It contains the following information: - Terminal used to process the transaction - Shift during which the transaction took place - Batch number - Transaction number within the batch You must store this value. If you give the customer a receipt, display this value on the receipt.  **Example** For the value 66012345001069003: - Terminal ID = 66012345 - Shift number = 001 - Batch number = 069 - Transaction number = 003 
    */
    'transactionId'?: string;
    /**
    * This field might contain information about a decline. This field is supported only for **CyberSource through VisaNet**. 
    */
    'responseDetails'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "sellerProtection",
            "baseName": "sellerProtection",
            "type": "PtsV2PaymentsOrderPost201ResponseProcessorInformationSellerProtection"
        },
        {
            "name": "avs",
            "baseName": "avs",
            "type": "PtsV2PaymentsPost201Response1ProcessorInformationAvs"
        },
        {
            "name": "transactionId",
            "baseName": "transactionId",
            "type": "string"
        },
        {
            "name": "responseDetails",
            "baseName": "responseDetails",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsOrderPost201ResponseProcessorInformation.attributeTypeMap;
    }
}

export class PtsV2PaymentsOrderPost201ResponseProcessorInformationSellerProtection {
    /**
    * The level of seller protection in force for the transaction. Possible values: - `ELIGIBLE` - `PARTIALLY_ELIGIBLE` - `INELIGIBLE` 
    */
    'eligibilty'?: string;
    /**
    * The kind of seller protection in force for the transaction. This field is returned only when the protection eligibility is set to ELIGIBLE or PARTIALLY_ELIGIBLE. Possible values: - `ITEM_NOT_RECEIVED_ELIGIBLE: Sellers are protected against claims for items not received.` - `UNAUTHORIZED_PAYMENT_ELIGIBLE: Sellers are protected against claims for unauthorized payments.One or both values can be returned.` 
    */
    'type'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "eligibilty",
            "baseName": "eligibilty",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsOrderPost201ResponseProcessorInformationSellerProtection.attributeTypeMap;
    }
}

export class PtsV2PaymentsPost201Response {
    'links'?: PtsV2PaymentsPost201ResponseLinks;
    /**
    * An unique identification number generated by Cybersource to identify the submitted request. Returned by all services. It is also appended to the endpoint of the resource. On incremental authorizations, this value with be the same as the identification number returned in the original authorization response. 
    */
    'id'?: string;
    /**
    * More information about the transaction response. 
    */
    'message'?: string;
    /**
    * Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ` **Example** `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.). The `T` separates the date and the time. The `Z` indicates UTC.  Returned by Cybersource for all services. 
    */
    'submitTimeUtc'?: string;
    /**
    * The status of the submitted transaction.  Possible values:  - AUTHORIZED  - PARTIAL_AUTHORIZED  - AUTHORIZED_PENDING_REVIEW  - AUTHORIZED_RISK_DECLINED  - PENDING_AUTHENTICATION  - PENDING_REVIEW  - DECLINED  - INVALID_REQUEST 
    */
    'status'?: string;
    /**
    * Reference number for the transaction. Depending on how your Cybersource account is configured, this value could either be provided in the API request or generated by CyberSource. The actual value used in the request to the processor is provided back to you by Cybersource in the response. 
    */
    'reconciliationId'?: string;
    'errorInformation'?: PtsV2PaymentsPost201ResponseErrorInformation;
    'clientReferenceInformation'?: PtsV2PaymentsPost201ResponseClientReferenceInformation;
    'processingInformation'?: PtsV2PaymentsPost201ResponseProcessingInformation;
    'processorInformation'?: PtsV2PaymentsPost201ResponseProcessorInformation;
    'issuerInformation'?: PtsV2PaymentsPost201ResponseIssuerInformation;
    'paymentAccountInformation'?: PtsV2PaymentsPost201ResponsePaymentAccountInformation;
    'paymentInformation'?: PtsV2PaymentsPost201ResponsePaymentInformation;
    'paymentInsightsInformation'?: PtsV2PaymentsPost201ResponsePaymentInsightsInformation;
    'orderInformation'?: PtsV2PaymentsPost201ResponseOrderInformation;
    'pointOfSaleInformation'?: PtsV2PaymentsPost201ResponsePointOfSaleInformation;
    'installmentInformation'?: PtsV2PaymentsPost201ResponseInstallmentInformation;
    'tokenInformation'?: PtsV2PaymentsPost201ResponseTokenInformation;
    'buyerInformation'?: PtsV2PaymentsPost201ResponseBuyerInformation;
    'riskInformation'?: PtsV2PaymentsPost201ResponseRiskInformation;
    'consumerAuthenticationInformation'?: PtsV2PaymentsPost201ResponseConsumerAuthenticationInformation;
    'merchantInformation'?: PtsV2PaymentsPost201ResponseMerchantInformation;
    'embeddedActions'?: PtsV2PaymentsPost201ResponseEmbeddedActions;
    'watchlistScreeningInformation'?: PtsV2PaymentsPost201ResponseWatchlistScreeningInformation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "PtsV2PaymentsPost201ResponseLinks"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        },
        {
            "name": "submitTimeUtc",
            "baseName": "submitTimeUtc",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "reconciliationId",
            "baseName": "reconciliationId",
            "type": "string"
        },
        {
            "name": "errorInformation",
            "baseName": "errorInformation",
            "type": "PtsV2PaymentsPost201ResponseErrorInformation"
        },
        {
            "name": "clientReferenceInformation",
            "baseName": "clientReferenceInformation",
            "type": "PtsV2PaymentsPost201ResponseClientReferenceInformation"
        },
        {
            "name": "processingInformation",
            "baseName": "processingInformation",
            "type": "PtsV2PaymentsPost201ResponseProcessingInformation"
        },
        {
            "name": "processorInformation",
            "baseName": "processorInformation",
            "type": "PtsV2PaymentsPost201ResponseProcessorInformation"
        },
        {
            "name": "issuerInformation",
            "baseName": "issuerInformation",
            "type": "PtsV2PaymentsPost201ResponseIssuerInformation"
        },
        {
            "name": "paymentAccountInformation",
            "baseName": "paymentAccountInformation",
            "type": "PtsV2PaymentsPost201ResponsePaymentAccountInformation"
        },
        {
            "name": "paymentInformation",
            "baseName": "paymentInformation",
            "type": "PtsV2PaymentsPost201ResponsePaymentInformation"
        },
        {
            "name": "paymentInsightsInformation",
            "baseName": "paymentInsightsInformation",
            "type": "PtsV2PaymentsPost201ResponsePaymentInsightsInformation"
        },
        {
            "name": "orderInformation",
            "baseName": "orderInformation",
            "type": "PtsV2PaymentsPost201ResponseOrderInformation"
        },
        {
            "name": "pointOfSaleInformation",
            "baseName": "pointOfSaleInformation",
            "type": "PtsV2PaymentsPost201ResponsePointOfSaleInformation"
        },
        {
            "name": "installmentInformation",
            "baseName": "installmentInformation",
            "type": "PtsV2PaymentsPost201ResponseInstallmentInformation"
        },
        {
            "name": "tokenInformation",
            "baseName": "tokenInformation",
            "type": "PtsV2PaymentsPost201ResponseTokenInformation"
        },
        {
            "name": "buyerInformation",
            "baseName": "buyerInformation",
            "type": "PtsV2PaymentsPost201ResponseBuyerInformation"
        },
        {
            "name": "riskInformation",
            "baseName": "riskInformation",
            "type": "PtsV2PaymentsPost201ResponseRiskInformation"
        },
        {
            "name": "consumerAuthenticationInformation",
            "baseName": "consumerAuthenticationInformation",
            "type": "PtsV2PaymentsPost201ResponseConsumerAuthenticationInformation"
        },
        {
            "name": "merchantInformation",
            "baseName": "merchantInformation",
            "type": "PtsV2PaymentsPost201ResponseMerchantInformation"
        },
        {
            "name": "embeddedActions",
            "baseName": "embeddedActions",
            "type": "PtsV2PaymentsPost201ResponseEmbeddedActions"
        },
        {
            "name": "watchlistScreeningInformation",
            "baseName": "watchlistScreeningInformation",
            "type": "PtsV2PaymentsPost201ResponseWatchlistScreeningInformation"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsPost201Response.attributeTypeMap;
    }
}

export class PtsV2PaymentsPost201Response1 {
    /**
    * An unique identification number generated by Cybersource to identify the submitted request. Returned by all services. It is also appended to the endpoint of the resource. On incremental authorizations, this value with be the same as the identification number returned in the original authorization response. 
    */
    'id'?: string;
    /**
    * The status of the submitted transaction.  Possible values:  - AUTHORIZED  - PARTIAL_AUTHORIZED  - AUTHORIZED_PENDING_REVIEW  - AUTHORIZED_RISK_DECLINED  - PENDING_AUTHENTICATION  - PENDING_REVIEW  - DECLINED  - INVALID_REQUEST 
    */
    'status'?: string;
    /**
    * Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ` **Example** `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.). The `T` separates the date and the time. The `Z` indicates UTC.  Returned by Cybersource for all services. 
    */
    'submitTimeUtc'?: string;
    'processorInformation'?: PtsV2PaymentsPost201Response1ProcessorInformation;
    /**
    * Reference number for the transaction. Depending on how your Cybersource account is configured, this value could either be provided in the API request or generated by CyberSource. The actual value used in the request to the processor is provided back to you by Cybersource in the response. 
    */
    'reconciliationId'?: string;
    'paymentInformation'?: PtsV2PaymentsPost201Response1PaymentInformation;
    'orderInformation'?: PtsV2PaymentsPost201Response1OrderInformation;
    'clientReferenceInformation'?: PtsV2IncrementalAuthorizationPatch201ResponseClientReferenceInformation;
    'issuerInformation'?: PtsV2PaymentsPost201Response1IssuerInformation;
    'errorInformation'?: PtsV2PaymentsPost201Response1ErrorInformation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "submitTimeUtc",
            "baseName": "submitTimeUtc",
            "type": "string"
        },
        {
            "name": "processorInformation",
            "baseName": "processorInformation",
            "type": "PtsV2PaymentsPost201Response1ProcessorInformation"
        },
        {
            "name": "reconciliationId",
            "baseName": "reconciliationId",
            "type": "string"
        },
        {
            "name": "paymentInformation",
            "baseName": "paymentInformation",
            "type": "PtsV2PaymentsPost201Response1PaymentInformation"
        },
        {
            "name": "orderInformation",
            "baseName": "orderInformation",
            "type": "PtsV2PaymentsPost201Response1OrderInformation"
        },
        {
            "name": "clientReferenceInformation",
            "baseName": "clientReferenceInformation",
            "type": "PtsV2IncrementalAuthorizationPatch201ResponseClientReferenceInformation"
        },
        {
            "name": "issuerInformation",
            "baseName": "issuerInformation",
            "type": "PtsV2PaymentsPost201Response1IssuerInformation"
        },
        {
            "name": "errorInformation",
            "baseName": "errorInformation",
            "type": "PtsV2PaymentsPost201Response1ErrorInformation"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsPost201Response1.attributeTypeMap;
    }
}

export class PtsV2PaymentsPost201Response1ErrorInformation {
    /**
    * The reason of the status. 
    */
    'reason'?: string;
    /**
    * The detail message related to the status and reason listed above.
    */
    'message'?: string;
    'details'?: Array<PtsV2PaymentsPost201Response1ErrorInformationDetails>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "reason",
            "baseName": "reason",
            "type": "string"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        },
        {
            "name": "details",
            "baseName": "details",
            "type": "Array<PtsV2PaymentsPost201Response1ErrorInformationDetails>"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsPost201Response1ErrorInformation.attributeTypeMap;
    }
}

export class PtsV2PaymentsPost201Response1ErrorInformationDetails {
    /**
    * Possible reasons for the error.  Possible values:  - MISSING_FIELD  - INVALID_DATA 
    */
    'reason'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "reason",
            "baseName": "reason",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsPost201Response1ErrorInformationDetails.attributeTypeMap;
    }
}

export class PtsV2PaymentsPost201Response1IssuerInformation {
    /**
    * Name of the card issuer provided by the processor. 
    */
    'name'?: string;
    /**
    * Unique code for card issuer provided by the processor. 
    */
    'code'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsPost201Response1IssuerInformation.attributeTypeMap;
    }
}

export class PtsV2PaymentsPost201Response1OrderInformation {
    'billTo'?: PtsV2PaymentsPost201Response1OrderInformationBillTo;
    'shipTo'?: PtsV2PaymentsPost201Response1OrderInformationShipTo;
    'amountDetails'?: PtsV2PaymentsPost201Response1OrderInformationAmountDetails;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "billTo",
            "baseName": "billTo",
            "type": "PtsV2PaymentsPost201Response1OrderInformationBillTo"
        },
        {
            "name": "shipTo",
            "baseName": "shipTo",
            "type": "PtsV2PaymentsPost201Response1OrderInformationShipTo"
        },
        {
            "name": "amountDetails",
            "baseName": "amountDetails",
            "type": "PtsV2PaymentsPost201Response1OrderInformationAmountDetails"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsPost201Response1OrderInformation.attributeTypeMap;
    }
}

export class PtsV2PaymentsPost201Response1OrderInformationAmountDetails {
    /**
    * This field will carry the remaning amount which can be refunded. 
    */
    'refundBalance'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "refundBalance",
            "baseName": "refundBalance",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsPost201Response1OrderInformationAmountDetails.attributeTypeMap;
    }
}

export class PtsV2PaymentsPost201Response1OrderInformationBillTo {
    /**
    * Customer’s first name. This name must be the same as the name on the card.  **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.  #### SEPA Required for Create Mandate and Import Mandate #### BACS Required for Import Mandate  #### CyberSource Latin American Processing **Important** For an authorization request, CyberSource Latin American Processing concatenates `orderInformation.billTo.firstName` and `orderInformation.billTo.lastName`. If the concatenated value exceeds 30 characters, CyberSource Latin American Processing declines the authorization request.\\ **Note** CyberSource Latin American Processing is the name of a specific processing connection that CyberSource supports. In the CyberSource API documentation, CyberSource Latin American Processing does not refer to the general topic of processing in Latin America. The information in this field description is for the specific processing connection called _CyberSource Latin American Processing_. It is not for any other Latin American processors that CyberSource supports.  #### CyberSource through VisaNet Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.  #### For Payouts: This field may be sent only for FDC Compass.  #### Chase Paymentech Solutions Optional field.  ####  Credit Mutuel-CIC Optional field.  #### OmniPay Direct Optional field.  #### SIX Optional field.  #### TSYS Acquiring Solutions Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.  #### Worldpay VAP Optional field.  #### All other processors Not used. 
    */
    'firstName'?: string;
    /**
    * Customer’s last name. This name must be the same as the name on the card.  **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.  #### SEPA Required for Create Mandate and Import Mandate #### BACS Required for Import Mandate #### Chase Paymentech Solutions Optional field.  ####  Credit Mutuel-CIC Optional field.  #### CyberSource Latin American Processing **Important** For an authorization request, CyberSource Latin American Processing concatenates `orderInformation.billTo.firstName` and `orderInformation.billTo.lastName`. If the concatenated value exceeds 30 characters, CyberSource Latin American Processing declines the authorization request.\\ **Note** CyberSource Latin American Processing is the name of a specific processing connection that CyberSource supports. In the CyberSource API documentation, CyberSource Latin American Processing does not refer to the general topic of processing in Latin America. The information in this field description is for the specific processing connection called CyberSource Latin American Processing. It is not for any other Latin American processors that CyberSource supports.  #### CyberSource through VisaNet Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.  #### For Payouts: This field may be sent only for FDC Compass.  #### OmniPay Direct Optional field.  #### RBS WorldPay Atlanta Optional field.  #### SIX Optional field.  #### TSYS Acquiring Solutions Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.  #### Worldpay VAP Optional field.  #### All other processors Not used. 
    */
    'lastName'?: string;
    /**
    * Customer’s name suffix. 
    */
    'nameSuffix'?: string;
    /**
    * Payment card billing street address as it appears on the credit card issuer’s records.  #### SEPA Required for Create Mandate and Import Mandate  #### Atos This field must not contain colons (:).  #### CyberSource through VisaNet **Important** When you populate orderInformation.billTo.address1 and orderInformation.billTo.address2, CyberSource through VisaNet concatenates the two values. If the concatenated value exceeds 40 characters, CyberSource through VisaNet truncates the value at 40 characters before sending it to Visa and the issuing bank. Truncating this value affects AVS results and therefore might also affect risk decisions and chargebacks. Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.  #### FDMS Nashville When the street name is numeric, it must be sent in numeric format. For example, if the address is _One First Street_, it must be sent as _1 1st Street_.  Required if keyed; not used if swiped.  String (20)  #### TSYS Acquiring Solutions Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.  #### All other processors: Optional. String (60)  #### For Payouts This field may be sent only for FDC Compass.  **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting. 
    */
    'address1'?: string;
    /**
    * Used for additional address information. For example: _Attention: Accounts Payable_ Optional field.  For Payouts: This field may be sent only for FDC Compass.  #### Atos This field must not contain colons (:).  #### CyberSource through VisaNet **Important** When you populate `orderInformation.billTo.address1` and `orderInformation.billTo.address2`, CyberSource through VisaNet concatenates the two values. If the concatenated value exceeds 40 characters, CyberSource through VisaNet truncates the value at 40 characters before sending it to Visa and the issuing bank. Truncating this value affects AVS results and therefore might also affect risk decisions and chargebacks. Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.  #### Chase Paymentech Solutions, FDC Compass, and TSYS Acquiring Solutions This value is used for AVS.  #### FDMS Nashville `orderInformation.billTo.address1` and `orderInformation.billTo.address2` together cannot exceed 20 characters. String (20)  #### All Other Processors String (60) 
    */
    'address2'?: string;
    /**
    * Payment card billing city.  #### SEPA Required for Create Mandate and Import Mandate  #### Atos This field must not contain colons (:).  #### CyberSource through VisaNet Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.  #### For Payouts: This field may be sent only for FDC Compass.  #### Chase Paymentech Solutions Optional field.  ####  Credit Mutuel-CIC Optional field.  #### OmniPay Direct Optional field.  #### SIX Optional field.  #### TSYS Acquiring Solutions Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.  #### Worldpay VAP Optional field.  #### All other processors Not used. 
    */
    'locality'?: string;
    /**
    * State or province of the billing address. Use the [State, Province, and Territory Codes for the United States and Canada](https://developer.cybersource.com/library/documentation/sbc/quickref/states_and_provinces.pdf).  For Payouts: This field may be sent only for FDC Compass.  ##### CyberSource through VisaNet Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.  **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.  #### Chase Paymentech Solutions Optional field.  ####  Credit Mutuel-CIC Optional field.  #### OmniPay Direct Optional field.  #### SIX Optional field.  #### TSYS Acquiring Solutions Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.  #### Worldpay VAP Optional field.  #### All other processors Not used. 
    */
    'administrativeArea'?: string;
    /**
    * Postal code for the billing address. The postal code must consist of 5 to 9 digits.  When the billing country is the U.S., the 9-digit postal code must follow this format: [5 digits][dash][4 digits]  **Example** `12345-6789`  When the billing country is Canada, the 6-digit postal code must follow this format: [alpha][numeric][alpha][space][numeric][alpha][numeric]  **Example** `A1B 2C3`  **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.  #### SEPA Required for Create Mandate and Import Mandate  #### For Payouts:  This field may be sent only for FDC Compass.  #### American Express Direct Before sending the postal code to the processor, CyberSource removes all nonalphanumeric characters and, if the remaining value is longer than nine characters, truncates the value starting from the right side.  #### Atos This field must not contain colons (:).  #### CyberSource through VisaNet Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.  #### FDMS Nashville Required if `pointOfSaleInformation.entryMode=keyed` and the address is in the U.S. or Canada. Optional if `pointOfSaleInformation.entryMode=keyed` and the address is **not** in the U.S. or Canada. Not used if swiped.  #### RBS WorldPay Atlanta: For best card-present keyed rates, send the postal code if `pointOfSaleInformation.entryMode=keyed`.  #### TSYS Acquiring Solutions Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.  #### All other processors: Optional field. 
    */
    'postalCode'?: string;
    /**
    * Payment card billing country. Use the two-character [ISO Standard Country Codes](http://apps.cybersource.com/library/documentation/sbc/quickref/countries_alpha_list.pdf).  #### SEPA/BACS Required for Create Mandate and Import Mandate  #### CyberSource through VisaNet Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.  **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.  #### Chase Paymentech Solutions Optional field.  ####  Credit Mutuel-CIC Optional field.  #### OmniPay Direct Optional field.  #### SIX Optional field.  #### TSYS Acquiring Solutions Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.  #### Worldpay VAP Optional field.  #### All other processors Not used. 
    */
    'country'?: string;
    /**
    * Customer's email address, including the full domain name.  #### CyberSource through VisaNet Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.  **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.  #### Invoicing Email address for the customer for sending the invoice. If the invoice is in SENT status and email is updated, the old email customer payment link won't work and you must resend the invoice with the new payment link.  #### Chase Paymentech Solutions Optional field.  ####  Credit Mutuel-CIC Optional field.  #### OmniPay Direct Optional field.  #### SIX Optional field.  #### TSYS Acquiring Solutions Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.  #### Worldpay VAP Optional field.  #### All other processors Not used. 
    */
    'email'?: string;
    /**
    * Whether buyer has verified their identity. Used in case of PayPal transactions.  Possible Values: * VERIFIED * UNVERIFIED 
    */
    'verificationStatus'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "firstName",
            "baseName": "firstName",
            "type": "string"
        },
        {
            "name": "lastName",
            "baseName": "lastName",
            "type": "string"
        },
        {
            "name": "nameSuffix",
            "baseName": "nameSuffix",
            "type": "string"
        },
        {
            "name": "address1",
            "baseName": "address1",
            "type": "string"
        },
        {
            "name": "address2",
            "baseName": "address2",
            "type": "string"
        },
        {
            "name": "locality",
            "baseName": "locality",
            "type": "string"
        },
        {
            "name": "administrativeArea",
            "baseName": "administrativeArea",
            "type": "string"
        },
        {
            "name": "postalCode",
            "baseName": "postalCode",
            "type": "string"
        },
        {
            "name": "country",
            "baseName": "country",
            "type": "string"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "verificationStatus",
            "baseName": "verificationStatus",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsPost201Response1OrderInformationBillTo.attributeTypeMap;
    }
}

export class PtsV2PaymentsPost201Response1OrderInformationShipTo {
    /**
    * First name of the recipient.  #### Litle Maximum length: 25  #### All other processors Maximum length: 60  Optional field. 
    */
    'firstName'?: string;
    /**
    * Last name of the recipient.  #### Litle Maximum length: 25  #### All other processors Maximum length: 60  Optional field. 
    */
    'lastName'?: string;
    /**
    * First line of the shipping address.  Required field for authorization if any shipping address information is included in the request; otherwise, optional.  #### Tax Calculation Optional field for U.S. and Canadian taxes. Not applicable to international and value added taxes. Billing address objects will be used to determine the cardholder’s location when shipTo objects are not present. 
    */
    'address1'?: string;
    /**
    * Second line of the shipping address.  Optional field.  #### Tax Calculation Optional field for U.S. and Canadian taxes. Not applicable to international and value added taxes. Billing address objects will be used to determine the cardholder’s location when shipTo objects are not present. 
    */
    'address2'?: string;
    /**
    * City of the shipping address.  Required field for authorization if any shipping address information is included in the request and shipping to the U.S. or Canada; otherwise, optional.  #### Tax Calculation Optional field for U.S. and Canadian taxes. Not applicable to international and value added taxes. Billing address objects will be used to determine the cardholder’s location when shipTo objects are not present. 
    */
    'locality'?: string;
    /**
    * State or province of the shipping address. Use the [State, Province, and Territory Codes for the United States and Canada](https://developer.cybersource.com/library/documentation/sbc/quickref/states_and_provinces.pdf) (maximum length: 2)   Required field for authorization if any shipping address information is included in the request and shipping to the U.S. or Canada; otherwise, optional.  #### Tax Calculation Optional field for U.S. and Canadian taxes. Not applicable to international and value added taxes. Billing address objects will be used to determine the cardholder’s location when shipTo objects are not present. 
    */
    'administrativeArea'?: string;
    /**
    * Postal code for the shipping address. The postal code must consist of 5 to 9 digits.  Required field for authorization if any shipping address information is included in the request and shipping to the U.S. or Canada; otherwise, optional.  When the billing country is the U.S., the 9-digit postal code must follow this format: [5 digits][dash][4 digits]  Example 12345-6789  When the billing country is Canada, the 6-digit postal code must follow this format: [alpha][numeric][alpha][space][numeric][alpha][numeric]  Example A1B 2C3  #### American Express Direct Before sending the postal code to the processor, all nonalphanumeric characters are removed and, if the remaining value is longer than nine characters, the value is truncated starting from the right side. #### Tax Calculation Optional field for U.S. and Canadian taxes. Not applicable to international and value added taxes. Billing address objects will be used to determine the cardholder’s location when shipTo objects are not present. 
    */
    'postalCode'?: string;
    /**
    * Country of the shipping address. Use the two-character [ISO Standard Country Codes.](http://apps.cybersource.com/library/documentation/sbc/quickref/countries_alpha_list.pdf)  Required field for authorization if any shipping address information is included in the request; otherwise, optional.  #### Tax Calculation Optional field for U.S., Canadian, international tax, and value added taxes. Billing address objects will be used to determine the cardholder’s location when shipTo objects are not present. 
    */
    'country'?: string;
    /**
    * Phone number associated with the shipping address.
    */
    'phoneNumber'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "firstName",
            "baseName": "firstName",
            "type": "string"
        },
        {
            "name": "lastName",
            "baseName": "lastName",
            "type": "string"
        },
        {
            "name": "address1",
            "baseName": "address1",
            "type": "string"
        },
        {
            "name": "address2",
            "baseName": "address2",
            "type": "string"
        },
        {
            "name": "locality",
            "baseName": "locality",
            "type": "string"
        },
        {
            "name": "administrativeArea",
            "baseName": "administrativeArea",
            "type": "string"
        },
        {
            "name": "postalCode",
            "baseName": "postalCode",
            "type": "string"
        },
        {
            "name": "country",
            "baseName": "country",
            "type": "string"
        },
        {
            "name": "phoneNumber",
            "baseName": "phoneNumber",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsPost201Response1OrderInformationShipTo.attributeTypeMap;
    }
}

export class PtsV2PaymentsPost201Response1PaymentInformation {
    'paymentType'?: PtsV2PaymentsPost201Response1PaymentInformationPaymentType;
    'eWallet'?: PtsV2PaymentsPost201Response1PaymentInformationEWallet;
    'customer'?: Ptsv2refreshpaymentstatusidPaymentInformationCustomer;
    'bank'?: PtsV2PaymentsPost201Response1PaymentInformationBank;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "paymentType",
            "baseName": "paymentType",
            "type": "PtsV2PaymentsPost201Response1PaymentInformationPaymentType"
        },
        {
            "name": "eWallet",
            "baseName": "eWallet",
            "type": "PtsV2PaymentsPost201Response1PaymentInformationEWallet"
        },
        {
            "name": "customer",
            "baseName": "customer",
            "type": "Ptsv2refreshpaymentstatusidPaymentInformationCustomer"
        },
        {
            "name": "bank",
            "baseName": "bank",
            "type": "PtsV2PaymentsPost201Response1PaymentInformationBank"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsPost201Response1PaymentInformation.attributeTypeMap;
    }
}

export class PtsV2PaymentsPost201Response1PaymentInformationBank {
    'account'?: PtsV2PaymentsPost201Response1PaymentInformationBankAccount;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "account",
            "baseName": "account",
            "type": "PtsV2PaymentsPost201Response1PaymentInformationBankAccount"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsPost201Response1PaymentInformationBank.attributeTypeMap;
    }
}

export class PtsV2PaymentsPost201Response1PaymentInformationBankAccount {
    /**
    * The description for this field is not available.
    */
    'ibanSuffix'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "ibanSuffix",
            "baseName": "ibanSuffix",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsPost201Response1PaymentInformationBankAccount.attributeTypeMap;
    }
}

export class PtsV2PaymentsPost201Response1PaymentInformationEWallet {
    /**
    * Valid Values: - CreditCard - BankTransfer - MobileTransfer - KakaoMoney - NaverPayPoint 
    */
    'name'?: string;
    /**
    * Valid Values: - PAYCO - Kakaopay - NaverPay - SSG Pay - L.Pay - Apple Pay - TOSS Pay - Samsung Pay 
    */
    'fundingSource'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "fundingSource",
            "baseName": "fundingSource",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsPost201Response1PaymentInformationEWallet.attributeTypeMap;
    }
}

export class PtsV2PaymentsPost201Response1PaymentInformationPaymentType {
    'method'?: PtsV2PaymentsPost201Response1PaymentInformationPaymentTypeMethod;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "method",
            "baseName": "method",
            "type": "PtsV2PaymentsPost201Response1PaymentInformationPaymentTypeMethod"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsPost201Response1PaymentInformationPaymentType.attributeTypeMap;
    }
}

export class PtsV2PaymentsPost201Response1PaymentInformationPaymentTypeMethod {
    /**
    * The payment channel that facilitates the transactions. This parameter can be used if the payment channels are listed on the merchant’s site, and the payment channel is known.  Possible Values:  #### Via PPRO - `alfaVa` - `kredivo` - `consumerBarCode` - `merchantQrCode` - `dokuWallet` 
    */
    'type'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsPost201Response1PaymentInformationPaymentTypeMethod.attributeTypeMap;
    }
}

export class PtsV2PaymentsPost201Response1ProcessorInformation {
    /**
    * Network transaction identifier (TID). You can use this value to identify a specific transaction when you are discussing the transaction with your processor. Not all processors provide this value.  Returned by the authorization service.  #### PIN debit Transaction identifier generated by the processor.  Returned by PIN debit credit.  #### GPX Processor transaction ID.  #### Cielo For Cielo, this value is the non-sequential unit (NSU) and is supported for all transactions. The value is generated by Cielo or the issuing bank.  #### Comercio Latino For Comercio Latino, this value is the proof of sale or non-sequential unit (NSU) number generated by the acquirers Cielo and Rede, or the issuing bank.  #### CyberSource through VisaNet and GPN For details about this value for CyberSource through VisaNet and GPN, see \"processorInformation.networkTransactionId\" in [REST API Fields](https://developer.cybersource.com/content/dam/docs/cybs/en-us/apifields/reference/all/rest/api-fields.pdf)  #### Moneris This value identifies the transaction on a host system. It contains the following information: - Terminal used to process the transaction - Shift during which the transaction took place - Batch number - Transaction number within the batch You must store this value. If you give the customer a receipt, display this value on the receipt.  **Example** For the value 66012345001069003: - Terminal ID = 66012345 - Shift number = 001 - Batch number = 069 - Transaction number = 003 
    */
    'transactionId'?: string;
    /**
    * The description for this field is not available.
    */
    'tradeNumber'?: string;
    /**
    * This field is set to the value of failure reason returned by the processor. 
    */
    'rawResponse'?: string;
    /**
    * This field is set to the value of failure reason returned by the processor in the local language of the processor. 
    */
    'rawResponseLocal'?: string;
    /**
    * This field might contain information about a decline. 
    */
    'responseDetails'?: string;
    /**
    * This field is set to the value of response code returned by the processor. 
    */
    'responseCode'?: string;
    'sellerProtection'?: PtsV2PaymentsPost201ResponseProcessorInformationSellerProtection;
    'avs'?: PtsV2PaymentsPost201Response1ProcessorInformationAvs;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "transactionId",
            "baseName": "transactionId",
            "type": "string"
        },
        {
            "name": "tradeNumber",
            "baseName": "tradeNumber",
            "type": "string"
        },
        {
            "name": "rawResponse",
            "baseName": "rawResponse",
            "type": "string"
        },
        {
            "name": "rawResponseLocal",
            "baseName": "rawResponseLocal",
            "type": "string"
        },
        {
            "name": "responseDetails",
            "baseName": "responseDetails",
            "type": "string"
        },
        {
            "name": "responseCode",
            "baseName": "responseCode",
            "type": "string"
        },
        {
            "name": "sellerProtection",
            "baseName": "sellerProtection",
            "type": "PtsV2PaymentsPost201ResponseProcessorInformationSellerProtection"
        },
        {
            "name": "avs",
            "baseName": "avs",
            "type": "PtsV2PaymentsPost201Response1ProcessorInformationAvs"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsPost201Response1ProcessorInformation.attributeTypeMap;
    }
}

export class PtsV2PaymentsPost201Response1ProcessorInformationAvs {
    /**
    * AVS result code sent directly from the processor. Returned only when the processor returns this value. **Important** Do not use this field to evaluate the result of AVS. Use for debugging purposes only.  Returned by authorization service. 
    */
    'codeRaw'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "codeRaw",
            "baseName": "codeRaw",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsPost201Response1ProcessorInformationAvs.attributeTypeMap;
    }
}

export class PtsV2PaymentsPost201Response2 {
    'links'?: PtsV2PaymentsPost201ResponseLinks;
    /**
    * An unique identification number generated by Cybersource to identify the submitted request. Returned by all services. It is also appended to the endpoint of the resource. On incremental authorizations, this value with be the same as the identification number returned in the original authorization response. 
    */
    'id'?: string;
    /**
    * Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ` **Example** `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.). The `T` separates the date and the time. The `Z` indicates UTC.  Returned by Cybersource for all services. 
    */
    'submitTimeUtc'?: string;
    /**
    * Status of the sessions request. Possible values:  Created  Failed 
    */
    'status'?: string;
    /**
    * Reference number for the transaction. Depending on how your Cybersource account is configured, this value could either be provided in the API request or generated by CyberSource. The actual value used in the request to the processor is provided back to you by Cybersource in the response. 
    */
    'reconciliationId'?: string;
    'errorInformation'?: PtsV2PaymentsPost201ResponseErrorInformation;
    'clientReferenceInformation'?: PtsV2PaymentsPost201ResponseClientReferenceInformation;
    'processorInformation'?: PtsV2PaymentsPost201Response2ProcessorInformation;
    'paymentInformation'?: PtsV2PaymentsPost201Response2PaymentInformation;
    'orderInformation'?: PtsV2PaymentsPost201Response2OrderInformation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "PtsV2PaymentsPost201ResponseLinks"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "submitTimeUtc",
            "baseName": "submitTimeUtc",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "reconciliationId",
            "baseName": "reconciliationId",
            "type": "string"
        },
        {
            "name": "errorInformation",
            "baseName": "errorInformation",
            "type": "PtsV2PaymentsPost201ResponseErrorInformation"
        },
        {
            "name": "clientReferenceInformation",
            "baseName": "clientReferenceInformation",
            "type": "PtsV2PaymentsPost201ResponseClientReferenceInformation"
        },
        {
            "name": "processorInformation",
            "baseName": "processorInformation",
            "type": "PtsV2PaymentsPost201Response2ProcessorInformation"
        },
        {
            "name": "paymentInformation",
            "baseName": "paymentInformation",
            "type": "PtsV2PaymentsPost201Response2PaymentInformation"
        },
        {
            "name": "orderInformation",
            "baseName": "orderInformation",
            "type": "PtsV2PaymentsPost201Response2OrderInformation"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsPost201Response2.attributeTypeMap;
    }
}

export class PtsV2PaymentsPost201Response2OrderInformation {
    'amountDetails'?: PtsV2PaymentsPost201Response2OrderInformationAmountDetails;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "amountDetails",
            "baseName": "amountDetails",
            "type": "PtsV2PaymentsPost201Response2OrderInformationAmountDetails"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsPost201Response2OrderInformation.attributeTypeMap;
    }
}

export class PtsV2PaymentsPost201Response2OrderInformationAmountDetails {
    /**
    * Grand total for the order. This value cannot be negative. You can include a decimal point (.), but no other special characters. CyberSource truncates the amount to the correct number of decimal places.  **Note** For CTV, FDCCompass, Paymentech processors, the maximum length for this field is 12.  **Important** Some processors have specific requirements and limitations, such as maximum amounts and maximum field lengths.  If your processor supports zero amount authorizations, you can set this field to 0 for the authorization to check if the card is lost or stolen.   #### Card Present Required to include either this field or `orderInformation.lineItems[].unitPrice` for the order.  #### Invoicing / Pay By Link Required for creating a new invoice or payment link.  #### PIN Debit Amount you requested for the PIN debit purchase. This value is returned for partial authorizations. The issuing bank can approve a partial amount if the balance on the debit card is less than the requested transaction amount.  Required field for PIN Debit purchase and PIN Debit credit requests. Optional field for PIN Debit reversal requests.  #### GPX This field is optional for reversing an authorization or credit; however, for all other processors, these fields are required.  #### DCC with a Third-Party Provider Set this field to the converted amount that was returned by the DCC provider. You must include either this field or the 1st line item in the order and the specific line-order amount in your request.   #### DCC for First Data Not used. 
    */
    'totalAmount'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "totalAmount",
            "baseName": "totalAmount",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsPost201Response2OrderInformationAmountDetails.attributeTypeMap;
    }
}

export class PtsV2PaymentsPost201Response2PaymentInformation {
    'eWallet'?: PtsV2PaymentsPost201Response2PaymentInformationEWallet;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "eWallet",
            "baseName": "eWallet",
            "type": "PtsV2PaymentsPost201Response2PaymentInformationEWallet"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsPost201Response2PaymentInformation.attributeTypeMap;
    }
}

export class PtsV2PaymentsPost201Response2PaymentInformationEWallet {
    /**
    * Payment mode for the transaction, possible values - INSTANT_TRANSFER - MANUAL_BANK_TRANSFER - DELAYED_TRANSFER - ECHECK 
    */
    'fundingSource'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "fundingSource",
            "baseName": "fundingSource",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsPost201Response2PaymentInformationEWallet.attributeTypeMap;
    }
}

export class PtsV2PaymentsPost201Response2ProcessorInformation {
    /**
    * Network transaction identifier (TID). You can use this value to identify a specific transaction when you are discussing the transaction with your processor. Not all processors provide this value.  Returned by the authorization service.  #### PIN debit Transaction identifier generated by the processor.  Returned by PIN debit credit.  #### GPX Processor transaction ID.  #### Cielo For Cielo, this value is the non-sequential unit (NSU) and is supported for all transactions. The value is generated by Cielo or the issuing bank.  #### Comercio Latino For Comercio Latino, this value is the proof of sale or non-sequential unit (NSU) number generated by the acquirers Cielo and Rede, or the issuing bank.  #### CyberSource through VisaNet and GPN For details about this value for CyberSource through VisaNet and GPN, see \"processorInformation.networkTransactionId\" in [REST API Fields](https://developer.cybersource.com/content/dam/docs/cybs/en-us/apifields/reference/all/rest/api-fields.pdf)  #### Moneris This value identifies the transaction on a host system. It contains the following information: - Terminal used to process the transaction - Shift during which the transaction took place - Batch number - Transaction number within the batch You must store this value. If you give the customer a receipt, display this value on the receipt.  **Example** For the value 66012345001069003: - Terminal ID = 66012345 - Shift number = 001 - Batch number = 069 - Transaction number = 003 
    */
    'transactionId'?: string;
    /**
    * Direct the customer to this URL to complete the payment.
    */
    'paymentUrl'?: string;
    /**
    * This field might contain information about a decline. This field is supported only for **CyberSource through VisaNet**. 
    */
    'responseDetails'?: string;
    /**
    * Payment gateway/processor assigned session token. 
    */
    'token'?: string;
    /**
    * Transaction status from the processor. 
    */
    'responseCode'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "transactionId",
            "baseName": "transactionId",
            "type": "string"
        },
        {
            "name": "paymentUrl",
            "baseName": "paymentUrl",
            "type": "string"
        },
        {
            "name": "responseDetails",
            "baseName": "responseDetails",
            "type": "string"
        },
        {
            "name": "token",
            "baseName": "token",
            "type": "string"
        },
        {
            "name": "responseCode",
            "baseName": "responseCode",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsPost201Response2ProcessorInformation.attributeTypeMap;
    }
}

export class PtsV2PaymentsPost201ResponseBuyerInformation {
    /**
    * Your identifier for the customer.  When a subscription or customer profile is being created, the maximum length for this field for most processors is 30. Otherwise, the maximum length is 100.  #### Comercio Latino For recurring payments in Mexico, the value is the customer’s contract number. Note Before you request the authorization, you must inform the issuer of the customer contract numbers that will be used for recurring transactions.  #### Worldpay VAP For a follow-on credit with Worldpay VAP, CyberSource checks the following locations, in the order given, for a customer account ID value and uses the first value it finds: 1. `customer_account_id` value in the follow-on credit request 2. Customer account ID value that was used for the capture that is being credited 3. Customer account ID value that was used for the original authorization If a customer account ID value cannot be found in any of these locations, then no value is used. 
    */
    'merchantCustomerId'?: string;
    /**
    * Recipient’s date of birth. **Format**: `YYYYMMDD`.  This field is a `pass-through`, which means that CyberSource ensures that the value is eight numeric characters but otherwise does not verify the value or modify it in any way before sending it to the processor. If the field is not required for the transaction, CyberSource does not forward it to the processor. 
    */
    'dateOfBirth'?: string;
    /**
    * Customer’s government-assigned tax identification number.  #### Tax Calculation Optional for international and value added taxes only. Not applicable to U.S. and Canadian taxes. 
    */
    'vatRegistrationNumber'?: string;
    'personalIdentification'?: Array<Ptsv2paymentsBuyerInformationPersonalIdentification>;
    /**
    * The description for this field is not available.
    */
    'taxId'?: string;
    /**
    * The buyer’s Alipay login Id, the id might be an email or mobile number. The id is partially masked for privacy. cao***@126.com  or 186***22156 
    */
    'loginId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "merchantCustomerId",
            "baseName": "merchantCustomerId",
            "type": "string"
        },
        {
            "name": "dateOfBirth",
            "baseName": "dateOfBirth",
            "type": "string"
        },
        {
            "name": "vatRegistrationNumber",
            "baseName": "vatRegistrationNumber",
            "type": "string"
        },
        {
            "name": "personalIdentification",
            "baseName": "personalIdentification",
            "type": "Array<Ptsv2paymentsBuyerInformationPersonalIdentification>"
        },
        {
            "name": "taxId",
            "baseName": "taxId",
            "type": "string"
        },
        {
            "name": "loginId",
            "baseName": "loginId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsPost201ResponseBuyerInformation.attributeTypeMap;
    }
}

export class PtsV2PaymentsPost201ResponseClientReferenceInformation {
    /**
    * Merchant-generated order reference or tracking number. It is recommended that you send a unique value for each transaction so that you can perform meaningful searches for the transaction.  #### Used by **Authorization** Required field.  #### PIN Debit Requests for PIN debit reversals need to use the same merchant reference number that was used in the transaction that is being reversed.  Required field for all PIN Debit requests (purchase, credit, and reversal).  #### FDC Nashville Global Certain circumstances can cause the processor to truncate this value to 15 or 17 characters for Level II and Level III processing, which can cause a discrepancy between the value you submit and the value included in some processor reports. 
    */
    'code'?: string;
    /**
    * Date and time at your physical location.  Format: `YYYYMMDDhhmmss`, where YYYY = year, MM = month, DD = day, hh = hour, mm = minutes ss = seconds  #### PIN Debit Optional field for PIN Debit purchase and credit requests. 
    */
    'submitLocalDateTime'?: string;
    /**
    * Merchant ID that was used to create the subscription or customer profile for which the service was requested.  If your CyberSource account is enabled for Recurring Billing, this field is returned only if you are using subscription sharing and if your merchant ID is in the same merchant ID pool as the owner merchant ID.  If your CyberSource account is enabled for Payment Tokenization, this field is returned only if you are using profile sharing and if your merchant ID is in the same merchant ID pool as the owner merchant ID. 
    */
    'ownerMerchantId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        },
        {
            "name": "submitLocalDateTime",
            "baseName": "submitLocalDateTime",
            "type": "string"
        },
        {
            "name": "ownerMerchantId",
            "baseName": "ownerMerchantId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsPost201ResponseClientReferenceInformation.attributeTypeMap;
    }
}

export class PtsV2PaymentsPost201ResponseConsumerAuthenticationInformation {
    /**
    * JSON Web Token (JWT) used to authenticate the consumer with the authentication provider, such as, CardinalCommerce or Rupay. Note - Max Length of this field is 2048 characters. 
    */
    'accessToken'?: string;
    /**
    * Identifies the UI Type the ACS will use to complete the challenge. **NOTE**: Only available for App transactions using the Cardinal Mobile SDK. 
    */
    'acsRenderingType'?: string;
    /**
    * Unique transaction identifier assigned by the ACS to identify a single transaction. 
    */
    'acsTransactionId'?: string;
    /**
    * URL for the card-issuing bank’s authentication form that you receive when the card is enrolled. The value can be very large. 
    */
    'acsUrl'?: string;
    /**
    * Indicates what displays to the customer during the authentication process. This field can contain one of these values: - `ADS`: (Card not enrolled) customer prompted to activate the card during the checkout process. - `ATTEMPTS`: (Attempts processing) Processing briefly displays before the checkout process is completed. - `ENROLLED`: (Card enrolled) the card issuer’s authentication window displays. - `UNKNOWN`: Card enrollment status cannot be determined. - `NOREDIRECT`: (Card not enrolled, authentication unavailable, or error occurred) nothing displays to the customer.  The following values can be returned if you are using rules-based payer authentication. - `RIBA`: The card-issuing bank supports risk-based authentication, but whether the cardholder is likely to be challenged cannot be determined. - `RIBA_PASS`: The card-issuing bank supports risk-based authentication and it is likely that the cardholder will not be challenged to provide credentials, also known as _silent authentication_. 
    */
    'authenticationPath'?: string;
    /**
    * The Base64 encoded JSON Payload of CB specific Authorization Values returned in the challenge Flow 
    */
    'authorizationPayload'?: string;
    /**
    * Payer authentication transaction identifier is used to link the check enrollment and validate authentication messages. For Rupay, this field should be passed as request only for Resend OTP use case. 
    */
    'authenticationTransactionId'?: string;
    /**
    * Text provided by the ACS/Issuer to Cardholder during a Frictionless or Decoupled transaction.The Issuer can provide information to Cardholder. For example, “Additional authentication is needed for this transaction, please contact (Issuer Name) at xxx-xxx-xxxx.”. The Issuing Bank can optionally support this value. 
    */
    'cardholderMessage'?: string;
    /**
    * Unique identifier generated by the card-issuing bank for Visa, American Express, JCB, Diners Club, and Discover transactions after the customer is authenticated. The value is in base64. When you request the card authorization service, CyberSource automatically converts the value, not the field name, to the format required by your payment processor. 
    */
    'cavv'?: string;
    /**
    * Field that is returned only when the CAVV is generated, which occurs when paresStatus contains the values Y (successful authentication) or A (attempted authentication). If you use the ATOS processor, send the value of this field in the `cavv_algorithm` request field of the authorization service. This field contains one of these values: - `2`: Visa, American Express, JCB, Diners Club, and Discover - `3`: Mastercard 
    */
    'cavvAlgorithm'?: string;
    /**
    * An indicator as to why the transaction was canceled. Possible Values:  - `01`: Cardholder selected Cancel. - `02`: Reserved for future EMVCo use (values invalid until defined by EMVCo). - `03`: Transaction Timed Out—Decoupled Authentication - `04`: Transaction timed out at ACS—other timeouts - `05`: Transaction Timed out at ACS - First CReq not received by ACS - `06`: Transaction Error - `07`: Unknown - `08`: Transaction Timed Out at SDK 
    */
    'challengeCancelCode'?: string;
    /**
    * Indicates whether a challenge is required in order to complete authentication. **Note** Regional mandates might determine that a challenge is required.  Possible values: - `Y`: Challenge required - `N`: Challenge not required **Note**  Used by the Hybrid integration. 
    */
    'challengeRequired'?: string;
    /**
    * Indicates whether the 3DS Requestor requests the ACS to utilize Decoupled Authentication and agrees to utilize Decoupled Authentication if the ACS confirms its use.  Possible Values:  Y - Decoupled Authentication is supported and preferred if challenge is necessary  N - Do not use Decoupled Authentication  **Default Value**: N 
    */
    'decoupledAuthenticationIndicator'?: string;
    /**
    * The directory server error code indicating a problem with this transaction. Note - Max Length of this field is typically 3 characters. 
    */
    'directoryServerErrorCode'?: string;
    /**
    * Directory server text and additional detail about the error for this transaction. 
    */
    'directoryServerErrorDescription'?: string;
    /**
    * Commerce indicator for cards not enrolled. This field contains one of these values: - `internet`: Card not enrolled, or card type not supported by payer authentication. No liability shift. - `js_attempted`: Card not enrolled, but attempt to authenticate is recorded. Liability shift. - `js_failure`: J/Secure directory service is not available. No liability shift. - `spa`: Mastercard card not enrolled in the SecureCode program. No liability shift. - `vbv_attempted`: Card not enrolled, but attempt to authenticate is recorded. Liability shift. - `vbv_failure`: For payment processor Barclays, Streamline, AIBMS, or FDC Germany, you receive this result if Visa’s directory service is not available. No liability shift. 
    */
    'ecommerceIndicator'?: string;
    /**
    * Note This field applies only to non-U.S-issued cards.  For enroll, Numeric electronic commerce indicator (ECI) returned only for Visa, American Express, JCB, Diners Club, and Discover transactions when the card is not enrolled. For more information, see \"Interpreting the Reply,\" page 22.  If you are not using the CyberSource payment services, you must send this value to your payment processor in the subsequent request for card authorization. This field contains one of these values: - `06`: The card can be enrolled. Liability shift. - `07`: The card cannot be enrolled. No liability shift.  For validate, Numeric electronic commerce indicator (ECI) returned only for Visa, American Express, JCB, Diners Club, and Discover transactions. The field is absent when authentication fails. You must send this value to your payment processor in the subsequent request for card authorization. This field contains one of these values: - `05`: Successful authentication - `06`: Authentication attempted - `07`: Failed authentication (No response from the merchant because of a problem.) 
    */
    'eci'?: string;
    /**
    * ECI value that can be returned for Visa, Mastercard, American Express, JCB, Diners Club, and Discover. The field is absent when authentication fails. If your payment processor is Streamline, you must pass the value of this field instead of the value of `eci` or `ucafCollectionIndicator`.  This field can contain one of these values: - `01`: Authentication attempted (Mastercard) - `02`: Successful authentication (Mastercard) - `05`: Successful authentication (Visa, American Express, JCB, Diners Club, and Discover) - `06`: Authentication attempted (Visa, American Express, JCB, Diners Club, and Discover) 
    */
    'eciRaw'?: string;
    /**
    * This field describes the type of 3DS transaction flow that took place.  It can be one of three possible flows; CH - Challenge FR - Frictionless FD - Frictionless with delegation, (challenge not generated by the issuer but by the scheme on behalf of the issuer). 
    */
    'effectiveAuthenticationType'?: string;
    'ivr'?: PtsV2PaymentsPost201ResponseConsumerAuthenticationInformationIvr;
    'strongAuthentication'?: PtsV2PaymentsPost201ResponseConsumerAuthenticationInformationStrongAuthentication;
    /**
    * The global score calculated by the CB scoring platform and returned to merchants. 
    */
    'networkScore'?: string;
    /**
    * Payer authentication request (PAReq) message that you need to forward to the ACS. The value can be very large. The value is in base64. 
    */
    'pareq'?: string;
    /**
    * Raw result of the authentication check. If you are configured for Asia, Middle East, and Africa Gateway Processing, you need to send the value of this field in your authorization request. This field can contain one of these values: - `A`: Proof of authentication attempt was generated. - `N`: Customer failed or canceled authentication. Transaction denied. - `U`: Authentication not completed regardless of the reason. - `Y`: Customer was successfully authenticated. 
    */
    'paresStatus'?: string;
    /**
    * Date and time of the enrollment check combined with the VEReq and VERes elements. If you ever need to show proof of enrollment checking, you may need to parse the string for the information required by the payment card company. The value can be very large.  For cards issued in the U.S. or Canada, Visa may require this data for specific merchant category codes.For cards not issued in the U.S. or Canada, your bank may require this data as proof of enrollment checking for any payer authentication transaction that you re-present because of a chargeback. 
    */
    'proofXml'?: string;
    /**
    * Encrypted version of the card number used in the payer authentication request message. 
    */
    'proxyPan'?: string;
    /**
    * SDK unique transaction identifier that is generated on each new transaction. 
    */
    'sdkTransactionId'?: string;
    /**
    * Provides additional information as to why the PAResStatus has a specific value. 
    */
    'signedParesStatusReason'?: string;
    /**
    * This field contains the 3D Secure version that was used to process the transaction. For example: 2.2.0 
    */
    'specificationVersion'?: string;
    /**
    * The fully qualified URL that the merchant uses to post a form to the cardholder in order to complete the Consumer Authentication transaction for the Cardinal Cruise API integration. 
    */
    'stepUpUrl'?: string;
    /**
    * Unique transaction identifier assigned by the 3DS Server to identify a single transaction. 
    */
    'threeDSServerTransactionId'?: string;
    /**
    * AAV is a unique identifier generated by the card-issuing bank for Mastercard Identity Check transactions after the customer is authenticated. The value is in base64. Include the data in the card authorization request. 
    */
    'ucafAuthenticationData'?: string;
    /**
    * For enroll, Returned only for Mastercard transactions. Indicates that authentication is not required because the customer is not enrolled. Add the value of this field to the authorization field ucaf_collection_indicator. This field can contain these values: 0, 1.  For validate, Numeric electronic commerce indicator (ECI) returned only for Mastercard Identity Check transactions. The field is absent when authentication fails. You must send this value to your payment processor in the request for card authorization. This field contain one of these values: - `0`: Authentication data not collected, and customer authentication was not completed. - `1`: Authentication data not collected because customer authentication was not completed. - `2`: Authentication data collected because customer completed authentication. 
    */
    'ucafCollectionIndicator'?: string;
    /**
    * Result of the enrollment check. This field can contain one of these values: - `Y`: Card enrolled or can be enrolled; you must authenticate. Liability shift. - `N`: Card not enrolled; proceed with authorization. Liability shift. - `U`: Unable to authenticate regardless of the reason. No liability shift.  **Note** This field only applies to the Asia, Middle East, and Africa Gateway. If you are configured for this processor, you must send the value of this field in your authorization request.  The following value can be returned if you are using rules-based Payer Authentication: - `B`: Indicates that authentication was bypassed. 
    */
    'veresEnrolled'?: string;
    /**
    * This data element will be populated by the system setting Whitelist Status. Possible Values: 01 - 3DS/ Server/ 02 – DS/03 - ACS 
    */
    'whiteListStatusSource'?: string;
    /**
    * Transaction identifier generated by CyberSource for successful enrollment or validation checks. Use this value, which is in base64, to match an outgoing PAReq with an incoming PARes. CyberSource forwards the XID with the card authorization service to these payment processors in these cases: - Barclays - Streamline (when the **ecommerceIndicator**`=spa`) 
    */
    'xid'?: string;
    /**
    * The Directory Server Transaction ID is generated by the Mastercard Directory Server during the authentication transaction and passed back to the merchant with the authentication results. For Cybersource Through Visanet Gateway: The value for this field corresponds to the following data in the TC 33 capture file3: Record: CP01 TCR7, Position: 114-149, Field: MC AVV Verification—Directory Server Transaction ID 
    */
    'directoryServerTransactionId'?: string;
    /**
    * The field is used to indicate that a transaction does not meet the Visa Secure authentication data quality requirements.
    */
    'dataQualityIndicator'?: string;
    /**
    * Raw authentication data that comes from the cardissuing bank. Primary authentication field that indicates if authentication was successful and if liability shift occurred. You should examine first the result of this field. This field contains one of these values: - `-1`: Invalid PARes. - `0`: Successful validation. - `1`: Cardholder is not participating, but the attempt to authenticate was recorded. - `6`: Issuer unable to perform authentication. - `9`: Cardholder did not complete authentication. 
    */
    'authenticationResult'?: string;
    /**
    * Message that explains the authenticationResult reply field. 
    */
    'authenticationStatusMsg'?: string;
    /**
    * Indicator used to differentiate Internet transactions from other types. The authentication failed if this field is not returned. For Visa, if your payment processor is Streamline, Barclays, AIBMS, or FDC Germany, you receive the value vbv_failure instead of internet when eci is 07. The value of this field is passed automatically to the authorization service if you request the services together. This field contains one of these values: - `aesk`: American Express SafeKey authentication verified successfully. - `aesk_attempted`: Card not enrolled in American Express SafeKey, but the attempt to authenticate was recorded. - `dipb`: Discover ProtectBuy authentication verified successfully. - `dipb_attempted`: Card not enrolled in Discover ProtectBuy, but the attempt to authenticate was recorded. - `internet`: Authentication was not verified successfully. - `js`: J/Secure authentication verified successfully. - `js_attempted`: Card not enrolled in J/Secure, but the attempt to authenticate was recorded. - `moto`: Mail or telephone order. - `pb_attempted`: Card not enrolled in Diners Club ProtectBuy, but the attempt to authenticate was recorded. - `recurring`: Recurring transaction. - `spa`: Mastercard Identity Check authentication verified successfully. - `spa_failure`: Mastercard Identity Check failed authentication. - `vbv`: Visa Secure authentication verified successfully. - `vbv_attempted`: Card not enrolled in Visa Secure, but the attempt to authenticate was recorded. - `vbv_failure`: Visa Secure authentication unavailable. 
    */
    'indicator'?: string;
    /**
    * Indicates the number of authentication cycles attempted by the cardholder and is tracked by the Issuing Banks ACS.Example: if customer gets the challenge window and enter in their one time password and hit submit then that interaction counter should just be 1. When customer gets the challenge window and the bank asks if they want to have the one time password  sent to their phone or their email and they have to choose before going to the next screen to enter in their one time password then this interaction count would be 2. One for the selection of how they want the one time password delivered and another with them actually entering in the one time password and hitting the submit button. 
    */
    'interactionCounter'?: string;
    /**
    * Enables the communication of trusted beneficiary/whitelist status between the ACS, the DS and the 3DS Requestor.  Possible Values:  Y - 3DS Requestor is whitelisted by cardholder  N - 3DS Requestor is not whitelisted by cardholder 
    */
    'whiteListStatus'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "accessToken",
            "baseName": "accessToken",
            "type": "string"
        },
        {
            "name": "acsRenderingType",
            "baseName": "acsRenderingType",
            "type": "string"
        },
        {
            "name": "acsTransactionId",
            "baseName": "acsTransactionId",
            "type": "string"
        },
        {
            "name": "acsUrl",
            "baseName": "acsUrl",
            "type": "string"
        },
        {
            "name": "authenticationPath",
            "baseName": "authenticationPath",
            "type": "string"
        },
        {
            "name": "authorizationPayload",
            "baseName": "authorizationPayload",
            "type": "string"
        },
        {
            "name": "authenticationTransactionId",
            "baseName": "authenticationTransactionId",
            "type": "string"
        },
        {
            "name": "cardholderMessage",
            "baseName": "cardholderMessage",
            "type": "string"
        },
        {
            "name": "cavv",
            "baseName": "cavv",
            "type": "string"
        },
        {
            "name": "cavvAlgorithm",
            "baseName": "cavvAlgorithm",
            "type": "string"
        },
        {
            "name": "challengeCancelCode",
            "baseName": "challengeCancelCode",
            "type": "string"
        },
        {
            "name": "challengeRequired",
            "baseName": "challengeRequired",
            "type": "string"
        },
        {
            "name": "decoupledAuthenticationIndicator",
            "baseName": "decoupledAuthenticationIndicator",
            "type": "string"
        },
        {
            "name": "directoryServerErrorCode",
            "baseName": "directoryServerErrorCode",
            "type": "string"
        },
        {
            "name": "directoryServerErrorDescription",
            "baseName": "directoryServerErrorDescription",
            "type": "string"
        },
        {
            "name": "ecommerceIndicator",
            "baseName": "ecommerceIndicator",
            "type": "string"
        },
        {
            "name": "eci",
            "baseName": "eci",
            "type": "string"
        },
        {
            "name": "eciRaw",
            "baseName": "eciRaw",
            "type": "string"
        },
        {
            "name": "effectiveAuthenticationType",
            "baseName": "effectiveAuthenticationType",
            "type": "string"
        },
        {
            "name": "ivr",
            "baseName": "ivr",
            "type": "PtsV2PaymentsPost201ResponseConsumerAuthenticationInformationIvr"
        },
        {
            "name": "strongAuthentication",
            "baseName": "strongAuthentication",
            "type": "PtsV2PaymentsPost201ResponseConsumerAuthenticationInformationStrongAuthentication"
        },
        {
            "name": "networkScore",
            "baseName": "networkScore",
            "type": "string"
        },
        {
            "name": "pareq",
            "baseName": "pareq",
            "type": "string"
        },
        {
            "name": "paresStatus",
            "baseName": "paresStatus",
            "type": "string"
        },
        {
            "name": "proofXml",
            "baseName": "proofXml",
            "type": "string"
        },
        {
            "name": "proxyPan",
            "baseName": "proxyPan",
            "type": "string"
        },
        {
            "name": "sdkTransactionId",
            "baseName": "sdkTransactionId",
            "type": "string"
        },
        {
            "name": "signedParesStatusReason",
            "baseName": "signedParesStatusReason",
            "type": "string"
        },
        {
            "name": "specificationVersion",
            "baseName": "specificationVersion",
            "type": "string"
        },
        {
            "name": "stepUpUrl",
            "baseName": "stepUpUrl",
            "type": "string"
        },
        {
            "name": "threeDSServerTransactionId",
            "baseName": "threeDSServerTransactionId",
            "type": "string"
        },
        {
            "name": "ucafAuthenticationData",
            "baseName": "ucafAuthenticationData",
            "type": "string"
        },
        {
            "name": "ucafCollectionIndicator",
            "baseName": "ucafCollectionIndicator",
            "type": "string"
        },
        {
            "name": "veresEnrolled",
            "baseName": "veresEnrolled",
            "type": "string"
        },
        {
            "name": "whiteListStatusSource",
            "baseName": "whiteListStatusSource",
            "type": "string"
        },
        {
            "name": "xid",
            "baseName": "xid",
            "type": "string"
        },
        {
            "name": "directoryServerTransactionId",
            "baseName": "directoryServerTransactionId",
            "type": "string"
        },
        {
            "name": "dataQualityIndicator",
            "baseName": "dataQualityIndicator",
            "type": "string"
        },
        {
            "name": "authenticationResult",
            "baseName": "authenticationResult",
            "type": "string"
        },
        {
            "name": "authenticationStatusMsg",
            "baseName": "authenticationStatusMsg",
            "type": "string"
        },
        {
            "name": "indicator",
            "baseName": "indicator",
            "type": "string"
        },
        {
            "name": "interactionCounter",
            "baseName": "interactionCounter",
            "type": "string"
        },
        {
            "name": "whiteListStatus",
            "baseName": "whiteListStatus",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsPost201ResponseConsumerAuthenticationInformation.attributeTypeMap;
    }
}

export class PtsV2PaymentsPost201ResponseConsumerAuthenticationInformationIvr {
    /**
    * Flag to indicate if a valid IVR transaction was detected. 
    */
    'enabledMessage'?: boolean;
    /**
    * Encryption key to be used in the event the ACS requires encryption of the credential field. 
    */
    'encryptionKey'?: string;
    /**
    * Flag to indicate if the ACS requires the credential to be encrypted. 
    */
    'encryptionMandatory'?: boolean;
    /**
    * An indicator from the ACS to inform the type of encryption that should be used in the event the ACS requires encryption of the credential field. 
    */
    'encryptionType'?: string;
    /**
    * An ACS Provided label that can be presented to the Consumer. Recommended use with an application. 
    */
    'label'?: string;
    /**
    * An ACS provided string that can be presented to the Consumer. Recommended use with an application. 
    */
    'prompt'?: string;
    /**
    * An ACS provided message that can provide additional information or details. 
    */
    'statusMessage'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "enabledMessage",
            "baseName": "enabledMessage",
            "type": "boolean"
        },
        {
            "name": "encryptionKey",
            "baseName": "encryptionKey",
            "type": "string"
        },
        {
            "name": "encryptionMandatory",
            "baseName": "encryptionMandatory",
            "type": "boolean"
        },
        {
            "name": "encryptionType",
            "baseName": "encryptionType",
            "type": "string"
        },
        {
            "name": "label",
            "baseName": "label",
            "type": "string"
        },
        {
            "name": "prompt",
            "baseName": "prompt",
            "type": "string"
        },
        {
            "name": "statusMessage",
            "baseName": "statusMessage",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsPost201ResponseConsumerAuthenticationInformationIvr.attributeTypeMap;
    }
}

export class PtsV2PaymentsPost201ResponseConsumerAuthenticationInformationStrongAuthentication {
    'issuerInformation'?: PaymentsStrongAuthIssuerInformation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "issuerInformation",
            "baseName": "issuerInformation",
            "type": "PaymentsStrongAuthIssuerInformation"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsPost201ResponseConsumerAuthenticationInformationStrongAuthentication.attributeTypeMap;
    }
}

/**
* Contains embedded actions, that includes status and response for every actions in the list.
*/
export class PtsV2PaymentsPost201ResponseEmbeddedActions {
    'CAPTURE'?: PtsV2PaymentsPost201ResponseEmbeddedActionsCAPTURE;
    'DECISION'?: PtsV2PaymentsPost201ResponseEmbeddedActionsDECISION;
    'CONSUMER_AUTHENTICATION'?: PtsV2PaymentsPost201ResponseEmbeddedActionsCONSUMERAUTHENTICATION;
    'VALIDATE_CONSUMER_AUTHENTICATION'?: PtsV2PaymentsPost201ResponseEmbeddedActionsCONSUMERAUTHENTICATION;
    'WATCHLIST_SCREENING'?: PtsV2PaymentsPost201ResponseEmbeddedActionsWATCHLISTSCREENING;
    'TOKEN_CREATE'?: PtsV2PaymentsPost201ResponseEmbeddedActionsTOKENCREATE;
    'TOKEN_UPDATE'?: PtsV2PaymentsPost201ResponseEmbeddedActionsTOKENUPDATE;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "CAPTURE",
            "baseName": "CAPTURE",
            "type": "PtsV2PaymentsPost201ResponseEmbeddedActionsCAPTURE"
        },
        {
            "name": "DECISION",
            "baseName": "DECISION",
            "type": "PtsV2PaymentsPost201ResponseEmbeddedActionsDECISION"
        },
        {
            "name": "CONSUMER_AUTHENTICATION",
            "baseName": "CONSUMER_AUTHENTICATION",
            "type": "PtsV2PaymentsPost201ResponseEmbeddedActionsCONSUMERAUTHENTICATION"
        },
        {
            "name": "VALIDATE_CONSUMER_AUTHENTICATION",
            "baseName": "VALIDATE_CONSUMER_AUTHENTICATION",
            "type": "PtsV2PaymentsPost201ResponseEmbeddedActionsCONSUMERAUTHENTICATION"
        },
        {
            "name": "WATCHLIST_SCREENING",
            "baseName": "WATCHLIST_SCREENING",
            "type": "PtsV2PaymentsPost201ResponseEmbeddedActionsWATCHLISTSCREENING"
        },
        {
            "name": "TOKEN_CREATE",
            "baseName": "TOKEN_CREATE",
            "type": "PtsV2PaymentsPost201ResponseEmbeddedActionsTOKENCREATE"
        },
        {
            "name": "TOKEN_UPDATE",
            "baseName": "TOKEN_UPDATE",
            "type": "PtsV2PaymentsPost201ResponseEmbeddedActionsTOKENUPDATE"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsPost201ResponseEmbeddedActions.attributeTypeMap;
    }
}

export class PtsV2PaymentsPost201ResponseEmbeddedActionsCAPTURE {
    /**
    * The status of the submitted transaction.  Possible values:  - PENDING  - TRANSMITTED (Only for Online Capture enabled merchants) 
    */
    'status'?: string;
    /**
    * The reason of the status.  Possible values:  - MISSING_FIELD  - INVALID_DATA  - DUPLICATE_REQUEST  - INVALID_MERCHANT_CONFIGURATION  - EXCEEDS_AUTH_AMOUNT  - AUTH_ALREADY_REVERSED  - TRANSACTION_ALREADY_SETTLED  - INVALID_AMOUNT  - MISSING_AUTH  - TRANSACTION_ALREADY_REVERSED_OR_SETTLED  - NOT_SUPPORTED 
    */
    'reason'?: string;
    /**
    * The detail message related to the status and reason listed above.
    */
    'message'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "reason",
            "baseName": "reason",
            "type": "string"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsPost201ResponseEmbeddedActionsCAPTURE.attributeTypeMap;
    }
}

export class PtsV2PaymentsPost201ResponseEmbeddedActionsCONSUMERAUTHENTICATION {
    /**
    * The status for payerAuthentication 201 enroll and validate calls. Possible values are: - `AUTHENTICATION_SUCCESSFUL` - `PENDING_AUTHENTICATION` - `AUTHENTICATION_FAILED` 
    */
    'status'?: string;
    /**
    * The reason of the status. Possible values are: - `INVALID_MERCHANT_CONFIGURATION` - `CONSUMER_AUTHENTICATION_REQUIRED` - `CONSUMER_AUTHENTICATION_FAILED` - `AUTHENTICATION_FAILED` 
    */
    'reason'?: string;
    /**
    * The message describing the reason of the status. Value is: - Encountered a Payer Authentication problem. Payer could not be authenticated. 
    */
    'message'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "reason",
            "baseName": "reason",
            "type": "string"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsPost201ResponseEmbeddedActionsCONSUMERAUTHENTICATION.attributeTypeMap;
    }
}

export class PtsV2PaymentsPost201ResponseEmbeddedActionsDECISION {
    /**
    * The status of the submitted transaction.  Possible values:   - `ACCEPTED`   - `REJECTED`   - `PENDING_REVIEW`   - `DECLINED`   - `PENDING_AUTHENTICATION`   - `INVALID_REQUEST`   - `AUTHENTICATION_FAILED`   - `CHALLENGE` 
    */
    'status'?: string;
    /**
    * The reason of the status.  Possible values:  - `EXPIRED_CARD`  - `SCORE_EXCEEDS_THRESHOLD`  - `DECISION_PROFILE_REVIEW`  - `DECISION_PROFILE_REJECT`  - `CONSUMER_AUTHENTICATION_REQUIRED`  - `INVALID_MERCHANT_CONFIGURATION`  - `CONSUMER_AUTHENTICATION_FAILED`  - `DECISION_PROFILE_CHALLENGE`  - `CUSTOMER_WATCHLIST_MATCH`  - `ADDRESS_COUNTRY_WATCHLIST_MATCH`  - `EMAIL_COUNTRY_WATCHLIST_MATCH`  - `IP_COUNTRY_WATCHLIST_MATCH` 
    */
    'reason'?: string;
    /**
    * The detail message related to the status and reason listed above.
    */
    'message'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "reason",
            "baseName": "reason",
            "type": "string"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsPost201ResponseEmbeddedActionsDECISION.attributeTypeMap;
    }
}

export class PtsV2PaymentsPost201ResponseEmbeddedActionsTOKENCREATE {
    /**
    * The status of the token create.  Possible value is:   - SUCCESS   - SERVER_ERROR   - INVALID_REQUEST 
    */
    'status'?: string;
    /**
    * The reason of the status.  Possible values:  - INVALID_DATA  - SYSTEM_ERROR  - MISSING_FIELD 
    */
    'reason'?: string;
    /**
    * The detail message related to the status and reason listed above.
    */
    'message'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "reason",
            "baseName": "reason",
            "type": "string"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsPost201ResponseEmbeddedActionsTOKENCREATE.attributeTypeMap;
    }
}

export class PtsV2PaymentsPost201ResponseEmbeddedActionsTOKENUPDATE {
    /**
    * The status of the token update.  Possible value is:   - SUCCESS   - SERVER_ERROR   - INVALID_REQUEST 
    */
    'status'?: string;
    /**
    * The reason of the status. Possible values:  - INVALID_DATA  - SYSTEM_ERROR  - MISSING_FIELD 
    */
    'reason'?: string;
    /**
    * The detail message related to the status and reason listed above.
    */
    'message'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "reason",
            "baseName": "reason",
            "type": "string"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsPost201ResponseEmbeddedActionsTOKENUPDATE.attributeTypeMap;
    }
}

export class PtsV2PaymentsPost201ResponseEmbeddedActionsWATCHLISTSCREENING {
    /**
    * The status for the call can be: - COMPLETED - INVALID_REQUEST - DECLINED 
    */
    'status'?: string;
    /**
    * The reason of the status. Value can be   - `CUSTOMER_WATCHLIST_MATCH`   - `ADDRESS_COUNTRY_WATCHLIST_MATCH`   - `EMAIL_COUNTRY_WATCHLIST_MATCH`   - `IP_COUNTRY_WATCHLIST_MATCH`   - `INVALID_MERCHANT_CONFIGURATION` 
    */
    'reason'?: string;
    /**
    * The message describing the reason of the status. Value can be   - The customer matched the Denied Parties List   - The Export bill_country/ship_country  match   - Export email_country match   - Export hostname_country/ip_country match 
    */
    'message'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "reason",
            "baseName": "reason",
            "type": "string"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsPost201ResponseEmbeddedActionsWATCHLISTSCREENING.attributeTypeMap;
    }
}

export class PtsV2PaymentsPost201ResponseErrorInformation {
    /**
    * The reason of the status.  Possible values:  - AVS_FAILED  - CONTACT_PROCESSOR  - EXPIRED_CARD  - PROCESSOR_DECLINED  - INSUFFICIENT_FUND  - STOLEN_LOST_CARD  - ISSUER_UNAVAILABLE  - UNAUTHORIZED_CARD  - CVN_NOT_MATCH  - EXCEEDS_CREDIT_LIMIT  - INVALID_CVN  - BLOCKED_BY_CARDHOLDER  - DECLINED_CHECK  - BLACKLISTED_CUSTOMER  - SUSPENDED_ACCOUNT  - PAYMENT_REFUSED  - CV_FAILED  - INVALID_ACCOUNT  - GENERAL_DECLINE  - INVALID_MERCHANT_CONFIGURATION  - DECISION_PROFILE_REJECT  - SCORE_EXCEEDS_THRESHOLD  - PENDING_AUTHENTICATION  - ACH_VERIFICATION_FAILED  - DECISION_PROFILE_REVIEW  - CONSUMER_AUTHENTICATION_REQUIRED  - CONSUMER_AUTHENTICATION_FAILED  - ALLOWABLE_PIN_RETRIES_EXCEEDED  - PROCESSOR_ERROR  - CUSTOMER_WATCHLIST_MATCH  - ADDRESS_COUNTRY_WATCHLIST_MATCH  - EMAIL_COUNTRY_WATCHLIST_MATCH  - IP_COUNTRY_WATCHLIST_MATCH  - INVALID_MERCHANT_CONFIGURATION 
    */
    'reason'?: string;
    /**
    * The detail message related to the status and reason listed above.
    */
    'message'?: string;
    'details'?: Array<PtsV2PaymentsPost201ResponseErrorInformationDetails>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "reason",
            "baseName": "reason",
            "type": "string"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        },
        {
            "name": "details",
            "baseName": "details",
            "type": "Array<PtsV2PaymentsPost201ResponseErrorInformationDetails>"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsPost201ResponseErrorInformation.attributeTypeMap;
    }
}

export class PtsV2PaymentsPost201ResponseErrorInformationDetails {
    /**
    * This is the flattened JSON object field name/path that is either missing or invalid.
    */
    'field'?: string;
    /**
    * Possible reasons for the error.  Possible values:  - MISSING_FIELD  - INVALID_DATA 
    */
    'reason'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "field",
            "baseName": "field",
            "type": "string"
        },
        {
            "name": "reason",
            "baseName": "reason",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsPost201ResponseErrorInformationDetails.attributeTypeMap;
    }
}

export class PtsV2PaymentsPost201ResponseInstallmentInformation {
    /**
    * Additional costs charged by the issuer to fund the installment payments.  This field is included in the authorization reply for the Crediario eligibility request when the issuer approves the cardholder's request for Crediario installment payments in Brazil.  This field is supported only for Crediario installment payments in Brazil on **CyberSource through VisaNet**.  The value for this field corresponds to the following data in the TC 33 capture file1: - Record: CP01 TCR9 - Position: 128-139 - Field: Total Other Costs 
    */
    'additionalCosts'?: string;
    /**
    * Additional costs divided by the amount funded.  For example: - A value of 1.0 specifies 1%. - A value of 4.0 specifies 4%.  This field is included in the authorization reply for the Crediario eligibility request when the issuer approves the cardholder's request for Crediario installment payments in Brazil.  This field is supported only for Crediario installment payments in Brazil on **CyberSource through VisaNet**.  The value for this field corresponds to the following data in the TC 33 capture file1: - Record: CP01 TCR9 - Position: 140-143 - Field: Percent of Total Other Costs 
    */
    'additionalCostsPercentage'?: string;
    /**
    * Amount for the current installment payment.  This field is supported only for CyberSource through VisaNet. 
    */
    'amount'?: string;
    /**
    * Amount funded.  This field is included in the authorization reply for the Crediario eligibility request when the issuer approves the cardholder's request for Crediario installment payments in Brazil.  This field is supported only for Crediario installment payments in Brazil on **CyberSource through VisaNet**.  The value for this field corresponds to the following data in the TC 33 capture file1: - Record: CP01 TCR9 - Position: 48-59 - Field: Total Amount Funded 
    */
    'amountFunded'?: string;
    /**
    * Amount requested divided by the amount funded.  For example: - A value of 90.0 specifies 90%. - A value of 93.7 specifies 93.7%.  This field is included in the authorization reply for the Crediario eligibility request when the issuer approves the cardholder's request for Crediario installment payments in Brazil.  This field is supported only for Crediario installment payments in Brazil on **CyberSource through VisaNet**.  The value for this field corresponds to the following data in the TC 33 capture file1: - Record: CP01 TCR9 - Position: 60-63 - Field: Percent of Amount Requested 
    */
    'amountRequestedPercentage'?: string;
    /**
    * Annual cost of financing the installment payments.  This field is included in the authorization reply for the Crediario eligibility request when the issuer approves the cardholder's request for Crediario installment payments in Brazil.  This field is supported only for Crediario installment payments in Brazil on **CyberSource through VisaNet**.  The value for this field corresponds to the following data in the TC 33 capture file1: - Record: CP01 TCR9 - Position: 158-164 - Field: Annual Total Cost of Financing 
    */
    'annualFinancingCost'?: string;
    /**
    * Annual interest rate.  This field is returned only for two kinds of installment payments on Visa Platform Connect: - Crediario with Visa in Brazil: this field is included in the authorization response for the Crediario eligibility request when the issuer approves the customer's request for Crediario installment payments. - Mastercard in all countries except Brazil, Croatia, Georgia, and Greece.   Example: A value of 1.0 specifies 1%.  Example: A value of 4.0 specifies 4%.  #### Brazil The value for this field corresponds to the following data in the TC 33 capture file: - Record: CP01 TCR9 - Position: 151-157 - Field: Annual Interest Rate   #### Other Countries The value for this field corresponds to the following data in the TC 33 capture file: - Record: CP01 TCR5 - Position: 58-62 SCMP API Fields| 216 - Field: Mastercard Annual Percentage Rate 
    */
    'annualInterestRate'?: string;
    /**
    * Expenses charged by the issuer to fund the installment payments.  This field is included in the authorization reply for the Crediario eligibility request when the issuer approves the cardholder's request for Crediario installment payments in Brazil.  This field is supported only for Crediario installment payments in Brazil on **CyberSource through VisaNet**.  The value for this field corresponds to the following data in the TC 33 capture file1: - Record: CP01 TCR9 - Position: 64-75 - Field: Total Expenses 
    */
    'expenses'?: string;
    /**
    * Expenses divided by the amount funded.  For example: - A value of 1.0 specifies 1%. - A value of 4.0 specifies 4%.  This field is included in the authorization reply for the Crediario eligibility request when the issuer approves the cardholder's request for Crediario installment payments in Brazil.  This field is supported only for Crediario installment payments in Brazil on **CyberSource through VisaNet**.  The value for this field corresponds to the following data in the TC 33 capture file1: - Record: CP01 TCR9 - Position: 76-79 - Field: Percent of Total Expenses 
    */
    'expensesPercentage'?: string;
    /**
    * Fees charged by the issuer to fund the installment payments.  This field is included in the authorization reply for the Crediario eligibility request when the issuer approves the cardholder's request for Crediario installment payments in Brazil.  This field is supported only for Crediario installment payments in Brazil on **CyberSource through VisaNet**.  The value for this field corresponds to the following data in the TC 33 capture file1: - Record: CP01 TCR9 - Position: 80-91 - Field: Total Fees 
    */
    'fees'?: string;
    /**
    * Fees divided by the amount funded.  For example: - A value of 1.0 specifies 1%. - A value of 4.0 specifies 4%.  This field is included in the authorization reply for the Crediario eligibility request when the issuer approves the cardholder's request for Crediario installment payments in Brazil.  This field is supported only for Crediario installment payments in Brazil on CyberSource through VisaNet.  The value for this field corresponds to the following data in the TC 33 capture file1: - Record: CP01 TCR9 - Position: 92-95 - Field: Percent of Total Fees 
    */
    'feesPercentage'?: string;
    /**
    * Frequency of the installment payments. When you do not include this field in a request for a Crediario installment payment, CyberSource sends a space character to the processor.  This field is supported only for CyberSource through VisaNet. Possible values: - `B`: Biweekly - `M`: Monthly - `W`: Weekly  For Crediario installment payments, the value for this field corresponds to the following data in the TC 33 capture file5: - Record: CP01 TCR9 - Position: 41 - Field: Installment Frequency 
    */
    'frequency'?: string;
    /**
    * Insurance charged by the issuer to fund the installment payments.  This field is included in the authorization reply for the Crediario eligibility request when the issuer approves the cardholder's request for Crediario installment payments in Brazil.  This field is supported only for Crediario installment payments in Brazil on **CyberSource through VisaNet**.  The value for this field corresponds to the following data in the TC 33 capture file1: - Record: CP01 TCR9 - Position: 112-123 - Field: Total Insurance 
    */
    'insurance'?: string;
    /**
    * Insurance costs divided by the amount funded.  For example: - A value of 1.0 specifies 1%. - A value of 4.0 specifies 4%.  This field is included in the authorization reply for the Crediario eligibility request when the issuer approves the cardholder's request for Crediario installment payments in Brazil.  This field is supported only for Crediario installment payments in Brazil on **CyberSource through VisaNet**.  The value for this field corresponds to the following data in the TC 33 capture file1: - Record: CP01 TCR9 - Position: 124-127 - Field: Percent Of Total Insurance 
    */
    'insurancePercentage'?: string;
    /**
    * Invoice information that you want to provide to the issuer. This value is similar to a tracking number and is the same for all installment payments for one purchase.  This field is supported only for installment payments with Mastercard on CyberSource through VisaNet in Brazil.  The value for this field corresponds to the following data in the TC 33 capture file5: - Record: CP07 TCR4 - Position: 51-70 - Field: Purchase Identification 
    */
    'invoiceData'?: string;
    /**
    * Monthly interest rate.  For example: - A value of 1.0 specifies 1%. - A value of 4.0 specifies 4%.  This field is included in the authorization reply for the Crediario eligibility request when the issuer approves the cardholder's request for Crediario installment payments in Brazil.  This field is supported only for Crediario installment payments in Brazil on **CyberSource through VisaNet**.  The value for this field corresponds to the following data in the TC 33 capture file1: - Record: CP01 TCR9 - Position: 144-150 - Field: Monthly Interest Rate 
    */
    'monthlyInterestRate'?: string;
    /**
    * #### American Express Direct, Cielo, and CyberSource Latin American Processing Flag that indicates the type of funding for the installment plan associated with the payment.  Possible values: - `1`: Merchant-funded installment plan - `2`: Issuer-funded installment plan If you do not include this field in the request, CyberSource uses the value in your CyberSource account.  To change the value in your CyberSource account, contact CyberSource Customer Service.  #### CyberSource through VisaNet and American Express Defined code that indicates the type of installment plan for this transaction.  Contact American Express for: - Information about the kinds of installment plans that American Express provides - Values for this field  For installment payments with American Express in Brazil, the value for this field corresponds to the following data in the TC 33 capture file*: - Record: CP07 TCR3 - Position: 5-6 - Field: Plan Type  * The TC 33 Capture file contains information about the purchases and refunds that a merchant submits to CyberSource. CyberSource through VisaNet creates the TC 33 Capture file at the end of the day and sends it to the merchant’s acquirer, who uses this information to facilitate end-of-day clearing processing with payment card companies.  #### CyberSource through VisaNet with Visa or Mastercard Flag indicating the type of funding for the installment plan associated with the payment. Possible values: - 1 or 01: Merchant-funded installment plan - 2 or 02: Issuer-funded installment plan - 43: Crediario installment plan—only with Visa in Brazil  For installment payments with Visa in Brazil, the value for this field corresponds to the following data in the TC 33 capture file5: - Record: CP07 TCR1 - Position: 5-6 - Field: Installment Type  For all other kinds of installment payments, the value for this field corresponds to the following data in the TC 33 capture file5: - Record: CP01 TCR5 - Position: 39-40 - Field: Installment Plan Type (Issuer or Merchant) 
    */
    'planType'?: string;
    /**
    * Installment number when making payments in installments. Used along with `totalCount` to track which payment is being processed.  For example, the second of 5 payments would be passed to CyberSource as `sequence` = 2 and `totalCount` = 5.  #### Chase Paymentech Solutions and FDC Compass This field is optional because this value is required in the merchant descriptors.  #### CyberSource through VisaNet When you do not include this field in a request for a Crediario installment payment, CyberSource sends a value of 0 to the processor.  For Crediario installment payments, the value for this field corresponds to the following data in the TC 33 capture file*: - Record: CP01 TCR9 - Position: 38-40 - Field: Installment Payment Number  * The TC 33 Capture file contains information about the purchases and refunds that a merchant submits to CyberSource. CyberSource through VisaNet creates the TC 33 Capture file at the end of the day and sends it to the merchant’s acquirer, who uses this information to facilitate end-of-day clearing processing with payment card companies. 
    */
    'sequence'?: number;
    /**
    * Taxes collected by the issuer to fund the installment payments.  This field is included in the authorization reply for the Crediario eligibility request when the issuer approves the cardholder's request for Crediario installment payments in Brazil.  This field is supported only for Crediario installment payments in Brazil on **CyberSource through VisaNet**.  The value for this field corresponds to the following data in the TC 33 capture file1: - Record: CP01 TCR9 - Position: 96-107 - Field: Total Taxes 
    */
    'taxes'?: string;
    /**
    * Taxes divided by the amount funded.  For example: - A value of 1.0 specifies 1%. - A value of 4.0 specifies 4%.  This field is included in the authorization reply for the Crediario eligibility request when the issuer approves the cardholder's request for Crediario installment payments in Brazil.  This field is supported only for Crediario installment payments in Brazil on **CyberSource through VisaNet**.  The value for this field corresponds to the following data in the TC 33 capture file1: - Record: CP01 TCR9 - Position: 108-111 - Field: Percent of Total Taxes 
    */
    'taxesPercentage'?: string;
    /**
    * Total amount of the loan that is being paid in installments. This field is supported only for CyberSource through VisaNet. 
    */
    'totalAmount'?: string;
    /**
    * Total number of installments when making payments in installments.  #### Chase Paymentech Solutions and FDC Compass This field is optional because this value is required in the merchant descriptors.  #### American Express Direct, Cielo, and Comercio Latino This value is the total number of installments you approved.  #### CyberSource Latin American Processing in Brazil This value is the total number of installments that you approved. The default is 1.  #### All Other Processors This value is used along with _sequence_ to track which payment is being processed.  For example, the second of 5 payments would be passed to CyberSource as _sequence_ = 2 and _totalCount_ = 5.  #### CyberSource through VisaNet For Crediario installment payments, the value for this field corresponds to the following data in the TC 33 capture file*: - Record: CP01 TCR9 - Position: 23-25 - Field: Number of Installments  For installment payments with American Express in Brazil, the value for this field corresponds to the following data in the TC 33 capture file*: - Record: CP07 TCR3 - Position: 7-8 - Field: Number of Installments  For installment payments with Visa in Brazil, the value for this field corresponds to the following data in the TC 33 capture file*: - Record: CP07 TCR1 - Position: 7-8 - Field: Number of Installments  For all other kinds of installment payments, the value for this field corresponds to the following data in the TC 33 capture file*: - Record: CP01 TCR5 - Position: 20-22 - Field: Installment Total Count  **Note** The TC 33 Capture file contains information about the purchases and refunds that a merchant submits to CyberSource. CyberSource through VisaNet creates the TC 33 Capture file at the end of the day and sends it to the merchant’s acquirer, who uses this information to facilitate end-of-day clearing processing with payment card companies. 
    */
    'totalCount'?: number;
    /**
    * \"Minimum number of installments offered by the issuer for this purchase. The issuer provides this value when the first installment payment is successful. This field is supported for installment payments with Mastercard on CyberSource through VisaNet in all countries except Brazil, Croatia, Georgia, and Greece. The value for this field corresponds to the following data in the TC 33 capture file: - Record: CP01 TCR5 - Position: 75-76 - Field: Mastercard Minimum Number Of Installments 
    */
    'minimumTotalCount'?: string;
    /**
    * Maximum number of installments offered by the issuer for this purchase. The issuer provides this value when the first installment payment is successful. This field is supported for installment payments with Mastercard on CyberSource through VisaNet in all countries except Brazil, Croatia, Georgia, and Greece. The value for this field corresponds to the following data in the TC 33 capture file1: - Record: CP01 TCR5 - Position: 77-78 - Field: Mastercard Maximum Number Of Installments 
    */
    'maximumTotalCount'?: string;
    /**
    * Amount of the first installment payment. The issuer provides this value when the first installment payment is successful. This field is supported for Mastercard installment payments on CyberSource through VisaNet in all countries except Brazil,Croatia, Georgia, and Greece. The value for this field corresponds to the following data in the TC 33 capture file: - Record: CP01 TCR5 - Position: 23-34 - Field: Amount of Each Installment 
    */
    'firstInstallmentAmount'?: string;
    /**
    * Date of the first installment payment. Format: YYMMDD. When you do not include this field, CyberSource sends a string of six zeros (000000) to the processor.  This field is supported only for Crediario installment payments in Brazil on CyberSource through VisaNet.  The value for this field corresponds to the following data in the TC 33 capture file: - Record: CP01 TCR9 - Position: 42-47 - Field: Date of First Installment 
    */
    'firstInstallmentDate'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "additionalCosts",
            "baseName": "additionalCosts",
            "type": "string"
        },
        {
            "name": "additionalCostsPercentage",
            "baseName": "additionalCostsPercentage",
            "type": "string"
        },
        {
            "name": "amount",
            "baseName": "amount",
            "type": "string"
        },
        {
            "name": "amountFunded",
            "baseName": "amountFunded",
            "type": "string"
        },
        {
            "name": "amountRequestedPercentage",
            "baseName": "amountRequestedPercentage",
            "type": "string"
        },
        {
            "name": "annualFinancingCost",
            "baseName": "annualFinancingCost",
            "type": "string"
        },
        {
            "name": "annualInterestRate",
            "baseName": "annualInterestRate",
            "type": "string"
        },
        {
            "name": "expenses",
            "baseName": "expenses",
            "type": "string"
        },
        {
            "name": "expensesPercentage",
            "baseName": "expensesPercentage",
            "type": "string"
        },
        {
            "name": "fees",
            "baseName": "fees",
            "type": "string"
        },
        {
            "name": "feesPercentage",
            "baseName": "feesPercentage",
            "type": "string"
        },
        {
            "name": "frequency",
            "baseName": "frequency",
            "type": "string"
        },
        {
            "name": "insurance",
            "baseName": "insurance",
            "type": "string"
        },
        {
            "name": "insurancePercentage",
            "baseName": "insurancePercentage",
            "type": "string"
        },
        {
            "name": "invoiceData",
            "baseName": "invoiceData",
            "type": "string"
        },
        {
            "name": "monthlyInterestRate",
            "baseName": "monthlyInterestRate",
            "type": "string"
        },
        {
            "name": "planType",
            "baseName": "planType",
            "type": "string"
        },
        {
            "name": "sequence",
            "baseName": "sequence",
            "type": "number"
        },
        {
            "name": "taxes",
            "baseName": "taxes",
            "type": "string"
        },
        {
            "name": "taxesPercentage",
            "baseName": "taxesPercentage",
            "type": "string"
        },
        {
            "name": "totalAmount",
            "baseName": "totalAmount",
            "type": "string"
        },
        {
            "name": "totalCount",
            "baseName": "totalCount",
            "type": "number"
        },
        {
            "name": "minimumTotalCount",
            "baseName": "minimumTotalCount",
            "type": "string"
        },
        {
            "name": "maximumTotalCount",
            "baseName": "maximumTotalCount",
            "type": "string"
        },
        {
            "name": "firstInstallmentAmount",
            "baseName": "firstInstallmentAmount",
            "type": "string"
        },
        {
            "name": "firstInstallmentDate",
            "baseName": "firstInstallmentDate",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsPost201ResponseInstallmentInformation.attributeTypeMap;
    }
}

export class PtsV2PaymentsPost201ResponseIssuerInformation {
    /**
    * Country in which the card was issued. This information enables you to determine whether the card was issued domestically or internationally. Use the two-character [ISO Standard Country Codes](https://developer.cybersource.com/library/documentation/sbc/quickref/countries_alpha_list.pdf).  This field is supported for Visa, Mastercard, Discover, Diners Club, JCB, and Maestro (International) on Chase Paymentech Solutions. 
    */
    'country'?: string;
    /**
    * Data defined by the issuer.  The value for this reply field will probably be the same as the value that you submitted in the authorization request, but it is possible for the processor, issuer, or acquirer to modify the value.  This field is supported only for Visa transactions on **CyberSource through VisaNet**. 
    */
    'discretionaryData'?: string;
    /**
    * Data defined by the issuer.  This national use field contains two subfields for information unique to the processing of Visa transactions by members in Japan. This subfield contains the Katakana text to be printed on the receipt. 
    */
    'countrySpecificDiscretionaryData'?: string;
    /**
    * This is the raw Association/Issuer Response Codes. You can use ‘issuer/association’ response codes to identify when you can retry to authorize a declined transaction and increase successful transaction volumes. You’ll receive an association/issuer response code for the majority of transactions.  #### Processors supported:   - HSBC   - FDC Nashville Global   - SIX  Currently SIX is not receiving Association/Issuer Response Codes here it receives the additional authorization code that must be printed on the receipt when returned by the processor.  #### Possible values: | Card Type   | Response Code | Description                                                                    | | ----------- | ------------- | ------------------------------------------------------------------------------ | | VISA        | 000           | Successful approval/completion or that V.I.P. PIN verification is successful   | | VISA        | 001           | Refer to card issuer                                                           | | VISA        | 002           | Refer to card issuer, special condition                                        | | VISA        | 003           | Invalid merchant or service provider                                           | | VISA        | 004           | Pickup card                                                                    |   | MasterCard  | 000           | Approved or completed successfully                                             | | MasterCard  | 001           | Refer to card issuer                                                           | | MasterCard  | 003           | Invalid merchant                                                               | | MasterCard  | 004           | Capture card                                                                   | | MasterCard  | 005           | Do not honor                                                                   | | AMEX        | 000           | Approved                                                                       | | AMEX        | 001           | Approve with ID                                                                | | AMEX        | 002           | Partial Approval (Prepaid Cards only)                                          | | AMEX        | 100           | Deny                                                                           | | AMEX        | 101           | Expired Card/Invalid Expiration Date                                           | | Discover    | 000           | Approved or completed successfully                                             | | Discover    | 001           | Reserved for future USE                                                        | | Discover    | 002           | Reserved for future USE                                                        | | Discover    | 003           | Invalid Merchant                                                               | | Discover    | 004           | Capture Card                                                                   | 
    */
    'responseCode'?: string;
    /**
    * This field contains value ‘1’ which is sent by Issuer in the response when PIN is requested by issuer,   This field is only supported for Visa Platform Connect. 
    */
    'pinRequestIndicator'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "country",
            "baseName": "country",
            "type": "string"
        },
        {
            "name": "discretionaryData",
            "baseName": "discretionaryData",
            "type": "string"
        },
        {
            "name": "countrySpecificDiscretionaryData",
            "baseName": "countrySpecificDiscretionaryData",
            "type": "string"
        },
        {
            "name": "responseCode",
            "baseName": "responseCode",
            "type": "string"
        },
        {
            "name": "pinRequestIndicator",
            "baseName": "pinRequestIndicator",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsPost201ResponseIssuerInformation.attributeTypeMap;
    }
}

export class PtsV2PaymentsPost201ResponseLinks {
    'self'?: PtsV2PaymentsPost201ResponseLinksSelf;
    'reversal'?: PtsV2PaymentsPost201ResponseLinksSelf;
    'capture'?: PtsV2PaymentsPost201ResponseLinksSelf;
    'customer'?: PtsV2PaymentsPost201ResponseLinksSelf;
    'paymentInstrument'?: PtsV2PaymentsPost201ResponseLinksSelf;
    'shippingAddress'?: PtsV2PaymentsPost201ResponseLinksSelf;
    'instrumentIdentifier'?: PtsV2PaymentsPost201ResponseLinksSelf;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "self",
            "baseName": "self",
            "type": "PtsV2PaymentsPost201ResponseLinksSelf"
        },
        {
            "name": "reversal",
            "baseName": "reversal",
            "type": "PtsV2PaymentsPost201ResponseLinksSelf"
        },
        {
            "name": "capture",
            "baseName": "capture",
            "type": "PtsV2PaymentsPost201ResponseLinksSelf"
        },
        {
            "name": "customer",
            "baseName": "customer",
            "type": "PtsV2PaymentsPost201ResponseLinksSelf"
        },
        {
            "name": "paymentInstrument",
            "baseName": "paymentInstrument",
            "type": "PtsV2PaymentsPost201ResponseLinksSelf"
        },
        {
            "name": "shippingAddress",
            "baseName": "shippingAddress",
            "type": "PtsV2PaymentsPost201ResponseLinksSelf"
        },
        {
            "name": "instrumentIdentifier",
            "baseName": "instrumentIdentifier",
            "type": "PtsV2PaymentsPost201ResponseLinksSelf"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsPost201ResponseLinks.attributeTypeMap;
    }
}

export class PtsV2PaymentsPost201ResponseLinksSelf {
    /**
    * This is the endpoint of the resource that was created by the successful request.
    */
    'href'?: string;
    /**
    * `method` refers to the HTTP method that you can send to the `self` endpoint to retrieve details of the resource.
    */
    'method'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "href",
            "baseName": "href",
            "type": "string"
        },
        {
            "name": "method",
            "baseName": "method",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsPost201ResponseLinksSelf.attributeTypeMap;
    }
}

export class PtsV2PaymentsPost201ResponseMerchantInformation {
    /**
    * Use this field only if you are requesting payment with Payer Authentication serice together.  Your company’s name as you want it to appear to the customer in the issuing bank’s authentication form. This value overrides the value specified by your merchant bank. 
    */
    'merchantName'?: string;
    'merchantDescriptor'?: PtsV2PaymentsPost201ResponseMerchantInformationMerchantDescriptor;
    /**
    * URL for displaying payment results to the consumer (notifications) after the transaction is processed. Usually this URL belongs to merchant and its behavior is defined by merchant 
    */
    'returnUrl'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "merchantName",
            "baseName": "merchantName",
            "type": "string"
        },
        {
            "name": "merchantDescriptor",
            "baseName": "merchantDescriptor",
            "type": "PtsV2PaymentsPost201ResponseMerchantInformationMerchantDescriptor"
        },
        {
            "name": "returnUrl",
            "baseName": "returnUrl",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsPost201ResponseMerchantInformation.attributeTypeMap;
    }
}

export class PtsV2PaymentsPost201ResponseMerchantInformationMerchantDescriptor {
    /**
    * The identifier of the store. 
    */
    'storeId'?: string;
    /**
    * The name of the store. 
    */
    'storeName'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "storeId",
            "baseName": "storeId",
            "type": "string"
        },
        {
            "name": "storeName",
            "baseName": "storeName",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsPost201ResponseMerchantInformationMerchantDescriptor.attributeTypeMap;
    }
}

export class PtsV2PaymentsPost201ResponseOrderInformation {
    'amountDetails'?: PtsV2PaymentsPost201ResponseOrderInformationAmountDetails;
    'invoiceDetails'?: PtsV2PaymentsPost201ResponseOrderInformationInvoiceDetails;
    'rewardPointsDetails'?: PtsV2PaymentsPost201ResponseOrderInformationRewardPointsDetails;
    'billTo'?: PtsV2PaymentsPost201ResponseOrderInformationBillTo;
    'shipTo'?: PtsV2PaymentsPost201ResponseOrderInformationShipTo;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "amountDetails",
            "baseName": "amountDetails",
            "type": "PtsV2PaymentsPost201ResponseOrderInformationAmountDetails"
        },
        {
            "name": "invoiceDetails",
            "baseName": "invoiceDetails",
            "type": "PtsV2PaymentsPost201ResponseOrderInformationInvoiceDetails"
        },
        {
            "name": "rewardPointsDetails",
            "baseName": "rewardPointsDetails",
            "type": "PtsV2PaymentsPost201ResponseOrderInformationRewardPointsDetails"
        },
        {
            "name": "billTo",
            "baseName": "billTo",
            "type": "PtsV2PaymentsPost201ResponseOrderInformationBillTo"
        },
        {
            "name": "shipTo",
            "baseName": "shipTo",
            "type": "PtsV2PaymentsPost201ResponseOrderInformationShipTo"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsPost201ResponseOrderInformation.attributeTypeMap;
    }
}

export class PtsV2PaymentsPost201ResponseOrderInformationAmountDetails {
    /**
    * Amount you requested for the payment or capture.  This value is returned for partial authorizations. This field is also returned on incremental authorizations will contain the aggregated amount from the original authorizations and all the incremental authorizations. 
    */
    'totalAmount'?: string;
    /**
    * Amount that was authorized.  Returned by authorization service.  #### PIN debit Amount of the purchase.  Returned by PIN debit purchase. 
    */
    'authorizedAmount'?: string;
    /**
    * Currency used for the order. Use the three-character [ISO Standard Currency Codes.](http://apps.cybersource.com/library/documentation/sbc/quickref/currencies.pdf)  #### Used by **Authorization** Required field.  **Authorization Reversal** For an authorization reversal (`reversalInformation`) or a capture (`processingOptions.capture` is set to `true`), you must use the same currency that you used in your payment authorization request.  #### PIN Debit Currency for the amount you requested for the PIN debit purchase. This value is returned for partial authorizations. The issuing bank can approve a partial amount if the balance on the debit card is less than the requested transaction amount. For the possible values, see the [ISO Standard Currency Codes](https://developer.cybersource.com/library/documentation/sbc/quickref/currencies.pdf). Returned by PIN debit purchase.  For PIN debit reversal requests, you must use the same currency that was used for the PIN debit purchase or PIN debit credit that you are reversing. For the possible values, see the [ISO Standard Currency Codes](https://developer.cybersource.com/library/documentation/sbc/quickref/currencies.pdf).  Required field for PIN Debit purchase and PIN Debit credit requests. Optional field for PIN Debit reversal requests.  #### GPX This field is optional for reversing an authorization or credit.  #### DCC for First Data Your local currency.  #### Tax Calculation Required for international tax and value added tax only. Optional for U.S. and Canadian taxes. Your local currency. 
    */
    'currency'?: string;
    /**
    * This is a multicurrency field. It contains the transaction amount (field 4), converted to the Currency used to bill the cardholder’s account. This field is returned for OCT transactions. 
    */
    'settlementAmount'?: string;
    /**
    * This is a multicurrency-only field. It contains a 3-digit numeric code that identifies the currency used by the issuer to bill the cardholder's account. This field is returned for OCT transactions. 
    */
    'settlementCurrency'?: string;
    /**
    * Amount in your original local pricing currency.  This value cannot be negative. You can include a decimal point (.) in this field to denote the currency exponent, but you cannot include any other special characters.  If needed, CyberSource truncates the amount to the correct number of decimal places. 
    */
    'originalAmount'?: string;
    /**
    * Your local pricing currency code.  For the possible values, see the [ISO Standard Currency Codes.](http://apps.cybersource.com/library/documentation/sbc/quickref/currencies.pdf) 
    */
    'originalCurrency'?: string;
    /**
    * Amount up to N digit after the decimals separator as defined in ISO 4217 for the appropriate currency code. 
    */
    'processorTransactionFee'?: string;
    /**
    * The rate of conversion of the currency given in the request to CNY. The conversion happens at the time when Alipay’s trade order is created 
    */
    'exchangeRate'?: string;
    /**
    * Currency code for the transaction performed in cross border currency. 
    */
    'foreignCurrency'?: string;
    /**
    * The transaction amount in CNY. 
    */
    'foreignAmount'?: string;
    /**
    * If coupons/vouchers are used in the transaction, the discount amount redeemed in the settlement currency will be returned. Otherwise, no return. 
    */
    'discountAmount'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "totalAmount",
            "baseName": "totalAmount",
            "type": "string"
        },
        {
            "name": "authorizedAmount",
            "baseName": "authorizedAmount",
            "type": "string"
        },
        {
            "name": "currency",
            "baseName": "currency",
            "type": "string"
        },
        {
            "name": "settlementAmount",
            "baseName": "settlementAmount",
            "type": "string"
        },
        {
            "name": "settlementCurrency",
            "baseName": "settlementCurrency",
            "type": "string"
        },
        {
            "name": "originalAmount",
            "baseName": "originalAmount",
            "type": "string"
        },
        {
            "name": "originalCurrency",
            "baseName": "originalCurrency",
            "type": "string"
        },
        {
            "name": "processorTransactionFee",
            "baseName": "processorTransactionFee",
            "type": "string"
        },
        {
            "name": "exchangeRate",
            "baseName": "exchangeRate",
            "type": "string"
        },
        {
            "name": "foreignCurrency",
            "baseName": "foreignCurrency",
            "type": "string"
        },
        {
            "name": "foreignAmount",
            "baseName": "foreignAmount",
            "type": "string"
        },
        {
            "name": "discountAmount",
            "baseName": "discountAmount",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsPost201ResponseOrderInformationAmountDetails.attributeTypeMap;
    }
}

export class PtsV2PaymentsPost201ResponseOrderInformationBillTo {
    'firstName'?: string;
    'lastName'?: string;
    /**
    * First line of the billing street address. 
    */
    'address1'?: string;
    /**
    * Second line of the billing street address. 
    */
    'address2'?: string;
    /**
    * City of the billing address. 
    */
    'locality'?: string;
    /**
    * Postal code for the billing address. The postal code must consist of 5 to 9 digits.  When the billing country is the U.S., the 9-digit postal code must follow this format: [5 digits][dash][4 digits] Example: 12345-6789 When the billing country is Canada, the 6-digit postal code must follow this format: [alpha][numeric][alpha][space] [numeric][alpha][numeric] Example: A1B 2C3 
    */
    'postalCode'?: string;
    /**
    * State or province of the billing address. Use the State, Province, and Territory Codes for the United States and Canada. 
    */
    'administrativeArea'?: string;
    /**
    * Country of the billing address. Use the two-character ISO Standard Country Codes. 
    */
    'country'?: string;
    /**
    * Email address of the customer. 
    */
    'email'?: string;
    /**
    * #### Visa Platform Connect Contains one of the following values that will identify the phone number result code in the account verification response message:  'VERIFIED' - Customer verified  'UNVERIFIED' - Customer not verified  'FAILED' - Customer verification failed 
    */
    'alternatePhoneNumberVerificationStatus'?: string;
    /**
    * #### Visa Platform Connect Contains one of the following values that will identify the phone number result code in the account verification response message:  'VERIFIED' - Customer verified  'UNVERIFIED' - Customer not verified  'FAILED' - Customer verification failed 
    */
    'alternateEmailVerificationStatus'?: string;
    /**
    * Customer’s phone number.  It is recommended that you include the country code when the order is from outside the U.S.  #### Chase Paymentech Solutions Optional field.  ####  Credit Mutuel-CIC Optional field.  #### CyberSource through VisaNet Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.  #### For Payouts: This field may be sent only for FDC Compass.  #### OmniPay Direct Optional field.  #### SIX Optional field.  #### TSYS Acquiring Solutions Optional field.  #### Worldpay VAP Optional field.  #### All other processors Not used. 
    */
    'phoneNumber'?: string;
    /**
    * Customer’s name suffix. 
    */
    'nameSuffix'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "firstName",
            "baseName": "firstName",
            "type": "string"
        },
        {
            "name": "lastName",
            "baseName": "lastName",
            "type": "string"
        },
        {
            "name": "address1",
            "baseName": "address1",
            "type": "string"
        },
        {
            "name": "address2",
            "baseName": "address2",
            "type": "string"
        },
        {
            "name": "locality",
            "baseName": "locality",
            "type": "string"
        },
        {
            "name": "postalCode",
            "baseName": "postalCode",
            "type": "string"
        },
        {
            "name": "administrativeArea",
            "baseName": "administrativeArea",
            "type": "string"
        },
        {
            "name": "country",
            "baseName": "country",
            "type": "string"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "alternatePhoneNumberVerificationStatus",
            "baseName": "alternatePhoneNumberVerificationStatus",
            "type": "string"
        },
        {
            "name": "alternateEmailVerificationStatus",
            "baseName": "alternateEmailVerificationStatus",
            "type": "string"
        },
        {
            "name": "phoneNumber",
            "baseName": "phoneNumber",
            "type": "string"
        },
        {
            "name": "nameSuffix",
            "baseName": "nameSuffix",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsPost201ResponseOrderInformationBillTo.attributeTypeMap;
    }
}

export class PtsV2PaymentsPost201ResponseOrderInformationInvoiceDetails {
    /**
    * Indicates whether CyberSource sent the Level III information to the processor. The possible values are:  If your account is not enabled for Level III data or if you did not include the purchasing level field in your request, CyberSource does not include the Level III data in the request sent to the processor.  Possible values: - **true** - **false** 
    */
    'level3TransmissionStatus'?: boolean;
    /**
    * Transaction identifier that is generated. You have the option of printing the sales slip number on the receipt. This field is supported only on Cybersource through Visanet and JCN gateway.  Optional field.  #### Card Present processing message If you included this field in the request, the returned value is the value that you sent in the request. If you did not include this field in the request, the system generated this value for you.  The difference between this reply field and the `processorInformation.systemTraceAuditNumber` field is that the system generates the system trace audit number (STAN), and you must print the receipt number on the receipt; whereas you can generate the sales slip number, and you can choose to print the sales slip number on the receipt. 
    */
    'salesSlipNumber'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "level3TransmissionStatus",
            "baseName": "level3TransmissionStatus",
            "type": "boolean"
        },
        {
            "name": "salesSlipNumber",
            "baseName": "salesSlipNumber",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsPost201ResponseOrderInformationInvoiceDetails.attributeTypeMap;
    }
}

export class PtsV2PaymentsPost201ResponseOrderInformationRewardPointsDetails {
    /**
    * Loyalty points total balance before redemption. For Example: Points, such as 100 
    */
    'pointsBeforeRedemption'?: string;
    /**
    * The total value of loyalty points before redemption in the default currency. Max characters is 12 excluding the \".\" symbol For Example: Points, such as 20.00 
    */
    'pointsValueBeforeRedemption'?: string;
    /**
    * Number of loyalty points that were redeemed. For Example: Points, such as 100 
    */
    'pointsRedeemed'?: string;
    /**
    * The value of the loyalty points that were redeemed in the default currency. Max characters is 12 excluding the \".\" symbol For Example: Points, such as 100.00 
    */
    'pointsValueRedeemed'?: string;
    /**
    * Loyalty Points remaining total balance after redemption. For Example: Points, such as 20.00 
    */
    'pointsAfterRedemption'?: string;
    /**
    * The value of the remaining loyalty points after redumption in the default currency. Max characters is 12 excluding the \".\" symbol For Example: Points, such as 20.00 
    */
    'pointsValueAfterRedemption'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "pointsBeforeRedemption",
            "baseName": "pointsBeforeRedemption",
            "type": "string"
        },
        {
            "name": "pointsValueBeforeRedemption",
            "baseName": "pointsValueBeforeRedemption",
            "type": "string"
        },
        {
            "name": "pointsRedeemed",
            "baseName": "pointsRedeemed",
            "type": "string"
        },
        {
            "name": "pointsValueRedeemed",
            "baseName": "pointsValueRedeemed",
            "type": "string"
        },
        {
            "name": "pointsAfterRedemption",
            "baseName": "pointsAfterRedemption",
            "type": "string"
        },
        {
            "name": "pointsValueAfterRedemption",
            "baseName": "pointsValueAfterRedemption",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsPost201ResponseOrderInformationRewardPointsDetails.attributeTypeMap;
    }
}

export class PtsV2PaymentsPost201ResponseOrderInformationShipTo {
    /**
    * First name of the recipient. 
    */
    'firstname'?: string;
    /**
    * Last name of the recipient. 
    */
    'lastname'?: string;
    /**
    * First line of the shipping address. 
    */
    'address1'?: string;
    /**
    * Second line of the shipping address. 
    */
    'address2'?: string;
    /**
    * City of the shipping address. 
    */
    'locality'?: string;
    /**
    * State or province of shipping address. This is a State, Province, and Territory Codes for the United States and Canada. 
    */
    'administrativeArea'?: string;
    /**
    * Postal code of the shipping address. Consists of 5 to 9 digits. 
    */
    'postalCode'?: string;
    /**
    * Country of shipping address. This is a two-character ISO Standard Country Codes. 
    */
    'country'?: string;
    /**
    * Phone number of the recipient. 
    */
    'phoneNumber'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "firstname",
            "baseName": "firstname",
            "type": "string"
        },
        {
            "name": "lastname",
            "baseName": "lastname",
            "type": "string"
        },
        {
            "name": "address1",
            "baseName": "address1",
            "type": "string"
        },
        {
            "name": "address2",
            "baseName": "address2",
            "type": "string"
        },
        {
            "name": "locality",
            "baseName": "locality",
            "type": "string"
        },
        {
            "name": "administrativeArea",
            "baseName": "administrativeArea",
            "type": "string"
        },
        {
            "name": "postalCode",
            "baseName": "postalCode",
            "type": "string"
        },
        {
            "name": "country",
            "baseName": "country",
            "type": "string"
        },
        {
            "name": "phoneNumber",
            "baseName": "phoneNumber",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsPost201ResponseOrderInformationShipTo.attributeTypeMap;
    }
}

export class PtsV2PaymentsPost201ResponsePaymentAccountInformation {
    'card'?: PtsV2PaymentsPost201ResponsePaymentAccountInformationCard;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "card",
            "baseName": "card",
            "type": "PtsV2PaymentsPost201ResponsePaymentAccountInformationCard"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsPost201ResponsePaymentAccountInformation.attributeTypeMap;
    }
}

export class PtsV2PaymentsPost201ResponsePaymentAccountInformationCard {
    /**
    * Last four digits of the cardholder’s account number. This field is included in the reply message when the client software that is installed on the POS terminal uses the token management service (TMS) to retrieve tokenized payment details.  You must contact customer support to have your account enabled to receive these fields in the credit reply message.  #### Google Pay transactions For PAN-based Google Pay transactions, this field is returned in the API response.  #### PIN debit This field is returned only for tokenized transactions. You can use this value on the receipt that you give to the cardholder.  Returned by PIN debit credit and PIN debit purchase.  This field is supported only by the following processors: - American Express Direct - Credit Mutuel-CIC - FDC Nashville Global - OmniPay Direct - SIX 
    */
    'suffix'?: string;
    /**
    * Two-digit month in which the payment card expires.  Format: `MM`.  Valid values: `01` through `12`. Leading 0 is required.  #### Barclays and Streamline For Maestro (UK Domestic) and Maestro (International) cards on Barclays and Streamline, this must be a valid value (`01` through `12`) but is not required to be a valid expiration date. In other words, an expiration date that is in the past does not cause CyberSource to reject your request. However, an invalid expiration date might cause the issuer to reject your request.  #### Encoded Account Numbers For encoded account numbers (_type_=039), if there is no expiration date on the card, use `12`.  #### FDMS Nashville Required field.  #### All other processors Required if `pointOfSaleInformation.entryMode=keyed`. However, this field is optional if your account is configured for relaxed requirements for address data and expiration date. **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.  #### Google Pay transactions For PAN-based Google Pay transactions, this field is returned in the API response. 
    */
    'expirationMonth'?: string;
    /**
    * Four-digit year in which the payment card expires.  Format: `YYYY`.  #### Barclays and Streamline For Maestro (UK Domestic) and Maestro (International) cards on Barclays and Streamline, this must be a valid value (`1900` through `3000`) but is not required to be a valid expiration date. In other words, an expiration date that is in the past does not cause CyberSource to reject your request. However, an invalid expiration date might cause the issuer to reject your request.  #### Encoded Account Numbers For encoded account numbers (**_type_**`=039`), if there is no expiration date on the card, use `2021`.  #### FDMS Nashville Required field.  #### FDC Nashville Global and FDMS South You can send in 2 digits or 4 digits. If you send in 2 digits, they must be the last 2 digits of the year.  #### All other processors Required if `pointOfSaleInformation.entryMode=keyed`. However, this field is optional if your account is configured for relaxed requirements for address data and expiration date. **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.  #### Google Pay transactions For PAN-based Google Pay transactions, this field is returned in the API response. 
    */
    'expirationYear'?: string;
    /**
    * Three-digit value that indicates the card type.  **IMPORTANT** It is strongly recommended that you include the card type field in request messages even if it is optional for your processor and card type. Omitting the card type can cause the transaction to be processed with the wrong card type.  Possible values: - `001`: Visa. Use card type value `001` for Visa Electron. - `002`: Mastercard, Eurocard[^1], which is a European regional brand of Mastercard. - `003`: American Express - `004`: Discover - `005`: Diners Club - `006`: Carte Blanche[^1] - `007`: JCB[^1] - `008`: Optima - `009`: GE Private Label - `010`: Beneficial Private Label - `011`: Twinpay Credit Card - `012`: Twinpay Debit Card - `013`: WalMart - `014`: Enroute[^1] - `015`: Lowe's Consumer - `016`: Home Depot Consumer - `017`: MBNA - `018`: Dick's Sportswear - `019`: Casual Corner - `020`: Sears - `021`: JAL[^1] - `023`: Disney Card - `024`: Maestro (UK Domestic)[^1] - `025`: Sam's Club Consumer - `026`: Sam's Club Business - `027`: Nico's - `028`: Paymentech Bill Me Later - `029`: Bebe - `030`: Restoration Hardware - `031`: Delta Online - `032`: Solo - `033`: Visa Electron[^1]. Do not use this value. Use `001` for all Visa card types. - `034`: Dankort[^1] - `035`: Laser - `036`: Cartes Bancaires[^1,4] - `037`: Carta Si[^1] - `038`: Pinless Debit - `039`: Encoded account number[^1] - `040`: UATP[^1] - `041`: HOUSEHOLD - `042`: Maestro (International)[^1] - `043`: GE MONEY - `044`: Korean Cards - `045`: Style Cards - `046`: JCrew - `047`: Payeasecn eWallet - `048`: Payeasecn Bank Transfer - `049`: Meijer - `050`: Hipercard[^2,3] - `051`: Aura - `052`: Redecard - `053`: Orico card - `054`: Elo[^3] - `055`: Capitol One Private Label - `056`: Carnet - `057`: Costco Private Label - `058`: Carnet - `059`: ValueLink - `060`: MADA - `061`: RuPay - `062`: China UnionPay - `063`: Falabella Private Label - `064`: Prompt Card - `065`: Korean Domestic - `066`: Banricompras - `067`: MEEZA - `068`: PayPak - `070`: EFTPOS - `071`: Codensa - `072`: Olimpica - `073`: Colsubsidio - `074`: Tuya - `075`: Sodexo - `076`: Naranja - `077`: Cabal - `078`: DINELCO - `079`: PANAL - `080`: EPM - `081`: Jaywan  [^1]: For this card type, you must include the `paymentInformation.card.type` or `paymentInformation.tokenizedCard.type` field in your request for an authorization or a stand-alone credit. [^2]: For this card type on Cielo 3.0, you must include the `paymentInformation.card.type` or `paymentInformation.tokenizedCard.type` field in a request for an authorization or a stand-alone credit. This card type is not supported on Cielo 1.5. [^3]: For this card type on Getnet and Rede, you must include the `paymentInformation.card.type` or `paymentInformation.tokenizedCard.type` field in a request for an authorization or a stand-alone credit. [^4]: For this card type, you must include the `paymentInformation.card.type` in your request for any payer authentication services.  #### Used by **Authorization** Required for Carte Blanche and JCB. Optional for all other card types.  #### Card Present reply This field is included in the reply message when the client software that is installed on the POS terminal uses the token management service (TMS) to retrieve tokenized payment details. You must contact customer support to have your account enabled to receive these fields in the credit reply message.  Returned by the Credit service.  This reply field is only supported by the following processors: - American Express Direct - Credit Mutuel-CIC - FDC Nashville Global - OmniPay Direct - SIX  #### Google Pay transactions For PAN-based Google Pay transactions, this field is returned in the API response.  #### GPX This field only supports transactions from the following card types: - Visa - Mastercard - AMEX - Discover - Diners - JCB - Union Pay International 
    */
    'type'?: string;
    /**
    * Bank Identification Number (BIN). This is the initial four to six numbers on a credit card account number.  #### Google Pay transactions For PAN-based Google Pay transactions, this field is returned in the API response. 
    */
    'prefix'?: string;
    /**
    * #### Visa Platform Connect This API field will contain the SHA 256 hashed value of PAN. 
    */
    'hashedNumber'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "suffix",
            "baseName": "suffix",
            "type": "string"
        },
        {
            "name": "expirationMonth",
            "baseName": "expirationMonth",
            "type": "string"
        },
        {
            "name": "expirationYear",
            "baseName": "expirationYear",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "prefix",
            "baseName": "prefix",
            "type": "string"
        },
        {
            "name": "hashedNumber",
            "baseName": "hashedNumber",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsPost201ResponsePaymentAccountInformationCard.attributeTypeMap;
    }
}

export class PtsV2PaymentsPost201ResponsePaymentInformation {
    'card'?: PtsV2PaymentsPost201ResponsePaymentAccountInformationCard;
    'tokenizedCard'?: PtsV2PaymentsPost201ResponsePaymentInformationTokenizedCard;
    'tokenizedPaymentMethod'?: PtsV2PaymentsPost201ResponsePaymentInformationTokenizedPaymentMethod;
    'accountFeatures'?: PtsV2PaymentsPost201ResponsePaymentInformationAccountFeatures;
    'bank'?: PtsV2PaymentsPost201ResponsePaymentInformationBank;
    'customer'?: Ptsv2paymentsPaymentInformationCustomer;
    'paymentInstrument'?: Ptsv2paymentsPaymentInformationPaymentInstrument;
    'instrumentIdentifier'?: PtsV2PaymentsPost201ResponsePaymentInformationInstrumentIdentifier;
    'shippingAddress'?: Ptsv2paymentsPaymentInformationShippingAddress;
    /**
    * Subtype of card account. This field can contain one of the following values: - Maestro International - Maestro UK Domestic - MasterCard Credit - MasterCard Debit - Visa Credit - Visa Debit - Visa Electron  **Note** Additional values may be present. 
    */
    'scheme'?: string;
    /**
    * Credit card BIN (the first six digits of the credit card).Derived either from the `cc_bin` request field or from the first six characters of the `customer_cc_num` field. 
    */
    'bin'?: string;
    /**
    * Type of payment card account. This field can refer to a credit card, debit card, or prepaid card account type. 
    */
    'accountType'?: string;
    /**
    * Name of the bank or entity that issued the card account. 
    */
    'issuer'?: string;
    /**
    * Country (two-digit country code) associated with the BIN of the customer’s card used for the payment. Returned if the information is available. Use this field for additional information when reviewing orders. This information is also displayed in the details page of the CyberSource Business Center. 
    */
    'binCountry'?: string;
    'eWallet'?: PtsV2PaymentsPost201ResponsePaymentInformationEWallet;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "card",
            "baseName": "card",
            "type": "PtsV2PaymentsPost201ResponsePaymentAccountInformationCard"
        },
        {
            "name": "tokenizedCard",
            "baseName": "tokenizedCard",
            "type": "PtsV2PaymentsPost201ResponsePaymentInformationTokenizedCard"
        },
        {
            "name": "tokenizedPaymentMethod",
            "baseName": "tokenizedPaymentMethod",
            "type": "PtsV2PaymentsPost201ResponsePaymentInformationTokenizedPaymentMethod"
        },
        {
            "name": "accountFeatures",
            "baseName": "accountFeatures",
            "type": "PtsV2PaymentsPost201ResponsePaymentInformationAccountFeatures"
        },
        {
            "name": "bank",
            "baseName": "bank",
            "type": "PtsV2PaymentsPost201ResponsePaymentInformationBank"
        },
        {
            "name": "customer",
            "baseName": "customer",
            "type": "Ptsv2paymentsPaymentInformationCustomer"
        },
        {
            "name": "paymentInstrument",
            "baseName": "paymentInstrument",
            "type": "Ptsv2paymentsPaymentInformationPaymentInstrument"
        },
        {
            "name": "instrumentIdentifier",
            "baseName": "instrumentIdentifier",
            "type": "PtsV2PaymentsPost201ResponsePaymentInformationInstrumentIdentifier"
        },
        {
            "name": "shippingAddress",
            "baseName": "shippingAddress",
            "type": "Ptsv2paymentsPaymentInformationShippingAddress"
        },
        {
            "name": "scheme",
            "baseName": "scheme",
            "type": "string"
        },
        {
            "name": "bin",
            "baseName": "bin",
            "type": "string"
        },
        {
            "name": "accountType",
            "baseName": "accountType",
            "type": "string"
        },
        {
            "name": "issuer",
            "baseName": "issuer",
            "type": "string"
        },
        {
            "name": "binCountry",
            "baseName": "binCountry",
            "type": "string"
        },
        {
            "name": "eWallet",
            "baseName": "eWallet",
            "type": "PtsV2PaymentsPost201ResponsePaymentInformationEWallet"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsPost201ResponsePaymentInformation.attributeTypeMap;
    }
}

export class PtsV2PaymentsPost201ResponsePaymentInformationAccountFeatures {
    /**
    * Type of account. This value is returned only if you requested a balance inquiry. Possible values:   - `00`: Not applicable or not specified  - `10`: Savings account  - `20`: Checking account  - `30`: Credit card account  - `40`: Universal account  #### PIN debit Type of account. This value is returned only if you requested a balance inquiry.  Possible values: - `00`: Not applicable or not specified - `10`: Savings account - `20`: Checking account - `40`: Universal account - `96`: Cash benefits account - `98`: Food stamp account  Returned by PIN debit purchase. 
    */
    'accountType'?: string;
    /**
    * Possible values: - `N`: Nonregulated - `R`: Regulated  Returned by PIN debit credit or PIN debit purchase.  **Note** This field is returned only for CyberSource through VisaNet. 
    */
    'accountStatus'?: string;
    /**
    * This is an array of multiple balances information an issuer can return for a given card.
    */
    'balances'?: Array<PtsV2PaymentsPost201ResponsePaymentInformationAccountFeaturesBalances>;
    /**
    * Remaining balance on the account.  Returned by authorization service.  #### PIN debit Remaining balance on the prepaid card.  Returned by PIN debit purchase. 
    */
    'balanceAmount'?: string;
    /**
    * Type of amount. This value is returned only if you requested a balance inquiry. The issuer determines the value that is returned. Possible values for deposit accounts:   - `01`: Current ledger (posted) balance.  - `02`: Current available balance, which is typically the ledger balance less outstanding authorizations.  Some depository institutions also include pending deposits and the credit or overdraft line associated with the account. Possible values for credit card accounts:   - `01`: Credit amount remaining for customer (open to buy).  - `02`: Credit limit. 
    */
    'balanceAmountType'?: string;
    /**
    * Currency of the remaining balance on the account. For the possible values, see the [ISO Standard Currency Codes.](http://apps.cybersource.com/library/documentation/sbc/quickref/currencies.pdf)  Returned by authorization service.  #### PIN debit Currency of the remaining balance on the prepaid card.  Returned by PIN debit purchase. 
    */
    'currency'?: string;
    /**
    * Sign for the remaining balance on the account. Returned only when the processor returns this value. Possible values:  Possible values: - `Positive` - `Negative`  #### PIN debit Sign for the remaining balance on the prepaid card. Returned only when the processor returns this value.  Returned by PIN debit purchase. 
    */
    'balanceSign'?: string;
    /**
    * **Chase Paymentech Solutions**  Indicates whether a customer has high credit limits. This information enables you to market high cost items to these customers and to understand the kinds of cards that high income customers are using.  This field is supported for Visa, Mastercard, Discover, and Diners Club. Possible values:   - `Y`: Yes  - `N`: No  - `X`: Not applicable / Unknown  #### Litle  Flag that indicates that a Visa cardholder or Mastercard cardholder is in one of the affluent categories. Possible values:   - `AFFLUENT`: High income customer with high spending pattern (>100k USD annual income and >40k USD annual    card usage).  - `MASS AFFLUENT`: High income customer (>100k USD annual income).   Maximum length is 13.  #### Chase Paymentech Solutions  Maximum length is 1. 
    */
    'affluenceIndicator'?: string;
    /**
    * #### GPX Mastercard product ID associated with the primary account number (PAN). Returned by authorization service.  #### CyberSource through VisaNet Visa or Mastercard product ID that is associated with the primary account number (PAN). For descriptions of the Visa product IDs, see the Product ID table on the [Visa Request & Response Codes web page.](https://developer.visa.com/guides/request_response_codes)  Data Length: String (3)  #### GPN Visa or Mastercard product ID that is associated with the primary account number (PAN). For descriptions of the Visa product IDs, see the Product ID table on the [Visa Request & Response Codes web page.](https://developer.visa.com/guides/request_response_codes)  Data Length: String (3)  #### Worldpay VAP **Important** Before using this field on Worldpay VAP, you must contact CyberSource Customer Support to have your account configured for this feature.  Type of card used in the transaction. The only possible value is: - `PREPAID`: Prepaid Card  Data Length: String (7)  #### RBS WorldPay Atlanta Type of card used in the transaction. Possible values: - `B`: Business Card - `O`: Noncommercial Card - `R`: Corporate Card - `S`: Purchase Card - `Blank`: Purchase card not supported  Data Length: String (1) 
    */
    'category'?: string;
    /**
    * Indicates whether the card is a commercial card, which enables you to include Level II data in your transaction requests. This field is supported for Visa and Mastercard on **Chase Paymentech Solutions**. Possible values:   - `Y`: Yes  - `N`: No  - `X`: Not applicable / Unknown 
    */
    'commercial'?: string;
    /**
    * Type of commercial card. This field is supported only for CyberSource through VisaNet. Possible values:   - `B`: Business card  - `R`: Corporate card  - `S`: Purchasing card  - `0`: Noncommercial card  Returned by authorization service. 
    */
    'group'?: string;
    /**
    * Indicates whether the card is a healthcare card. This field is supported for Visa and Mastercard on **Chase Paymentech Solutions**. Possible values:   - `Y`: Yes  - `N`: No  - `X`: Not applicable / Unknown 
    */
    'healthCare'?: string;
    /**
    * Indicates whether the card is a payroll card. This field is supported for Visa, Discover, Diners Club, and JCB on **Chase Paymentech Solutions**. Possible values:   - `Y`: Yes  - `N`: No  - `X`: Not applicable / Unknown 
    */
    'payroll'?: string;
    /**
    * Indicates whether the card is eligible for Level III interchange fees, which enables you to include Level III data in your transaction requests. This field is supported for Visa and Mastercard on **Chase Paymentech Solutions**. Possible values:   - `Y`: Yes  - `N`: No  - `X`: Not applicable / Unknown 
    */
    'level3Eligible'?: string;
    /**
    * Indicates whether the card is a PINless debit card. This field is supported for Visa and Mastercard on **Chase Paymentech Solutions**. Possible values:   - `Y`: Yes  - `N`: No  - `X`: Not applicable / Unknown 
    */
    'pinlessDebit'?: string;
    /**
    * Indicates whether the card is a signature debit card.  This information enables you to alter the way an order is processed. For example, you might not want to reauthorize a transaction for a signature debit card, or you might want to perform reversals promptly for a signature debit card. This field is supported for Visa, Mastercard, and Maestro (International) on Chase Paymentech Solutions. Possible values:   - `Y`: Yes  - `N`: No  - `X`: Not applicable / Unknown 
    */
    'signatureDebit'?: string;
    /**
    * Indicates whether the card is a prepaid card. This information enables you to determine when a gift card or prepaid card is presented for use when establishing a new recurring, installment, or deferred billing relationship.  This field is supported for Visa, Mastercard, Discover, Diners Club, and JCB on Chase Paymentech Solutions. Possible values:   - `Y`: Yes  - `N`: No  - `X`: Not applicable / Unknown 
    */
    'prepaid'?: string;
    /**
    * Indicates whether the card is regulated according to the Durbin Amendment. If the card is regulated, the card issuer is subject to price caps and interchange rules. This field is supported for Visa, Mastercard, Discover, Diners Club, and JCB on Chase Paymentech Solutions. Possible values:   - `Y`: Yes  - `N`: No  - `X`: Not applicable / Unknown 
    */
    'regulated'?: string;
    /**
    * This is the account owner information, valid values are: - `01` : primary account holder - `02` : secondary account holder This is returned in the response of an account verification transaction by the Issuer.  
    */
    'accountHolderType'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "accountType",
            "baseName": "accountType",
            "type": "string"
        },
        {
            "name": "accountStatus",
            "baseName": "accountStatus",
            "type": "string"
        },
        {
            "name": "balances",
            "baseName": "balances",
            "type": "Array<PtsV2PaymentsPost201ResponsePaymentInformationAccountFeaturesBalances>"
        },
        {
            "name": "balanceAmount",
            "baseName": "balanceAmount",
            "type": "string"
        },
        {
            "name": "balanceAmountType",
            "baseName": "balanceAmountType",
            "type": "string"
        },
        {
            "name": "currency",
            "baseName": "currency",
            "type": "string"
        },
        {
            "name": "balanceSign",
            "baseName": "balanceSign",
            "type": "string"
        },
        {
            "name": "affluenceIndicator",
            "baseName": "affluenceIndicator",
            "type": "string"
        },
        {
            "name": "category",
            "baseName": "category",
            "type": "string"
        },
        {
            "name": "commercial",
            "baseName": "commercial",
            "type": "string"
        },
        {
            "name": "group",
            "baseName": "group",
            "type": "string"
        },
        {
            "name": "healthCare",
            "baseName": "healthCare",
            "type": "string"
        },
        {
            "name": "payroll",
            "baseName": "payroll",
            "type": "string"
        },
        {
            "name": "level3Eligible",
            "baseName": "level3Eligible",
            "type": "string"
        },
        {
            "name": "pinlessDebit",
            "baseName": "pinlessDebit",
            "type": "string"
        },
        {
            "name": "signatureDebit",
            "baseName": "signatureDebit",
            "type": "string"
        },
        {
            "name": "prepaid",
            "baseName": "prepaid",
            "type": "string"
        },
        {
            "name": "regulated",
            "baseName": "regulated",
            "type": "string"
        },
        {
            "name": "accountHolderType",
            "baseName": "accountHolderType",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsPost201ResponsePaymentInformationAccountFeatures.attributeTypeMap;
    }
}

export class PtsV2PaymentsPost201ResponsePaymentInformationAccountFeaturesBalances {
    /**
    * Type of account.  This value is returned only if you request a balance inquiry.  Possible values:   - `00`: Not applicable or not specified  - `10`: Savings account  - `20`: Checking account  - `30`: Credit card account  - `40`: Universal account  Balance Account Types returned on EBT Debit card transactions:   - `96`: Cash Benefits Account (PIN Debit Gateway EBT only)  - `98`: Food Stamp Account (PIN Debit Gateway EBT only) 
    */
    'accountType'?: string;
    /**
    * Remaining balance on the account. If the processor returns the sign, positive or negative, this sign is prefixed to the amount value as (+/-). 
    */
    'amount'?: string;
    /**
    * Type of amount. This value is returned only if you request a balance inquiry. The issuer determines the value that is returned.  Possible values for deposit accounts:   - `01`: Current ledger (posted) balance.  - `02`: Current available balance, which is typically the ledger balance minus outstanding authorizations. Some  depository institutions also include pending deposits and the credit or overdraft line associated with the account.  Possible values for credit card accounts:   - `01`: Credit amount remaining for customer (open to buy).  - `02`: Credit limit. 
    */
    'amountType'?: string;
    /**
    * Currency of the remaining balance on the account. 
    */
    'currency'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "accountType",
            "baseName": "accountType",
            "type": "string"
        },
        {
            "name": "amount",
            "baseName": "amount",
            "type": "string"
        },
        {
            "name": "amountType",
            "baseName": "amountType",
            "type": "string"
        },
        {
            "name": "currency",
            "baseName": "currency",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsPost201ResponsePaymentInformationAccountFeaturesBalances.attributeTypeMap;
    }
}

export class PtsV2PaymentsPost201ResponsePaymentInformationBank {
    'account'?: PtsV2PaymentsPost201ResponsePaymentInformationBankAccount;
    /**
    * Corrected account number from the ACH verification service. 
    */
    'correctedRoutingNumber'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "account",
            "baseName": "account",
            "type": "PtsV2PaymentsPost201ResponsePaymentInformationBankAccount"
        },
        {
            "name": "correctedRoutingNumber",
            "baseName": "correctedRoutingNumber",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsPost201ResponsePaymentInformationBank.attributeTypeMap;
    }
}

export class PtsV2PaymentsPost201ResponsePaymentInformationBankAccount {
    /**
    * Corrected account number from the ACH verification service. 
    */
    'correctedAccountNumber'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "correctedAccountNumber",
            "baseName": "correctedAccountNumber",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsPost201ResponsePaymentInformationBankAccount.attributeTypeMap;
    }
}

export class PtsV2PaymentsPost201ResponsePaymentInformationEWallet {
    /**
    * Payment mode for the reference transaction. Possible values: - `INSTANT_TRANSFER` - `MANUAL_BANK_TRANSFER` - `DELAYED_TRANSFER` - `ECHECK` 
    */
    'fundingSource'?: string;
    /**
    * The ID of the customer, passed in the return_url field by PayPal after customer approval. 
    */
    'accountId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "fundingSource",
            "baseName": "fundingSource",
            "type": "string"
        },
        {
            "name": "accountId",
            "baseName": "accountId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsPost201ResponsePaymentInformationEWallet.attributeTypeMap;
    }
}

export class PtsV2PaymentsPost201ResponsePaymentInformationInstrumentIdentifier {
    /**
    * Unique identifier for the Instrument Identifier token used in the transaction. When you include this value in your request, many of the fields that can be supplied for an authorization or credit become optional. 
    */
    'id'?: string;
    /**
    * Issuers state for the card number. Valid values: - ACTIVE - CLOSED : The account has been closed. 
    */
    'state'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsPost201ResponsePaymentInformationInstrumentIdentifier.attributeTypeMap;
    }
}

export class PtsV2PaymentsPost201ResponsePaymentInformationTokenizedCard {
    /**
    * First six digits of token. CyberSource includes this field in the reply message when it decrypts the payment blob for the tokenized transaction. 
    */
    'prefix'?: string;
    /**
    * Last four digits of token. CyberSource includes this field in the reply message when it decrypts the payment blob for the tokenized transaction.  For details, see `token_suffix` field description in [Google Pay Using the SCMP API.] (https://apps.cybersource.com/library/documentation/dev_guides/Google_Pay_SCMP_API/html/) 
    */
    'suffix'?: string;
    /**
    * Three-digit value that indicates the card type.  **IMPORTANT** It is strongly recommended that you include the card type field in request messages even if it is optional for your processor and card type. Omitting the card type can cause the transaction to be processed with the wrong card type.  Possible values: - `001`: Visa. Use card type value `001` for Visa Electron. - `002`: Mastercard, Eurocard[^1], which is a European regional brand of Mastercard. - `003`: American Express - `004`: Discover - `005`: Diners Club - `006`: Carte Blanche[^1] - `007`: JCB[^1] - `008`: Optima - `009`: GE Private Label - `010`: Beneficial Private Label - `011`: Twinpay Credit Card - `012`: Twinpay Debit Card - `013`: WalMart - `014`: Enroute[^1] - `015`: Lowe's Consumer - `016`: Home Depot Consumer - `017`: MBNA - `018`: Dick's Sportswear - `019`: Casual Corner - `020`: Sears - `021`: JAL[^1] - `023`: Disney Card - `024`: Maestro (UK Domestic)[^1] - `025`: Sam's Club Consumer - `026`: Sam's Club Business - `027`: Nico's - `028`: Paymentech Bill Me Later - `029`: Bebe - `030`: Restoration Hardware - `031`: Delta Online - `032`: Solo - `033`: Visa Electron[^1]. Do not use this value. Use `001` for all Visa card types. - `034`: Dankort[^1] - `035`: Laser - `036`: Cartes Bancaires[^1,4] - `037`: Carta Si[^1] - `038`: Pinless Debit - `039`: Encoded account number[^1] - `040`: UATP[^1] - `041`: HOUSEHOLD - `042`: Maestro (International)[^1] - `043`: GE MONEY - `044`: Korean Cards - `045`: Style Cards - `046`: JCrew - `047`: Payeasecn eWallet - `048`: Payeasecn Bank Transfer - `049`: Meijer - `050`: Hipercard[^2,3] - `051`: Aura - `052`: Redecard - `053`: Orico card - `054`: Elo[^3] - `055`: Capitol One Private Label - `056`: Carnet - `057`: Costco Private Label - `058`: Carnet - `059`: ValueLink - `060`: MADA - `061`: RuPay - `062`: China UnionPay - `063`: Falabella Private Label - `064`: Prompt Card - `065`: Korean Domestic - `066`: Banricompras - `067`: MEEZA - `068`: PayPak - `070`: EFTPOS - `071`: Codensa - `072`: Olimpica - `073`: Colsubsidio - `074`: Tuya - `075`: Sodexo - `076`: Naranja - `077`: Cabal - `078`: DINELCO - `079`: PANAL - `080`: EPM - `081`: Jaywan  [^1]: For this card type, you must include the `paymentInformation.card.type` or `paymentInformation.tokenizedCard.type` field in your request for an authorization or a stand-alone credit. [^2]: For this card type on Cielo 3.0, you must include the `paymentInformation.card.type` or `paymentInformation.tokenizedCard.type` field in a request for an authorization or a stand-alone credit. This card type is not supported on Cielo 1.5. [^3]: For this card type on Getnet and Rede, you must include the `paymentInformation.card.type` or `paymentInformation.tokenizedCard.type` field in a request for an authorization or a stand-alone credit. [^4]: For this card type, you must include the `paymentInformation.card.type` in your request for any payer authentication services.  #### Used by **Authorization** Required for Carte Blanche and JCB. Optional for all other card types.  #### Card Present reply This field is included in the reply message when the client software that is installed on the POS terminal uses the token management service (TMS) to retrieve tokenized payment details. You must contact customer support to have your account enabled to receive these fields in the credit reply message.  Returned by the Credit service.  This reply field is only supported by the following processors: - American Express Direct - Credit Mutuel-CIC - FDC Nashville Global - OmniPay Direct - SIX  #### Google Pay transactions For PAN-based Google Pay transactions, this field is returned in the API response.  #### GPX This field only supports transactions from the following card types: - Visa - Mastercard - AMEX - Discover - Diners - JCB - Union Pay International 
    */
    'type'?: string;
    /**
    * Confidence level of the tokenization. This value is assigned by the token service provider.  **Note** This field is supported only for **CyberSource through VisaNet** and **FDC Nashville Global**.  Returned by PIN debit credit or PIN debit purchase.  **Note** Merchants supported for **CyberSource through VisaNet**_/_**Visa Platform Connect** are advised not to use this field. 
    */
    'assuranceLevel'?: string;
    /**
    * One of two possible meanings: - The two-digit month in which a token expires. - The two-digit month in which a card expires. Format: `MM` Possible values: `01` through `12`  **NOTE** The meaning of this field is dependent on the payment processor that is returning the value in an authorization reply. Please see the processor-specific details below.  #### Barclays and Streamline For Maestro (UK Domestic) and Maestro (International) cards on Barclays and Streamline, this must be a valid value (`01` through `12`) but is not required to be a valid expiration date. In other words, an expiration date that is in the past does not cause CyberSource to reject your request. However, an invalid expiration date might cause the issuer to reject your request.  #### Encoded Account Numbers For encoded account numbers (`card_type=039`), if there is no expiration date on the card, use `12`.\\ **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.  #### Samsung Pay and Apple Pay Month in which the token expires. CyberSource includes this field in the reply message when it decrypts the payment blob for the tokenized transaction. 
    */
    'expirationMonth'?: string;
    /**
    * One of two possible meanings: - The four-digit year in which a token expires. - The four-digit year in which a card expires. Format: `YYYY` Possible values: `1900` through `3000` Data type: Non-negative integer  **NOTE** The meaning of this field is dependent on the payment processor that is returning the value in an authorization reply. Please see the processor-specific details below.  #### Barclays and Streamline For Maestro (UK Domestic) and Maestro (International) cards on Barclays and Streamline, this must be a valid value (1900 through 3000) but is not required to be a valid expiration date. In other words, an expiration date that is in the past does not cause CyberSource to reject your request. However, an invalid expiration date might cause the issuer to reject your request.  #### Encoded Account Numbers For encoded account numbers (`card_ type=039`), if there is no expiration date on the card, use `2021`.  #### FDC Nashville Global and FDMS South You can send in 2 digits or 4 digits. When you send in 2 digits, they must be the last 2 digits of the year.  #### Samsung Pay and Apple Pay Year in which the token expires. CyberSource includes this field in the reply message when it decrypts the payment blob for the tokenized transaction.  **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting. 
    */
    'expirationYear'?: string;
    /**
    * Value that identifies your business and indicates that the cardholder’s account number is tokenized. This value is assigned by the token service provider and is unique within the token service provider’s database.  **Note** This field is supported only for **CyberSource through VisaNet** and **FDC Nashville Global**.  #### PIN debit Optional field for PIN debit credit or PIN debit purchase transactions that use payment network tokens; otherwise, not used. 
    */
    'requestorId'?: string;
    /**
    * Confidence level of the tokenization. This value is assigned by the token service provider.  **Note** This field is supported only for **Visa Platform Connect** 
    */
    'assuranceMethod'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "prefix",
            "baseName": "prefix",
            "type": "string"
        },
        {
            "name": "suffix",
            "baseName": "suffix",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "assuranceLevel",
            "baseName": "assuranceLevel",
            "type": "string"
        },
        {
            "name": "expirationMonth",
            "baseName": "expirationMonth",
            "type": "string"
        },
        {
            "name": "expirationYear",
            "baseName": "expirationYear",
            "type": "string"
        },
        {
            "name": "requestorId",
            "baseName": "requestorId",
            "type": "string"
        },
        {
            "name": "assuranceMethod",
            "baseName": "assuranceMethod",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsPost201ResponsePaymentInformationTokenizedCard.attributeTypeMap;
    }
}

export class PtsV2PaymentsPost201ResponsePaymentInformationTokenizedPaymentMethod {
    /**
    * The PayPal-generated ID for the token. 
    */
    'id'?: string;
    /**
    * The vault status.   Possible Values:   - `VAULTED`   - `CREATED`   - `APPROVED` 
    */
    'status'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsPost201ResponsePaymentInformationTokenizedPaymentMethod.attributeTypeMap;
    }
}

export class PtsV2PaymentsPost201ResponsePaymentInsightsInformation {
    'responseInsights'?: PtsV2PaymentsPost201ResponsePaymentInsightsInformationResponseInsights;
    'orchestration'?: PtsV2PaymentsPost201ResponsePaymentInsightsInformationOrchestration;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "responseInsights",
            "baseName": "responseInsights",
            "type": "PtsV2PaymentsPost201ResponsePaymentInsightsInformationResponseInsights"
        },
        {
            "name": "orchestration",
            "baseName": "orchestration",
            "type": "PtsV2PaymentsPost201ResponsePaymentInsightsInformationOrchestration"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsPost201ResponsePaymentInsightsInformation.attributeTypeMap;
    }
}

export class PtsV2PaymentsPost201ResponsePaymentInsightsInformationOrchestration {
    /**
    * Infocodes indicating which rules were triggered by the Service Orchestration product. 
    */
    'infoCodes'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "infoCodes",
            "baseName": "infoCodes",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsPost201ResponsePaymentInsightsInformationOrchestration.attributeTypeMap;
    }
}

export class PtsV2PaymentsPost201ResponsePaymentInsightsInformationResponseInsights {
    /**
    * Categorization of response message from processor  Possible Values: - `ISSUER_WILL_NEVER_APPROVE` - `ISSUER_CANNOT_APPROVE_AT_THIS_TIME` - `ISSUER_CANNOT_APPROVE_WITH_THESE_DETAILS` - `GENERIC_ERROR` - `PAYMENT_INSIGHTS_INTERNAL_ERROR` - `OTHERS` - `PAYMENT_INSIGHTS_RESPONSE_CATEGORY_MATCH_NOT_FOUND` 
    */
    'category'?: string;
    /**
    * Categorization Code of response message from processor  Possible Values: - `01` : ISSUER_WILL_NEVER_APPROVE - `02` : ISSUER_CANNOT_APPROVE_AT_THIS_TIME - `03` : ISSUER_CANNOT_APPROVE_WITH_THESE_DETAILS - `04` : GENERIC_ERROR - `97` : PAYMENT_INSIGHTS_INTERNAL_ERROR - `98` : OTHERS - `99` : PAYMENT_INSIGHTS_RESPONSE_CATEGORY_MATCH_NOT_FOUND 
    */
    'categoryCode'?: string;
    /**
    * Raw name of the processor used for the transaction processing, especially useful during acquirer swing to see which processor transaction settled with 
    */
    'processorRawName'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "category",
            "baseName": "category",
            "type": "string"
        },
        {
            "name": "categoryCode",
            "baseName": "categoryCode",
            "type": "string"
        },
        {
            "name": "processorRawName",
            "baseName": "processorRawName",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsPost201ResponsePaymentInsightsInformationResponseInsights.attributeTypeMap;
    }
}

export class PtsV2PaymentsPost201ResponsePointOfSaleInformation {
    'emv'?: PtsV2PaymentsPost201ResponsePointOfSaleInformationEmv;
    /**
    * Point-of-sale details for the transaction. This value is returned only for **American Express Direct**. CyberSource generates this value, which consists of a series of codes that identify terminal capability, security data, and specific conditions present at the time the transaction occurred. To comply with the CAPN requirements, this value must be included in all subsequent follow-on requests, such as captures and follow-on credits.  When you perform authorizations, captures, and credits through CyberSource, CyberSource passes this value from the authorization service to the subsequent services for you. However, when you perform authorizations through CyberSource and perform subsequent services through other financial institutions, you must ensure that your requests for captures and credits include this value. 
    */
    'amexCapnData'?: string;
    /**
    * Identifier for the terminal at your retail location. You can define this value yourself, but consult the processor for requirements.  #### CyberSource through VisaNet A list of all possible values is stored in your CyberSource account. If terminal ID validation is enabled for your CyberSource account, the value you send for this field is validated against the list each time you include the field in a request. To enable or disable terminal ID validation, contact CyberSource Customer Support.  When you do not include this field in a request, CyberSource uses the default value that is defined in your CyberSource account.  #### FDC Nashville Global To have your account configured to support this field, contact CyberSource Customer Support. This value must be a value that FDC Nashville Global issued to you.  #### For Payouts This field is applicable for CyberSource through VisaNet.  #### GPX Identifier for the terminal at your retail location. A list of all possible values is stored in your account. If terminal ID validation is enabled for your account, the value you send for this field is validated against the list each time you include the field in a request. To enable or disable terminal ID validation, contact customer support.  When you do not include this field in a request, the default value that is defined in your account is used.  Optional for authorizations.  #### Used by **Authorization** Optional for the following processors. When you do not include this field in a request, the default value that is defined in your account is used.   - American Express Direct   - Credit Mutuel-CIC   - FDC Nashville Global   - SIX - Chase Paymentech Solutions: Optional field. If you include this field in your request, you must also include `pointOfSaleInformation.catLevel`. - FDMS Nashville: The default value that is defined in your account is used. - GPX - OmniPay Direct: Optional field.  For the following processors, this field is not used. - GPN - JCN Gateway - RBS WorldPay Atlanta - TSYS Acquiring Solutions - Worldpay VAP  #### Card Present reply Terminal identifier assigned by the acquirer. This value must be printed on the receipt. 
    */
    'terminalId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "emv",
            "baseName": "emv",
            "type": "PtsV2PaymentsPost201ResponsePointOfSaleInformationEmv"
        },
        {
            "name": "amexCapnData",
            "baseName": "amexCapnData",
            "type": "string"
        },
        {
            "name": "terminalId",
            "baseName": "terminalId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsPost201ResponsePointOfSaleInformation.attributeTypeMap;
    }
}

export class PtsV2PaymentsPost201ResponsePointOfSaleInformationEmv {
    /**
    * EMV data that is transmitted from the chip card to the issuer, and from the issuer to the chip card. The EMV data is in the tag-length-value format and includes chip card tags, terminal tags, and transaction detail tags.  For information about the individual tags, see the “Application Specification” section in the EMV 4.3 Specifications: http://emvco.com  **Note** Card present information about EMV applies only to credit card processing and PIN debit processing. All other card present information applies only to credit card processing. PIN debit processing is available only on FDC Nashville Global.  **Important** The following tags contain sensitive information and **must not** be included in this field:   - `56`: Track 1 equivalent data  - `57`: Track 2 equivalent data  - `5A`: Application PAN  - `5F20`: Cardholder name  - `5F24`: Application expiration date (This sensitivity has been relaxed for Credit Mutuel-CIC, American Express Direct, FDC Nashville Global, First Data Merchant Solutions, and SIX)  - `99`: Transaction PIN  - `9F0B`: Cardholder name (extended)  - `9F1F`: Track 1 discretionary data  - `9F20`: Track 2 discretionary data  For captures, this field is required for contact EMV transactions. Otherwise, it is optional.  For credits, this field is required for contact EMV stand-alone credits and contactless EMV stand-alone credits. Otherwise, it is optional.  **Important** For contact EMV captures, contact EMV stand-alone credits, and contactless EMV stand-alone credits, you must include the following tags in this field. For all other types of EMV transactions, the following tags are optional.   - `95`: Terminal verification results  - `9F10`: Issuer application data  - `9F26`: Application cryptogram   #### CyberSource through VisaNet - In Japan: 199 bytes - In other countries: String (252)  For Mastercard Transactions, Optionally Tag 9F60 (Authenticated Application Data) and  Tag 96 (Kernel Identifier - Terminal) can be included in the Field.  #### GPX This field only supports transactions from the following card types: - Visa - Mastercard - AMEX - Discover - Diners - JCB - Union Pay International  #### JCN Gateway The following tags must be included: - `4F`: Application identifier - `84`: Dedicated file name  Data length: 199 bytes  #### All other processors: String (999)  #### Used by Authorization: Optional Authorization Reversal: Optional Credit: Optional PIN Debit processing (purchase, credit and reversal): Optional 
    */
    'tags'?: string;
    /**
    * Entity or service that provided the validation results returned in `chipValidationResult`.  Possible values:  - `02`: MasterCard on-behalf pre-validation service (The MasterCard authorization platform validated the M/Chip cryptogram before the authorization request reached the issuer.)  - `03`: MasterCard on-behalf stand-in service (The MasterCard authorization platform validated the M/Chip cryptogram because the issuer was not available.)  - `50`: Issuer  - `90`: Chip fall-back transaction downgrade process (The chip could not be read.)  This field is returned only for NFC payment network tokenization transactions with MasterCard.  **Note** No CyberSource through VisaNet acquirers support EMV at this time. 
    */
    'chipValidationType'?: string;
    /**
    * Cryptogram validation results returned by the entity or service specified in `chipValidationType`.  Possible values: - `A`: Application cryptogram is valid, but the application transaction counter (ATC) is outside allowed range. (A large jump in ATC values may indicate data copying or other fraud.) - `C`: Chip validation was completed successfully. - `E`: Application cryptogram is valid but the ATC indicates possible replay fraud. - `F`: Format error in the chip data. - `G`: Application cryptogram is valid but is not a valid authorization request cryptogram (ARQC). - `I`: Application cryptogram is invalid. - `T`: Application cryptogram is valid but terminal verification results (TVR) or card verification results (CVR) are invalid. - `U`: Application cryptogram could not be validated because of a technical error.  This field is returned only for NFC payment network tokenization transactions with MasterCard.  **Note** No CyberSource through VisaNet acquirers support EMV at this time. 
    */
    'chipValidationResult'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "tags",
            "baseName": "tags",
            "type": "string"
        },
        {
            "name": "chipValidationType",
            "baseName": "chipValidationType",
            "type": "string"
        },
        {
            "name": "chipValidationResult",
            "baseName": "chipValidationResult",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsPost201ResponsePointOfSaleInformationEmv.attributeTypeMap;
    }
}

export class PtsV2PaymentsPost201ResponseProcessingInformation {
    'bankTransferOptions'?: PtsV2PaymentsPost201ResponseProcessingInformationBankTransferOptions;
    /**
    * Type of digital payment solution for the transaction. Possible Values:   - `visacheckout`: Visa Checkout. This value is required for Visa Checkout transactions. For details, see `payment_solution` field description in [Visa Checkout Using the REST API.](https://developer.cybersource.com/content/dam/docs/cybs/en-us/apifields/reference/all/rest/api-fields.pdf)  - `001`: Apple Pay.  - `004`: Cybersource In-App Solution.  - `005`: Masterpass. This value is required for Masterpass transactions on OmniPay Direct.   - `006`: Android Pay.  - `007`: Chase Pay.  - `008`: Samsung Pay.  - `012`: Google Pay.  - `013`: Cybersource P2PE Decryption  - `014`: Mastercard credential on file (COF) payment network token. Returned in authorizations that use a payment network token associated with a TMS token.  - `015`: Visa credential on file (COF) payment network token. Returned in authorizations that use a payment network token associated with a TMS token.  - `027`: Click to Pay. 
    */
    'paymentSolution'?: string;
    /**
    * The possible values for the reply field are: - `true` : the airline data was included in the request to the processor. - `false` : the airline data was not included in the request to the processor.  Returned by authorization, capture, or credit services. 
    */
    'enhancedDataEnabled'?: boolean;
    'captureOptions'?: PtsV2PaymentsPost201ResponseProcessingInformationCaptureOptions;
    'authorizationOptions'?: PtsV2PaymentsPost201ResponseProcessingInformationAuthorizationOptions;
    'purchaseOptions'?: PtsV2PaymentsPost201ResponseProcessingInformationPurchaseOptions;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "bankTransferOptions",
            "baseName": "bankTransferOptions",
            "type": "PtsV2PaymentsPost201ResponseProcessingInformationBankTransferOptions"
        },
        {
            "name": "paymentSolution",
            "baseName": "paymentSolution",
            "type": "string"
        },
        {
            "name": "enhancedDataEnabled",
            "baseName": "enhancedDataEnabled",
            "type": "boolean"
        },
        {
            "name": "captureOptions",
            "baseName": "captureOptions",
            "type": "PtsV2PaymentsPost201ResponseProcessingInformationCaptureOptions"
        },
        {
            "name": "authorizationOptions",
            "baseName": "authorizationOptions",
            "type": "PtsV2PaymentsPost201ResponseProcessingInformationAuthorizationOptions"
        },
        {
            "name": "purchaseOptions",
            "baseName": "purchaseOptions",
            "type": "PtsV2PaymentsPost201ResponseProcessingInformationPurchaseOptions"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsPost201ResponseProcessingInformation.attributeTypeMap;
    }
}

export class PtsV2PaymentsPost201ResponseProcessingInformationAuthorizationOptions {
    /**
    * Field is used for back-to-back funding transaction and can be defined as a payment flow that automatically transfers funds through a real-time  funding or a live-load. This type of transaction can also be connected to a purchase.  In back-to-back funding of general purpose card that is used to make a purchase, two separate accounts are involved:  - account one is used to make the purchase - account two is used to automatically fund or reimburse account one  Possible values: - 0B = back to back funding transaction - 00 = normal transaction - 01 = originator hold - 02 = Visa deferred OCT hold, default interval - 03 = Visa deferred OCT hold, user-defined interval - 09 = Cancel pending deferred OCT request - 0I = Visa Direct custom program 1 - 0Q = uery the status of the deferred OCT - A0 = Alias Directory 2 
    */
    'serviceType'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "serviceType",
            "baseName": "serviceType",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsPost201ResponseProcessingInformationAuthorizationOptions.attributeTypeMap;
    }
}

export class PtsV2PaymentsPost201ResponseProcessingInformationBankTransferOptions {
    /**
    * Method used for settlement.  Possible values: - `A`: Automated Clearing House (default for credits and for transactions using Canadian dollars) - `F`: Facsimile draft (U.S. dollars only) - `B`: Best possible (U.S. dollars only) (default if the field has not already been configured for your merchant ID) 
    */
    'settlementMethod'?: string;
    /**
    * Level of fraud screening.  Possible values: - `1`: Validation — default if the field has not already been configured for your merchant ID - `2`: Verification 
    */
    'fraudScreeningLevel'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "settlementMethod",
            "baseName": "settlementMethod",
            "type": "string"
        },
        {
            "name": "fraudScreeningLevel",
            "baseName": "fraudScreeningLevel",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsPost201ResponseProcessingInformationBankTransferOptions.attributeTypeMap;
    }
}

export class PtsV2PaymentsPost201ResponseProcessingInformationCaptureOptions {
    /**
    * Indicates whether you can make additional captures against the authorized payment. Set to true if you do not intend to capture additional payments against the authorization. Set to false if you intend to capture additional payments Possible Values: - `true` - `false` 
    */
    'finalCapture'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "finalCapture",
            "baseName": "finalCapture",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsPost201ResponseProcessingInformationCaptureOptions.attributeTypeMap;
    }
}

export class PtsV2PaymentsPost201ResponseProcessingInformationPurchaseOptions {
    /**
    * This field contains installment data defined by MasterCard. Possible values:   - Y = eligible   - N = not eligile 
    */
    'eligibilityIndicator'?: string;
    /**
    * Data mapped received in response from MasterCard. Possible values: - 01 = Meal Voucher - Employee Nutrition Program - 02 = Food Voucher - Employee Nutrition Program - 03 = Culture Voucher - Worker's Culture Program - 04 = Meal Voucher - Consolidation of Labor Laws - 05 = Food Voucher - Consolidation of Labor Laws 
    */
    'type'?: string;
    /**
    * Workplace benefit amount.
    */
    'benefitAmount'?: string;
    /**
    * Workplace benefit type. Possible values: - 70 = employee benefit - 4T = transportation / transit - 52 = general benefit - 53 = meal voucher - 54 = fuel - 55 = ecological / sustainability - 58 = philanthropy / patronage / consumption - 59 = gift - 5S = sport / culture - 5T = book / education 
    */
    'benefitType'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "eligibilityIndicator",
            "baseName": "eligibilityIndicator",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "benefitAmount",
            "baseName": "benefitAmount",
            "type": "string"
        },
        {
            "name": "benefitType",
            "baseName": "benefitType",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsPost201ResponseProcessingInformationPurchaseOptions.attributeTypeMap;
    }
}

export class PtsV2PaymentsPost201ResponseProcessorInformation {
    /**
    * Flag that specifies the purpose of the authorization.  Possible values:  - `0`: Preauthorization  - `1`: Final authorization 
    */
    'authIndicator'?: string;
    /**
    * Authorization code. Returned only when the processor returns this value.  The length of this value depends on your processor.  Returned by authorization service.  #### PIN debit Authorization code that is returned by the processor.  Returned by PIN debit credit.  #### Elavon Encrypted Account Number Program The returned value is OFFLINE.  #### TSYS Acquiring Solutions The returned value for a successful zero amount authorization is 000000. 
    */
    'approvalCode'?: string;
    /**
    * The Scheme reference data is a variable length data element up to a maximum of 56 characters. It may be sent by the acquirer in the authorisation response message, and by the terminal (unchanged) in subsequent authorisation request messages associated with the same transaction. This field is used by Streamline and HSBC UK only, at present. 
    */
    'cardReferenceData'?: string;
    /**
    * Network transaction identifier (TID). You can use this value to identify a specific transaction when you are discussing the transaction with your processor. Not all processors provide this value.  Returned by the authorization service.  #### PIN debit Transaction identifier generated by the processor.  Returned by PIN debit credit.  #### GPX Processor transaction ID.  #### Cielo For Cielo, this value is the non-sequential unit (NSU) and is supported for all transactions. The value is generated by Cielo or the issuing bank.  #### Comercio Latino For Comercio Latino, this value is the proof of sale or non-sequential unit (NSU) number generated by the acquirers Cielo and Rede, or the issuing bank.  #### CyberSource through VisaNet and GPN For details about this value for CyberSource through VisaNet and GPN, see \"processorInformation.networkTransactionId\" in [REST API Fields](https://developer.cybersource.com/content/dam/docs/cybs/en-us/apifields/reference/all/rest/api-fields.pdf)  #### Moneris This value identifies the transaction on a host system. It contains the following information: - Terminal used to process the transaction - Shift during which the transaction took place - Batch number - Transaction number within the batch You must store this value. If you give the customer a receipt, display this value on the receipt.  **Example** For the value 66012345001069003: - Terminal ID = 66012345 - Shift number = 001 - Batch number = 069 - Transaction number = 003 
    */
    'transactionId'?: string;
    /**
    * Same value as `processorInformation.transactionId`
    */
    'networkTransactionId'?: string;
    /**
    * For most processors, this is the error message sent directly from the bank. Returned only when the processor returns this value.  **Important** Do not use this field to evaluate the result of the authorization.  #### PIN debit Response value that is returned by the processor or bank. **Important** Do not use this field to evaluate the results of the transaction request.  Returned by PIN debit credit, PIN debit purchase, and PIN debit reversal.  #### AIBMS If this value is `08`, you can accept the transaction if the customer provides you with identification.  #### Atos This value is the response code sent from Atos and it might also include the response code from the bank. Format: `aa,bb` with the two values separated by a comma and where: - `aa` is the two-digit error message from Atos. - `bb` is the optional two-digit error message from the bank.  #### Comercio Latino This value is the status code and the error or response code received from the processor separated by a colon. Format: [status code]:E[error code] or [status code]:R[response code] Example `2:R06`  #### JCN Gateway Processor-defined detail error code. The associated response category code is in the `processorInformation.responseCategoryCode` field. String (3)  #### paypalgateway Processor generated ID for the itemized detail. 
    */
    'responseCode'?: string;
    /**
    * Used by Visa only and contains the response source/reason code that identifies the source of the response decision. 
    */
    'responseCodeSource'?: string;
    /**
    * This field might contain information about a decline. This field is supported only for **CyberSource through VisaNet**. 
    */
    'responseDetails'?: string;
    /**
    * Processor-defined response category code. The associated detail error code is in the `processorInformation.responseCode` or `issuerInformation.responseCode` field of the service you requested.  This field is supported only for:   - Japanese issuers  - Domestic transactions in Japan  - Comercio Latino—processor transaction ID required for troubleshooting  #### Maximum length for processors   - Comercio Latino: 36  - All other processors: 3 
    */
    'responseCategoryCode'?: string;
    /**
    * Name of the Japanese acquirer that processed the transaction. Returned only for JCN Gateway. Please contact the CyberSource Japan Support Group for more information. 
    */
    'forwardedAcquirerCode'?: string;
    /**
    * Field contains a settlement date. The date is in mmdd format, where: mm = month and dd = day. 
    */
    'settlementDate'?: string;
    /**
    * This field serves as a unique identifier for initial and subsequent recurring transactions, specific to the payment brand, and is crucial for transaction tracking and recurrence management. Not all processors provide this value. Returned by the authorization service. 
    */
    'sequenceNumber'?: string;
    'avs'?: PtsV2PaymentsPost201ResponseProcessorInformationAvs;
    'cardVerification'?: PtsV2PaymentsPost201ResponseProcessorInformationCardVerification;
    'merchantAdvice'?: PtsV2PaymentsPost201ResponseProcessorInformationMerchantAdvice;
    'electronicVerificationResults'?: PtsV2PaymentsPost201ResponseProcessorInformationElectronicVerificationResults;
    'achVerification'?: PtsV2PaymentsPost201ResponseProcessorInformationAchVerification;
    'customer'?: PtsV2PaymentsPost201ResponseProcessorInformationCustomer;
    'consumerAuthenticationResponse'?: PtsV2PaymentsPost201ResponseProcessorInformationConsumerAuthenticationResponse;
    /**
    * This field is returned only for **American Express Direct** and **CyberSource through VisaNet**. Returned by authorization and incremental authorization services.  #### American Express Direct  System trace audit number (STAN). This value identifies the transaction and is useful when investigating a chargeback dispute.  #### CyberSource through VisaNet  System trace number that must be printed on the customer’s receipt. 
    */
    'systemTraceAuditNumber'?: string;
    /**
    * Payment Account Reference (PAR) is a non-financial reference assigned to each unique payment account and used to link a payment account to associated network tokens, i.e. the same PAR is returned for PAN-based and tokenized transactions, such as from digital wallets. PAR can be returned in authorisation responses for requests initiated with both real PANs and tokenized PANs. PAR can be used by merchants for fraud detection and regulatory compliance across different channels and digital wallets. PAR allows all participants in the payments chain to have a single, non-sensitive value assigned to a consumer. This value can be used in place of sensitive card holder identification fields, and transmitted across the payments ecosystem to facilitate card holder identification.  **Note** On CyberSource through VisaNet, the value for this field corresponds to the following data in the TC 33 capture file: - Record: CP01 TCR8 - Position: 79-110 - Field: Payment Account Reference  The TC 33 Capture file contains information about the purchases and refunds that a merchant submits to CyberSource. CyberSource through VisaNet creates the TC 33 Capture file at the end of the day and sends it to the merchant’s acquirer, who uses this information to facilitate end-of-day clearing processing with payment networks. 
    */
    'paymentAccountReferenceNumber'?: string;
    /**
    * Transaction integrity classification provided by Mastercard. This value specifies Mastercard’s evaluation of the transaction’s safety and security. This field is returned only for **CyberSource through VisaNet**.  For card-present transactions, possible values:   - `A1`: EMV or token in a secure, trusted environment  - `B1`: EMV or chip equivalent  - `C1`: Magnetic stripe  - `E1`: Key entered  - `U0`: Unclassified  For card-not-present transactions, possible values:   - `A2`: Digital transactions  - `B2`: Authenticated checkout  - `C2`: Transaction validation  - `D2`: Enhanced data  - `E2`: Generic messaging  - `U0`: Unclassified  For information about these values, contact Mastercard or your acquirer.  #### CyberSource through VisaNet  The value for this field corresponds to the following data in the TC 33 capture file,<sup>1</sup>: - Record: CP01 TCR6 - Position: 136-137 - Field: Mastercard Transaction Integrity Classification  <sup>1</sup> The TC 33 Capture file contains information about the purchases and refunds that a merchant submits to CyberSource. CyberSource through VisaNet creates the TC 33 Capture file at the end of the day and sends it to the merchant’s acquirer, who uses this information to facilitate end-of-day clearing processing with payment networks. 
    */
    'transactionIntegrityCode'?: string;
    /**
    * Referral response number for a verbal authorization with FDMS Nashville when using an American Express card. Give this number to American Express when you call them for the verbal authorization. 
    */
    'amexVerbalAuthReferenceNumber'?: string;
    /**
    * Mastercard service that was used for the transaction. Mastercard provides this value to CyberSource.  Possible value:  - 53: Mastercard card-on-file token service  #### CyberSource through VisaNet The value for this field corresponds to the following data in the TC 33 capture file: - Record: CP01 TCR6 - Position: 133-134 - Field: Mastercard Merchant on-behalf service. **Note** This field is returned only for CyberSource through VisaNet. 
    */
    'masterCardServiceCode'?: string;
    /**
    * Result of the Mastercard card-on-file token service. Mastercard provides this value to CyberSource.  Possible values:   - `C`: Service completed successfully.  - `F`: One of the following:    - Incorrect Mastercard POS entry mode. The Mastercard POS entry mode should be 81 for an authorization or      authorization reversal.    - Incorrect Mastercard POS entry mode. The Mastercard POS entry mode should be 01 for a tokenized request.    - Token requestor ID is missing or formatted incorrectly.  - `I`: One of the following:    - Invalid token requestor ID.    - Suspended or deactivated token.    - Invalid token (not in mapping table).  - `T`: Invalid combination of token requestor ID and token.  - `U`: Expired token.  - `W`: Primary account number (PAN) listed in electronic warning bulletin.  **Note** This field is returned only for **CyberSource through VisaNet**. 
    */
    'masterCardServiceReplyCode'?: string;
    /**
    * Type of authentication for which the transaction qualifies as determined by the Mastercard authentication service, which confirms the identity of the cardholder. Mastercard provides this value to CyberSource.  Possible values:   - `1`: Transaction qualifies for Mastercard authentication type 1.  - `2`: Transaction qualifies for Mastercard authentication type 2.  #### CyberSource through VisaNet The value for this field corresponds to the following data in the TC 33 capture file: - Record: CP01 TCR6 - Position: 132 - Field: Mastercard Member Defined service. **Note** This field is returned only for CyberSource through VisaNet. 
    */
    'masterCardAuthenticationType'?: string;
    /**
    * Name of the Processor. 
    */
    'name'?: string;
    'routing'?: PtsV2PaymentsPost201ResponseProcessorInformationRouting;
    /**
    * Identifier that was assigned to you by your acquirer. This value must be printed on the receipt.  #### Returned by Authorizations and Credits.  This reply field is only supported by merchants who have installed client software on their POS terminals and use these processors: - American Express Direct - Credit Mutuel-CIC - FDC Nashville Global - OmniPay Direct - SIX 
    */
    'merchantNumber'?: string;
    /**
    * #### Ingenico ePayments Unique number that CyberSource generates to identify the transaction. You can use this value to identify transactions in the Ingenico ePayments Collections Report, which provides settlement information. Contact customer support for information about the report.  ### CyberSource through VisaNet Retrieval request number. 
    */
    'retrievalReferenceNumber'?: string;
    /**
    * Direct the customer to this URL to complete the payment.
    */
    'paymentUrl'?: string;
    /**
    * The redirect URL for forwarding the consumer to complete page.  This redirect needed by PSP to track browser information of consumer. PSP then redirect consumer to merchant success URL. 
    */
    'completeUrl'?: string;
    'signature'?: string;
    'publicKey'?: string;
    'sellerProtection'?: PtsV2PaymentsPost201ResponseProcessorInformationSellerProtection;
    /**
    * The date on which the transaction expires and payment cannot be made. 
    */
    'transactionExpiryDate'?: string;
    /**
    * For merchants to declare customs Customs declaration service URL. 
    */
    'customUrl'?: string;
    /**
    * Unique id assigned to a merchant by the APM and not PSP The merchant ID, as boarded with Alipay 
    */
    'schemeAssignedId'?: string;
    /**
    * The QR code value. Convert this value into an image and send it to the POS terminal to be displayed. The terminal can also perform the conversion. The value is a URL like in the example below: https://qr.alipay.com/pmxabcka1ts5grar12. 
    */
    'deviceUrl'?: string;
    /**
    * The funds are released to the merchant immediately. INSTANT The funds are released to the merchant immediately. DELAYED The funds are held for a finite number of days. The actual duration depends on the region and type of integration. You can release the funds through a referenced payout. Otherwise, the funds disbursed automatically after the specified duration. 
    */
    'disbursementMode'?: string;
    /**
    * The date and time when the transaction was last updated, in Internet date and time format. 
    */
    'updateTimeUtc'?: string;
    /**
    * The date and time when the authorized payment expires, in Internet date and time format. 
    */
    'expirationTimeUtc'?: string;
    /**
    * The id of the order 
    */
    'orderId'?: string;
    /**
    * The order status.  Possible values: - `CREATED` - `VOIDED` - `COMPLETED` - `PAYER_ACTION_REQUIRED` 
    */
    'orderStatus'?: string;
    /**
    * Mastercard is introducing the Merchant Risk Predict Service in the middle East/Africa Region. A newly launched service comprised of seven independent artificial intelligence (AI)-powered scores intended to augment existing merchant risk management practices. 
    */
    'merchantRiskPrediction'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "authIndicator",
            "baseName": "authIndicator",
            "type": "string"
        },
        {
            "name": "approvalCode",
            "baseName": "approvalCode",
            "type": "string"
        },
        {
            "name": "cardReferenceData",
            "baseName": "cardReferenceData",
            "type": "string"
        },
        {
            "name": "transactionId",
            "baseName": "transactionId",
            "type": "string"
        },
        {
            "name": "networkTransactionId",
            "baseName": "networkTransactionId",
            "type": "string"
        },
        {
            "name": "responseCode",
            "baseName": "responseCode",
            "type": "string"
        },
        {
            "name": "responseCodeSource",
            "baseName": "responseCodeSource",
            "type": "string"
        },
        {
            "name": "responseDetails",
            "baseName": "responseDetails",
            "type": "string"
        },
        {
            "name": "responseCategoryCode",
            "baseName": "responseCategoryCode",
            "type": "string"
        },
        {
            "name": "forwardedAcquirerCode",
            "baseName": "forwardedAcquirerCode",
            "type": "string"
        },
        {
            "name": "settlementDate",
            "baseName": "settlementDate",
            "type": "string"
        },
        {
            "name": "sequenceNumber",
            "baseName": "sequenceNumber",
            "type": "string"
        },
        {
            "name": "avs",
            "baseName": "avs",
            "type": "PtsV2PaymentsPost201ResponseProcessorInformationAvs"
        },
        {
            "name": "cardVerification",
            "baseName": "cardVerification",
            "type": "PtsV2PaymentsPost201ResponseProcessorInformationCardVerification"
        },
        {
            "name": "merchantAdvice",
            "baseName": "merchantAdvice",
            "type": "PtsV2PaymentsPost201ResponseProcessorInformationMerchantAdvice"
        },
        {
            "name": "electronicVerificationResults",
            "baseName": "electronicVerificationResults",
            "type": "PtsV2PaymentsPost201ResponseProcessorInformationElectronicVerificationResults"
        },
        {
            "name": "achVerification",
            "baseName": "achVerification",
            "type": "PtsV2PaymentsPost201ResponseProcessorInformationAchVerification"
        },
        {
            "name": "customer",
            "baseName": "customer",
            "type": "PtsV2PaymentsPost201ResponseProcessorInformationCustomer"
        },
        {
            "name": "consumerAuthenticationResponse",
            "baseName": "consumerAuthenticationResponse",
            "type": "PtsV2PaymentsPost201ResponseProcessorInformationConsumerAuthenticationResponse"
        },
        {
            "name": "systemTraceAuditNumber",
            "baseName": "systemTraceAuditNumber",
            "type": "string"
        },
        {
            "name": "paymentAccountReferenceNumber",
            "baseName": "paymentAccountReferenceNumber",
            "type": "string"
        },
        {
            "name": "transactionIntegrityCode",
            "baseName": "transactionIntegrityCode",
            "type": "string"
        },
        {
            "name": "amexVerbalAuthReferenceNumber",
            "baseName": "amexVerbalAuthReferenceNumber",
            "type": "string"
        },
        {
            "name": "masterCardServiceCode",
            "baseName": "masterCardServiceCode",
            "type": "string"
        },
        {
            "name": "masterCardServiceReplyCode",
            "baseName": "masterCardServiceReplyCode",
            "type": "string"
        },
        {
            "name": "masterCardAuthenticationType",
            "baseName": "masterCardAuthenticationType",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "routing",
            "baseName": "routing",
            "type": "PtsV2PaymentsPost201ResponseProcessorInformationRouting"
        },
        {
            "name": "merchantNumber",
            "baseName": "merchantNumber",
            "type": "string"
        },
        {
            "name": "retrievalReferenceNumber",
            "baseName": "retrievalReferenceNumber",
            "type": "string"
        },
        {
            "name": "paymentUrl",
            "baseName": "paymentUrl",
            "type": "string"
        },
        {
            "name": "completeUrl",
            "baseName": "completeUrl",
            "type": "string"
        },
        {
            "name": "signature",
            "baseName": "signature",
            "type": "string"
        },
        {
            "name": "publicKey",
            "baseName": "publicKey",
            "type": "string"
        },
        {
            "name": "sellerProtection",
            "baseName": "sellerProtection",
            "type": "PtsV2PaymentsPost201ResponseProcessorInformationSellerProtection"
        },
        {
            "name": "transactionExpiryDate",
            "baseName": "transactionExpiryDate",
            "type": "string"
        },
        {
            "name": "customUrl",
            "baseName": "customUrl",
            "type": "string"
        },
        {
            "name": "schemeAssignedId",
            "baseName": "schemeAssignedId",
            "type": "string"
        },
        {
            "name": "deviceUrl",
            "baseName": "deviceUrl",
            "type": "string"
        },
        {
            "name": "disbursementMode",
            "baseName": "disbursementMode",
            "type": "string"
        },
        {
            "name": "updateTimeUtc",
            "baseName": "updateTimeUtc",
            "type": "string"
        },
        {
            "name": "expirationTimeUtc",
            "baseName": "expirationTimeUtc",
            "type": "string"
        },
        {
            "name": "orderId",
            "baseName": "orderId",
            "type": "string"
        },
        {
            "name": "orderStatus",
            "baseName": "orderStatus",
            "type": "string"
        },
        {
            "name": "merchantRiskPrediction",
            "baseName": "merchantRiskPrediction",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsPost201ResponseProcessorInformation.attributeTypeMap;
    }
}

export class PtsV2PaymentsPost201ResponseProcessorInformationAchVerification {
    /**
    * Results from the ACH verification service. 
    */
    'resultCode'?: string;
    /**
    * Raw results from the ACH verification service. 
    */
    'resultCodeRaw'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "resultCode",
            "baseName": "resultCode",
            "type": "string"
        },
        {
            "name": "resultCodeRaw",
            "baseName": "resultCodeRaw",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsPost201ResponseProcessorInformationAchVerification.attributeTypeMap;
    }
}

export class PtsV2PaymentsPost201ResponseProcessorInformationAvs {
    /**
    * AVS result code.  Returned by authorization service. 
    */
    'code'?: string;
    /**
    * AVS result code sent directly from the processor. Returned only when the processor returns this value. **Important** Do not use this field to evaluate the result of AVS. Use for debugging purposes only.  Returned by authorization service. 
    */
    'codeRaw'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        },
        {
            "name": "codeRaw",
            "baseName": "codeRaw",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsPost201ResponseProcessorInformationAvs.attributeTypeMap;
    }
}

export class PtsV2PaymentsPost201ResponseProcessorInformationCardVerification {
    /**
    * CVN result code. 
    */
    'resultCode'?: string;
    /**
    * CVN result code sent directly from the processor. Returned only when the processor returns this value.  **Important** Do not use this field to evaluate the result of card verification. Use for debugging purposes only. 
    */
    'resultCodeRaw'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "resultCode",
            "baseName": "resultCode",
            "type": "string"
        },
        {
            "name": "resultCodeRaw",
            "baseName": "resultCodeRaw",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsPost201ResponseProcessorInformationCardVerification.attributeTypeMap;
    }
}

export class PtsV2PaymentsPost201ResponseProcessorInformationConsumerAuthenticationResponse {
    /**
    * Mapped response code for Visa Secure and American Express SafeKey. 
    */
    'code'?: string;
    /**
    * Raw response code sent directly from the processor for Visa Secure and American Express SafeKey: 
    */
    'codeRaw'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        },
        {
            "name": "codeRaw",
            "baseName": "codeRaw",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsPost201ResponseProcessorInformationConsumerAuthenticationResponse.attributeTypeMap;
    }
}

export class PtsV2PaymentsPost201ResponseProcessorInformationCustomer {
    /**
    * Personal identifier result. This field is supported only for Redecard in Brazil for CyberSource Latin American Processing. If you included `buyerInformation.personalIdentification[].ID` in the request, this value indicates whether or not `buyerInformation.personalIdentification[].ID` matched a value in a record on file. Returned only when the personal ID result is returned by the processor.  Possible values:   - `Y`: Match  - `N`: No match  - `K`: Not supported  - `U`: Unknown  - `Z`: No response returned **Note** CyberSource Latin American Processing is the name of a specific processing connection that CyberSource supports. In the CyberSource API documentation, CyberSource Latin American Processing does not refer to the general topic of processing in Latin America.The information in this field description is for the specific processing connection called CyberSource Latin American Processing. It is not for any other Latin American processors that CyberSource supports. 
    */
    'personalIdResult'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "personalIdResult",
            "baseName": "personalIdResult",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsPost201ResponseProcessorInformationCustomer.attributeTypeMap;
    }
}

export class PtsV2PaymentsPost201ResponseProcessorInformationElectronicVerificationResults {
    /**
    * Mapped Electronic Verification response code for the customer’s name. 
    */
    'code'?: string;
    /**
    * Raw Electronic Verification response code from the processor for the customer’s last name
    */
    'codeRaw'?: string;
    /**
    * Mapped Electronic Verification response code for the customer’s email address. 
    */
    'email'?: string;
    /**
    * Raw Electronic Verification response code from the processor for the customer’s email address.
    */
    'emailRaw'?: string;
    /**
    * Mapped Electronic Verification response code for the customer’s phone number. 
    */
    'phoneNumber'?: string;
    /**
    * Raw Electronic Verification response code from the processor for the customer’s phone number.
    */
    'phoneNumberRaw'?: string;
    /**
    * Mapped Electronic Verification response code for the customer’s postal code. 
    */
    'postalCode'?: string;
    /**
    * Raw Electronic Verification response code from the processor for the customer’s postal code.
    */
    'postalCodeRaw'?: string;
    /**
    * Mapped Electronic Verification response code for the customer’s street address. 
    */
    'street'?: string;
    /**
    * Raw Electronic Verification response code from the processor for the customer’s street address.
    */
    'streetRaw'?: string;
    /**
    * #### Visa Platform Connect Mapped Electronic Verification response code for the customer’s name.  Valid values :  'Y'   Yes, the data Matches 'N'   No Match 'O'   Partial Match 
    */
    'name'?: string;
    /**
    * #### Visa Platform Connect Raw Electronic Verification response code from the processor for the customer’s name.  Valid values :  '01'     Match '50'     Partial Match '99'     No Match 
    */
    'nameRaw'?: string;
    /**
    * #### Visa Platform Connect Raw electronic verification response code from the processor for the customer’s first name.  Valid values :  '01'     Match '50'     Partial Match '99'     No Match 
    */
    'firstNameRaw'?: string;
    /**
    * #### Visa Platform Connect Mapped electronic verification response code from the processor for the customer’s first name.  Valid values :  'Y'   Yes, the data Matches 'N'   No Match 'O'   Partial Match 
    */
    'firstName'?: string;
    /**
    * #### Visa Platform Connect Raw electronic verification response code from the processor for the customer’s middle name.  Valid values :  '01'     Match '50'     Partial Match '99'     No Match 
    */
    'middleNameRaw'?: string;
    /**
    * #### Visa Platform Connect Mapped electronic verification response code from the processor for the customer’s middle name.  Valid values :  'Y'   Yes, the data Matches 'N'   No Match 'O'   Partial Match 
    */
    'middleName'?: string;
    /**
    * #### Visa Platform Connect Raw electronic verification response code from the processor for the customer’s last name.  Valid values :  '01'     Match '50'     Partial Match '99'     No Match 
    */
    'lastNameRaw'?: string;
    /**
    * #### Visa Platform Connect Mapped electronic verification response code from the processor for the customer’s last name.  Valid values :  'Y'   Yes, the data Matches 'N'   No Match 'O'   Partial Match 
    */
    'lastName'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        },
        {
            "name": "codeRaw",
            "baseName": "codeRaw",
            "type": "string"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "emailRaw",
            "baseName": "emailRaw",
            "type": "string"
        },
        {
            "name": "phoneNumber",
            "baseName": "phoneNumber",
            "type": "string"
        },
        {
            "name": "phoneNumberRaw",
            "baseName": "phoneNumberRaw",
            "type": "string"
        },
        {
            "name": "postalCode",
            "baseName": "postalCode",
            "type": "string"
        },
        {
            "name": "postalCodeRaw",
            "baseName": "postalCodeRaw",
            "type": "string"
        },
        {
            "name": "street",
            "baseName": "street",
            "type": "string"
        },
        {
            "name": "streetRaw",
            "baseName": "streetRaw",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "nameRaw",
            "baseName": "nameRaw",
            "type": "string"
        },
        {
            "name": "firstNameRaw",
            "baseName": "firstNameRaw",
            "type": "string"
        },
        {
            "name": "firstName",
            "baseName": "firstName",
            "type": "string"
        },
        {
            "name": "middleNameRaw",
            "baseName": "middleNameRaw",
            "type": "string"
        },
        {
            "name": "middleName",
            "baseName": "middleName",
            "type": "string"
        },
        {
            "name": "lastNameRaw",
            "baseName": "lastNameRaw",
            "type": "string"
        },
        {
            "name": "lastName",
            "baseName": "lastName",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsPost201ResponseProcessorInformationElectronicVerificationResults.attributeTypeMap;
    }
}

export class PtsV2PaymentsPost201ResponseProcessorInformationMerchantAdvice {
    /**
    * - Merchant should update their retry logic to ensure retry is not attempted for the cards for which Issuer won’t approve the transactions and where the retry is allowed. - Card Processing Associations provides this data which is being passed through in the following data element irrespective of the Card Associations.   Usage of this data must be always associated with the Card Associations card types for merchant processing retry logic. - In additions to the Merchant Advice code, Associations also provides the decline response codes which provides the reason for decline.  Association response code will be a pass-through value.  #### Processors supported:   - HSBC   - Barclays   - FDC Nash   - FDI Global   - Elavon America   - VPC   - Rede   - Payment tech Salem   #### Possible values: | Card Type   | Advice Code   |  Description                                | | ----------- | ------------- | ------------------------------------------- | | VISA        | 1             | Issuer never approves                       | | VISA        | 2             | Issuer cannot approve at this time          | | VISA        | 3             | Data quality/revalidate payment information | | MasterCard  | 01            | New account information available           | | MasterCard  | 02            | Try Again Later                             | | MasterCard  | 03            | Do Not Try Again                            | | MasterCard  | 04            | Token not supported                         | | MasterCard  | 21            | Do not honor                                | | MasterCard  | 22            | Merchant does not qualify for product code  | | MasterCard  | 24            | Retry after 1 hour                          | | MasterCard  | 25            | Retry after 24 hours                        | | MasterCard  | 26            | Retry after 2 days                          | | MasterCard  | 27            | Retry after 4 days                          | | MasterCard  | 28            | Retry after 6 days                          | | MasterCard  | 29            | Retry after 8 days                          | | MasterCard  | 30            | Retry after 10 days                         | | MasterCard  | 40            | Consumer non-reloadable prepaid card        | | MasterCard  | 41            | Consumer single-use virtual card number     | | MasterCard  | 42            | Sanctions score exceeds threshold value     | | MasterCard  | 99            | Do Not Try Again                            | 
    */
    'code'?: string;
    /**
    * Raw merchant advice code sent directly from the processor. This field is used only for Mastercard.  #### CyberSource through VisaNet The value for this field corresponds to the following data in the TC 33 capture file1: - Record: CP01 TCR7 - Position: 96-99 - Field: Response Data-Merchant Advice Code 
    */
    'codeRaw'?: string;
    /**
    * #### Visa Platform Connect The field contains will contain the Account Name Request Result for zero amount Authorization request. Valid values are:  00 = Name Match Performed 01 = Name Match not Performed 02 = Name Match not supported 
    */
    'nameMatch'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        },
        {
            "name": "codeRaw",
            "baseName": "codeRaw",
            "type": "string"
        },
        {
            "name": "nameMatch",
            "baseName": "nameMatch",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsPost201ResponseProcessorInformationMerchantAdvice.attributeTypeMap;
    }
}

export class PtsV2PaymentsPost201ResponseProcessorInformationRouting {
    /**
    * PIN Debit Services: Contains the ID of the debit network to which the transaction was routed.  | Code | Network | | --- | --- | | 0000 | Priority Routing or Generic File Update | | 0002 | Visa programs, Private Label and non-Visa Authorization Gateway Services | | 0003 | Interlink | | 0004 | Plus | | 0008 | Star | | 0009 | Pulse| | 0010 | Star | | 0011 | Star | | 0012 | Star (primary network ID) | | 0013 | AFFN | | 0015 | Star | | 0016 | Maestro | | 0017 | Pulse (primary network ID) | | 0018 | NYCE (primary network ID) | | 0019 | Pulse | | 0020 | Accel | | 0023 | NETS | | 0024 | CU24 | | 0025 | Alaska Option | | 0027 | NYCE | | 0028 | Shazam | | 0029 | EBT POS |  FDC Nashville Global authorization service:  Indicates whether the transaction was routed to a credit network, a debit network, or the STAR signature debit network. - `C`: Credit network - `D`: Debit network (without signature) - `S`: STAR signature debit network 
    */
    'network'?: string;
    /**
    * Name of the network to which the transaction was routed. 
    */
    'networkName'?: string;
    /**
    * Indicates whether you need to obtain the cardholder's signature.  Possible values: - `Y`: You need to obtain the cardholder's signature. - `N`: You do not need to obtain the cardholder's signature. 
    */
    'customerSignatureRequired'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "network",
            "baseName": "network",
            "type": "string"
        },
        {
            "name": "networkName",
            "baseName": "networkName",
            "type": "string"
        },
        {
            "name": "customerSignatureRequired",
            "baseName": "customerSignatureRequired",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsPost201ResponseProcessorInformationRouting.attributeTypeMap;
    }
}

export class PtsV2PaymentsPost201ResponseProcessorInformationSellerProtection {
    /**
    * The kind of seller protection in force for the transaction. This field is returned only when the protection eligibility value is set to ELIGIBLE or PARTIALLY_ELIGIBLE. Possible values - ITEM_NOT_RECEIVED_ELIGIBLE: Sellers are protected against claims for items not received. - UNAUTHORIZED_PAYMENT_ELIGIBLE: Sellers are protected against claims for unauthorized payments. One or both values can be returned. 
    */
    'type'?: string;
    /**
    * Indicates whether the transaction is eligible for seller protection. The values returned are described below. Possible values: - `ELIGIBLE` - `PARTIALLY_ELIGIBLE` - `INELIGIBLE` - `NOT_ELIGIBLE` 
    */
    'eligibility'?: string;
    /**
    * An array of conditions that are covered for the transaction. 
    */
    'disputeCategories'?: Array<string>;
    /**
    * The kind of seller protection in force for the transaction. This field is returned only when the protection_eligibility property is set to ELIGIBLE or PARTIALLY_ELIGIBLE. Possible values: - `ITEM_NOT_RECEIVED_ELIGIBLE: Sellers are protected against claims for items not received.` - `UNAUTHORIZED_PAYMENT_ELIGIBLE: Sellers are protected against claims for unauthorized payments.` One or both values can be returned. 
    */
    'eligibilityType'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "eligibility",
            "baseName": "eligibility",
            "type": "string"
        },
        {
            "name": "disputeCategories",
            "baseName": "disputeCategories",
            "type": "Array<string>"
        },
        {
            "name": "eligibilityType",
            "baseName": "eligibilityType",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsPost201ResponseProcessorInformationSellerProtection.attributeTypeMap;
    }
}

/**
* Contains the result of risk assessment.
*/
export class PtsV2PaymentsPost201ResponseRiskInformation {
    'profile'?: PtsV2PaymentsPost201ResponseRiskInformationProfile;
    'rules'?: Array<PtsV2PaymentsPost201ResponseRiskInformationRules>;
    'infoCodes'?: PtsV2PaymentsPost201ResponseRiskInformationInfoCodes;
    'velocity'?: PtsV2PaymentsPost201ResponseRiskInformationVelocity;
    /**
    * You receive this field only if you subscribe to the Enhanced Case Management service. The priority level ranges from 1 (highest) to 5 (lowest); the default value is 3. If you do not assign a priority to your rules or to your profiles, the default value is given to the order.  For all possible values, see the `decision_case_priority` field description in the _Decision Manager Using the SCMP API Developer Guide_ on the [CyberSource Business Center.](https://ebc2.cybersource.com/ebc2/) Click **Decision Manager** > **Documentation** > **Guides** > _Decision Manager Using the SCMP API Developer Guide_ (PDF link). 
    */
    'casePriority'?: number;
    /**
    * The customer's local time (`hh:mm:ss`), which is calculated from the transaction request time and the customer's billing address.  For details, see the `score_time_local` field description in the _Decision Manager Using the SCMP API Developer Guide_ on the [CyberSource Business Center.](https://ebc2.cybersource.com/ebc2/) 
    */
    'localTime'?: string;
    'score'?: PtsV2PaymentsPost201ResponseRiskInformationScore;
    'ipAddress'?: PtsV2PaymentsPost201ResponseRiskInformationIpAddress;
    /**
    * Name of the 3rd party provider, for example, Emailage. For all possible values, see the `decision_provider_#_name` field description in the _Decision Manager Using the SCMP API Developer Guide_ on the [CyberSource Business Center.](https://ebc2.cybersource.com/ebc2/) Click **Decision Manager** > **Documentation** > **Guides** > _Decision Manager Using the SCMP API Developer Guide_ (PDF link).
    */
    'providers'?: { [key: string]: { [key: string]: string; }; };
    'travel'?: PtsV2PaymentsPost201ResponseRiskInformationTravel;
    'processorResults'?: PtsV2PaymentsPost201ResponseRiskInformationProcessorResults;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "profile",
            "baseName": "profile",
            "type": "PtsV2PaymentsPost201ResponseRiskInformationProfile"
        },
        {
            "name": "rules",
            "baseName": "rules",
            "type": "Array<PtsV2PaymentsPost201ResponseRiskInformationRules>"
        },
        {
            "name": "infoCodes",
            "baseName": "infoCodes",
            "type": "PtsV2PaymentsPost201ResponseRiskInformationInfoCodes"
        },
        {
            "name": "velocity",
            "baseName": "velocity",
            "type": "PtsV2PaymentsPost201ResponseRiskInformationVelocity"
        },
        {
            "name": "casePriority",
            "baseName": "casePriority",
            "type": "number"
        },
        {
            "name": "localTime",
            "baseName": "localTime",
            "type": "string"
        },
        {
            "name": "score",
            "baseName": "score",
            "type": "PtsV2PaymentsPost201ResponseRiskInformationScore"
        },
        {
            "name": "ipAddress",
            "baseName": "ipAddress",
            "type": "PtsV2PaymentsPost201ResponseRiskInformationIpAddress"
        },
        {
            "name": "providers",
            "baseName": "providers",
            "type": "{ [key: string]: { [key: string]: string; }; }"
        },
        {
            "name": "travel",
            "baseName": "travel",
            "type": "PtsV2PaymentsPost201ResponseRiskInformationTravel"
        },
        {
            "name": "processorResults",
            "baseName": "processorResults",
            "type": "PtsV2PaymentsPost201ResponseRiskInformationProcessorResults"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsPost201ResponseRiskInformation.attributeTypeMap;
    }
}

export class PtsV2PaymentsPost201ResponseRiskInformationInfoCodes {
    /**
    * List of information codes triggered by the order. These information codes were generated when you created the order and product velocity rules and are returned so that you can associate them with the rules. 
    */
    'velocity'?: Array<string>;
    /**
    * Indicates a mismatch between the customer’s billing and shipping addresses. 
    */
    'address'?: Array<string>;
    /**
    * Indicates that customer information is associated with transactions that are either on the negative or the positive list. 
    */
    'customerList'?: Array<string>;
    /**
    * Indicates the device behavior information code(s) returned from device fingerprinting. 
    */
    'deviceBehavior'?: Array<string>;
    /**
    * Indicates excessive identity changes. The threshold is variable depending on the identity elements being compared. 
    */
    'identityChange'?: Array<string>;
    /**
    * Indicates a problem with the customer’s email address, IP address, or billing address. 
    */
    'internet'?: Array<string>;
    /**
    * Indicates a problem with the customer’s phone number. 
    */
    'phone'?: Array<string>;
    /**
    * Indicates that the customer provided potentially suspicious information. 
    */
    'suspicious'?: Array<string>;
    /**
    * Indicates that the customer has a high purchase frequency. 
    */
    'globalVelocity'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "velocity",
            "baseName": "velocity",
            "type": "Array<string>"
        },
        {
            "name": "address",
            "baseName": "address",
            "type": "Array<string>"
        },
        {
            "name": "customerList",
            "baseName": "customerList",
            "type": "Array<string>"
        },
        {
            "name": "deviceBehavior",
            "baseName": "deviceBehavior",
            "type": "Array<string>"
        },
        {
            "name": "identityChange",
            "baseName": "identityChange",
            "type": "Array<string>"
        },
        {
            "name": "internet",
            "baseName": "internet",
            "type": "Array<string>"
        },
        {
            "name": "phone",
            "baseName": "phone",
            "type": "Array<string>"
        },
        {
            "name": "suspicious",
            "baseName": "suspicious",
            "type": "Array<string>"
        },
        {
            "name": "globalVelocity",
            "baseName": "globalVelocity",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsPost201ResponseRiskInformationInfoCodes.attributeTypeMap;
    }
}

/**
* Contains detailed response information about the customer's IP address.
*/
export class PtsV2PaymentsPost201ResponseRiskInformationIpAddress {
    /**
    * Indicates whether the transaction IP address is associated with a known anonymous proxy.  For all possible values, see the `score_ip_anonymizer_status` field description in the _Decision Manager Using the SCMP API Developer Guide_ on the [CyberSource Business Center.](https://ebc2.cybersource.com/ebc2/) Click **Decision Manager** > **Documentation** > **Guides** > _Decision Manager Using the SCMP API Developer Guide_ (PDF link). 
    */
    'anonymizerStatus'?: string;
    /**
    * Name of the city decoded from the IP address used directly or indirectly by the customer to send the order.  For all possible values, see the `score_ip_city` field description in the _Decision Manager Using the SCMP API Developer Guide_ on the [CyberSource Business Center.](https://ebc2.cybersource.com/ebc2/) Click **Decision Manager** > **Documentation** > **Guides** > _Decision Manager Using the SCMP API Developer Guide_ (PDF link). 
    */
    'locality'?: string;
    /**
    * Name of the country decoded from the IP address used directly or indirectly by the customer to send the order.  For all possible values, see the `score_ip_country` field description in the _Decision Manager Using the SCMP API Developer Guide_ on the [CyberSource Business Center.](https://ebc2.cybersource.com/ebc2/) Click **Decision Manager** > **Documentation** > **Guides** > _Decision Manager Using the SCMP API Developer Guide_ (PDF link). 
    */
    'country'?: string;
    /**
    * Name of the state decoded from the IP address used directly or indirectly by the customer to send the order.  For all possible values, see the `score_ip_state` field description in the _Decision Manager Using the SCMP API Developer Guide_ on the [CyberSource Business Center.](https://ebc2.cybersource.com/ebc2/) Click **Decision Manager** > **Documentation** > **Guides** > _Decision Manager Using the SCMP API Developer Guide_ (PDF link). 
    */
    'administrativeArea'?: string;
    /**
    * Routing method decoded from the IP address used directly or indirectly by the customer to send the order.  For all possible values, see the `score_ip_routing_method` field description in the _Decision Manager Using the SCMP API Developer Guide_ on the [CyberSource Business Center.](https://ebc2.cybersource.com/ebc2/) Click **Decision Manager** > **Documentation** > **Guides** > _Decision Manager Using the SCMP API Developer Guide_ (PDF link). 
    */
    'routingMethod'?: string;
    /**
    * Provides the name of the organization that owns the ASN. The carrier is responsible for the traffic carried on the network or set of networks designated as an Autonomous System (AS) and identified by the ASN. While there are more than 27,000 active ASNs, there are fewer carriers, because a single carrier often manages several ASNs. 
    */
    'carrier'?: string;
    /**
    * The Registering Organization is the entity responsible for the actions and content associated with a given block of IP addresses. This is in contrast to the carrier, which is responsible for the routing of traffic for network blocks. Registering Organizations include many types of entities, including corporate, government, or educational entities, and ISPs managing the allocation and use of network blocks. 
    */
    'organization'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "anonymizerStatus",
            "baseName": "anonymizerStatus",
            "type": "string"
        },
        {
            "name": "locality",
            "baseName": "locality",
            "type": "string"
        },
        {
            "name": "country",
            "baseName": "country",
            "type": "string"
        },
        {
            "name": "administrativeArea",
            "baseName": "administrativeArea",
            "type": "string"
        },
        {
            "name": "routingMethod",
            "baseName": "routingMethod",
            "type": "string"
        },
        {
            "name": "carrier",
            "baseName": "carrier",
            "type": "string"
        },
        {
            "name": "organization",
            "baseName": "organization",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsPost201ResponseRiskInformationIpAddress.attributeTypeMap;
    }
}

export class PtsV2PaymentsPost201ResponseRiskInformationProcessorResults {
    /**
    * Type of filter. Possible values: - ACCEPT - PENDING - DENY - REPORT 
    */
    'fraudDecision'?: string;
    /**
    * possible values - AVS_NO_MATCH - AVS_PARTIAL_MATCH - AVS_UNAVAILABLE_OR_UNSUPPORTED - CARD_SECURITY_CODE_MISMATCH - MAXIMUM_TRANSACTION_AMOUNT - UNCONFIRMED_ADDRESS - COUNTRY_MONITOR - LARGE_ORDER_NUMBER - BILLING_OR_SHIPPING_ADDRESS_MISMATCH - RISKY_ZIP_CODE - SUSPECTED_FREIGHT_FORWARDER_CHECK - TOTAL_PURCHASE_PRICE_MINIMUM - IP_ADDRESS_VELOCITY - RISKY_EMAIL_ADDRESS_DOMAIN_CHECK - RISKY_BANK_IDENTIFICATION_NUMBER_CHECK, RISKY_IP_ADDRESS_RANGE - PAYPAL_FRAUD_MODEL 
    */
    'fraudDecisionReason'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "fraudDecision",
            "baseName": "fraudDecision",
            "type": "string"
        },
        {
            "name": "fraudDecisionReason",
            "baseName": "fraudDecisionReason",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsPost201ResponseRiskInformationProcessorResults.attributeTypeMap;
    }
}

export class PtsV2PaymentsPost201ResponseRiskInformationProfile {
    /**
    * Name of the active profile chosen by the profile selector. If no profile selector exists, the default active profile is chosen.  **Note** By default, your default profile is the active profile, or the Profile Selector chooses the active profile. Use this field only if you want to specify the name of a different profile. The passed-in profile will then become the active profile. 
    */
    'name'?: string;
    /**
    * Name of the queue where orders that are not automatically accepted are sent. 
    */
    'desinationQueue'?: string;
    /**
    * Name of the profile selector rule that chooses the profile to use for the transaction. If no profile selector exists, the value is Default Active Profile. 
    */
    'selectorRule'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "desinationQueue",
            "baseName": "desinationQueue",
            "type": "string"
        },
        {
            "name": "selectorRule",
            "baseName": "selectorRule",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsPost201ResponseRiskInformationProfile.attributeTypeMap;
    }
}

export class PtsV2PaymentsPost201ResponseRiskInformationRules {
    /**
    * Description of the rule as it appears in the Profile Editor.
    */
    'name'?: string;
    /**
    * Summarizes the result for the rule according to the setting that you chose in the Profile Editor. This field can contain one of the following values: - `IGNORE` - `REVIEW` - `REJECT` - `ACCEPT` 
    */
    'decision'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "decision",
            "baseName": "decision",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsPost201ResponseRiskInformationRules.attributeTypeMap;
    }
}

export class PtsV2PaymentsPost201ResponseRiskInformationScore {
    'factorCodes'?: Array<string>;
    /**
    * Name of the score model used for the transaction. If you did not include a custom model in your request, this field contains the name of CyberSource’s default model.  For all possible values, see the `score_model_used` field description in the _Decision Manager Using the SCMP API Developer Guide_ on the [CyberSource Business Center.](https://ebc2.cybersource.com/ebc2/) Click **Decision Manager** > **Documentation** > **Guides** > _Decision Manager Using the SCMP API Developer Guide_ (PDF link). 
    */
    'modelUsed'?: string;
    /**
    * Total score calculated for this order. The value cannot be negative.  For all possible values, see the `score_score_result` field description in the _Decision Manager Using the SCMP API Developer Guide_ on the [CyberSource Business Center.](https://ebc2.cybersource.com/ebc2/) Click **Decision Manager** > **Documentation** > **Guides** > _Decision Manager Using the SCMP API Developer Guide_ (PDF link). 
    */
    'result'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "factorCodes",
            "baseName": "factorCodes",
            "type": "Array<string>"
        },
        {
            "name": "modelUsed",
            "baseName": "modelUsed",
            "type": "string"
        },
        {
            "name": "result",
            "baseName": "result",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsPost201ResponseRiskInformationScore.attributeTypeMap;
    }
}

export class PtsV2PaymentsPost201ResponseRiskInformationTravel {
    'actualFinalDestination'?: PtsV2PaymentsPost201ResponseRiskInformationTravelActualFinalDestination;
    'firstDeparture'?: PtsV2PaymentsPost201ResponseRiskInformationTravelFirstDeparture;
    'firstDestination'?: PtsV2PaymentsPost201ResponseRiskInformationTravelFirstDestination;
    'lastDestination'?: PtsV2PaymentsPost201ResponseRiskInformationTravelLastDestination;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "actualFinalDestination",
            "baseName": "actualFinalDestination",
            "type": "PtsV2PaymentsPost201ResponseRiskInformationTravelActualFinalDestination"
        },
        {
            "name": "firstDeparture",
            "baseName": "firstDeparture",
            "type": "PtsV2PaymentsPost201ResponseRiskInformationTravelFirstDeparture"
        },
        {
            "name": "firstDestination",
            "baseName": "firstDestination",
            "type": "PtsV2PaymentsPost201ResponseRiskInformationTravelFirstDestination"
        },
        {
            "name": "lastDestination",
            "baseName": "lastDestination",
            "type": "PtsV2PaymentsPost201ResponseRiskInformationTravelLastDestination"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsPost201ResponseRiskInformationTravel.attributeTypeMap;
    }
}

export class PtsV2PaymentsPost201ResponseRiskInformationTravelActualFinalDestination {
    /**
    * Country of actual final destination on the route.
    */
    'country'?: string;
    /**
    * City of actual final destination on the route.
    */
    'locality'?: string;
    /**
    * Latitude of actual final destination on the route.
    */
    'latitude'?: string;
    /**
    * Longitude of actual final destination on the route.
    */
    'longitude'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "country",
            "baseName": "country",
            "type": "string"
        },
        {
            "name": "locality",
            "baseName": "locality",
            "type": "string"
        },
        {
            "name": "latitude",
            "baseName": "latitude",
            "type": "string"
        },
        {
            "name": "longitude",
            "baseName": "longitude",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsPost201ResponseRiskInformationTravelActualFinalDestination.attributeTypeMap;
    }
}

export class PtsV2PaymentsPost201ResponseRiskInformationTravelFirstDeparture {
    /**
    * Country of first departure on the route.
    */
    'country'?: string;
    /**
    * City of first departure on the route.
    */
    'locality'?: string;
    /**
    * Latitude of first departure on the route.
    */
    'latitude'?: string;
    /**
    * Longitude of first departure on the route.
    */
    'longitude'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "country",
            "baseName": "country",
            "type": "string"
        },
        {
            "name": "locality",
            "baseName": "locality",
            "type": "string"
        },
        {
            "name": "latitude",
            "baseName": "latitude",
            "type": "string"
        },
        {
            "name": "longitude",
            "baseName": "longitude",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsPost201ResponseRiskInformationTravelFirstDeparture.attributeTypeMap;
    }
}

export class PtsV2PaymentsPost201ResponseRiskInformationTravelFirstDestination {
    /**
    * Country of first destination on the route.
    */
    'country'?: string;
    /**
    * City of first destination on the route.
    */
    'locality'?: string;
    /**
    * Latitude of first destination on the route.
    */
    'latitude'?: string;
    /**
    * Longitude of first destination on the route.
    */
    'longitude'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "country",
            "baseName": "country",
            "type": "string"
        },
        {
            "name": "locality",
            "baseName": "locality",
            "type": "string"
        },
        {
            "name": "latitude",
            "baseName": "latitude",
            "type": "string"
        },
        {
            "name": "longitude",
            "baseName": "longitude",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsPost201ResponseRiskInformationTravelFirstDestination.attributeTypeMap;
    }
}

export class PtsV2PaymentsPost201ResponseRiskInformationTravelLastDestination {
    /**
    * Country of last destination on the route.
    */
    'country'?: string;
    /**
    * City of last destination on the route.
    */
    'locality'?: string;
    /**
    * Latitude of last destination on the route.
    */
    'latitude'?: string;
    /**
    * Longitude of last destination on the route.
    */
    'longitude'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "country",
            "baseName": "country",
            "type": "string"
        },
        {
            "name": "locality",
            "baseName": "locality",
            "type": "string"
        },
        {
            "name": "latitude",
            "baseName": "latitude",
            "type": "string"
        },
        {
            "name": "longitude",
            "baseName": "longitude",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsPost201ResponseRiskInformationTravelLastDestination.attributeTypeMap;
    }
}

export class PtsV2PaymentsPost201ResponseRiskInformationVelocity {
    /**
    * List of information codes triggered by the order. These information codes were generated when you created the order and product velocity rules and are returned so that you can associate them with the rules.  Returned by scoring service. 
    */
    'morphing'?: Array<PtsV2PaymentsPost201ResponseRiskInformationVelocityMorphing>;
    'address'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "morphing",
            "baseName": "morphing",
            "type": "Array<PtsV2PaymentsPost201ResponseRiskInformationVelocityMorphing>"
        },
        {
            "name": "address",
            "baseName": "address",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsPost201ResponseRiskInformationVelocity.attributeTypeMap;
    }
}

export class PtsV2PaymentsPost201ResponseRiskInformationVelocityMorphing {
    /**
    * Morphing count specified by the number #.  **Note** The count is not returned for the initial transaction. 
    */
    'count'?: number;
    /**
    * Field name of the morphing element. specified by the setting that you chose in the Velocity Editor.  For all possible values, see the `decisionReply_morphingElement_#_fieldName` field description in the _Decision Manager Using the SCMP API Developer Guide_ on the [CyberSource Business Center.](https://ebc2.cybersource.com/ebc2/) Click **Decision Manager** > **Documentation** > **Guides** > _Decision Manager Using the SCMP API Developer Guide_ (PDF link). 
    */
    'fieldName'?: string;
    /**
    * Identifier that CyberSource assigned to the velocity rule specified by the number #.  For all possible values, see the `decision_velocity_morphing_#_info_code` field description in the _Decision Manager Using the SCMP API Developer Guide_ on the [CyberSource Business Center.](https://ebc2.cybersource.com/ebc2/) Click **Decision Manager** >  
    */
    'informationCode'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "count",
            "baseName": "count",
            "type": "number"
        },
        {
            "name": "fieldName",
            "baseName": "fieldName",
            "type": "string"
        },
        {
            "name": "informationCode",
            "baseName": "informationCode",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsPost201ResponseRiskInformationVelocityMorphing.attributeTypeMap;
    }
}

export class PtsV2PaymentsPost201ResponseTokenInformation {
    /**
    * A value of true means the card number or bank account used to create an Instrument Identifier was new and did not already exist in the token vault. A value of false means the card number or bank account used to create an Instrument Identifier already existed in the token vault. 
    */
    'instrumentidentifierNew'?: boolean;
    'customer'?: PtsV2PaymentsPost201ResponseTokenInformationCustomer;
    'paymentInstrument'?: PtsV2PaymentsPost201ResponseTokenInformationPaymentInstrument;
    'shippingAddress'?: PtsV2PaymentsPost201ResponseTokenInformationShippingAddress;
    'instrumentIdentifier'?: PtsV2PaymentsPost201ResponseTokenInformationInstrumentIdentifier;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "instrumentidentifierNew",
            "baseName": "instrumentidentifierNew",
            "type": "boolean"
        },
        {
            "name": "customer",
            "baseName": "customer",
            "type": "PtsV2PaymentsPost201ResponseTokenInformationCustomer"
        },
        {
            "name": "paymentInstrument",
            "baseName": "paymentInstrument",
            "type": "PtsV2PaymentsPost201ResponseTokenInformationPaymentInstrument"
        },
        {
            "name": "shippingAddress",
            "baseName": "shippingAddress",
            "type": "PtsV2PaymentsPost201ResponseTokenInformationShippingAddress"
        },
        {
            "name": "instrumentIdentifier",
            "baseName": "instrumentIdentifier",
            "type": "PtsV2PaymentsPost201ResponseTokenInformationInstrumentIdentifier"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsPost201ResponseTokenInformation.attributeTypeMap;
    }
}

export class PtsV2PaymentsPost201ResponseTokenInformationCustomer {
    /**
    * Unique identifier for the Customer token that was created as part of a bundled TOKEN_CREATE action. 
    */
    'id'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsPost201ResponseTokenInformationCustomer.attributeTypeMap;
    }
}

export class PtsV2PaymentsPost201ResponseTokenInformationInstrumentIdentifier {
    /**
    * Unique identifier for the Instrument Identifier token that was created as part of a bundled TOKEN_CREATE action. 
    */
    'id'?: string;
    /**
    * Issuers state for the card number. Valid values: - ACTIVE - CLOSED : The account has been closed. 
    */
    'state'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsPost201ResponseTokenInformationInstrumentIdentifier.attributeTypeMap;
    }
}

export class PtsV2PaymentsPost201ResponseTokenInformationPaymentInstrument {
    /**
    * Unique identifier for the Payment Instrument token that was created as part of a bundled TOKEN_CREATE action. 
    */
    'id'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsPost201ResponseTokenInformationPaymentInstrument.attributeTypeMap;
    }
}

export class PtsV2PaymentsPost201ResponseTokenInformationShippingAddress {
    /**
    * Unique identifier for the Customers Shipping Address token that was created as part of a bundled TOKEN_CREATE action. 
    */
    'id'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsPost201ResponseTokenInformationShippingAddress.attributeTypeMap;
    }
}

export class PtsV2PaymentsPost201ResponseWatchlistScreeningInformation {
    /**
    * Likelihood that the country associated with the customer’s IP address was identified correctly. Returns a value from 1–100, where 100 indicates the highest likelihood. If the country cannot be determined, the value is –1. 
    */
    'ipCountryConfidence'?: number;
    /**
    * Returned when the Denied Parties List check (first two codes) or the export service (all others) would have declined the transaction. This field can contain one or more of these values: - `MATCH-DPC`: Denied Parties List match. - `UNV-DPC`: Denied Parties List unavailable. - `MATCH-BCO`: Billing country restricted. - `MATCH-EMCO`: Email country restricted. - `MATCH-HCO`: Host name country restricted. - `MATCH-IPCO`: IP country restricted. - `MATCH-SCO`: Shipping country restricted. 
    */
    'infoCodes'?: Array<string>;
    'watchList'?: PtsV2PaymentsPost201ResponseWatchlistScreeningInformationWatchList;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "ipCountryConfidence",
            "baseName": "ipCountryConfidence",
            "type": "number"
        },
        {
            "name": "infoCodes",
            "baseName": "infoCodes",
            "type": "Array<string>"
        },
        {
            "name": "watchList",
            "baseName": "watchList",
            "type": "PtsV2PaymentsPost201ResponseWatchlistScreeningInformationWatchList"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsPost201ResponseWatchlistScreeningInformation.attributeTypeMap;
    }
}

export class PtsV2PaymentsPost201ResponseWatchlistScreeningInformationWatchList {
    'matches'?: Array<PtsV2PaymentsPost201ResponseWatchlistScreeningInformationWatchListMatches>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "matches",
            "baseName": "matches",
            "type": "Array<PtsV2PaymentsPost201ResponseWatchlistScreeningInformationWatchListMatches>"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsPost201ResponseWatchlistScreeningInformationWatchList.attributeTypeMap;
    }
}

export class PtsV2PaymentsPost201ResponseWatchlistScreeningInformationWatchListMatches {
    /**
    * Address found on the list specified in export_matchN_list for the entity (name and address) in the request. 
    */
    'addresses'?: Array<string>;
    /**
    * List on which the first Denied Parties List check match appears. For a list of codes, see \"Denied Parties List Check Codes,\" page 56. 
    */
    'sanctionList'?: string;
    /**
    * Name found on the list specified in export_matchN_list for the entity (name and address) in the request. 
    */
    'aliases'?: Array<string>;
    /**
    * Sub-lists matched by the order data. List members are separated by carets (^).
    */
    'programs'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "addresses",
            "baseName": "addresses",
            "type": "Array<string>"
        },
        {
            "name": "sanctionList",
            "baseName": "sanctionList",
            "type": "string"
        },
        {
            "name": "aliases",
            "baseName": "aliases",
            "type": "Array<string>"
        },
        {
            "name": "programs",
            "baseName": "programs",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsPost201ResponseWatchlistScreeningInformationWatchListMatches.attributeTypeMap;
    }
}

export class PtsV2PaymentsPost400Response {
    /**
    * Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ` **Example** `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.). The `T` separates the date and the time. The `Z` indicates UTC.  Returned by Cybersource for all services. 
    */
    'submitTimeUtc'?: string;
    /**
    * The status of the submitted transaction.  Possible values:  - INVALID_REQUEST 
    */
    'status'?: string;
    /**
    * The reason of the status.  Possible values:  - MISSING_FIELD  - INVALID_DATA  - DUPLICATE_REQUEST  - INVALID_CARD  - CARD_TYPE_NOT_ACCEPTED  - INVALID_MERCHANT_CONFIGURATION  - PROCESSOR_UNAVAILABLE  - INVALID_AMOUNT  - INVALID_CARD_TYPE  - INVALID_PAYMENT_ID  - NOT_SUPPORTED 
    */
    'reason'?: string;
    /**
    * The detail message related to the status and reason listed above.
    */
    'message'?: string;
    'details'?: Array<PtsV2PaymentsPost201ResponseErrorInformationDetails>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "submitTimeUtc",
            "baseName": "submitTimeUtc",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "reason",
            "baseName": "reason",
            "type": "string"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        },
        {
            "name": "details",
            "baseName": "details",
            "type": "Array<PtsV2PaymentsPost201ResponseErrorInformationDetails>"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsPost400Response.attributeTypeMap;
    }
}

export class PtsV2PaymentsPost502Response {
    /**
    * Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ` **Example** `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.). The `T` separates the date and the time. The `Z` indicates UTC.  Returned by Cybersource for all services. 
    */
    'submitTimeUtc'?: string;
    /**
    * The status of the submitted transaction.  Possible values:  - SERVER_ERROR 
    */
    'status'?: string;
    /**
    * The reason of the status.  Possible values:  - SYSTEM_ERROR  - SERVER_TIMEOUT  - SERVICE_TIMEOUT 
    */
    'reason'?: string;
    /**
    * The detail message related to the status and reason listed above.
    */
    'message'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "submitTimeUtc",
            "baseName": "submitTimeUtc",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "reason",
            "baseName": "reason",
            "type": "string"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsPost502Response.attributeTypeMap;
    }
}

export class PtsV2PaymentsRefundPost201Response {
    'links'?: PtsV2PaymentsRefundPost201ResponseLinks;
    /**
    * An unique identification number generated by Cybersource to identify the submitted request. Returned by all services. It is also appended to the endpoint of the resource. On incremental authorizations, this value with be the same as the identification number returned in the original authorization response. 
    */
    'id'?: string;
    /**
    * Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ` **Example** `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.). The `T` separates the date and the time. The `Z` indicates UTC.  Returned by Cybersource for all services. 
    */
    'submitTimeUtc'?: string;
    /**
    * The status of the submitted transaction.  Possible values:  - PENDING 
    */
    'status'?: string;
    /**
    * Reference number for the transaction. Depending on how your Cybersource account is configured, this value could either be provided in the API request or generated by CyberSource. The actual value used in the request to the processor is provided back to you by Cybersource in the response. 
    */
    'reconciliationId'?: string;
    'clientReferenceInformation'?: PtsV2PaymentsRefundPost201ResponseClientReferenceInformation;
    'refundAmountDetails'?: PtsV2PaymentsRefundPost201ResponseRefundAmountDetails;
    'processingInformation'?: PtsV2PaymentsCapturesPost201ResponseProcessingInformation;
    'processorInformation'?: PtsV2PaymentsRefundPost201ResponseProcessorInformation;
    'orderInformation'?: PtsV2PaymentsRefundPost201ResponseOrderInformation;
    'pointOfSaleInformation'?: PtsV2PaymentsCapturesPost201ResponsePointOfSaleInformation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "PtsV2PaymentsRefundPost201ResponseLinks"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "submitTimeUtc",
            "baseName": "submitTimeUtc",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "reconciliationId",
            "baseName": "reconciliationId",
            "type": "string"
        },
        {
            "name": "clientReferenceInformation",
            "baseName": "clientReferenceInformation",
            "type": "PtsV2PaymentsRefundPost201ResponseClientReferenceInformation"
        },
        {
            "name": "refundAmountDetails",
            "baseName": "refundAmountDetails",
            "type": "PtsV2PaymentsRefundPost201ResponseRefundAmountDetails"
        },
        {
            "name": "processingInformation",
            "baseName": "processingInformation",
            "type": "PtsV2PaymentsCapturesPost201ResponseProcessingInformation"
        },
        {
            "name": "processorInformation",
            "baseName": "processorInformation",
            "type": "PtsV2PaymentsRefundPost201ResponseProcessorInformation"
        },
        {
            "name": "orderInformation",
            "baseName": "orderInformation",
            "type": "PtsV2PaymentsRefundPost201ResponseOrderInformation"
        },
        {
            "name": "pointOfSaleInformation",
            "baseName": "pointOfSaleInformation",
            "type": "PtsV2PaymentsCapturesPost201ResponsePointOfSaleInformation"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsRefundPost201Response.attributeTypeMap;
    }
}

export class PtsV2PaymentsRefundPost201ResponseClientReferenceInformation {
    /**
    * Merchant-generated order reference or tracking number. It is recommended that you send a unique value for each transaction so that you can perform meaningful searches for the transaction.  #### Used by **Authorization** Required field.  #### PIN Debit Requests for PIN debit reversals need to use the same merchant reference number that was used in the transaction that is being reversed.  Required field for all PIN Debit requests (purchase, credit, and reversal).  #### FDC Nashville Global Certain circumstances can cause the processor to truncate this value to 15 or 17 characters for Level II and Level III processing, which can cause a discrepancy between the value you submit and the value included in some processor reports. 
    */
    'code'?: string;
    /**
    * Date and time at your physical location.  Format: `YYYYMMDDhhmmss`, where YYYY = year, MM = month, DD = day, hh = hour, mm = minutes ss = seconds  #### PIN Debit Optional field for PIN Debit purchase and credit requests. 
    */
    'submitLocalDateTime'?: string;
    /**
    * Merchant ID that was used to create the subscription or customer profile for which the service was requested.  If your CyberSource account is enabled for Recurring Billing, this field is returned only if you are using subscription sharing and if your merchant ID is in the same merchant ID pool as the owner merchant ID.  If your CyberSource account is enabled for Payment Tokenization, this field is returned only if you are using profile sharing and if your merchant ID is in the same merchant ID pool as the owner merchant ID. 
    */
    'ownerMerchantId'?: string;
    /**
    * A new ID which is created for refund
    */
    'returnReconciliationId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        },
        {
            "name": "submitLocalDateTime",
            "baseName": "submitLocalDateTime",
            "type": "string"
        },
        {
            "name": "ownerMerchantId",
            "baseName": "ownerMerchantId",
            "type": "string"
        },
        {
            "name": "returnReconciliationId",
            "baseName": "returnReconciliationId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsRefundPost201ResponseClientReferenceInformation.attributeTypeMap;
    }
}

export class PtsV2PaymentsRefundPost201ResponseLinks {
    'self'?: PtsV2PaymentsPost201ResponseLinksSelf;
    '_void'?: PtsV2PaymentsPost201ResponseLinksSelf;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "self",
            "baseName": "self",
            "type": "PtsV2PaymentsPost201ResponseLinksSelf"
        },
        {
            "name": "_void",
            "baseName": "void",
            "type": "PtsV2PaymentsPost201ResponseLinksSelf"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsRefundPost201ResponseLinks.attributeTypeMap;
    }
}

export class PtsV2PaymentsRefundPost201ResponseOrderInformation {
    'amountDetails'?: PtsV2PaymentsRefundPost201ResponseOrderInformationAmountDetails;
    'invoiceDetails'?: PtsV2PaymentsCapturesPost201ResponseOrderInformationInvoiceDetails;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "amountDetails",
            "baseName": "amountDetails",
            "type": "PtsV2PaymentsRefundPost201ResponseOrderInformationAmountDetails"
        },
        {
            "name": "invoiceDetails",
            "baseName": "invoiceDetails",
            "type": "PtsV2PaymentsCapturesPost201ResponseOrderInformationInvoiceDetails"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsRefundPost201ResponseOrderInformation.attributeTypeMap;
    }
}

export class PtsV2PaymentsRefundPost201ResponseOrderInformationAmountDetails {
    /**
    * This is a multicurrency field. It contains the transaction amount (field 4), converted to the Currency used to bill the cardholder’s account. This field is returned for OCT transactions. 
    */
    'settlementAmount'?: string;
    /**
    * This is a multicurrency-only field. It contains a 3-digit numeric code that identifies the currency used by the issuer to bill the cardholder's account. This field is returned for OCT transactions. 
    */
    'settlementCurrency'?: string;
    /**
    * Exchange rate returned by the DCC service. Includes a decimal point and a maximum of 4 decimal places. 
    */
    'exchangeRate'?: string;
    /**
    * Set this field to the converted amount that was returned by the DCC provider. 
    */
    'foreignAmount'?: string;
    /**
    * Set this field to the converted amount that was returned by the DCC provider. 
    */
    'foreignCurrency'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "settlementAmount",
            "baseName": "settlementAmount",
            "type": "string"
        },
        {
            "name": "settlementCurrency",
            "baseName": "settlementCurrency",
            "type": "string"
        },
        {
            "name": "exchangeRate",
            "baseName": "exchangeRate",
            "type": "string"
        },
        {
            "name": "foreignAmount",
            "baseName": "foreignAmount",
            "type": "string"
        },
        {
            "name": "foreignCurrency",
            "baseName": "foreignCurrency",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsRefundPost201ResponseOrderInformationAmountDetails.attributeTypeMap;
    }
}

export class PtsV2PaymentsRefundPost201ResponseProcessorInformation {
    /**
    * Authorization code. Returned only when the processor returns this value.  The length of this value depends on your processor.  Returned by authorization service.  #### PIN debit Authorization code that is returned by the processor.  Returned by PIN debit credit.  #### Elavon Encrypted Account Number Program The returned value is OFFLINE.  #### TSYS Acquiring Solutions The returned value for a successful zero amount authorization is 000000. 
    */
    'approvalCode'?: string;
    /**
    * Processor transaction ID.  This value identifies the transaction on a host system. This value is supported only for Moneris. It contains this information:   - Terminal used to process the transaction  - Shift during which the transaction took place  - Batch number  - Transaction number within the batch  You must store this value. If you give the customer a receipt, display this value on the receipt.  Example For the value 66012345001069003:   - Terminal ID = 66012345  - Shift number = 001  - Batch number = 069  - Transaction number = 003 
    */
    'transactionId'?: string;
    /**
    * Name of the Japanese acquirer that processed the transaction. Returned only for JCN Gateway. Please contact the CyberSource Japan Support Group for more information. 
    */
    'forwardedAcquirerCode'?: string;
    /**
    * Identifier that was assigned to you by your acquirer. This value must be printed on the receipt.  #### Returned by Authorizations and Credits.  This reply field is only supported by merchants who have installed client software on their POS terminals and use these processors: - American Express Direct - Credit Mutuel-CIC - FDC Nashville Global - OmniPay Direct - SIX 
    */
    'merchantNumber'?: string;
    /**
    * For most processors, this is the error message sent directly from the bank. Returned only when the processor returns this value.  **Important** Do not use this field to evaluate the result of the authorization.  #### PIN debit Response value that is returned by the processor or bank. **Important** Do not use this field to evaluate the results of the transaction request.  Returned by PIN debit credit, PIN debit purchase, and PIN debit reversal.  #### AIBMS If this value is `08`, you can accept the transaction if the customer provides you with identification.  #### Atos This value is the response code sent from Atos and it might also include the response code from the bank. Format: `aa,bb` with the two values separated by a comma and where: - `aa` is the two-digit error message from Atos. - `bb` is the optional two-digit error message from the bank.  #### Comercio Latino This value is the status code and the error or response code received from the processor separated by a colon. Format: [status code]:E[error code] or [status code]:R[response code] Example `2:R06`  #### JCN Gateway Processor-defined detail error code. The associated response category code is in the `processorInformation.responseCategoryCode` field. String (3)  #### paypalgateway Processor generated ID for the itemized detail. 
    */
    'responseCode'?: string;
    'achVerification'?: PtsV2PaymentsPost201ResponseProcessorInformationAchVerification;
    /**
    * Same value as `processorInformation.transactionId`
    */
    'networkTransactionId'?: string;
    /**
    * Field contains a settlement date. The date is in mmdd format, where: mm = month and dd = day. 
    */
    'settlementDate'?: string;
    /**
    * The date and time when the transaction was last updated, in Internet date and time format. 
    */
    'updateTimeUtc'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "approvalCode",
            "baseName": "approvalCode",
            "type": "string"
        },
        {
            "name": "transactionId",
            "baseName": "transactionId",
            "type": "string"
        },
        {
            "name": "forwardedAcquirerCode",
            "baseName": "forwardedAcquirerCode",
            "type": "string"
        },
        {
            "name": "merchantNumber",
            "baseName": "merchantNumber",
            "type": "string"
        },
        {
            "name": "responseCode",
            "baseName": "responseCode",
            "type": "string"
        },
        {
            "name": "achVerification",
            "baseName": "achVerification",
            "type": "PtsV2PaymentsPost201ResponseProcessorInformationAchVerification"
        },
        {
            "name": "networkTransactionId",
            "baseName": "networkTransactionId",
            "type": "string"
        },
        {
            "name": "settlementDate",
            "baseName": "settlementDate",
            "type": "string"
        },
        {
            "name": "updateTimeUtc",
            "baseName": "updateTimeUtc",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsRefundPost201ResponseProcessorInformation.attributeTypeMap;
    }
}

export class PtsV2PaymentsRefundPost201ResponseRefundAmountDetails {
    /**
    * Total amount of the refund.
    */
    'refundAmount'?: string;
    /**
    * Amount that was credited to the cardholder’s account.  Returned by PIN debit credit. 
    */
    'creditAmount'?: string;
    /**
    * Currency used for the order. Use the three-character [ISO Standard Currency Codes.](http://apps.cybersource.com/library/documentation/sbc/quickref/currencies.pdf)  #### Used by **Authorization** Required field.  **Authorization Reversal** For an authorization reversal (`reversalInformation`) or a capture (`processingOptions.capture` is set to `true`), you must use the same currency that you used in your payment authorization request.  #### PIN Debit Currency for the amount you requested for the PIN debit purchase. This value is returned for partial authorizations. The issuing bank can approve a partial amount if the balance on the debit card is less than the requested transaction amount. For the possible values, see the [ISO Standard Currency Codes](https://developer.cybersource.com/library/documentation/sbc/quickref/currencies.pdf). Returned by PIN debit purchase.  For PIN debit reversal requests, you must use the same currency that was used for the PIN debit purchase or PIN debit credit that you are reversing. For the possible values, see the [ISO Standard Currency Codes](https://developer.cybersource.com/library/documentation/sbc/quickref/currencies.pdf).  Required field for PIN Debit purchase and PIN Debit credit requests. Optional field for PIN Debit reversal requests.  #### GPX This field is optional for reversing an authorization or credit.  #### DCC for First Data Your local currency.  #### Tax Calculation Required for international tax and value added tax only. Optional for U.S. and Canadian taxes. Your local currency. 
    */
    'currency'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "refundAmount",
            "baseName": "refundAmount",
            "type": "string"
        },
        {
            "name": "creditAmount",
            "baseName": "creditAmount",
            "type": "string"
        },
        {
            "name": "currency",
            "baseName": "currency",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsRefundPost201ResponseRefundAmountDetails.attributeTypeMap;
    }
}

export class PtsV2PaymentsRefundPost400Response {
    /**
    * Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ` **Example** `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.). The `T` separates the date and the time. The `Z` indicates UTC.  Returned by Cybersource for all services. 
    */
    'submitTimeUtc'?: string;
    /**
    * The status of the submitted transaction.  Possible values:  - INVALID_REQUEST 
    */
    'status'?: string;
    /**
    * The reason of the status.  Possible values:  - MISSING_FIELD  - INVALID_DATA  - DUPLICATE_REQUEST  - INVALID_CARD  - INVALID_MERCHANT_CONFIGURATION  - INVALID_AMOUNT  - CAPTURE_ALREADY_VOIDED  - ACCOUNT_NOT_ALLOWED_CREDIT  - NOT_SUPPORTED 
    */
    'reason'?: string;
    /**
    * The detail message related to the status and reason listed above.
    */
    'message'?: string;
    'details'?: Array<PtsV2PaymentsPost201ResponseErrorInformationDetails>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "submitTimeUtc",
            "baseName": "submitTimeUtc",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "reason",
            "baseName": "reason",
            "type": "string"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        },
        {
            "name": "details",
            "baseName": "details",
            "type": "Array<PtsV2PaymentsPost201ResponseErrorInformationDetails>"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsRefundPost400Response.attributeTypeMap;
    }
}

export class PtsV2PaymentsReversalsPost201Response {
    'links'?: PtsV2IncrementalAuthorizationPatch201ResponseLinks;
    /**
    * An unique identification number generated by Cybersource to identify the submitted request. Returned by all services. It is also appended to the endpoint of the resource. On incremental authorizations, this value with be the same as the identification number returned in the original authorization response. 
    */
    'id'?: string;
    /**
    * Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ` **Example** `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.). The `T` separates the date and the time. The `Z` indicates UTC.  Returned by Cybersource for all services. 
    */
    'submitTimeUtc'?: string;
    /**
    * The status of the submitted transaction.  Possible values:  - REVERSED 
    */
    'status'?: string;
    /**
    * Reference number for the transaction. Depending on how your Cybersource account is configured, this value could either be provided in the API request or generated by CyberSource. The actual value used in the request to the processor is provided back to you by Cybersource in the response. 
    */
    'reconciliationId'?: string;
    'clientReferenceInformation'?: PtsV2PaymentsPost201ResponseClientReferenceInformation;
    'reversalAmountDetails'?: PtsV2PaymentsReversalsPost201ResponseReversalAmountDetails;
    'processorInformation'?: PtsV2PaymentsReversalsPost201ResponseProcessorInformation;
    'issuerInformation'?: PtsV2PaymentsReversalsPost201ResponseIssuerInformation;
    'authorizationInformation'?: PtsV2PaymentsReversalsPost201ResponseAuthorizationInformation;
    'pointOfSaleInformation'?: Ptsv2paymentsidreversalsPointOfSaleInformation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "PtsV2IncrementalAuthorizationPatch201ResponseLinks"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "submitTimeUtc",
            "baseName": "submitTimeUtc",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "reconciliationId",
            "baseName": "reconciliationId",
            "type": "string"
        },
        {
            "name": "clientReferenceInformation",
            "baseName": "clientReferenceInformation",
            "type": "PtsV2PaymentsPost201ResponseClientReferenceInformation"
        },
        {
            "name": "reversalAmountDetails",
            "baseName": "reversalAmountDetails",
            "type": "PtsV2PaymentsReversalsPost201ResponseReversalAmountDetails"
        },
        {
            "name": "processorInformation",
            "baseName": "processorInformation",
            "type": "PtsV2PaymentsReversalsPost201ResponseProcessorInformation"
        },
        {
            "name": "issuerInformation",
            "baseName": "issuerInformation",
            "type": "PtsV2PaymentsReversalsPost201ResponseIssuerInformation"
        },
        {
            "name": "authorizationInformation",
            "baseName": "authorizationInformation",
            "type": "PtsV2PaymentsReversalsPost201ResponseAuthorizationInformation"
        },
        {
            "name": "pointOfSaleInformation",
            "baseName": "pointOfSaleInformation",
            "type": "Ptsv2paymentsidreversalsPointOfSaleInformation"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsReversalsPost201Response.attributeTypeMap;
    }
}

export class PtsV2PaymentsReversalsPost201ResponseAuthorizationInformation {
    /**
    * The authorization code returned by the processor.
    */
    'approvalCode'?: string;
    /**
    * Reply flag for the original transaction.
    */
    'reasonCode'?: string;
    /**
    * Flag indicating whether a full authorization reversal was successfully submitted.  Possible values: - Y: The authorization reversal was successfully submitted. - N: The authorization reversal was not successfully submitted. You must send a credit request for a refund.  This field is supported only for **FDC Nashville Global**. 
    */
    'reversalSubmitted'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "approvalCode",
            "baseName": "approvalCode",
            "type": "string"
        },
        {
            "name": "reasonCode",
            "baseName": "reasonCode",
            "type": "string"
        },
        {
            "name": "reversalSubmitted",
            "baseName": "reversalSubmitted",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsReversalsPost201ResponseAuthorizationInformation.attributeTypeMap;
    }
}

export class PtsV2PaymentsReversalsPost201ResponseIssuerInformation {
    /**
    * This is the raw Association/Issuer Response Codes. You can use ‘issuer/association’ response codes to identify when you can retry to authorize a declined transaction and increase successful transaction volumes. You’ll receive an association/issuer response code for the majority of transactions.  #### Processors supported:   - HSBC   - FDC Nashville Global   - SIX  Currently SIX is not receiving Association/Issuer Response Codes here it receives the additional authorization code that must be printed on the receipt when returned by the processor.  #### Possible values: | Card Type   | Response Code | Description                                                                    | | ----------- | ------------- | ------------------------------------------------------------------------------ | | VISA        | 000           | Successful approval/completion or that V.I.P. PIN verification is successful   | | VISA        | 001           | Refer to card issuer                                                           | | VISA        | 002           | Refer to card issuer, special condition                                        | | VISA        | 003           | Invalid merchant or service provider                                           | | VISA        | 004           | Pickup card                                                                    |   | MasterCard  | 000           | Approved or completed successfully                                             | | MasterCard  | 001           | Refer to card issuer                                                           | | MasterCard  | 003           | Invalid merchant                                                               | | MasterCard  | 004           | Capture card                                                                   | | MasterCard  | 005           | Do not honor                                                                   | | AMEX        | 000           | Approved                                                                       | | AMEX        | 001           | Approve with ID                                                                | | AMEX        | 002           | Partial Approval (Prepaid Cards only)                                          | | AMEX        | 100           | Deny                                                                           | | AMEX        | 101           | Expired Card/Invalid Expiration Date                                           | | Discover    | 000           | Approved or completed successfully                                             | | Discover    | 001           | Reserved for future USE                                                        | | Discover    | 002           | Reserved for future USE                                                        | | Discover    | 003           | Invalid Merchant                                                               | | Discover    | 004           | Capture Card                                                                   | 
    */
    'responseCode'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "responseCode",
            "baseName": "responseCode",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsReversalsPost201ResponseIssuerInformation.attributeTypeMap;
    }
}

export class PtsV2PaymentsReversalsPost201ResponseProcessorInformation {
    /**
    * Processor transaction ID.  This value identifies the transaction on a host system. This value is supported only for Moneris. It contains this information:   - Terminal used to process the transaction  - Shift during which the transaction took place  - Batch number  - Transaction number within the batch  You must store this value. If you give the customer a receipt, display this value on the receipt.  Example For the value 66012345001069003:   - Terminal ID = 66012345  - Shift number = 001  - Batch number = 069  - Transaction number = 003 
    */
    'transactionId'?: string;
    /**
    * For most processors, this is the error message sent directly from the bank. Returned only when the processor returns this value.  **Important** Do not use this field to evaluate the result of the authorization.  #### PIN debit Response value that is returned by the processor or bank. **Important** Do not use this field to evaluate the results of the transaction request.  Returned by PIN debit credit, PIN debit purchase, and PIN debit reversal.  #### AIBMS If this value is `08`, you can accept the transaction if the customer provides you with identification.  #### Atos This value is the response code sent from Atos and it might also include the response code from the bank. Format: `aa,bb` with the two values separated by a comma and where: - `aa` is the two-digit error message from Atos. - `bb` is the optional two-digit error message from the bank.  #### Comercio Latino This value is the status code and the error or response code received from the processor separated by a colon. Format: [status code]:E[error code] or [status code]:R[response code] Example `2:R06`  #### JCN Gateway Processor-defined detail error code. The associated response category code is in the `processorInformation.responseCategoryCode` field. String (3)  #### paypalgateway Processor generated ID for the itemized detail. 
    */
    'responseCode'?: string;
    /**
    * Same value as `processorInformation.transactionId`
    */
    'networkTransactionId'?: string;
    /**
    * Processor-defined response category code. The associated detail error code is in the `processorInformation.responseCode` or `issuerInformation.responseCode` field of the service you requested.  This field is supported only for:   - Japanese issuers  - Domestic transactions in Japan  - Comercio Latino—processor transaction ID required for troubleshooting  #### Maximum length for processors   - Comercio Latino: 36  - All other processors: 3 
    */
    'responseCategoryCode'?: string;
    /**
    * Name of the Japanese acquirer that processed the transaction. Returned only for JCN Gateway. Please contact the CyberSource Japan Support Group for more information. 
    */
    'forwardedAcquirerCode'?: string;
    /**
    * Mastercard service that was used for the transaction. Mastercard provides this value to CyberSource.  Possible value:  - 53: Mastercard card-on-file token service  #### CyberSource through VisaNet The value for this field corresponds to the following data in the TC 33 capture file: - Record: CP01 TCR6 - Position: 133-134 - Field: Mastercard Merchant on-behalf service. **Note** This field is returned only for CyberSource through VisaNet. 
    */
    'masterCardServiceCode'?: string;
    /**
    * Result of the Mastercard card-on-file token service. Mastercard provides this value to CyberSource.  Possible values:   - `C`: Service completed successfully.  - `F`: One of the following:    - Incorrect Mastercard POS entry mode. The Mastercard POS entry mode should be 81 for an authorization or      authorization reversal.    - Incorrect Mastercard POS entry mode. The Mastercard POS entry mode should be 01 for a tokenized request.    - Token requestor ID is missing or formatted incorrectly.  - `I`: One of the following:    - Invalid token requestor ID.    - Suspended or deactivated token.    - Invalid token (not in mapping table).  - `T`: Invalid combination of token requestor ID and token.  - `U`: Expired token.  - `W`: Primary account number (PAN) listed in electronic warning bulletin.  **Note** This field is returned only for **CyberSource through VisaNet**. 
    */
    'masterCardServiceReplyCode'?: string;
    /**
    * This field might contain information about a decline. This field is supported only for **CyberSource through VisaNet**. 
    */
    'responseDetails'?: string;
    /**
    * Processor response to the API request. 
    */
    'providerResponse'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "transactionId",
            "baseName": "transactionId",
            "type": "string"
        },
        {
            "name": "responseCode",
            "baseName": "responseCode",
            "type": "string"
        },
        {
            "name": "networkTransactionId",
            "baseName": "networkTransactionId",
            "type": "string"
        },
        {
            "name": "responseCategoryCode",
            "baseName": "responseCategoryCode",
            "type": "string"
        },
        {
            "name": "forwardedAcquirerCode",
            "baseName": "forwardedAcquirerCode",
            "type": "string"
        },
        {
            "name": "masterCardServiceCode",
            "baseName": "masterCardServiceCode",
            "type": "string"
        },
        {
            "name": "masterCardServiceReplyCode",
            "baseName": "masterCardServiceReplyCode",
            "type": "string"
        },
        {
            "name": "responseDetails",
            "baseName": "responseDetails",
            "type": "string"
        },
        {
            "name": "providerResponse",
            "baseName": "providerResponse",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsReversalsPost201ResponseProcessorInformation.attributeTypeMap;
    }
}

export class PtsV2PaymentsReversalsPost201ResponseReversalAmountDetails {
    /**
    * Total reversed amount.  Returned by authorization reversal. 
    */
    'reversedAmount'?: string;
    /**
    * Amount of the original transaction.  Returned by authorization reversal and void. 
    */
    'originalTransactionAmount'?: string;
    /**
    * Currency used for the order. Use the three-character [ISO Standard Currency Codes.](http://apps.cybersource.com/library/documentation/sbc/quickref/currencies.pdf)  #### Used by **Authorization** Required field.  **Authorization Reversal** For an authorization reversal (`reversalInformation`) or a capture (`processingOptions.capture` is set to `true`), you must use the same currency that you used in your payment authorization request.  #### PIN Debit Currency for the amount you requested for the PIN debit purchase. This value is returned for partial authorizations. The issuing bank can approve a partial amount if the balance on the debit card is less than the requested transaction amount. For the possible values, see the [ISO Standard Currency Codes](https://developer.cybersource.com/library/documentation/sbc/quickref/currencies.pdf). Returned by PIN debit purchase.  For PIN debit reversal requests, you must use the same currency that was used for the PIN debit purchase or PIN debit credit that you are reversing. For the possible values, see the [ISO Standard Currency Codes](https://developer.cybersource.com/library/documentation/sbc/quickref/currencies.pdf).  Required field for PIN Debit purchase and PIN Debit credit requests. Optional field for PIN Debit reversal requests.  #### GPX This field is optional for reversing an authorization or credit.  #### DCC for First Data Your local currency.  #### Tax Calculation Required for international tax and value added tax only. Optional for U.S. and Canadian taxes. Your local currency. 
    */
    'currency'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "reversedAmount",
            "baseName": "reversedAmount",
            "type": "string"
        },
        {
            "name": "originalTransactionAmount",
            "baseName": "originalTransactionAmount",
            "type": "string"
        },
        {
            "name": "currency",
            "baseName": "currency",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsReversalsPost201ResponseReversalAmountDetails.attributeTypeMap;
    }
}

export class PtsV2PaymentsReversalsPost400Response {
    /**
    * Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ` **Example** `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.). The `T` separates the date and the time. The `Z` indicates UTC.  Returned by Cybersource for all services. 
    */
    'submitTimeUtc'?: string;
    /**
    * The status of the submitted transaction.  Possible values:  - INVALID_REQUEST 
    */
    'status'?: string;
    /**
    * The reason of the status.  Possible values:  - MISSING_FIELD  - INVALID_DATA  - DUPLICATE_REQUEST  - INVALID_MERCHANT_CONFIGURATION  - PROCESSOR_UNAVAILABLE  - AUTH_ALREADY_REVERSED  - TRANSACTION_ALREADY_SETTLED  - INVALID_AMOUNT  - MISSING_AUTH  - TRANSACTION_ALREADY_REVERSED_OR_SETTLED  - NOT_SUPPORTED 
    */
    'reason'?: string;
    /**
    * The detail message related to the status and reason listed above.
    */
    'message'?: string;
    'details'?: Array<PtsV2PaymentsPost201ResponseErrorInformationDetails>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "submitTimeUtc",
            "baseName": "submitTimeUtc",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "reason",
            "baseName": "reason",
            "type": "string"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        },
        {
            "name": "details",
            "baseName": "details",
            "type": "Array<PtsV2PaymentsPost201ResponseErrorInformationDetails>"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsReversalsPost400Response.attributeTypeMap;
    }
}

export class PtsV2PaymentsVoidsPost201Response {
    'links'?: PtsV2IncrementalAuthorizationPatch201ResponseLinks;
    /**
    * An unique identification number generated by Cybersource to identify the submitted request. Returned by all services. It is also appended to the endpoint of the resource. On incremental authorizations, this value with be the same as the identification number returned in the original authorization response. 
    */
    'id'?: string;
    /**
    * Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ` **Example** `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.). The `T` separates the date and the time. The `Z` indicates UTC.  Returned by Cybersource for all services. 
    */
    'submitTimeUtc'?: string;
    /**
    * The status of the submitted transaction.  Possible values:  - VOIDED  - CANCELLED  - FAILED 
    */
    'status'?: string;
    'clientReferenceInformation'?: PtsV2PaymentsPost201ResponseClientReferenceInformation;
    'voidAmountDetails'?: PtsV2PaymentsVoidsPost201ResponseVoidAmountDetails;
    'processorInformation'?: PtsV2PaymentsVoidsPost201ResponseProcessorInformation;
    /**
    * Reference number that you use to reconcile CyberSource reports with your reports. 
    */
    'reconciliationId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "PtsV2IncrementalAuthorizationPatch201ResponseLinks"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "submitTimeUtc",
            "baseName": "submitTimeUtc",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "clientReferenceInformation",
            "baseName": "clientReferenceInformation",
            "type": "PtsV2PaymentsPost201ResponseClientReferenceInformation"
        },
        {
            "name": "voidAmountDetails",
            "baseName": "voidAmountDetails",
            "type": "PtsV2PaymentsVoidsPost201ResponseVoidAmountDetails"
        },
        {
            "name": "processorInformation",
            "baseName": "processorInformation",
            "type": "PtsV2PaymentsVoidsPost201ResponseProcessorInformation"
        },
        {
            "name": "reconciliationId",
            "baseName": "reconciliationId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsVoidsPost201Response.attributeTypeMap;
    }
}

export class PtsV2PaymentsVoidsPost201ResponseProcessorInformation {
    /**
    * For most processors, this is the error message sent directly from the bank. Returned only when the processor returns this value.  **Important** Do not use this field to evaluate the result of the authorization.  #### PIN debit Response value that is returned by the processor or bank. **Important** Do not use this field to evaluate the results of the transaction request.  Returned by PIN debit credit, PIN debit purchase, and PIN debit reversal.  #### AIBMS If this value is `08`, you can accept the transaction if the customer provides you with identification.  #### Atos This value is the response code sent from Atos and it might also include the response code from the bank. Format: `aa,bb` with the two values separated by a comma and where: - `aa` is the two-digit error message from Atos. - `bb` is the optional two-digit error message from the bank.  #### Comercio Latino This value is the status code and the error or response code received from the processor separated by a colon. Format: [status code]:E[error code] or [status code]:R[response code] Example `2:R06`  #### JCN Gateway Processor-defined detail error code. The associated response category code is in the `processorInformation.responseCategoryCode` field. String (3)  #### paypalgateway Processor generated ID for the itemized detail. 
    */
    'responseCode'?: string;
    /**
    * The reason for when the transaction status is Pending or Reversed. Possible values: - `PAYER_SHIPPING_UNCONFIRMED` - `MULTI_CURRENCY` - `RISK_REVIEW` - `REGULATORY_REVIEW` - `VERIFICATION_REQUIRED` - `ORDER` - `OTHER` 
    */
    'responseDetails'?: string;
    /**
    * Identifier of the order transaction. 
    */
    'transactionId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "responseCode",
            "baseName": "responseCode",
            "type": "string"
        },
        {
            "name": "responseDetails",
            "baseName": "responseDetails",
            "type": "string"
        },
        {
            "name": "transactionId",
            "baseName": "transactionId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsVoidsPost201ResponseProcessorInformation.attributeTypeMap;
    }
}

export class PtsV2PaymentsVoidsPost201ResponseVoidAmountDetails {
    /**
    * Total amount of the void.  #### PIN Debit Amount of the reversal.  Returned by PIN debit reversal. 
    */
    'voidAmount'?: string;
    /**
    * Amount of the original transaction.
    */
    'originalTransactionAmount'?: string;
    /**
    * Currency used for the order. Use the three-character [ISO Standard Currency Codes.](http://apps.cybersource.com/library/documentation/sbc/quickref/currencies.pdf)  #### Used by **Authorization** Required field.  **Authorization Reversal** For an authorization reversal (`reversalInformation`) or a capture (`processingOptions.capture` is set to `true`), you must use the same currency that you used in your payment authorization request.  #### PIN Debit Currency for the amount you requested for the PIN debit purchase. This value is returned for partial authorizations. The issuing bank can approve a partial amount if the balance on the debit card is less than the requested transaction amount. For the possible values, see the [ISO Standard Currency Codes](https://developer.cybersource.com/library/documentation/sbc/quickref/currencies.pdf). Returned by PIN debit purchase.  For PIN debit reversal requests, you must use the same currency that was used for the PIN debit purchase or PIN debit credit that you are reversing. For the possible values, see the [ISO Standard Currency Codes](https://developer.cybersource.com/library/documentation/sbc/quickref/currencies.pdf).  Required field for PIN Debit purchase and PIN Debit credit requests. Optional field for PIN Debit reversal requests.  #### GPX This field is optional for reversing an authorization or credit.  #### DCC for First Data Your local currency.  #### Tax Calculation Required for international tax and value added tax only. Optional for U.S. and Canadian taxes. Your local currency. 
    */
    'currency'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "voidAmount",
            "baseName": "voidAmount",
            "type": "string"
        },
        {
            "name": "originalTransactionAmount",
            "baseName": "originalTransactionAmount",
            "type": "string"
        },
        {
            "name": "currency",
            "baseName": "currency",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsVoidsPost201ResponseVoidAmountDetails.attributeTypeMap;
    }
}

export class PtsV2PaymentsVoidsPost400Response {
    /**
    * Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ` **Example** `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.). The `T` separates the date and the time. The `Z` indicates UTC.  Returned by Cybersource for all services. 
    */
    'submitTimeUtc'?: string;
    /**
    * The status of the submitted transaction.  Possible values:  - INVALID_REQUEST 
    */
    'status'?: string;
    /**
    * The reason of the status.  Possible values:  - MISSING_FIELD  - INVALID_DATA  - DUPLICATE_REQUEST  - INVALID_MERCHANT_CONFIGURATION  - NOT_VOIDABLE  - NOT_SUPPORTED 
    */
    'reason'?: string;
    /**
    * The detail message related to the status and reason listed above.
    */
    'message'?: string;
    'details'?: Array<PtsV2PaymentsPost201ResponseErrorInformationDetails>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "submitTimeUtc",
            "baseName": "submitTimeUtc",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "reason",
            "baseName": "reason",
            "type": "string"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        },
        {
            "name": "details",
            "baseName": "details",
            "type": "Array<PtsV2PaymentsPost201ResponseErrorInformationDetails>"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PaymentsVoidsPost400Response.attributeTypeMap;
    }
}

export class PtsV2PayoutsPost201Response {
    'links'?: PtsV2IncrementalAuthorizationPatch201ResponseLinks;
    /**
    * An unique identification number generated by Cybersource to identify the submitted request. Returned by all services. It is also appended to the endpoint of the resource. On incremental authorizations, this value with be the same as the identification number returned in the original authorization response. 
    */
    'id'?: string;
    /**
    * Time of request in UTC. `Format: YYYY-MM-DDThh:mm:ssZ`  Example 2016-08-11T22:47:57Z equals August 11, 2016, at 22:47:57 (10:47:57 p.m.). The T separates the date and the time. The Z indicates UTC. 
    */
    'submitTimeUtc'?: string;
    /**
    * The status of the submitted transaction.  Possible values:  - ACCEPTED  - DECLINED  - INVALID_REQUEST 
    */
    'status'?: string;
    /**
    * Cybersource or merchant generated transaction reference number. This is sent to the processor and is echoed back in the response to the merchant. This is This value is used for reconciliation purposes. 
    */
    'reconciliationId'?: string;
    'errorInformation'?: PtsV2PayoutsPost201ResponseErrorInformation;
    'clientReferenceInformation'?: PtsV2PaymentsPost201ResponseClientReferenceInformation;
    'merchantInformation'?: PtsV2PayoutsPost201ResponseMerchantInformation;
    'orderInformation'?: PtsV2PayoutsPost201ResponseOrderInformation;
    'processorInformation'?: PtsV2PayoutsPost201ResponseProcessorInformation;
    'recipientInformation'?: PtsV2PayoutsPost201ResponseRecipientInformation;
    'issuerInformation'?: PtsV2PayoutsPost201ResponseIssuerInformation;
    'tokenInformation'?: PtsV2PaymentsPost201ResponseTokenInformation;
    'processingInformation'?: PtsV2PayoutsPost201ResponseProcessingInformation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "PtsV2IncrementalAuthorizationPatch201ResponseLinks"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "submitTimeUtc",
            "baseName": "submitTimeUtc",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "reconciliationId",
            "baseName": "reconciliationId",
            "type": "string"
        },
        {
            "name": "errorInformation",
            "baseName": "errorInformation",
            "type": "PtsV2PayoutsPost201ResponseErrorInformation"
        },
        {
            "name": "clientReferenceInformation",
            "baseName": "clientReferenceInformation",
            "type": "PtsV2PaymentsPost201ResponseClientReferenceInformation"
        },
        {
            "name": "merchantInformation",
            "baseName": "merchantInformation",
            "type": "PtsV2PayoutsPost201ResponseMerchantInformation"
        },
        {
            "name": "orderInformation",
            "baseName": "orderInformation",
            "type": "PtsV2PayoutsPost201ResponseOrderInformation"
        },
        {
            "name": "processorInformation",
            "baseName": "processorInformation",
            "type": "PtsV2PayoutsPost201ResponseProcessorInformation"
        },
        {
            "name": "recipientInformation",
            "baseName": "recipientInformation",
            "type": "PtsV2PayoutsPost201ResponseRecipientInformation"
        },
        {
            "name": "issuerInformation",
            "baseName": "issuerInformation",
            "type": "PtsV2PayoutsPost201ResponseIssuerInformation"
        },
        {
            "name": "tokenInformation",
            "baseName": "tokenInformation",
            "type": "PtsV2PaymentsPost201ResponseTokenInformation"
        },
        {
            "name": "processingInformation",
            "baseName": "processingInformation",
            "type": "PtsV2PayoutsPost201ResponseProcessingInformation"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PayoutsPost201Response.attributeTypeMap;
    }
}

export class PtsV2PayoutsPost201ResponseErrorInformation {
    /**
    * The reason of the status.  Possible values:  - EXPIRED_CARD  - PROCESSOR_DECLINED  - STOLEN_LOST_CARD  - UNAUTHORIZED_CARD  - CVN_NOT_MATCH  - INVALID_CVN  - BLOCKED_BY_CARDHOLDER  - BLACKLISTED_CUSTOMER  - INVALID_ACCOUNT  - GENERAL_DECLINE  - RISK_CONTROL_DECLINE  - PROCESSOR_RISK_CONTROL_DECLINE  - ALLOWABLE_PIN_RETRIES_EXCEEDED  - PROCESSOR_ERROR 
    */
    'reason'?: string;
    /**
    * The detail message related to the status and reason listed above.
    */
    'message'?: string;
    'details'?: Array<PtsV2PaymentsPost201ResponseErrorInformationDetails>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "reason",
            "baseName": "reason",
            "type": "string"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        },
        {
            "name": "details",
            "baseName": "details",
            "type": "Array<PtsV2PaymentsPost201ResponseErrorInformationDetails>"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PayoutsPost201ResponseErrorInformation.attributeTypeMap;
    }
}

export class PtsV2PayoutsPost201ResponseIssuerInformation {
    /**
    * This field contains values that identify the service type under which the transaction should be processed. The valid value for the Visa Alias Directory Service is A0 (Alias) and 00 (normal transaction). 
    */
    'serviceProcessingType'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "serviceProcessingType",
            "baseName": "serviceProcessingType",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PayoutsPost201ResponseIssuerInformation.attributeTypeMap;
    }
}

export class PtsV2PayoutsPost201ResponseMerchantInformation {
    'merchantDescriptor'?: PtsV2PayoutsPost201ResponseMerchantInformationMerchantDescriptor;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "merchantDescriptor",
            "baseName": "merchantDescriptor",
            "type": "PtsV2PayoutsPost201ResponseMerchantInformationMerchantDescriptor"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PayoutsPost201ResponseMerchantInformation.attributeTypeMap;
    }
}

export class PtsV2PayoutsPost201ResponseMerchantInformationMerchantDescriptor {
    /**
    * Your merchant name.  **Note** For Paymentech processor using Cybersource Payouts, the maximum data length is 22.  #### PIN debit Your business name. This name is displayed on the cardholder’s statement. When you include more than one consecutive space, extra spaces are removed.  When you do not include this value in your PIN debit request, the merchant name from your account is used. **Important** This value must consist of English characters.  Optional field for PIN debit credit or PIN debit purchase requests.  #### Airline processing Your merchant name. This name is displayed on the cardholder’s statement. When you include more than one consecutive space, extra spaces are removed.  **Note** Some airline fee programs may require the original ticket number (ticket identifier) or the ancillary service description in positions 13 through 23 of this field.  **Important** This value must consist of English characters.  Required for captures and credits. 
    */
    'name'?: string;
    /**
    * Merchant's City.  #### PIN debit City for your business location. This value might be displayed on the cardholder’s statement.  When you do not include this value in your PIN debit request, the merchant name from your account is used. **Important** This value must consist of English characters.  Optional field for PIN debit credit or PIN debit purchase requests. 
    */
    'locality'?: string;
    /**
    * Merchant's country.  #### PIN debit Country code for your business location. Use the [ISO Standard Country Codes](https://developer.cybersource.com/library/documentation/sbc/quickref/countries_alpha_list.pdf) This value might be displayed on the cardholder’s statement.  When you do not include this value in your PIN debit request, the merchant name from your account is used. **Important** This value must consist of English characters. **Note** If your business is located in the U.S. or Canada and you include this field in a request, you must also include `merchantInformation.merchantDescriptor.administrativeArea`.  Optional field for PIN debit credit or PIN debit purchase. 
    */
    'country'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "locality",
            "baseName": "locality",
            "type": "string"
        },
        {
            "name": "country",
            "baseName": "country",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PayoutsPost201ResponseMerchantInformationMerchantDescriptor.attributeTypeMap;
    }
}

export class PtsV2PayoutsPost201ResponseOrderInformation {
    'amountDetails'?: PtsV2PayoutsPost201ResponseOrderInformationAmountDetails;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "amountDetails",
            "baseName": "amountDetails",
            "type": "PtsV2PayoutsPost201ResponseOrderInformationAmountDetails"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PayoutsPost201ResponseOrderInformation.attributeTypeMap;
    }
}

export class PtsV2PayoutsPost201ResponseOrderInformationAmountDetails {
    /**
    * Grand total for the order. This value cannot be negative. You can include a decimal point (.), but no other special characters. CyberSource truncates the amount to the correct number of decimal places.  **Note** For CTV, FDCCompass, Paymentech processors, the maximum length for this field is 12.  **Important** Some processors have specific requirements and limitations, such as maximum amounts and maximum field lengths.  If your processor supports zero amount authorizations, you can set this field to 0 for the authorization to check if the card is lost or stolen.   #### Card Present Required to include either this field or `orderInformation.lineItems[].unitPrice` for the order.  #### Invoicing / Pay By Link Required for creating a new invoice or payment link.  #### PIN Debit Amount you requested for the PIN debit purchase. This value is returned for partial authorizations. The issuing bank can approve a partial amount if the balance on the debit card is less than the requested transaction amount.  Required field for PIN Debit purchase and PIN Debit credit requests. Optional field for PIN Debit reversal requests.  #### GPX This field is optional for reversing an authorization or credit; however, for all other processors, these fields are required.  #### DCC with a Third-Party Provider Set this field to the converted amount that was returned by the DCC provider. You must include either this field or the 1st line item in the order and the specific line-order amount in your request.   #### DCC for First Data Not used. 
    */
    'totalAmount'?: string;
    /**
    * Currency used for the order. Use the three-character [ISO Standard Currency Codes.](http://apps.cybersource.com/library/documentation/sbc/quickref/currencies.pdf)  #### Used by **Authorization** Required field.  **Authorization Reversal** For an authorization reversal (`reversalInformation`) or a capture (`processingOptions.capture` is set to `true`), you must use the same currency that you used in your payment authorization request.  #### PIN Debit Currency for the amount you requested for the PIN debit purchase. This value is returned for partial authorizations. The issuing bank can approve a partial amount if the balance on the debit card is less than the requested transaction amount. For the possible values, see the [ISO Standard Currency Codes](https://developer.cybersource.com/library/documentation/sbc/quickref/currencies.pdf). Returned by PIN debit purchase.  For PIN debit reversal requests, you must use the same currency that was used for the PIN debit purchase or PIN debit credit that you are reversing. For the possible values, see the [ISO Standard Currency Codes](https://developer.cybersource.com/library/documentation/sbc/quickref/currencies.pdf).  Required field for PIN Debit purchase and PIN Debit credit requests. Optional field for PIN Debit reversal requests.  #### GPX This field is optional for reversing an authorization or credit.  #### DCC for First Data Your local currency.  #### Tax Calculation Required for international tax and value added tax only. Optional for U.S. and Canadian taxes. Your local currency. 
    */
    'currency'?: string;
    /**
    * This is a multicurrency field. It contains the transaction amount (field 4), converted to the Currency used to bill the cardholder’s account. This field is returned for OCT transactions. 
    */
    'settlementAmount'?: string;
    /**
    * This is a multicurrency-only field. It contains a 3-digit numeric code that identifies the currency used by the issuer to bill the cardholder's account. This field is returned for OCT transactions. 
    */
    'settlementCurrency'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "totalAmount",
            "baseName": "totalAmount",
            "type": "string"
        },
        {
            "name": "currency",
            "baseName": "currency",
            "type": "string"
        },
        {
            "name": "settlementAmount",
            "baseName": "settlementAmount",
            "type": "string"
        },
        {
            "name": "settlementCurrency",
            "baseName": "settlementCurrency",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PayoutsPost201ResponseOrderInformationAmountDetails.attributeTypeMap;
    }
}

export class PtsV2PayoutsPost201ResponseProcessingInformation {
    'purchaseOptions'?: Ptsv2payoutsProcessingInformationPurchaseOptions;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "purchaseOptions",
            "baseName": "purchaseOptions",
            "type": "Ptsv2payoutsProcessingInformationPurchaseOptions"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PayoutsPost201ResponseProcessingInformation.attributeTypeMap;
    }
}

export class PtsV2PayoutsPost201ResponseProcessorInformation {
    /**
    * Issuer-generated approval code for the transaction.
    */
    'approvalCode'?: string;
    /**
    * Transaction status from the processor.
    */
    'responseCode'?: string;
    /**
    * Network transaction identifier (TID). This value can be used to identify a specific transaction when you are discussing the transaction with your processor. 
    */
    'transactionId'?: string;
    /**
    * This field is returned only for **American Express Direct** and **CyberSource through VisaNet**. Returned by authorization and incremental authorization services.  #### American Express Direct  System trace audit number (STAN). This value identifies the transaction and is useful when investigating a chargeback dispute.  #### CyberSource through VisaNet  System trace number that must be printed on the customer’s receipt. 
    */
    'systemTraceAuditNumber'?: string;
    /**
    * Used by Visa only and contains the response source/reason code that identifies the source of the response decision. 
    */
    'responseCodeSource'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "approvalCode",
            "baseName": "approvalCode",
            "type": "string"
        },
        {
            "name": "responseCode",
            "baseName": "responseCode",
            "type": "string"
        },
        {
            "name": "transactionId",
            "baseName": "transactionId",
            "type": "string"
        },
        {
            "name": "systemTraceAuditNumber",
            "baseName": "systemTraceAuditNumber",
            "type": "string"
        },
        {
            "name": "responseCodeSource",
            "baseName": "responseCodeSource",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PayoutsPost201ResponseProcessorInformation.attributeTypeMap;
    }
}

export class PtsV2PayoutsPost201ResponseRecipientInformation {
    'card'?: PtsV2PayoutsPost201ResponseRecipientInformationCard;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "card",
            "baseName": "card",
            "type": "PtsV2PayoutsPost201ResponseRecipientInformationCard"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PayoutsPost201ResponseRecipientInformation.attributeTypeMap;
    }
}

export class PtsV2PayoutsPost201ResponseRecipientInformationCard {
    /**
    * This field shows the available balance in the prepaid account. Acquirers always receive the available balance in the transaction currency. 
    */
    'balance'?: string;
    /**
    * This field indicates the 3-letter [ISO Standard Currency Codes](http://apps.cybersource.com/library/documentation/sbc/quickref/currencies.pdf) for the card currency. 
    */
    'currency'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "balance",
            "baseName": "balance",
            "type": "string"
        },
        {
            "name": "currency",
            "baseName": "currency",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PayoutsPost201ResponseRecipientInformationCard.attributeTypeMap;
    }
}

export class PtsV2PayoutsPost400Response {
    /**
    * Time of request in UTC. `Format: YYYY-MM-DDThh:mm:ssZ`  Example 2016-08-11T22:47:57Z equals August 11, 2016, at 22:47:57 (10:47:57 p.m.). The T separates the date and the time. The Z indicates UTC. 
    */
    'submitTimeUtc'?: string;
    /**
    * The status of the submitted transaction.
    */
    'status'?: string;
    /**
    * The reason of the status.  Possible values:  - MISSING_FIELD  - INVALID_DATA  - DUPLICATE_REQUEST  - INVALID_CARD  - INVALID_MERCHANT_CONFIGURATION  - INVALID_AMOUNT 
    */
    'reason'?: string;
    /**
    * The detail message related to the status and reason listed above.
    */
    'message'?: string;
    'details'?: Array<PtsV2PaymentsPost201ResponseErrorInformationDetails>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "submitTimeUtc",
            "baseName": "submitTimeUtc",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "reason",
            "baseName": "reason",
            "type": "string"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        },
        {
            "name": "details",
            "baseName": "details",
            "type": "Array<PtsV2PaymentsPost201ResponseErrorInformationDetails>"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2PayoutsPost400Response.attributeTypeMap;
    }
}

export class PtsV2RetrievePaymentTokenGet400Response {
    /**
    * An unique identification number generated by Cybersource to identify the submitted request. Returned by all services. It is also appended to the endpoint of the resource. On incremental authorizations, this value with be the same as the identification number returned in the original authorization response. 
    */
    'id'?: string;
    /**
    * Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ` **Example** `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.). The `T` separates the date and the time. The `Z` indicates UTC.  Returned by Cybersource for all services. 
    */
    'submitTimeUtc'?: string;
    /**
    * The status of the submitted transaction.  Possible values:  - INVALID_REQUEST 
    */
    'status'?: string;
    /**
    * The reason of the status.        Possible values:  - INVALID_DATA  - RESOURCE_NOT_FOUND 
    */
    'reason'?: string;
    /**
    * The detail message related to the status and reason listed above.
    */
    'message'?: string;
    'details'?: Array<PtsV2PaymentsPost201ResponseErrorInformationDetails>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "submitTimeUtc",
            "baseName": "submitTimeUtc",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "reason",
            "baseName": "reason",
            "type": "string"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        },
        {
            "name": "details",
            "baseName": "details",
            "type": "Array<PtsV2PaymentsPost201ResponseErrorInformationDetails>"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2RetrievePaymentTokenGet400Response.attributeTypeMap;
    }
}

export class PtsV2RetrievePaymentTokenGet502Response {
    /**
    * Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ` **Example** `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.). The `T` separates the date and the time. The `Z` indicates UTC.  Returned by Cybersource for all services. 
    */
    'submitTimeUtc'?: string;
    /**
    * The status of the submitted transaction.  Possible values:  - SERVER_ERROR 
    */
    'status'?: string;
    /**
    * The reason of the status.  Possible values:  - INTERNAL_SERVER_ERROR 
    */
    'reason'?: string;
    /**
    * The detail message related to the status and reason listed above.
    */
    'message'?: string;
    /**
    * An unique identification number generated by Cybersource to identify the submitted request. Returned by all services. It is also appended to the endpoint of the resource. On incremental authorizations, this value with be the same as the identification number returned in the original authorization response. 
    */
    'id'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "submitTimeUtc",
            "baseName": "submitTimeUtc",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "reason",
            "baseName": "reason",
            "type": "string"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2RetrievePaymentTokenGet502Response.attributeTypeMap;
    }
}

export class PtsV2UpdateOrderPatch201Response {
    /**
    * The status of the submitted transaction. Possible values:   - CREATED   - SAVED   - APPROVED   - VOIDED   - COMPLETED   - PAYER_ACTION_REQUIRED 
    */
    'status'?: string;
    'processorInformation'?: PtsV2CreateOrderPost201ResponseProcessorInformation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "processorInformation",
            "baseName": "processorInformation",
            "type": "PtsV2CreateOrderPost201ResponseProcessorInformation"
        }    ];

    static getAttributeTypeMap() {
        return PtsV2UpdateOrderPatch201Response.attributeTypeMap;
    }
}

export class Ptsv2billingagreementsAggregatorInformation {
    /**
    * Your payment aggregator business name.  **American Express Direct**\\ The maximum length of the aggregator name depends on the length of the sub-merchant name. The combined length for both values must not exceed 36 characters.\\  #### CyberSource through VisaNet With American Express, the maximum length of the aggregator name depends on the length of the sub-merchant name. The combined length for both values must not exceed 36 characters. The value for this field does not map to the TC 33 capture file5.  **FDC Compass**\\ This value must consist of uppercase characters. 
    */
    'name'?: string;
    'subMerchant'?: Ptsv2paymentsAggregatorInformationSubMerchant;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "subMerchant",
            "baseName": "subMerchant",
            "type": "Ptsv2paymentsAggregatorInformationSubMerchant"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2billingagreementsAggregatorInformation.attributeTypeMap;
    }
}

export class Ptsv2billingagreementsAgreementInformation {
    /**
    * Identifier for the mandate. #### SEPA/BACS Required for mandates services 
    */
    'id'?: string;
    /**
    * Date the mandate has been signed.  Format YYYYMMdd #### SEPA/BACS Required for Import Mandate 
    */
    'dateSigned'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "dateSigned",
            "baseName": "dateSigned",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2billingagreementsAgreementInformation.attributeTypeMap;
    }
}

export class Ptsv2billingagreementsBuyerInformation {
    /**
    * Your identifier for the customer.  When a subscription or customer profile is being created, the maximum length for this field for most processors is 30. Otherwise, the maximum length is 100.  #### SEPA/BACS Required for Create Mandate and Import Mandate  #### Comercio Latino For recurring payments in Mexico, the value is the customer’s contract number. Note Before you request the authorization, you must inform the issuer of the customer contract numbers that will be used for recurring transactions.  #### Worldpay VAP For a follow-on credit with Worldpay VAP, CyberSource checks the following locations, in the order given, for a customer account ID value and uses the first value it finds: 1. `customer_account_id` value in the follow-on credit request 2. Customer account ID value that was used for the capture that is being credited 3. Customer account ID value that was used for the original authorization If a customer account ID value cannot be found in any of these locations, then no value is used. 
    */
    'merchantCustomerId'?: string;
    /**
    * Recipient’s date of birth. **Format**: `YYYYMMDD`.  This field is a `pass-through`, which means that CyberSource ensures that the value is eight numeric characters but otherwise does not verify the value or modify it in any way before sending it to the processor. If the field is not required for the transaction, CyberSource does not forward it to the processor. 
    */
    'dateOfBirth'?: string;
    /**
    * Customer's gender. Possible values are F (female), M (male), O (other).
    */
    'gender'?: string;
    /**
    * language setting of the user
    */
    'language'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "merchantCustomerId",
            "baseName": "merchantCustomerId",
            "type": "string"
        },
        {
            "name": "dateOfBirth",
            "baseName": "dateOfBirth",
            "type": "string"
        },
        {
            "name": "gender",
            "baseName": "gender",
            "type": "string"
        },
        {
            "name": "language",
            "baseName": "language",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2billingagreementsBuyerInformation.attributeTypeMap;
    }
}

export class Ptsv2billingagreementsClientReferenceInformation {
    /**
    * Merchant-generated order reference or tracking number. It is recommended that you send a unique value for each transaction so that you can perform meaningful searches for the transaction.  #### Used by  #### SEPA/BACS Required for mandates services #### Paypal Required for billing agreements   **Authorization** Required field.  #### PIN Debit Requests for PIN debit reversals need to use the same merchant reference number that was used in the transaction that is being reversed.  Required field for all PIN Debit requests (purchase, credit, and reversal).  #### FDC Nashville Global Certain circumstances can cause the processor to truncate this value to 15 or 17 characters for Level II and Level III processing, which can cause a discrepancy between the value you submit and the value included in some processor reports. 
    */
    'code'?: string;
    /**
    * Reference number for the transaction. Depending on how your Cybersource account is configured, this value could either be provided in the API request or generated by CyberSource. The actual value used in the request to the processor is provided back to you by Cybersource in the response. 
    */
    'reconciliationId'?: string;
    /**
    * Used to resume a transaction that was paused for an order modification rule to allow for payer authentication to complete. To resume and continue with the authorization/decision service flow, call the services and include the request id from the prior decision call. 
    */
    'pausedRequestId'?: string;
    /**
    * Identifier that you assign to the transaction. Normally generated by a client server to identify a unique API request.  **Note** Use this field only if you want to support merchant-initiated reversal and void operations.  #### Used by **Authorization, Authorization Reversal, Capture, Credit, and Void** Optional field.  #### PIN Debit For a PIN debit reversal, your request must include a request ID or a merchant transaction identifier. Optional field for PIN debit purchase or credit requests. 
    */
    'transactionId'?: string;
    /**
    * Brief description of the order or any comment you wish to add to the order.
    */
    'comments'?: string;
    'partner'?: Ptsv2paymentsClientReferenceInformationPartner;
    /**
    * The name of the Connection Method client (such as Virtual Terminal or SOAP Toolkit API) that the merchant uses to send a transaction request to CyberSource. 
    */
    'applicationName'?: string;
    /**
    * Version of the CyberSource application or integration used for a transaction. 
    */
    'applicationVersion'?: string;
    /**
    * The entity that is responsible for running the transaction and submitting the processing request to CyberSource. This could be a person, a system, or a connection method. 
    */
    'applicationUser'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        },
        {
            "name": "reconciliationId",
            "baseName": "reconciliationId",
            "type": "string"
        },
        {
            "name": "pausedRequestId",
            "baseName": "pausedRequestId",
            "type": "string"
        },
        {
            "name": "transactionId",
            "baseName": "transactionId",
            "type": "string"
        },
        {
            "name": "comments",
            "baseName": "comments",
            "type": "string"
        },
        {
            "name": "partner",
            "baseName": "partner",
            "type": "Ptsv2paymentsClientReferenceInformationPartner"
        },
        {
            "name": "applicationName",
            "baseName": "applicationName",
            "type": "string"
        },
        {
            "name": "applicationVersion",
            "baseName": "applicationVersion",
            "type": "string"
        },
        {
            "name": "applicationUser",
            "baseName": "applicationUser",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2billingagreementsClientReferenceInformation.attributeTypeMap;
    }
}

export class Ptsv2billingagreementsConsumerAuthenticationInformation {
    /**
    * Payer authentication transaction identifier passed to link the validation and authorization calls. 
    */
    'authenticationTransactionContextId'?: string;
    /**
    * Unique identifier generated by the card-issuing bank for Visa, American Express, JCB, Diners Club, and Discover transactions after the customer is authenticated. The value is in base64. When you request the card authorization service, CyberSource automatically converts the value, not the field name, to the format required by your payment processor. 
    */
    'cavv'?: string;
    /**
    * Web based token used to authenticate consumer with Rupay authentication provider. 
    */
    'transactionToken'?: string;
    /**
    * Transaction identifier generated by CyberSource for successful enrollment or validation checks. Use this value, which is in base64, to match an outgoing PAReq with an incoming PARes. CyberSource forwards the XID with the card authorization service to these payment processors in these cases: - Barclays - Streamline (when the **ecommerceIndicator**`=spa`) 
    */
    'xid'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "authenticationTransactionContextId",
            "baseName": "authenticationTransactionContextId",
            "type": "string"
        },
        {
            "name": "cavv",
            "baseName": "cavv",
            "type": "string"
        },
        {
            "name": "transactionToken",
            "baseName": "transactionToken",
            "type": "string"
        },
        {
            "name": "xid",
            "baseName": "xid",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2billingagreementsConsumerAuthenticationInformation.attributeTypeMap;
    }
}

export class Ptsv2billingagreementsDeviceInformation {
    /**
    * Value of the Accept header sent by the customer’s web browser. **Note** If the customer’s browser provides a value, you must include it in your request. 
    */
    'httpAcceptBrowserValue'?: string;
    /**
    * IP address of the customer.  #### Used by **Authorization, Capture, and Credit** Optional field. 
    */
    'ipAddress'?: string;
    /**
    * Value of the User-Agent header sent by the customer’s web browser. Note If the customer’s browser provides a value, you must include it in your request. 
    */
    'userAgentBrowserValue'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "httpAcceptBrowserValue",
            "baseName": "httpAcceptBrowserValue",
            "type": "string"
        },
        {
            "name": "ipAddress",
            "baseName": "ipAddress",
            "type": "string"
        },
        {
            "name": "userAgentBrowserValue",
            "baseName": "userAgentBrowserValue",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2billingagreementsDeviceInformation.attributeTypeMap;
    }
}

export class Ptsv2billingagreementsInstallmentInformation {
    /**
    * Applicable only for SI. Required in case the authentication is initiated for SI registration. Valid Values: - `SMS` - `EMAIL` - `BOTH` 
    */
    'alertPreference'?: string;
    /**
    * Date of the first installment payment. Format: YYMMDD. When you do not include this field, CyberSource sends a string of six zeros (000000) to the processor.  This field is supported only for Crediario installment payments in Brazil on CyberSource through VisaNet.  The value for this field corresponds to the following data in the TC 33 capture file: - Record: CP01 TCR9 - Position: 42-47 - Field: Date of First Installment 
    */
    'firstInstallmentDate'?: string;
    /**
    * Standing Instruction/Installment identifier. 
    */
    'identifier'?: string;
    /**
    * End date of the SI transactions. Cannot be later than card expiry date. Ideally this can be set to expiry date. Required in case the authentication is initiated for SI registration. 
    */
    'lastInstallmentDate'?: string;
    /**
    * Maximum Amount for which SI can be initiated. Required in case the authentication is initiated for SI registration. 
    */
    'maxAmount'?: string;
    /**
    * Minimum Amount for which SI can be initiated. Required in case the authentication is initiated for SI registration. 
    */
    'minAmount'?: string;
    /**
    * Payment plan for the installments. This field is supported only for installment payments on Visa Platform Connect, RuPay and SPG-KSA seamless flow.  Possible values for a standing-instruction (SI) merchant-initiated transaction (MIT) with Diners Club or Mastercard in India or with an India-issued card: - 1: SI with a fixed amount. - 2: SI with a maximum amount. - 3: Other kind of SI.  Possible values for a type of Installment transaction for on-soil transaction in Kingdom of Saudi Arabia - 1: Registration or first transaction. - 2: Subsequent transaction.  Possible values for other kinds of installment payments: - 0 (default): Regular installment. This value is not allowed for airline transactions. - 1: Installment payment with down payment. - 2: Installment payment without down payment. This value is supported only for airline transactions. - 3: Installment payment; down payment and boarding fee will follow. This value is supported only for airline transactions. - 4: Down payment only; regular installment payment will follow. - 5: Boarding fee only. This value is supported only for airline transactions. - 6: SI de-registration on RuPay for the payer authentication seamless flow. 
    */
    'paymentType'?: string;
    /**
    * Preferred date for initiating the SI transaction every month. This field need not be sent in case the SI has to be initiated as and when required, e.g., topping up the wallet, etc. 
    */
    'preferredDay'?: string;
    /**
    * Installment number when making payments in installments. Used along with `totalCount` to track which payment is being processed.  For example, the second of 5 payments would be passed to CyberSource as `sequence` = 2 and `totalCount` = 5.  #### Chase Paymentech Solutions and FDC Compass This field is optional because this value is required in the merchant descriptors.  #### CyberSource through VisaNet When you do not include this field in a request for a Crediario installment payment, CyberSource sends a value of 0 to the processor.  For Crediario installment payments, the value for this field corresponds to the following data in the TC 33 capture file*: - Record: CP01 TCR9 - Position: 38-40 - Field: Installment Payment Number  * The TC 33 Capture file contains information about the purchases and refunds that a merchant submits to CyberSource. CyberSource through VisaNet creates the TC 33 Capture file at the end of the day and sends it to the merchant’s acquirer, who uses this information to facilitate end-of-day clearing processing with payment card companies. 
    */
    'sequence'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "alertPreference",
            "baseName": "alertPreference",
            "type": "string"
        },
        {
            "name": "firstInstallmentDate",
            "baseName": "firstInstallmentDate",
            "type": "string"
        },
        {
            "name": "identifier",
            "baseName": "identifier",
            "type": "string"
        },
        {
            "name": "lastInstallmentDate",
            "baseName": "lastInstallmentDate",
            "type": "string"
        },
        {
            "name": "maxAmount",
            "baseName": "maxAmount",
            "type": "string"
        },
        {
            "name": "minAmount",
            "baseName": "minAmount",
            "type": "string"
        },
        {
            "name": "paymentType",
            "baseName": "paymentType",
            "type": "string"
        },
        {
            "name": "preferredDay",
            "baseName": "preferredDay",
            "type": "string"
        },
        {
            "name": "sequence",
            "baseName": "sequence",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2billingagreementsInstallmentInformation.attributeTypeMap;
    }
}

export class Ptsv2billingagreementsMerchantInformation {
    'merchantDescriptor'?: Ptsv2billingagreementsMerchantInformationMerchantDescriptor;
    /**
    * The value for this field is a four-digit number that the payment card industry uses to classify merchants into market segments. A payment card company assigned one or more of these values to your business when you started accepting the payment card company’s cards. When you do not include this field in your request, CyberSource uses the value in your CyberSource account.  #### CyberSource through VisaNet The value for this field corresponds to the following data in the TC 33 capture file5: - Record: CP01 TCR4 - Position: 150-153 - Field: Merchant Category Code 
    */
    'categoryCode'?: number;
    /**
    * The state where the merchant is located.  #### PIN debit State code or region code for your business. Use the Use the [State, Province, and Territory Codes for the United States and Canada](https://developer.cybersource.com/library/documentation/sbc/quickref/states_and_provinces.pdf) This value might be displayed on the cardholder’s statement.  When you do not include this value in your PIN debit request, the merchant name from your account is used. **Important** This value must consist of English characters.  **Note** This field is supported only for businesses located in the U.S. or Canada.  Optional field for PIN debit credit or PIN debit purchase. 
    */
    'administrativeArea'?: string;
    /**
    * Date and time at your physical location.  Format: `YYYYMMDDhhmmss`, where:  - `YYYY` = year  - `MM` = month  - `DD` = day  - `hh` = hour  - `mm` = minutes  - `ss` = seconds  #### Used by **Authorization** Required for these processors: - American Express Direct                                                                                                                                                                                                                                                                                                                         - American Express Direct - Credit Mutuel-CIC - FDC Nashville Global - SIX  Optional for all other processors. 
    */
    'transactionLocalDateTime'?: string;
    /**
    * URL to which the customer is directed if they fail to sign the mandate. #### SEPA Required for Create Mandate and Update Mandate #### BACS Required for Create Mandate 
    */
    'cancelUrl'?: string;
    /**
    * URL to which the customer is directed if they fail to sign the mandate. #### SEPA Required for Create Mandate and Update Mandate #### BACS Required for Create Mandate 
    */
    'successUrl'?: string;
    /**
    * URL to which the customer is directed if they fail to sign the mandate. #### SEPA Required for Create Mandate and Update Mandate #### BACS Required for Create Mandate 
    */
    'failureUrl'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "merchantDescriptor",
            "baseName": "merchantDescriptor",
            "type": "Ptsv2billingagreementsMerchantInformationMerchantDescriptor"
        },
        {
            "name": "categoryCode",
            "baseName": "categoryCode",
            "type": "number"
        },
        {
            "name": "administrativeArea",
            "baseName": "administrativeArea",
            "type": "string"
        },
        {
            "name": "transactionLocalDateTime",
            "baseName": "transactionLocalDateTime",
            "type": "string"
        },
        {
            "name": "cancelUrl",
            "baseName": "cancelUrl",
            "type": "string"
        },
        {
            "name": "successUrl",
            "baseName": "successUrl",
            "type": "string"
        },
        {
            "name": "failureUrl",
            "baseName": "failureUrl",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2billingagreementsMerchantInformation.attributeTypeMap;
    }
}

export class Ptsv2billingagreementsMerchantInformationMerchantDescriptor {
    /**
    * Merchant's postal code.  #### PIN debit Postal code for your business location. This value might be displayed on the cardholder’s statement.  If your business is domiciled in the U.S., you can use a 5-digit or 9-digit postal code. A 9-digit postal code must follow this format: [5 digits][dash][4 digits] Example: `12345-6789`  If your business is domiciled in Canada, you can use a 6-digit or 9-digit postal code. A 6-digit postal code must follow this format: [alpha][numeric][alpha][space] [numeric][alpha][numeric] Example: `A1B 2C3`  When you do not include this value in your PIN debit request, the merchant name from your account is used. **Important** This value must consist of English characters.  **Note** This field is supported only for businesses located in the U.S. or Canada. **Important** Mastercard requires a postal code for any country that uses postal codes. You can provide the postal code in your account or you can include this field in your request.  Optional field for PIN debit credit or PIN debit purchase. 
    */
    'postalCode'?: string;
    /**
    * Contact information for the merchant.  **Note** These are the maximum data lengths for the following payment processors: - FDCCompass (13) - Paymentech (13) 
    */
    'contact'?: string;
    /**
    * Merchant's City.  #### PIN debit City for your business location. This value might be displayed on the cardholder’s statement.  When you do not include this value in your PIN debit request, the merchant name from your account is used. **Important** This value must consist of English characters.  Optional field for PIN debit credit or PIN debit purchase requests. 
    */
    'locality'?: string;
    /**
    * Your merchant name.  **Note** For Paymentech processor using Cybersource Payouts, the maximum data length is 22.  #### PIN debit Your business name. This name is displayed on the cardholder’s statement. When you include more than one consecutive space, extra spaces are removed.  When you do not include this value in your PIN debit request, the merchant name from your account is used. **Important** This value must consist of English characters.  Optional field for PIN debit credit or PIN debit purchase requests.  #### Airline processing Your merchant name. This name is displayed on the cardholder’s statement. When you include more than one consecutive space, extra spaces are removed.  **Note** Some airline fee programs may require the original ticket number (ticket identifier) or the ancillary service description in positions 13 through 23 of this field.  **Important** This value must consist of English characters.  Required for captures and credits. 
    */
    'name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "postalCode",
            "baseName": "postalCode",
            "type": "string"
        },
        {
            "name": "contact",
            "baseName": "contact",
            "type": "string"
        },
        {
            "name": "locality",
            "baseName": "locality",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2billingagreementsMerchantInformationMerchantDescriptor.attributeTypeMap;
    }
}

export class Ptsv2billingagreementsOrderInformation {
    'amountDetails'?: Ptsv2paymentsidreversalsReversalInformationAmountDetails;
    'billTo'?: Ptsv2billingagreementsOrderInformationBillTo;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "amountDetails",
            "baseName": "amountDetails",
            "type": "Ptsv2paymentsidreversalsReversalInformationAmountDetails"
        },
        {
            "name": "billTo",
            "baseName": "billTo",
            "type": "Ptsv2billingagreementsOrderInformationBillTo"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2billingagreementsOrderInformation.attributeTypeMap;
    }
}

export class Ptsv2billingagreementsOrderInformationBillTo {
    /**
    * Payment card billing street address as it appears on the credit card issuer’s records.  #### SEPA Required for Create Mandate and Import Mandate  #### Atos This field must not contain colons (:).  #### CyberSource through VisaNet **Important** When you populate orderInformation.billTo.address1 and orderInformation.billTo.address2, CyberSource through VisaNet concatenates the two values. If the concatenated value exceeds 40 characters, CyberSource through VisaNet truncates the value at 40 characters before sending it to Visa and the issuing bank. Truncating this value affects AVS results and therefore might also affect risk decisions and chargebacks. Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.  #### FDMS Nashville When the street name is numeric, it must be sent in numeric format. For example, if the address is _One First Street_, it must be sent as _1 1st Street_.  Required if keyed; not used if swiped.  String (20)  #### TSYS Acquiring Solutions Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.  #### All other processors: Optional. String (60)  #### For Payouts This field may be sent only for FDC Compass.  **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting. 
    */
    'address1'?: string;
    /**
    * Used for additional address information. For example: _Attention: Accounts Payable_ Optional field.  For Payouts: This field may be sent only for FDC Compass.  #### Atos This field must not contain colons (:).  #### CyberSource through VisaNet **Important** When you populate `orderInformation.billTo.address1` and `orderInformation.billTo.address2`, CyberSource through VisaNet concatenates the two values. If the concatenated value exceeds 40 characters, CyberSource through VisaNet truncates the value at 40 characters before sending it to Visa and the issuing bank. Truncating this value affects AVS results and therefore might also affect risk decisions and chargebacks. Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.  #### Chase Paymentech Solutions, FDC Compass, and TSYS Acquiring Solutions This value is used for AVS.  #### FDMS Nashville `orderInformation.billTo.address1` and `orderInformation.billTo.address2` together cannot exceed 20 characters. String (20)  #### All Other Processors String (60) 
    */
    'address2'?: string;
    /**
    * State or province of the billing address. Use the [State, Province, and Territory Codes for the United States and Canada](https://developer.cybersource.com/library/documentation/sbc/quickref/states_and_provinces.pdf). 
    */
    'administrativeArea'?: string;
    /**
    * Building number in the street address.  For example, if the street address is: Rua da Quitanda 187 then the building number is 187.  This field is supported only for:  - Cielo transactions.  - Redecard customer validation with CyberSource Latin American Processing. 
    */
    'buildingNumber'?: string;
    /**
    * Company's Name, e.g. VISA
    */
    'company'?: string;
    /**
    * Payment card billing country. Use the two-character [ISO Standard Country Codes](http://apps.cybersource.com/library/documentation/sbc/quickref/countries_alpha_list.pdf).  #### SEPA/BACS Required for Create Mandate and Import Mandate  #### CyberSource through VisaNet Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.  **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.  #### Chase Paymentech Solutions Optional field.  ####  Credit Mutuel-CIC Optional field.  #### OmniPay Direct Optional field.  #### SIX Optional field.  #### TSYS Acquiring Solutions Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.  #### Worldpay VAP Optional field.  #### All other processors Not used. 
    */
    'country'?: string;
    /**
    * U.S. county if available.
    */
    'county'?: string;
    /**
    * Customer’s neighborhood, community, or region within the city or municipality.  #### SEPA/BACS When you include this field in a request, the value for this field must be the same as the value for the billTo_state field. 
    */
    'district'?: string;
    /**
    * Customer's email address, including the full domain name.  #### CyberSource through VisaNet Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.  **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.  #### Invoicing Email address for the customer for sending the invoice. If the invoice is in SENT status and email is updated, the old email customer payment link won't work and you must resend the invoice with the new payment link.  #### Chase Paymentech Solutions Optional field.  ####  Credit Mutuel-CIC Optional field.  #### OmniPay Direct Optional field.  #### SIX Optional field.  #### TSYS Acquiring Solutions Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.  #### Worldpay VAP Optional field.  #### All other processors Not used. 
    */
    'email'?: string;
    /**
    * Customer’s first name. This name must be the same as the name on the card.  **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.  #### SEPA Required for Create Mandate and Import Mandate #### BACS Required for Import Mandate  #### CyberSource Latin American Processing **Important** For an authorization request, CyberSource Latin American Processing concatenates `orderInformation.billTo.firstName` and `orderInformation.billTo.lastName`. If the concatenated value exceeds 30 characters, CyberSource Latin American Processing declines the authorization request.\\ **Note** CyberSource Latin American Processing is the name of a specific processing connection that CyberSource supports. In the CyberSource API documentation, CyberSource Latin American Processing does not refer to the general topic of processing in Latin America. The information in this field description is for the specific processing connection called _CyberSource Latin American Processing_. It is not for any other Latin American processors that CyberSource supports.  #### CyberSource through VisaNet Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.  #### For Payouts: This field may be sent only for FDC Compass.  #### Chase Paymentech Solutions Optional field.  ####  Credit Mutuel-CIC Optional field.  #### OmniPay Direct Optional field.  #### SIX Optional field.  #### TSYS Acquiring Solutions Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.  #### Worldpay VAP Optional field.  #### All other processors Not used. 
    */
    'firstName'?: string;
    /**
    * Customer’s middle name. 
    */
    'middleName'?: string;
    /**
    * Customer’s last name. This name must be the same as the name on the card.  **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.  #### SEPA Required for Create Mandate and Import Mandate #### BACS Required for Import Mandate #### Chase Paymentech Solutions Optional field.  ####  Credit Mutuel-CIC Optional field.  #### CyberSource Latin American Processing **Important** For an authorization request, CyberSource Latin American Processing concatenates `orderInformation.billTo.firstName` and `orderInformation.billTo.lastName`. If the concatenated value exceeds 30 characters, CyberSource Latin American Processing declines the authorization request.\\ **Note** CyberSource Latin American Processing is the name of a specific processing connection that CyberSource supports. In the CyberSource API documentation, CyberSource Latin American Processing does not refer to the general topic of processing in Latin America. The information in this field description is for the specific processing connection called CyberSource Latin American Processing. It is not for any other Latin American processors that CyberSource supports.  #### CyberSource through VisaNet Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.  #### For Payouts: This field may be sent only for FDC Compass.  #### OmniPay Direct Optional field.  #### RBS WorldPay Atlanta Optional field.  #### SIX Optional field.  #### TSYS Acquiring Solutions Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.  #### Worldpay VAP Optional field.  #### All other processors Not used. 
    */
    'lastName'?: string;
    /**
    * Payment card billing city.  #### SEPA Required for Create Mandate and Import Mandate  #### Atos This field must not contain colons (:).  #### CyberSource through VisaNet Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.  #### For Payouts: This field may be sent only for FDC Compass.  #### Chase Paymentech Solutions Optional field.  ####  Credit Mutuel-CIC Optional field.  #### OmniPay Direct Optional field.  #### SIX Optional field.  #### TSYS Acquiring Solutions Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.  #### Worldpay VAP Optional field.  #### All other processors Not used. 
    */
    'locality'?: string;
    /**
    * Customer’s phone number.  It is recommended that you include the country code when the order is from outside the U.S.  #### Chase Paymentech Solutions Optional field.  ####  Credit Mutuel-CIC Optional field.  #### CyberSource through VisaNet Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.  #### For Payouts: This field may be sent only for FDC Compass.  #### OmniPay Direct Optional field.  #### SIX Optional field.  #### TSYS Acquiring Solutions Optional field.  #### Worldpay VAP Optional field.  #### All other processors Not used. 
    */
    'phoneNumber'?: string;
    /**
    * Postal code for the billing address. The postal code must consist of 5 to 9 digits.  When the billing country is the U.S., the 9-digit postal code must follow this format: [5 digits][dash][4 digits]  **Example** `12345-6789`  When the billing country is Canada, the 6-digit postal code must follow this format: [alpha][numeric][alpha][space][numeric][alpha][numeric]  **Example** `A1B 2C3`  **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.  #### SEPA Required for Create Mandate and Import Mandate  #### For Payouts:  This field may be sent only for FDC Compass.  #### American Express Direct Before sending the postal code to the processor, CyberSource removes all nonalphanumeric characters and, if the remaining value is longer than nine characters, truncates the value starting from the right side.  #### Atos This field must not contain colons (:).  #### CyberSource through VisaNet Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.  #### FDMS Nashville Required if `pointOfSaleInformation.entryMode=keyed` and the address is in the U.S. or Canada. Optional if `pointOfSaleInformation.entryMode=keyed` and the address is **not** in the U.S. or Canada. Not used if swiped.  #### RBS WorldPay Atlanta: For best card-present keyed rates, send the postal code if `pointOfSaleInformation.entryMode=keyed`.  #### TSYS Acquiring Solutions Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.  #### All other processors: Optional field. 
    */
    'postalCode'?: string;
    'title'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "address1",
            "baseName": "address1",
            "type": "string"
        },
        {
            "name": "address2",
            "baseName": "address2",
            "type": "string"
        },
        {
            "name": "administrativeArea",
            "baseName": "administrativeArea",
            "type": "string"
        },
        {
            "name": "buildingNumber",
            "baseName": "buildingNumber",
            "type": "string"
        },
        {
            "name": "company",
            "baseName": "company",
            "type": "string"
        },
        {
            "name": "country",
            "baseName": "country",
            "type": "string"
        },
        {
            "name": "county",
            "baseName": "county",
            "type": "string"
        },
        {
            "name": "district",
            "baseName": "district",
            "type": "string"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "firstName",
            "baseName": "firstName",
            "type": "string"
        },
        {
            "name": "middleName",
            "baseName": "middleName",
            "type": "string"
        },
        {
            "name": "lastName",
            "baseName": "lastName",
            "type": "string"
        },
        {
            "name": "locality",
            "baseName": "locality",
            "type": "string"
        },
        {
            "name": "phoneNumber",
            "baseName": "phoneNumber",
            "type": "string"
        },
        {
            "name": "postalCode",
            "baseName": "postalCode",
            "type": "string"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2billingagreementsOrderInformationBillTo.attributeTypeMap;
    }
}

export class Ptsv2billingagreementsPaymentInformation {
    'card'?: Ptsv2billingagreementsPaymentInformationCard;
    'tokenizedCard'?: Ptsv2billingagreementsPaymentInformationTokenizedCard;
    'paymentType'?: Ptsv2billingagreementsPaymentInformationPaymentType;
    'bank'?: Ptsv2billingagreementsPaymentInformationBank;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "card",
            "baseName": "card",
            "type": "Ptsv2billingagreementsPaymentInformationCard"
        },
        {
            "name": "tokenizedCard",
            "baseName": "tokenizedCard",
            "type": "Ptsv2billingagreementsPaymentInformationTokenizedCard"
        },
        {
            "name": "paymentType",
            "baseName": "paymentType",
            "type": "Ptsv2billingagreementsPaymentInformationPaymentType"
        },
        {
            "name": "bank",
            "baseName": "bank",
            "type": "Ptsv2billingagreementsPaymentInformationBank"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2billingagreementsPaymentInformation.attributeTypeMap;
    }
}

export class Ptsv2billingagreementsPaymentInformationBank {
    'account'?: Ptsv2billingagreementsPaymentInformationBankAccount;
    /**
    * International Bank Account Number (IBAN). #### SEPA Required for mandates services 
    */
    'iban'?: string;
    /**
    * Bank’s SWIFT code. You can use this field only when scoring a direct debit transaction. #### BACS Required for mandates services 
    */
    'swiftCode'?: string;
    /**
    * The scheme that sets the rules for the direct debit process. Possible values:   - SEPA   - BACS #### SEPA/BACS Required for mandates services 
    */
    'scheme'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "account",
            "baseName": "account",
            "type": "Ptsv2billingagreementsPaymentInformationBankAccount"
        },
        {
            "name": "iban",
            "baseName": "iban",
            "type": "string"
        },
        {
            "name": "swiftCode",
            "baseName": "swiftCode",
            "type": "string"
        },
        {
            "name": "scheme",
            "baseName": "scheme",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2billingagreementsPaymentInformationBank.attributeTypeMap;
    }
}

export class Ptsv2billingagreementsPaymentInformationBankAccount {
    /**
    * Customer’s bank account number. #### BACS Required for Create Mandate, Import Mandate, and Update Mandate 
    */
    'number'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "number",
            "baseName": "number",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2billingagreementsPaymentInformationBankAccount.attributeTypeMap;
    }
}

export class Ptsv2billingagreementsPaymentInformationCard {
    /**
    * Two-digit month in which the payment card expires.  Format: `MM`.  Valid values: `01` through `12`. Leading 0 is required.  #### Barclays and Streamline For Maestro (UK Domestic) and Maestro (International) cards on Barclays and Streamline, this must be a valid value (`01` through `12`) but is not required to be a valid expiration date. In other words, an expiration date that is in the past does not cause CyberSource to reject your request. However, an invalid expiration date might cause the issuer to reject your request.  #### Encoded Account Numbers For encoded account numbers (_type_=039), if there is no expiration date on the card, use `12`.  #### FDMS Nashville Required field.  #### All other processors Required if `pointOfSaleInformation.entryMode=keyed`. However, this field is optional if your account is configured for relaxed requirements for address data and expiration date. **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.  #### Google Pay transactions For PAN-based Google Pay transactions, this field is returned in the API response. 
    */
    'expirationMonth'?: string;
    /**
    * Four-digit year in which the payment card expires.  Format: `YYYY`.  #### Barclays and Streamline For Maestro (UK Domestic) and Maestro (International) cards on Barclays and Streamline, this must be a valid value (`1900` through `3000`) but is not required to be a valid expiration date. In other words, an expiration date that is in the past does not cause CyberSource to reject your request. However, an invalid expiration date might cause the issuer to reject your request.  #### Encoded Account Numbers For encoded account numbers (**_type_**`=039`), if there is no expiration date on the card, use `2021`.  #### FDMS Nashville Required field.  #### FDC Nashville Global and FDMS South You can send in 2 digits or 4 digits. If you send in 2 digits, they must be the last 2 digits of the year.  #### All other processors Required if `pointOfSaleInformation.entryMode=keyed`. However, this field is optional if your account is configured for relaxed requirements for address data and expiration date. **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.  #### Google Pay transactions For PAN-based Google Pay transactions, this field is returned in the API response. 
    */
    'expirationYear'?: string;
    /**
    * The customer’s payment card number, also known as the Primary Account Number (PAN). You can also use this field for encoded account numbers.  #### FDMS Nashville Required. String (19)  #### GPX Required if `pointOfSaleInformation.entryMode=keyed`. However, this field is optional if your account is configured for relaxed requirements for address data and expiration date. **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.  #### All other processors Required if `pointOfSaleInformation.entryMode=keyed`. However, this field is optional if your account is configured for relaxed requirements for address data and expiration date. **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting. 
    */
    'number'?: string;
    /**
    * Card Verification Number.  #### FDMS Nashville Required for American Express or if swiped; otherwise, optional.  #### Ingenico ePayments Do not include this field when `commerceIndicator=recurring`. **Note** Ingenico ePayments was previously called _Global Collect_.  #### TSYS Acquiring Solutions Optional if pointOfSaleInformation.entryMode=keyed; otherwise, not used.  #### GPX Optional.  #### All other processors: Optional. 
    */
    'securityCode'?: string;
    /**
    * Three-digit value that indicates the card type.  **IMPORTANT** It is strongly recommended that you include the card type field in request messages even if it is optional for your processor and card type. Omitting the card type can cause the transaction to be processed with the wrong card type.  Possible values: - `001`: Visa. Use card type value `001` for Visa Electron. - `002`: Mastercard, Eurocard[^1], which is a European regional brand of Mastercard. - `003`: American Express - `004`: Discover - `005`: Diners Club - `006`: Carte Blanche[^1] - `007`: JCB[^1] - `008`: Optima - `009`: GE Private Label - `010`: Beneficial Private Label - `011`: Twinpay Credit Card - `012`: Twinpay Debit Card - `013`: WalMart - `014`: Enroute[^1] - `015`: Lowe's Consumer - `016`: Home Depot Consumer - `017`: MBNA - `018`: Dick's Sportswear - `019`: Casual Corner - `020`: Sears - `021`: JAL[^1] - `023`: Disney Card - `024`: Maestro (UK Domestic)[^1] - `025`: Sam's Club Consumer - `026`: Sam's Club Business - `027`: Nico's - `028`: Paymentech Bill Me Later - `029`: Bebe - `030`: Restoration Hardware - `031`: Delta Online - `032`: Solo - `033`: Visa Electron[^1]. Do not use this value. Use `001` for all Visa card types. - `034`: Dankort[^1] - `035`: Laser - `036`: Cartes Bancaires[^1,4] - `037`: Carta Si[^1] - `038`: Pinless Debit - `039`: Encoded account number[^1] - `040`: UATP[^1] - `041`: HOUSEHOLD - `042`: Maestro (International)[^1] - `043`: GE MONEY - `044`: Korean Cards - `045`: Style Cards - `046`: JCrew - `047`: Payeasecn eWallet - `048`: Payeasecn Bank Transfer - `049`: Meijer - `050`: Hipercard[^2,3] - `051`: Aura - `052`: Redecard - `053`: Orico card - `054`: Elo[^3] - `055`: Capitol One Private Label - `056`: Carnet - `057`: Costco Private Label - `058`: Carnet - `059`: ValueLink - `060`: MADA - `061`: RuPay - `062`: China UnionPay - `063`: Falabella Private Label - `064`: Prompt Card - `065`: Korean Domestic - `066`: Banricompras - `067`: MEEZA - `068`: PayPak - `070`: EFTPOS - `071`: Codensa - `072`: Olimpica - `073`: Colsubsidio - `074`: Tuya - `075`: Sodexo - `076`: Naranja - `077`: Cabal - `078`: DINELCO - `079`: PANAL - `080`: EPM - `081`: Jaywan  [^1]: For this card type, you must include the `paymentInformation.card.type` or `paymentInformation.tokenizedCard.type` field in your request for an authorization or a stand-alone credit. [^2]: For this card type on Cielo 3.0, you must include the `paymentInformation.card.type` or `paymentInformation.tokenizedCard.type` field in a request for an authorization or a stand-alone credit. This card type is not supported on Cielo 1.5. [^3]: For this card type on Getnet and Rede, you must include the `paymentInformation.card.type` or `paymentInformation.tokenizedCard.type` field in a request for an authorization or a stand-alone credit. [^4]: For this card type, you must include the `paymentInformation.card.type` in your request for any payer authentication services.  #### Used by **Authorization** Required for Carte Blanche and JCB. Optional for all other card types.  #### Card Present reply This field is included in the reply message when the client software that is installed on the POS terminal uses the token management service (TMS) to retrieve tokenized payment details. You must contact customer support to have your account enabled to receive these fields in the credit reply message.  Returned by the Credit service.  This reply field is only supported by the following processors: - American Express Direct - Credit Mutuel-CIC - FDC Nashville Global - OmniPay Direct - SIX  #### Google Pay transactions For PAN-based Google Pay transactions, this field is returned in the API response.  #### GPX This field only supports transactions from the following card types: - Visa - Mastercard - AMEX - Discover - Diners - JCB - Union Pay International 
    */
    'type'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "expirationMonth",
            "baseName": "expirationMonth",
            "type": "string"
        },
        {
            "name": "expirationYear",
            "baseName": "expirationYear",
            "type": "string"
        },
        {
            "name": "number",
            "baseName": "number",
            "type": "string"
        },
        {
            "name": "securityCode",
            "baseName": "securityCode",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2billingagreementsPaymentInformationCard.attributeTypeMap;
    }
}

export class Ptsv2billingagreementsPaymentInformationPaymentType {
    'method'?: Ptsv2billingagreementsPaymentInformationPaymentTypeMethod;
    /**
    * A Payment Type is an agreed means for a payee to receive legal tender from a payer. The way one pays for a commercial financial transaction. Examples: Card, Bank Transfer, Digital, Direct Debit. Possible values: - `EWALLET` - `directDebitSepa` - `directDebitBacs` #### SEPA/BACS Required for mandates services #### Paypal Required for billing agreements 
    */
    'name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "method",
            "baseName": "method",
            "type": "Ptsv2billingagreementsPaymentInformationPaymentTypeMethod"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2billingagreementsPaymentInformationPaymentType.attributeTypeMap;
    }
}

export class Ptsv2billingagreementsPaymentInformationPaymentTypeMethod {
    /**
    * Identifier for the payment type. Possible Values:    - SENTENIAL   - PAYPAL #### SEPA/BACS Required for mandates services #### Paypal Required for billing agreements 
    */
    'name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2billingagreementsPaymentInformationPaymentTypeMethod.attributeTypeMap;
    }
}

export class Ptsv2billingagreementsPaymentInformationTokenizedCard {
    /**
    * This field contains token information.
    */
    'cryptogram'?: string;
    /**
    * One of two possible meanings: - The two-digit month in which a token expires. - The two-digit month in which a card expires. Format: `MM` Possible values: `01` through `12`  **NOTE** The meaning of this field is dependent on the payment processor that is returning the value in an authorization reply. Please see the processor-specific details below.  #### Barclays and Streamline For Maestro (UK Domestic) and Maestro (International) cards on Barclays and Streamline, this must be a valid value (`01` through `12`) but is not required to be a valid expiration date. In other words, an expiration date that is in the past does not cause CyberSource to reject your request. However, an invalid expiration date might cause the issuer to reject your request.  #### Encoded Account Numbers For encoded account numbers (`card_type=039`), if there is no expiration date on the card, use `12`.\\ **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.  #### Samsung Pay and Apple Pay Month in which the token expires. CyberSource includes this field in the reply message when it decrypts the payment blob for the tokenized transaction. 
    */
    'expirationMonth'?: string;
    /**
    * One of two possible meanings: - The four-digit year in which a token expires. - The four-digit year in which a card expires. Format: `YYYY` Possible values: `1900` through `3000` Data type: Non-negative integer  **NOTE** The meaning of this field is dependent on the payment processor that is returning the value in an authorization reply. Please see the processor-specific details below.  #### Barclays and Streamline For Maestro (UK Domestic) and Maestro (International) cards on Barclays and Streamline, this must be a valid value (1900 through 3000) but is not required to be a valid expiration date. In other words, an expiration date that is in the past does not cause CyberSource to reject your request. However, an invalid expiration date might cause the issuer to reject your request.  #### Encoded Account Numbers For encoded account numbers (`card_ type=039`), if there is no expiration date on the card, use `2021`.  #### FDC Nashville Global and FDMS South You can send in 2 digits or 4 digits. When you send in 2 digits, they must be the last 2 digits of the year.  #### Samsung Pay and Apple Pay Year in which the token expires. CyberSource includes this field in the reply message when it decrypts the payment blob for the tokenized transaction.  **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting. 
    */
    'expirationYear'?: string;
    /**
    * Customer’s payment network token value. 
    */
    'number'?: string;
    /**
    * Type of transaction that provided the token data. This value does not specify the token service provider; it specifies the entity that provided you with information about the token.  Possible value: - `2`: Near-field communication (NFC) transaction. The customer’s mobile device provided the token data for a contactless EMV transaction. For recurring transactions, use this value if the original transaction was a contactless EMV transaction.  #### Visa Platform Connect - `1`: For Rupay and In App tokenization. Example: InApp apple pay. - `3`: Card/Credential On File Tokenization.  **NOTE** No CyberSource through VisaNet acquirers support EMV at this time.  Required field for PIN debit credit or PIN debit purchase transactions that use payment network tokens; otherwise, not used.  #### Rupay - `3`: Card/Credential On File Tokenization. - `4`: Tokenizined Transaction. Should be used for Guest Checkout transactions with token. 
    */
    'transactionType'?: string;
    /**
    * Three-digit value that indicates the card type.  **IMPORTANT** It is strongly recommended that you include the card type field in request messages even if it is optional for your processor and card type. Omitting the card type can cause the transaction to be processed with the wrong card type.  Possible values: - `001`: Visa. Use card type value `001` for Visa Electron. - `002`: Mastercard, Eurocard[^1], which is a European regional brand of Mastercard. - `003`: American Express - `004`: Discover - `005`: Diners Club - `006`: Carte Blanche[^1] - `007`: JCB[^1] - `008`: Optima - `009`: GE Private Label - `010`: Beneficial Private Label - `011`: Twinpay Credit Card - `012`: Twinpay Debit Card - `013`: WalMart - `014`: Enroute[^1] - `015`: Lowe's Consumer - `016`: Home Depot Consumer - `017`: MBNA - `018`: Dick's Sportswear - `019`: Casual Corner - `020`: Sears - `021`: JAL[^1] - `023`: Disney Card - `024`: Maestro (UK Domestic)[^1] - `025`: Sam's Club Consumer - `026`: Sam's Club Business - `027`: Nico's - `028`: Paymentech Bill Me Later - `029`: Bebe - `030`: Restoration Hardware - `031`: Delta Online - `032`: Solo - `033`: Visa Electron[^1]. Do not use this value. Use `001` for all Visa card types. - `034`: Dankort[^1] - `035`: Laser - `036`: Cartes Bancaires[^1,4] - `037`: Carta Si[^1] - `038`: Pinless Debit - `039`: Encoded account number[^1] - `040`: UATP[^1] - `041`: HOUSEHOLD - `042`: Maestro (International)[^1] - `043`: GE MONEY - `044`: Korean Cards - `045`: Style Cards - `046`: JCrew - `047`: Payeasecn eWallet - `048`: Payeasecn Bank Transfer - `049`: Meijer - `050`: Hipercard[^2,3] - `051`: Aura - `052`: Redecard - `053`: Orico card - `054`: Elo[^3] - `055`: Capitol One Private Label - `056`: Carnet - `057`: Costco Private Label - `058`: Carnet - `059`: ValueLink - `060`: MADA - `061`: RuPay - `062`: China UnionPay - `063`: Falabella Private Label - `064`: Prompt Card - `065`: Korean Domestic - `066`: Banricompras - `067`: MEEZA - `068`: PayPak - `070`: EFTPOS - `071`: Codensa - `072`: Olimpica - `073`: Colsubsidio - `074`: Tuya - `075`: Sodexo - `076`: Naranja - `077`: Cabal - `078`: DINELCO - `079`: PANAL - `080`: EPM - `081`: Jaywan  [^1]: For this card type, you must include the `paymentInformation.card.type` or `paymentInformation.tokenizedCard.type` field in your request for an authorization or a stand-alone credit. [^2]: For this card type on Cielo 3.0, you must include the `paymentInformation.card.type` or `paymentInformation.tokenizedCard.type` field in a request for an authorization or a stand-alone credit. This card type is not supported on Cielo 1.5. [^3]: For this card type on Getnet and Rede, you must include the `paymentInformation.card.type` or `paymentInformation.tokenizedCard.type` field in a request for an authorization or a stand-alone credit. [^4]: For this card type, you must include the `paymentInformation.card.type` in your request for any payer authentication services.  #### Used by **Authorization** Required for Carte Blanche and JCB. Optional for all other card types.  #### Card Present reply This field is included in the reply message when the client software that is installed on the POS terminal uses the token management service (TMS) to retrieve tokenized payment details. You must contact customer support to have your account enabled to receive these fields in the credit reply message.  Returned by the Credit service.  This reply field is only supported by the following processors: - American Express Direct - Credit Mutuel-CIC - FDC Nashville Global - OmniPay Direct - SIX  #### Google Pay transactions For PAN-based Google Pay transactions, this field is returned in the API response.  #### GPX This field only supports transactions from the following card types: - Visa - Mastercard - AMEX - Discover - Diners - JCB - Union Pay International 
    */
    'type'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "cryptogram",
            "baseName": "cryptogram",
            "type": "string"
        },
        {
            "name": "expirationMonth",
            "baseName": "expirationMonth",
            "type": "string"
        },
        {
            "name": "expirationYear",
            "baseName": "expirationYear",
            "type": "string"
        },
        {
            "name": "number",
            "baseName": "number",
            "type": "string"
        },
        {
            "name": "transactionType",
            "baseName": "transactionType",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2billingagreementsPaymentInformationTokenizedCard.attributeTypeMap;
    }
}

export class Ptsv2billingagreementsProcessingInformation {
    /**
    * Type of transaction. Used to determine fees based on channel.  Possible values:    - aesk: American Express SafeKey authentication was successful.   - aesk_attempted: American Express SafeKey authentication was attempted but did not succeed. • install: Installment payment.   - install_internet: Non-U.S. e-commerce (Internet) installment payment. This value is supported only on Visa Platform Connect.   - internet (default for authorizations): E-commerce order placed using a web site.   - js: JCB J/Secure authentication was successful.   - js_attempted: JCB J/Secure authentication was attempted but did not succeed.   - moto: Mail order or telephone order.   - moto_cc: Mail order or telephone order from a call center. This value is supported only on the Asia, Middle East, and Africa Gateway.   - pb: ProtectBuy authentication was successful.   - pb_attempted: ProtectBuy authentication was attempted but did not succeed.   - recurring: Recurring payment that is a U.S. transaction or non-U.S. mail order / telephone order (MOTO) transaction.   - recurring_internet: Recurring payment that is a non-U.S. e-commerce (Internet) transaction.   - retail: Card-present transaction.   - spa: For Mastercard Identity Check: Authentication was successful or was attempted but did not succeed. The e-commerce indicator for all Mastercard Identity Check transactions, including authentication attempts, must be set to spa.   - spa_attempted: Authentication for a co-badged Mastercard and Cartes Bancaires card was attempted but did not succeed.   - spa_failure: – For Mastercard Identity Check: Authentication failed. This value is supported only on Elavon, HSBC, and Streamline.   - vbv: – For Visa Secure: Authentication was successful.   - vbv_attempted: – For Visa Secure: Authentication was attempted but did not succeed.   - vbv_failure: – For Visa Secure: Authentication failed. This value is supported only on HSBC and Streamline. 
    */
    'commerceIndicator'?: string;
    /**
    * - Use `CONSUMER_AUTHENTICATION` to use Payer Authentication along with Decision Manager. For any other value, only Decision Manager will run. - Use `WATCHLIST_SCREENING`  when you want to call Watchlist Screening service. - Use `UPDATE_AGREEMENT` - Use `BILLING_AGREEMENT_CREATE` when Alternative Payment create mandate service is requested - Use `CANCEL_AGREEMENT` - Use `AP_IMPORT_AGREEMENT` when Alternative Payment import mandate service is requested. 
    */
    'actionList'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "commerceIndicator",
            "baseName": "commerceIndicator",
            "type": "string"
        },
        {
            "name": "actionList",
            "baseName": "actionList",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2billingagreementsProcessingInformation.attributeTypeMap;
    }
}

export class Ptsv2billingagreementsidAgreementInformation {
    /**
    * Identifier for the mandate. #### SEPA/BACS Required for mandates services 
    */
    'id'?: string;
    'eSignIndicator'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "eSignIndicator",
            "baseName": "eSignIndicator",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2billingagreementsidAgreementInformation.attributeTypeMap;
    }
}

export class Ptsv2billingagreementsidBuyerInformation {
    /**
    * Recipient’s date of birth. **Format**: `YYYYMMDD`.  This field is a `pass-through`, which means that CyberSource ensures that the value is eight numeric characters but otherwise does not verify the value or modify it in any way before sending it to the processor. If the field is not required for the transaction, CyberSource does not forward it to the processor. 
    */
    'dateOfBirth'?: string;
    /**
    * Customer's gender. Possible values are F (female), M (male), O (other).
    */
    'gender'?: string;
    /**
    * language setting of the user
    */
    'language'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "dateOfBirth",
            "baseName": "dateOfBirth",
            "type": "string"
        },
        {
            "name": "gender",
            "baseName": "gender",
            "type": "string"
        },
        {
            "name": "language",
            "baseName": "language",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2billingagreementsidBuyerInformation.attributeTypeMap;
    }
}

export class Ptsv2billingagreementsidProcessingInformation {
    /**
    * Type of transaction. Used to determine fees based on channel.  Possible values:    - aesk: American Express SafeKey authentication was successful.   - aesk_attempted: American Express SafeKey authentication was attempted but did not succeed. • install: Installment payment.   - install_internet: Non-U.S. e-commerce (Internet) installment payment. This value is supported only on Visa Platform Connect.   - internet (default for authorizations): E-commerce order placed using a web site.   - js: JCB J/Secure authentication was successful.   - js_attempted: JCB J/Secure authentication was attempted but did not succeed.   - moto: Mail order or telephone order.   - moto_cc: Mail order or telephone order from a call center. This value is supported only on the Asia, Middle East, and Africa Gateway.   - pb: ProtectBuy authentication was successful.   - pb_attempted: ProtectBuy authentication was attempted but did not succeed.   - recurring: Recurring payment that is a U.S. transaction or non-U.S. mail order / telephone order (MOTO) transaction.   - recurring_internet: Recurring payment that is a non-U.S. e-commerce (Internet) transaction.   - retail: Card-present transaction.   - spa: For Mastercard Identity Check: Authentication was successful or was attempted but did not succeed. The e-commerce indicator for all Mastercard Identity Check transactions, including authentication attempts, must be set to spa.   - spa_attempted: Authentication for a co-badged Mastercard and Cartes Bancaires card was attempted but did not succeed.   - spa_failure: – For Mastercard Identity Check: Authentication failed. This value is supported only on Elavon, HSBC, and Streamline.   - vbv: – For Visa Secure: Authentication was successful.   - vbv_attempted: – For Visa Secure: Authentication was attempted but did not succeed.   - vbv_failure: – For Visa Secure: Authentication failed. This value is supported only on HSBC and Streamline. 
    */
    'commerceIndicator'?: string;
    /**
    * - Use `CONSUMER_AUTHENTICATION` to use Payer Authentication along with Decision Manager. For any other value, only Decision Manager will run. - Use `WATCHLIST_SCREENING`  when you want to call Watchlist Screening service. - Use `BILLING_AGREEMENT_CREATE` when Paypal billing agreements service is requested. - Use `UPDATE_AGREEMENT` - Use `CANCEL_AGREEMENT` - Use `AP_UPDATE_AGREEMENT` when Alternative Payment update mandate service is requested. - Use `AP_CANCEL_AGREEMENT` when Alternative Payment revoke mandate service is requested. - Use `AP_REFRESH_AGREEMENT_STATUS` when Alternative Payment mandate status service is requested. 
    */
    'actionList'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "commerceIndicator",
            "baseName": "commerceIndicator",
            "type": "string"
        },
        {
            "name": "actionList",
            "baseName": "actionList",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2billingagreementsidProcessingInformation.attributeTypeMap;
    }
}

export class Ptsv2creditsInstallmentInformation {
    /**
    * #### American Express Direct, Cielo, and CyberSource Latin American Processing Flag that indicates the type of funding for the installment plan associated with the payment.  Possible values: - `1`: Merchant-funded installment plan - `2`: Issuer-funded installment plan If you do not include this field in the request, CyberSource uses the value in your CyberSource account.  To change the value in your CyberSource account, contact CyberSource Customer Service.  #### CyberSource through VisaNet and American Express Defined code that indicates the type of installment plan for this transaction.  Contact American Express for: - Information about the kinds of installment plans that American Express provides - Values for this field  For installment payments with American Express in Brazil, the value for this field corresponds to the following data in the TC 33 capture file*: - Record: CP07 TCR3 - Position: 5-6 - Field: Plan Type  * The TC 33 Capture file contains information about the purchases and refunds that a merchant submits to CyberSource. CyberSource through VisaNet creates the TC 33 Capture file at the end of the day and sends it to the merchant’s acquirer, who uses this information to facilitate end-of-day clearing processing with payment card companies.  #### CyberSource through VisaNet with Visa or Mastercard Flag indicating the type of funding for the installment plan associated with the payment. Possible values: - 1 or 01: Merchant-funded installment plan - 2 or 02: Issuer-funded installment plan - 43: Crediario installment plan—only with Visa in Brazil  For installment payments with Visa in Brazil, the value for this field corresponds to the following data in the TC 33 capture file5: - Record: CP07 TCR1 - Position: 5-6 - Field: Installment Type  For all other kinds of installment payments, the value for this field corresponds to the following data in the TC 33 capture file5: - Record: CP01 TCR5 - Position: 39-40 - Field: Installment Plan Type (Issuer or Merchant) 
    */
    'planType'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "planType",
            "baseName": "planType",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2creditsInstallmentInformation.attributeTypeMap;
    }
}

export class Ptsv2creditsProcessingInformation {
    /**
    * Type of transaction. Some payment card companies use this information when determining discount rates.  #### Used by **Authorization** Required payer authentication transactions; otherwise, optional. **Credit** Required for standalone credits on Chase Paymentech solutions; otherwise, optional.  The list of valid values in this field depends on your processor.  #### Ingenico ePayments When you omit this field for Ingenico ePayments, the processor uses the default transaction type they have on file for you instead of the default value   #### Card Present You must set this field to `retail`. This field is required for a card-present transaction. Note that this should ONLY be used when the cardholder and card are present at the time of the transaction. For all keyed transactions originated from a POS terminal where the cardholder and card are not present, commerceIndicator should be submitted as “moto\" 
    */
    'commerceIndicator'?: string;
    /**
    * Value that identifies the processor/acquirer to use for the transaction. This value is supported only for **CyberSource through VisaNet**.  Contact CyberSource Customer Support to get the value for this field. 
    */
    'processorId'?: string;
    /**
    * Type of digital payment solution for the transaction. Possible Values:   - `visacheckout`: Visa Checkout. This value is required for Visa Checkout transactions. For details, see `payment_solution` field description in [Visa Checkout Using the REST API.](https://developer.cybersource.com/content/dam/docs/cybs/en-us/apifields/reference/all/rest/api-fields.pdf)  - `001`: Apple Pay.  - `004`: Cybersource In-App Solution.  - `005`: Masterpass. This value is required for Masterpass transactions on OmniPay Direct.   - `006`: Android Pay.  - `007`: Chase Pay.  - `008`: Samsung Pay.  - `012`: Google Pay.  - `013`: Cybersource P2PE Decryption  - `014`: Mastercard credential on file (COF) payment network token. Returned in authorizations that use a payment network token associated with a TMS token.  - `015`: Visa credential on file (COF) payment network token. Returned in authorizations that use a payment network token associated with a TMS token.  - `027`: Click to Pay. 
    */
    'paymentSolution'?: string;
    /**
    * Please check with Cybersource customer support to see if your merchant account is configured correctly so you can include this field in your request. * For Payouts: max length for FDCCompass is String (22). 
    */
    'reconciliationId'?: string;
    /**
    * Value that links the current authorization request to the original authorization request. Set this value to the ID that was returned in the reply message from the original authorization request.  This value is used for:  - Partial authorizations - Split shipments 
    */
    'linkId'?: string;
    /**
    * Attribute that lets you define custom grouping for your processor reports. This field is supported only for **Worldpay VAP**. 
    */
    'reportGroup'?: string;
    /**
    * Identifier for the **Visa Checkout** order. Visa Checkout provides a unique order ID for every transaction in the Visa Checkout **callID** field. 
    */
    'visaCheckoutId'?: string;
    /**
    * Set this field to 3 to indicate that the request includes Level III data.
    */
    'purchaseLevel'?: string;
    /**
    * Indicates that the transaction includes industry-specific data.  Possible Values: - `airline` - `restaurant` - `lodging` - `auto_rental` - `transit` - `healthcare_medical` - `healthcare_transit` - `transit`  #### Card Present, Airlines and Auto Rental You must set this field to `airline` in order for airline data to be sent to the processor. For example, if this field is not set to `airline` or is not included in the request, no airline data is sent to the processor.  You must set this field to `restaurant` in order for restaurant data to be sent to the processor. When this field is not set to `restaurant` or is not included in the request, no restaurant data is sent to the processor.  You must set this field to `auto_rental` in order for auto rental data to be sent to the processor. For example, if this field is not set to `auto_rental` or is not included in the request, no auto rental data is sent to the processor.  Restaurant data is supported only on CyberSource through VisaNet. 
    */
    'industryDataType'?: string;
    /**
    * This field carries the wallet type in authorization requests and credit requests. Possible value are: - `101`: Masterpass remote payment. The customer created the wallet by manually interacting with a customer-controlled device such as a computer, tablet, or phone. This value is supported only for Masterpass transactions on Chase Paymentech Solutions and CyberSource through VisaNet. - `102`: Masterpass remote near field communication (NFC) payment. The customer created the wallet by tapping a PayPass card or customer-controlled device at a contactless card reader. This value is supported only for card-present Masterpass transactions on CyberSource through VisaNet. - `103`: Masterpass Apple Pay payment. The payment was made with a combination of Masterpass and Apple Pay. This value is supported only for Masterpass Apple Pay transactions on CyberSource through VisaNet. - `216`: Masterpass Google Pay payment. The payment was made with a combination of Masterpass and Google Pay. This value is supported only for Masterpass Google Pay transactions on CyberSource through VisaNet. - `217`: Masterpass Samsung Pay payment. The payment was made with a combination of Masterpass and Samsung Pay. This value is supported only for Masterpass Samsung Pay transactions on CyberSource through VisaNet. - `SDW`: Staged digital wallet. An issuer or operator created the wallet. This value is supported only for Masterpass transactions on Chase Paymentech Solutions. - `VCIND`: Visa Checkout payment. This value is supported only on CyberSource through VisaNet, FDC Compass, FDC Nashville Global, FDI Australia, and TSYS Acquiring Solutions. See Getting Started with Visa Checkout. For Visa Checkout transactions, the way CyberSource processes the value for this field depends on the processor. See the Visa Checkout section below. For all other values, this field is a passthrough; therefore, CyberSource does not verify the value or modify it in any way before sending it to the processor. Masterpass (101, 102, 103, 216, and 217): The Masterpass platform generates the wallet type value and passes it to you along with the customer’s checkout information.  Visa Checkout: This field is optional for Visa Checkout authorizations on FDI Australia. For all other processors, this field is required for Visa Checkout authorizations. For Visa Checkout transactions on the following processors, CyberSource sends the value that the processor expects for this field:FDC Compass,FDC Nashville Global,FDI Australia,TSYS Acquiring Solutions For all other processors, this field is a passthrough; therefore, CyberSource does not verify the value or modify it in any way before sending it to the processor. For incremental authorizations, this field is supported only for Mastercard and the supported values are 101 and 102. Payment card companies can introduce new values without notice. Your order management system should be able to process new values without problems.  CyberSource through VisaNet When the value for this field is 101, 102, 103, 216, or 217, it corresponds to the following data in the TC 33 capture file5: Record: CP01 TCR6, Position: 88-90,  Field: Mastercard Wallet Identifier. When the value for this field is VCIND, it corresponds to the following data in the TC 33 capture file5: Record: CP01 TCR8, Position: 72-76, Field: Agent Unique ID. 
    */
    'walletType'?: string;
    /**
    * Supplementary domestic transaction information provided by the acquirer for National Net Settlement Service (NNSS) transactions. NNSS is a settlement service that Visa provides. For transactions on CyberSource through VisaNet in countries that subscribe to NNSS: VisaNet clears transactions; VisaNet transfers funds to the acquirer after deducting processing fees and interchange fees. VisaNet settles transactions in the local pricing currency through a local financial institution. This field is supported only on CyberSource through VisaNet for domestic data in Colombia 
    */
    'nationalNetDomesticData'?: string;
    /**
    * On PIN Debit Gateways: This U.S.-only field is optionally used by  participants (merchants and acquirers) to specify the network access priority. VisaNet checks to determine if there are issuer routing preferences for any of the networks specified by the sharing group code. If an issuer preference exists for one of the specified debit networks, VisaNet makes a routing selection based on the issuer’s preference. If an issuer preference exists for more than one of the specified debit networks, or if no issuer preference exists, VisaNet makes a selection based on the acquirer’s routing priorities.  #### PIN debit Priority order of the networks through which he transaction will be routed. Set this value to a series of one-character network codes in your preferred order. This is a list of the network codes:  | Network | Code | | --- | --- | | Accel | E | | AFFN | U | | Alaska Option | 3 | | CU24 | C | | Interlink | G | | Maestro | 8 | | NETS | P | | NYCE | F | | Pulse | H | | Shazam | 7 | | Star | M | | Visa | V |  For example, if the Star network is your first preference and Pulse is your second preference, set this field to a value of `MH`.  When you do not include this value in your PIN debit request, the list of network codes from your account is used. **Note** This field is supported only for businesses located in the U.S.  Optional field for PIN debit credit or PIN debit purchase. 
    */
    'networkRoutingOrder'?: string;
    'recurringOptions'?: Ptsv2paymentsidrefundsProcessingInformationRecurringOptions;
    'bankTransferOptions'?: Ptsv2creditsProcessingInformationBankTransferOptions;
    'purchaseOptions'?: Ptsv2creditsProcessingInformationPurchaseOptions;
    'electronicBenefitsTransfer'?: Ptsv2creditsProcessingInformationElectronicBenefitsTransfer;
    'loanOptions'?: Ptsv2paymentsProcessingInformationLoanOptions;
    'japanPaymentOptions'?: Ptsv2creditsProcessingInformationJapanPaymentOptions;
    'refundOptions'?: Ptsv2creditsProcessingInformationRefundOptions;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "commerceIndicator",
            "baseName": "commerceIndicator",
            "type": "string"
        },
        {
            "name": "processorId",
            "baseName": "processorId",
            "type": "string"
        },
        {
            "name": "paymentSolution",
            "baseName": "paymentSolution",
            "type": "string"
        },
        {
            "name": "reconciliationId",
            "baseName": "reconciliationId",
            "type": "string"
        },
        {
            "name": "linkId",
            "baseName": "linkId",
            "type": "string"
        },
        {
            "name": "reportGroup",
            "baseName": "reportGroup",
            "type": "string"
        },
        {
            "name": "visaCheckoutId",
            "baseName": "visaCheckoutId",
            "type": "string"
        },
        {
            "name": "purchaseLevel",
            "baseName": "purchaseLevel",
            "type": "string"
        },
        {
            "name": "industryDataType",
            "baseName": "industryDataType",
            "type": "string"
        },
        {
            "name": "walletType",
            "baseName": "walletType",
            "type": "string"
        },
        {
            "name": "nationalNetDomesticData",
            "baseName": "nationalNetDomesticData",
            "type": "string"
        },
        {
            "name": "networkRoutingOrder",
            "baseName": "networkRoutingOrder",
            "type": "string"
        },
        {
            "name": "recurringOptions",
            "baseName": "recurringOptions",
            "type": "Ptsv2paymentsidrefundsProcessingInformationRecurringOptions"
        },
        {
            "name": "bankTransferOptions",
            "baseName": "bankTransferOptions",
            "type": "Ptsv2creditsProcessingInformationBankTransferOptions"
        },
        {
            "name": "purchaseOptions",
            "baseName": "purchaseOptions",
            "type": "Ptsv2creditsProcessingInformationPurchaseOptions"
        },
        {
            "name": "electronicBenefitsTransfer",
            "baseName": "electronicBenefitsTransfer",
            "type": "Ptsv2creditsProcessingInformationElectronicBenefitsTransfer"
        },
        {
            "name": "loanOptions",
            "baseName": "loanOptions",
            "type": "Ptsv2paymentsProcessingInformationLoanOptions"
        },
        {
            "name": "japanPaymentOptions",
            "baseName": "japanPaymentOptions",
            "type": "Ptsv2creditsProcessingInformationJapanPaymentOptions"
        },
        {
            "name": "refundOptions",
            "baseName": "refundOptions",
            "type": "Ptsv2creditsProcessingInformationRefundOptions"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2creditsProcessingInformation.attributeTypeMap;
    }
}

export class Ptsv2creditsProcessingInformationBankTransferOptions {
    /**
    * Payment related information.  This information is included on the customer’s statement. 
    */
    'customerMemo'?: string;
    /**
    * Specifies the authorization method for the transaction.  #### TeleCheck Accepts only the following values: - `ARC`: account receivable conversion - `CCD`: corporate cash disbursement - `POP`: point of purchase conversion - `PPD`: prearranged payment and deposit entry - `TEL`: telephone-initiated entry - `WEB`: internet-initiated entry 
    */
    'secCode'?: string;
    /**
    * City in which the terminal is located. If more than four alphanumeric characters are submitted, the transaction will be declined.  You cannot include any special characters. 
    */
    'terminalCity'?: string;
    /**
    * State in which the terminal is located. If more than two alphanumeric characters are submitted, the transaction will be declined.  You cannot include any special characters. 
    */
    'terminalState'?: string;
    /**
    * Effective date for the transaction. The effective date must be within 45 days of the current day. If you do not include this value, CyberSource sets the effective date to the next business day.  Format: `MMDDYYYY`  Supported only for the CyberSource ACH Service. 
    */
    'effectiveDate'?: string;
    /**
    * Identifier for a partial payment or partial credit.  The value for each debit request or credit request must be unique within the scope of the order. 
    */
    'partialPaymentId'?: string;
    /**
    * Method used for settlement.  Possible values: - `A`: Automated Clearing House (default for credits and for transactions using Canadian dollars) - `F`: Facsimile draft (U.S. dollars only) - `B`: Best possible (U.S. dollars only) (default if the field has not already been configured for your merchant ID) 
    */
    'settlementMethod'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "customerMemo",
            "baseName": "customerMemo",
            "type": "string"
        },
        {
            "name": "secCode",
            "baseName": "secCode",
            "type": "string"
        },
        {
            "name": "terminalCity",
            "baseName": "terminalCity",
            "type": "string"
        },
        {
            "name": "terminalState",
            "baseName": "terminalState",
            "type": "string"
        },
        {
            "name": "effectiveDate",
            "baseName": "effectiveDate",
            "type": "string"
        },
        {
            "name": "partialPaymentId",
            "baseName": "partialPaymentId",
            "type": "string"
        },
        {
            "name": "settlementMethod",
            "baseName": "settlementMethod",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2creditsProcessingInformationBankTransferOptions.attributeTypeMap;
    }
}

export class Ptsv2creditsProcessingInformationElectronicBenefitsTransfer {
    /**
    * Flag that specifies the category for the EBT transaction.  Possible values: - `CASH`: Cash benefits, which can be used to purchase any item at a participating retailer, as well as to obtain cash-back or make a cash withdrawal from a participating ATM. - `FOOD`: Food stamp benefits, which can be used only to purchase food items authorized by the USDA SNAP program.  #### PIN debit Required field for EBT transactions that use PIN debit credit or PIN debit purchase; otherwise, not used. 
    */
    'category'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "category",
            "baseName": "category",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2creditsProcessingInformationElectronicBenefitsTransfer.attributeTypeMap;
    }
}

export class Ptsv2creditsProcessingInformationJapanPaymentOptions {
    /**
    * This value is a 2-digit code indicating the payment method. Use Payment Method Code value that applies to the tranasction. - 10 (One-time payment) - 21, 22, 23, 24  (Bonus(one-time)payment) - 61 (Installment payment) - 31, 32, 33, 34  (Integrated (Bonus + Installment)payment) - 80 (Revolving payment) 
    */
    'paymentMethod'?: string;
    /**
    * Number of Installments. 
    */
    'installments'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "paymentMethod",
            "baseName": "paymentMethod",
            "type": "string"
        },
        {
            "name": "installments",
            "baseName": "installments",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2creditsProcessingInformationJapanPaymentOptions.attributeTypeMap;
    }
}

export class Ptsv2creditsProcessingInformationPurchaseOptions {
    /**
    * Flag that indicates whether this transaction is an EBT transaction. Possible values: - `true` - `false`  #### PIN debit Required field for EBT and EBT voucher transactions that use PIN debit credit or PIN debit purchase; otherwise, not used. 
    */
    'isElectronicBenefitsTransfer'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "isElectronicBenefitsTransfer",
            "baseName": "isElectronicBenefitsTransfer",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2creditsProcessingInformationPurchaseOptions.attributeTypeMap;
    }
}

export class Ptsv2creditsProcessingInformationRefundOptions {
    /**
    * Must be set to `pow` for Mastercard Gaming Payment of Winnings tranactions.
    */
    'reason'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "reason",
            "baseName": "reason",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2creditsProcessingInformationRefundOptions.attributeTypeMap;
    }
}

export class Ptsv2creditsRecipientInformation {
    /**
    * First name of recipient of the funds. * Required for Mastercard Payment of Winnings (POW) transactions. * Must not be all numeric. * Must contain only ASCII characters in range 32-122. * Must not be greater than 35 characters including spaces. * Required for POW on Barclays 
    */
    'firstName'?: string;
    /**
    * Last name of recipient of the funds. * Required for Mastercard Payment of Winnings (POW) transactions. * Must not be all numeric. * Must contain only ASCII characters in range 32-122. * Must not be greater than 35 characters including spaces. * Required for POW on Barclays 
    */
    'lastName'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "firstName",
            "baseName": "firstName",
            "type": "string"
        },
        {
            "name": "lastName",
            "baseName": "lastName",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2creditsRecipientInformation.attributeTypeMap;
    }
}

export class Ptsv2creditsSenderInformation {
    /**
    * First name of the sender of the funds. For Gaming Payment of Winnings transactions these are the merchant details. * Required for Mastercard Payment of Winnings (POW) transactions. * Must not be all numeric. * Must contain only ASCII characters in range 32-122. * Must not be greater than 35 characters including spaces. * Required for POW on Barclays. 
    */
    'firstName'?: string;
    /**
    * Last name of the sender of the funds. For Gaming Payment of Winnings transactions these are the merchant details. * Optional for Mastercard Payment of Winnings (POW) transactions. * Must not be all numeric. * Must contain only ASCII characters in range 32-122. * Must not be greater than 35 characters including spaces. * Optional for POW on Barclays. 
    */
    'lastName'?: string;
    /**
    * Street address of the sender of the funds. For Gaming Payment of Winnings transactions these are the merchant details. * Required for Mastercard Payment of Winnings (POW) transactions. * Must not be all numeric. * Must contain only ASCII characters in range 32-122. * Must not be greater than 50 characters including spaces. * Required for POW on Barclays. 
    */
    'address1'?: string;
    /**
    * City of the sender of the funds. For Gaming Payment of Winnings transactions these are the merchant details. * Required for Mastercard Payment of Winnings (POW) transactions. * Must not be all numeric. * Must contain only ASCII characters in range 32-122. * Must not be greater than 25 characters including spaces. * Required for POW on Barclays. 
    */
    'locality'?: string;
    /**
    * Country of the sender of the funds. For Gaming Payment of Winnings transactions these are the merchant details. * Required for Mastercard Payment of Winnings (POW) transactions. * Must be a valid three character ISO country code as defined by ISO 3166. * Must not be greater than 3 characters. * Required for POW on Barclays. 
    */
    'countryCode'?: string;
    'account'?: Ptsv2creditsSenderInformationAccount;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "firstName",
            "baseName": "firstName",
            "type": "string"
        },
        {
            "name": "lastName",
            "baseName": "lastName",
            "type": "string"
        },
        {
            "name": "address1",
            "baseName": "address1",
            "type": "string"
        },
        {
            "name": "locality",
            "baseName": "locality",
            "type": "string"
        },
        {
            "name": "countryCode",
            "baseName": "countryCode",
            "type": "string"
        },
        {
            "name": "account",
            "baseName": "account",
            "type": "Ptsv2creditsSenderInformationAccount"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2creditsSenderInformation.attributeTypeMap;
    }
}

export class Ptsv2creditsSenderInformationAccount {
    /**
    * Account number of the sender of the funds. For Gaming Payment of Winnings transactions this is the merchant account number. * Required for Mastercard Payment of Winnings (POW) transactions. * Must contain only ASCII characters in range 32-122. * Must not be greater than 50 characters. * Required for POW on Barclays. 
    */
    'number'?: string;
    /**
    * Source of funds for the sender. For Gaming Payment of Winnings transactions this is the merchant account type. * Required for Mastercard Payment of Winnings (POW) transactions. * Valid values:   * 00 - Other   * 01 - RTN + Bank Account   * 02 - IBAN   * 03 - Card Account   * 04 - Email   * 05 - PhoneNumber   * 06 - Bank account number (BAN) + Bank Identification Code (BIC)   * 07 - Wallet ID   * 08 - Social Network ID 
    */
    'fundsSource'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "number",
            "baseName": "number",
            "type": "string"
        },
        {
            "name": "fundsSource",
            "baseName": "fundsSource",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2creditsSenderInformationAccount.attributeTypeMap;
    }
}

export class Ptsv2intentsClientReferenceInformation {
    /**
    * Reference number for the transaction. Depending on how your Cybersource account is configured, this value could either be provided in the API request or generated by CyberSource. The actual value used in the request to the processor is provided back to you by Cybersource in the response. 
    */
    'reconciliationId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "reconciliationId",
            "baseName": "reconciliationId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2intentsClientReferenceInformation.attributeTypeMap;
    }
}

export class Ptsv2intentsEventInformation {
    /**
    * The date of the event. 
    */
    'date'?: string;
    /**
    * The type of the event. 
    */
    'type'?: string;
    /**
    * The total number of tickets for the event. 
    */
    'totalTickets'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "date",
            "baseName": "date",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "totalTickets",
            "baseName": "totalTickets",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2intentsEventInformation.attributeTypeMap;
    }
}

export class Ptsv2intentsMerchantInformation {
    'merchantDescriptor'?: Ptsv2intentsMerchantInformationMerchantDescriptor;
    /**
    * customer would be redirected to this url based on the decision of the transaction
    */
    'cancelUrl'?: string;
    /**
    * customer would be redirected to this url based on the decision of the transaction
    */
    'successUrl'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "merchantDescriptor",
            "baseName": "merchantDescriptor",
            "type": "Ptsv2intentsMerchantInformationMerchantDescriptor"
        },
        {
            "name": "cancelUrl",
            "baseName": "cancelUrl",
            "type": "string"
        },
        {
            "name": "successUrl",
            "baseName": "successUrl",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2intentsMerchantInformation.attributeTypeMap;
    }
}

export class Ptsv2intentsMerchantInformationMerchantDescriptor {
    /**
    * Your merchant name.  **Note** For Paymentech processor using Cybersource Payouts, the maximum data length is 22.  #### PIN debit Your business name. This name is displayed on the cardholder’s statement. When you include more than one consecutive space, extra spaces are removed.  When you do not include this value in your PIN debit request, the merchant name from your account is used. **Important** This value must consist of English characters.  Optional field for PIN debit credit or PIN debit purchase requests.  #### Airline processing Your merchant name. This name is displayed on the cardholder’s statement. When you include more than one consecutive space, extra spaces are removed.  **Note** Some airline fee programs may require the original ticket number (ticket identifier) or the ancillary service description in positions 13 through 23 of this field.  **Important** This value must consist of English characters.  Required for captures and credits. 
    */
    'name'?: string;
    /**
    * Email address of the merchant.
    */
    'email'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2intentsMerchantInformationMerchantDescriptor.attributeTypeMap;
    }
}

export class Ptsv2intentsOrderInformation {
    'amountDetails'?: Ptsv2intentsOrderInformationAmountDetails;
    'billTo'?: Ptsv2intentsOrderInformationBillTo;
    'shipTo'?: Ptsv2intentsOrderInformationShipTo;
    'lineItems'?: Array<Ptsv2intentsOrderInformationLineItems>;
    'invoiceDetails'?: Ptsv2intentsOrderInformationInvoiceDetails;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "amountDetails",
            "baseName": "amountDetails",
            "type": "Ptsv2intentsOrderInformationAmountDetails"
        },
        {
            "name": "billTo",
            "baseName": "billTo",
            "type": "Ptsv2intentsOrderInformationBillTo"
        },
        {
            "name": "shipTo",
            "baseName": "shipTo",
            "type": "Ptsv2intentsOrderInformationShipTo"
        },
        {
            "name": "lineItems",
            "baseName": "lineItems",
            "type": "Array<Ptsv2intentsOrderInformationLineItems>"
        },
        {
            "name": "invoiceDetails",
            "baseName": "invoiceDetails",
            "type": "Ptsv2intentsOrderInformationInvoiceDetails"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2intentsOrderInformation.attributeTypeMap;
    }
}

export class Ptsv2intentsOrderInformationAmountDetails {
    /**
    * Grand total for the order. This value cannot be negative. You can include a decimal point (.), but you cannot include any other special characters. CyberSource truncates the amount to the correct number of decimal places 
    */
    'totalAmount'?: string;
    /**
    * Currency used for the order 
    */
    'currency'?: string;
    /**
    * Discount amount for the transaction.  
    */
    'discountAmount'?: string;
    /**
    * Aggregate shipping charges for the transactions. 
    */
    'shippingAmount'?: string;
    /**
    * Shipping discount amount for the transaction.  
    */
    'shippingDiscountAmount'?: string;
    /**
    * Total tax amount.  
    */
    'taxAmount'?: string;
    /**
    * Amount being charged for the insurance fee.  
    */
    'insuranceAmount'?: string;
    /**
    * Amount being charged as duty amount.             
    */
    'dutyAmount'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "totalAmount",
            "baseName": "totalAmount",
            "type": "string"
        },
        {
            "name": "currency",
            "baseName": "currency",
            "type": "string"
        },
        {
            "name": "discountAmount",
            "baseName": "discountAmount",
            "type": "string"
        },
        {
            "name": "shippingAmount",
            "baseName": "shippingAmount",
            "type": "string"
        },
        {
            "name": "shippingDiscountAmount",
            "baseName": "shippingDiscountAmount",
            "type": "string"
        },
        {
            "name": "taxAmount",
            "baseName": "taxAmount",
            "type": "string"
        },
        {
            "name": "insuranceAmount",
            "baseName": "insuranceAmount",
            "type": "string"
        },
        {
            "name": "dutyAmount",
            "baseName": "dutyAmount",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2intentsOrderInformationAmountDetails.attributeTypeMap;
    }
}

export class Ptsv2intentsOrderInformationBillTo {
    /**
    * Email address of the PayPal account holder. 
    */
    'email'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2intentsOrderInformationBillTo.attributeTypeMap;
    }
}

export class Ptsv2intentsOrderInformationInvoiceDetails {
    /**
    * Brief description of item.
    */
    'productDescription'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "productDescription",
            "baseName": "productDescription",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2intentsOrderInformationInvoiceDetails.attributeTypeMap;
    }
}

export class Ptsv2intentsOrderInformationLineItems {
    /**
    * For an authorization or capture transaction (`processingOptions.capture` is `true` or `false`), this field is required when `orderInformation.lineItems[].productCode` is not `default` or one of the other values that are related to shipping and/or handling.  #### Tax Calculation Optional field for U.S., Canadian, international tax, and value added taxes. 
    */
    'productName'?: string;
    /**
    * Brief description of item.
    */
    'productDescription'?: string;
    /**
    * Product identifier code. Also known as the Stock Keeping Unit (SKU) code for the product.  For an authorization or capture transaction (`processingOptions.capture` is set to `true` or `false`), this field is required when `orderInformation.lineItems[].productCode` is not set to **default** or one of the other values that are related to shipping and/or handling.  #### Tax Calculation Optional field for U.S. and Canadian taxes. Not applicable to international and value added taxes. For an authorization or capture transaction (`processingOptions.capture` is set to `true` or `false`), this field is required when `orderInformation.lineItems[].productCode` is not `default` or one of the values related to shipping and/or handling. 
    */
    'productSku'?: string;
    /**
    * Number of units for this order. Must be a non-negative integer.  The default is `1`. For an authorization or capture transaction (`processingOptions.capture` is set to `true` or `false`), this field is required when `orderInformation.lineItems[].productCode` is not `default` or one of the other values related to shipping and/or handling.  #### Tax Calculation Optional field for U.S., Canadian, international tax, and value added taxes. 
    */
    'quantity'?: number;
    /**
    * Flag to indicate whether the purchase is categorized as goods or services. Possible values:   - 00: goods  - 01: services 
    */
    'typeOfSupply'?: string;
    /**
    * Per-item price of the product. This value for this field cannot be negative.  You must include either this field or the request-level field `orderInformation.amountDetails.totalAmount` in your request.  You can include a decimal point (.), but you cannot include any other special characters. The value is truncated to the correct number of decimal places.  #### DCC with a Third-Party Provider Set this field to the converted amount that was returned by the DCC provider. You must include either the 1st line item in the order and this field, or the request-level field `orderInformation.amountDetails.totalAmount` in your request.  #### Tax Calculation Required field for U.S., Canadian, international and value added taxes.  #### Zero Amount Authorizations If your processor supports zero amount authorizations, you can set this field to 0 for the authorization to check if the card is lost or stolen.  #### Maximum Field Lengths For GPN and JCN Gateway: Decimal (10) All other processors: Decimal (15) 
    */
    'unitPrice'?: string;
    /**
    * Total amount for the item. Normally calculated as the unit price times quantity.  When `orderInformation.lineItems[].productCode` is \"gift_card\", this is the purchase amount total for prepaid gift cards in major units.  Example: 123.45 USD = 123 
    */
    'totalAmount'?: string;
    /**
    * Total tax to apply to the product. This value cannot be negative. The tax amount and the offer amount must be in the same currency. The tax amount field is additive.  The following example uses a two-exponent currency such as USD:   1. You include each line item in your request.  ..- 1st line item has amount=10.00, quantity=1, and taxAmount=0.80  ..- 2nd line item has amount=20.00, quantity=1, and taxAmount=1.60  2. The total amount authorized will be 32.40, not 30.00 with 2.40 of tax included.  Optional field.  #### Airlines processing Tax portion of the order amount. This value cannot exceed 99999999999999 (fourteen 9s). Format: English characters only. Optional request field for a line item.  #### Tax Calculation Optional field for U.S., Canadian, international tax, and value added taxes.  Note if you send this field in your tax request, the value in the field will override the tax engine 
    */
    'taxAmount'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "productName",
            "baseName": "productName",
            "type": "string"
        },
        {
            "name": "productDescription",
            "baseName": "productDescription",
            "type": "string"
        },
        {
            "name": "productSku",
            "baseName": "productSku",
            "type": "string"
        },
        {
            "name": "quantity",
            "baseName": "quantity",
            "type": "number"
        },
        {
            "name": "typeOfSupply",
            "baseName": "typeOfSupply",
            "type": "string"
        },
        {
            "name": "unitPrice",
            "baseName": "unitPrice",
            "type": "string"
        },
        {
            "name": "totalAmount",
            "baseName": "totalAmount",
            "type": "string"
        },
        {
            "name": "taxAmount",
            "baseName": "taxAmount",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2intentsOrderInformationLineItems.attributeTypeMap;
    }
}

export class Ptsv2intentsOrderInformationShipTo {
    /**
    * First name of the recipient.  #### Litle Maximum length: 25  #### All other processors Maximum length: 60  Optional field. 
    */
    'firstName'?: string;
    /**
    * Last name of the recipient.  #### Litle Maximum length: 25  #### All other processors Maximum length: 60  Optional field. 
    */
    'lastName'?: string;
    /**
    * First line of the shipping address.  Required field for authorization if any shipping address information is included in the request; otherwise, optional.  #### Tax Calculation Optional field for U.S. and Canadian taxes. Not applicable to international and value added taxes. Billing address objects will be used to determine the cardholder’s location when shipTo objects are not present. 
    */
    'address1'?: string;
    /**
    * Second line of the shipping address.  Optional field.  #### Tax Calculation Optional field for U.S. and Canadian taxes. Not applicable to international and value added taxes. Billing address objects will be used to determine the cardholder’s location when shipTo objects are not present. 
    */
    'address2'?: string;
    /**
    * City of the shipping address.  Required field for authorization if any shipping address information is included in the request and shipping to the U.S. or Canada; otherwise, optional.  #### Tax Calculation Optional field for U.S. and Canadian taxes. Not applicable to international and value added taxes. Billing address objects will be used to determine the cardholder’s location when shipTo objects are not present. 
    */
    'locality'?: string;
    /**
    * State or province of the shipping address. Use the [State, Province, and Territory Codes for the United States and Canada](https://developer.cybersource.com/library/documentation/sbc/quickref/states_and_provinces.pdf) (maximum length: 2)   Required field for authorization if any shipping address information is included in the request and shipping to the U.S. or Canada; otherwise, optional.  #### Tax Calculation Optional field for U.S. and Canadian taxes. Not applicable to international and value added taxes. Billing address objects will be used to determine the cardholder’s location when shipTo objects are not present. 
    */
    'administrativeArea'?: string;
    /**
    * Postal code for the shipping address. The postal code must consist of 5 to 9 digits.  Required field for authorization if any shipping address information is included in the request and shipping to the U.S. or Canada; otherwise, optional.  When the billing country is the U.S., the 9-digit postal code must follow this format: [5 digits][dash][4 digits]  Example 12345-6789  When the billing country is Canada, the 6-digit postal code must follow this format: [alpha][numeric][alpha][space][numeric][alpha][numeric]  Example A1B 2C3  #### American Express Direct Before sending the postal code to the processor, all nonalphanumeric characters are removed and, if the remaining value is longer than nine characters, the value is truncated starting from the right side. #### Tax Calculation Optional field for U.S. and Canadian taxes. Not applicable to international and value added taxes. Billing address objects will be used to determine the cardholder’s location when shipTo objects are not present. 
    */
    'postalCode'?: string;
    /**
    * Country of the shipping address. Use the two-character [ISO Standard Country Codes.](http://apps.cybersource.com/library/documentation/sbc/quickref/countries_alpha_list.pdf)  Required field for authorization if any shipping address information is included in the request; otherwise, optional.  #### Tax Calculation Optional field for U.S., Canadian, international tax, and value added taxes. Billing address objects will be used to determine the cardholder’s location when shipTo objects are not present. 
    */
    'country'?: string;
    /**
    * Shipping method for the product. Possible values: - lowcost: Lowest-cost service - sameday: Courier or same-day service - oneday: Next-day or overnight service - twoday: Two-day service - threeday: Three-day service - pickup: Store pick-up - other: Other shipping method - none: No shipping method because product is a service or subscription Required for American Express SafeKey (U.S.). 
    */
    'method'?: string;
    /**
    * Customer's email address, including the full domain name. 
    */
    'email'?: string;
    /**
    * Phone number associated with the shipping address. 
    */
    'phoneNumber'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "firstName",
            "baseName": "firstName",
            "type": "string"
        },
        {
            "name": "lastName",
            "baseName": "lastName",
            "type": "string"
        },
        {
            "name": "address1",
            "baseName": "address1",
            "type": "string"
        },
        {
            "name": "address2",
            "baseName": "address2",
            "type": "string"
        },
        {
            "name": "locality",
            "baseName": "locality",
            "type": "string"
        },
        {
            "name": "administrativeArea",
            "baseName": "administrativeArea",
            "type": "string"
        },
        {
            "name": "postalCode",
            "baseName": "postalCode",
            "type": "string"
        },
        {
            "name": "country",
            "baseName": "country",
            "type": "string"
        },
        {
            "name": "method",
            "baseName": "method",
            "type": "string"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "phoneNumber",
            "baseName": "phoneNumber",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2intentsOrderInformationShipTo.attributeTypeMap;
    }
}

export class Ptsv2intentsPaymentInformation {
    'paymentType'?: Ptsv2intentsPaymentInformationPaymentType;
    'tokenizedPaymentMethod'?: Ptsv2intentsPaymentInformationTokenizedPaymentMethod;
    /**
    * Indicates the industry type. Possible Values: - “Events” - \"Ticketing\" - \"Fuel\" - \"GAMING\" - \"DIGITAL GOODS\" - \"TELCO\" - \"Token Service Providers\" - \"Gambling\" - \"CFDs\" - \"car rental\" - \"hotel\" - \"transportation\" - \"travel package\" - \"Cruise Line\" - \"P2P\" - \"Retail\" - \"Food\" - \"Groceries\" - \"Ride Sharing\" - \"Taxi\" - \"Remittance\" - \"Crypto\" - \"Marketplaces\" 
    */
    'industryType'?: string;
    'eWallet'?: Ptsv2intentsPaymentInformationEWallet;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "paymentType",
            "baseName": "paymentType",
            "type": "Ptsv2intentsPaymentInformationPaymentType"
        },
        {
            "name": "tokenizedPaymentMethod",
            "baseName": "tokenizedPaymentMethod",
            "type": "Ptsv2intentsPaymentInformationTokenizedPaymentMethod"
        },
        {
            "name": "industryType",
            "baseName": "industryType",
            "type": "string"
        },
        {
            "name": "eWallet",
            "baseName": "eWallet",
            "type": "Ptsv2intentsPaymentInformationEWallet"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2intentsPaymentInformation.attributeTypeMap;
    }
}

export class Ptsv2intentsPaymentInformationEWallet {
    /**
    * The unique ID for a customer generated by PayPal. 
    */
    'accountId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "accountId",
            "baseName": "accountId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2intentsPaymentInformationEWallet.attributeTypeMap;
    }
}

export class Ptsv2intentsPaymentInformationPaymentType {
    /**
    * A Payment Type is an agreed means for a payee to receive legal tender from a payer. The way one pays for a commercial financial transaction. Examples: Card, Bank Transfer, Digital, Direct Debit. Possible values: - `CARD` (use this for a PIN debit transaction) - `CHECK` (use this for all eCheck payment transactions - ECP Debit, ECP Follow-on Credit, ECP StandAlone Credit) - `bankTransfer` (use for Online Bank Transafer for methods such as P24, iDeal, Estonia Bank, KCP) - `localCard` (KCP Local card via Altpay) - `carrierBilling` (KCP Carrier Billing via Altpay) 
    */
    'name'?: string;
    'method'?: Ptsv2intentsPaymentInformationPaymentTypeMethod;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "method",
            "baseName": "method",
            "type": "Ptsv2intentsPaymentInformationPaymentTypeMethod"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2intentsPaymentInformationPaymentType.attributeTypeMap;
    }
}

export class Ptsv2intentsPaymentInformationPaymentTypeMethod {
    /**
    * A Payment Type is enabled through a Method. Examples: Visa, Master Card, ApplePay, iDeal, 7Eleven, alfamart, etc #### Via PayPal ptsV2CreateOrderPost201Response   - 'payPal'   - 'venmo' 
    */
    'name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2intentsPaymentInformationPaymentTypeMethod.attributeTypeMap;
    }
}

export class Ptsv2intentsPaymentInformationTokenizedPaymentMethod {
    /**
    * Description of the vaulted payment method shown to the buyer during checkout and in their PayPal account. 
    */
    'description'?: string;
    /**
    * Indicates how the merchant will primarily use the vaulted payment method. Valid values: - “IMMEDIATE”: For on-demand, instant payments. These payments are variable in both amount and frequency and will be used to pay for goods or services before they are rendered to the buyer - “DEFERRED”: For post-pay payments; that is, payments for goods or services that have already been rendered to the buyer - “RECURRING_PREPAID”: For recurring payments before services are rendered. - “RECURRING_POSTPAID”: For recurring payments after services are rendered. - “THRESHOLD_PREPAID”: For payments when a pre-defined threshold is reached before services are rendered. - “THRESHOLD_POSTPAID”: For payments when a pre-defined threshold is reached after services are rendered. 
    */
    'usagePattern'?: string;
    /**
    * Indicates the type of vaulting relationship. Valid values: - “MERCHANT”: Single merchant relationship. - “PLATFORM”: Platform hosting multiple merchants. 
    */
    'usageType'?: string;
    /**
    * Create multiple payment tokens for the same payer, merchant/platform combination. This helps to identify customers distinctly even though they may share the same PayPal account. 
    */
    'allowMultipleTokens'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "usagePattern",
            "baseName": "usagePattern",
            "type": "string"
        },
        {
            "name": "usageType",
            "baseName": "usageType",
            "type": "string"
        },
        {
            "name": "allowMultipleTokens",
            "baseName": "allowMultipleTokens",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2intentsPaymentInformationTokenizedPaymentMethod.attributeTypeMap;
    }
}

export class Ptsv2intentsProcessingInformation {
    /**
    * The instruction to process an order. - default value: 'NO_INSTRUCTION' - 'ORDER_SAVED_EXPLICITLY' 
    */
    'processingInstruction'?: string;
    'authorizationOptions'?: Ptsv2intentsProcessingInformationAuthorizationOptions;
    /**
    * Array of actions (one or more) to be included in the order to invoke bundled services along with order. Possible values: - `AP_ORDER`: Use this when Alternative Payment Order service is requested. 
    */
    'actionList'?: Array<string>;
    /**
    * Indicates if the transaction is flagged as high risk. 
    */
    'highRiskTransactionFlag'?: string;
    /**
    * Indicates if the transaction is a retry. 
    */
    'transactionRetry'?: string;
    /**
    * The number of transactions in the last one hour. 
    */
    'lastOneHrTransactionCount'?: string;
    /**
    * The number of transactions in the last one day. 
    */
    'lastOneDayTransactionCount'?: string;
    /**
    * The number of transactions in the last three months. 
    */
    'lastThreeMonthsTxnCount'?: string;
    /**
    * The total number of transactions. 
    */
    'totalTransactionCount'?: string;
    /**
    * Indicates if PIN verification is required. 
    */
    'pinVerification'?: string;
    /**
    * Indicates if face ID verification is required. 
    */
    'faceIdVerification'?: string;
    /**
    * Indicates if the user passed verification. 
    */
    'userPassedVerification'?: string;
    /**
    * The IP address of the user. 
    */
    'ipAddress'?: string;
    /**
    * The date of the transaction. 
    */
    'transactionDate'?: string;
    /**
    * Indicates if the transaction involves tangible goods. 
    */
    'tangible'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "processingInstruction",
            "baseName": "processingInstruction",
            "type": "string"
        },
        {
            "name": "authorizationOptions",
            "baseName": "authorizationOptions",
            "type": "Ptsv2intentsProcessingInformationAuthorizationOptions"
        },
        {
            "name": "actionList",
            "baseName": "actionList",
            "type": "Array<string>"
        },
        {
            "name": "highRiskTransactionFlag",
            "baseName": "highRiskTransactionFlag",
            "type": "string"
        },
        {
            "name": "transactionRetry",
            "baseName": "transactionRetry",
            "type": "string"
        },
        {
            "name": "lastOneHrTransactionCount",
            "baseName": "lastOneHrTransactionCount",
            "type": "string"
        },
        {
            "name": "lastOneDayTransactionCount",
            "baseName": "lastOneDayTransactionCount",
            "type": "string"
        },
        {
            "name": "lastThreeMonthsTxnCount",
            "baseName": "lastThreeMonthsTxnCount",
            "type": "string"
        },
        {
            "name": "totalTransactionCount",
            "baseName": "totalTransactionCount",
            "type": "string"
        },
        {
            "name": "pinVerification",
            "baseName": "pinVerification",
            "type": "string"
        },
        {
            "name": "faceIdVerification",
            "baseName": "faceIdVerification",
            "type": "string"
        },
        {
            "name": "userPassedVerification",
            "baseName": "userPassedVerification",
            "type": "string"
        },
        {
            "name": "ipAddress",
            "baseName": "ipAddress",
            "type": "string"
        },
        {
            "name": "transactionDate",
            "baseName": "transactionDate",
            "type": "string"
        },
        {
            "name": "tangible",
            "baseName": "tangible",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2intentsProcessingInformation.attributeTypeMap;
    }
}

export class Ptsv2intentsProcessingInformationAuthorizationOptions {
    /**
    * Authorization type. Possible values:   - `AUTOCAPTURE`: automatic capture.  - `STANDARDCAPTURE`: standard capture.  - `VERBAL`: forced capture. Include it in the payment request for a forced capture. Include it in the capture request for a verbal payment.  #### Asia, Middle East, and Africa Gateway; Cielo; Comercio Latino; and CyberSource Latin American Processing Set this field to `AUTOCAPTURE` and include it in a bundled request to indicate that you are requesting an automatic capture. If your account is configured to enable automatic captures, set this field to `STANDARDCAPTURE` and include it in a standard authorization or bundled request to indicate that you are overriding an automatic capture.  #### Forced Capture Set this field to `VERBAL` and include it in the authorization request to indicate that you are performing a forced capture; therefore, you receive the authorization code outside the CyberSource system.  #### Verbal Authorization Set this field to `VERBAL` and include it in the capture request to indicate that the request is for a verbal authorization.  #### for PayPal ptsV2CreateOrderPost400Response Set this field to 'AUTHORIZE' or 'CAPTURE' depending on whether you want to invoke delayed capture or sale respectively. 
    */
    'authType'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "authType",
            "baseName": "authType",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2intentsProcessingInformationAuthorizationOptions.attributeTypeMap;
    }
}

export class Ptsv2intentsRecipientInformation {
    /**
    * The account ID of the recipient. 
    */
    'accountId'?: string;
    /**
    * The date when the recipient's account was created. 
    */
    'createDate'?: string;
    /**
    * The email address of the recipient 
    */
    'email'?: string;
    /**
    * The country code of the recipient. 
    */
    'countryCode'?: string;
    /**
    * The business name of the recipient. 
    */
    'businessName'?: string;
    /**
    * The risk popularity score of the recipient. 
    */
    'riskPopularityScore'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "accountId",
            "baseName": "accountId",
            "type": "string"
        },
        {
            "name": "createDate",
            "baseName": "createDate",
            "type": "string"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "countryCode",
            "baseName": "countryCode",
            "type": "string"
        },
        {
            "name": "businessName",
            "baseName": "businessName",
            "type": "string"
        },
        {
            "name": "riskPopularityScore",
            "baseName": "riskPopularityScore",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2intentsRecipientInformation.attributeTypeMap;
    }
}

export class Ptsv2intentsSenderInformation {
    'account'?: Ptsv2intentsSenderInformationAccount;
    /**
    * The first name of the sender. 
    */
    'firstName'?: string;
    /**
    * The last name of the sender. 
    */
    'lastName'?: string;
    /**
    * The email address of the sender. 
    */
    'email'?: string;
    /**
    * The phone number of the sender. 
    */
    'phoneNumber'?: string;
    /**
    * The country code of the sender. 
    */
    'countryCode'?: string;
    /**
    * The date when the sender's account was created. 
    */
    'createDate'?: string;
    /**
    * The postal code of the sender. 
    */
    'postalCode'?: string;
    /**
    * The risk popularity score of the sender. 
    */
    'riskPopularityScore'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "account",
            "baseName": "account",
            "type": "Ptsv2intentsSenderInformationAccount"
        },
        {
            "name": "firstName",
            "baseName": "firstName",
            "type": "string"
        },
        {
            "name": "lastName",
            "baseName": "lastName",
            "type": "string"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "phoneNumber",
            "baseName": "phoneNumber",
            "type": "string"
        },
        {
            "name": "countryCode",
            "baseName": "countryCode",
            "type": "string"
        },
        {
            "name": "createDate",
            "baseName": "createDate",
            "type": "string"
        },
        {
            "name": "postalCode",
            "baseName": "postalCode",
            "type": "string"
        },
        {
            "name": "riskPopularityScore",
            "baseName": "riskPopularityScore",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2intentsSenderInformation.attributeTypeMap;
    }
}

export class Ptsv2intentsSenderInformationAccount {
    /**
    * The account number of the sender. 
    */
    'number'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "number",
            "baseName": "number",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2intentsSenderInformationAccount.attributeTypeMap;
    }
}

export class Ptsv2intentsTravelInformation {
    'agency'?: Ptsv2intentsTravelInformationAgency;
    /**
    * The type of journey. 
    */
    'journeyType'?: string;
    /**
    * The actual final destination of the travel. 
    */
    'actualFinalDestination'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "agency",
            "baseName": "agency",
            "type": "Ptsv2intentsTravelInformationAgency"
        },
        {
            "name": "journeyType",
            "baseName": "journeyType",
            "type": "string"
        },
        {
            "name": "actualFinalDestination",
            "baseName": "actualFinalDestination",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2intentsTravelInformation.attributeTypeMap;
    }
}

export class Ptsv2intentsTravelInformationAgency {
    /**
    * The start date of the agency's service. 
    */
    'startDate'?: string;
    /**
    * The end date of the agency's service. 
    */
    'endDate'?: string;
    /**
    * Indicates if there is a change of guest. 
    */
    'changeOfGuest'?: string;
    /**
    * The country code of the agency. 
    */
    'countryCode'?: string;
    /**
    * The locality of the agency. 
    */
    'locality'?: string;
    /**
    * The postal code of the agency. 
    */
    'postalCode'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "startDate",
            "baseName": "startDate",
            "type": "string"
        },
        {
            "name": "endDate",
            "baseName": "endDate",
            "type": "string"
        },
        {
            "name": "changeOfGuest",
            "baseName": "changeOfGuest",
            "type": "string"
        },
        {
            "name": "countryCode",
            "baseName": "countryCode",
            "type": "string"
        },
        {
            "name": "locality",
            "baseName": "locality",
            "type": "string"
        },
        {
            "name": "postalCode",
            "baseName": "postalCode",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2intentsTravelInformationAgency.attributeTypeMap;
    }
}

export class Ptsv2intentsidMerchantInformation {
    'merchantDescriptor'?: Ptsv2intentsMerchantInformationMerchantDescriptor;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "merchantDescriptor",
            "baseName": "merchantDescriptor",
            "type": "Ptsv2intentsMerchantInformationMerchantDescriptor"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2intentsidMerchantInformation.attributeTypeMap;
    }
}

export class Ptsv2intentsidOrderInformation {
    'amountDetails'?: Ptsv2intentsOrderInformationAmountDetails;
    'shipTo'?: Ptsv2intentsOrderInformationShipTo;
    'lineItems'?: Array<Ptsv2intentsOrderInformationLineItems>;
    'invoiceDetails'?: Ptsv2intentsOrderInformationInvoiceDetails;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "amountDetails",
            "baseName": "amountDetails",
            "type": "Ptsv2intentsOrderInformationAmountDetails"
        },
        {
            "name": "shipTo",
            "baseName": "shipTo",
            "type": "Ptsv2intentsOrderInformationShipTo"
        },
        {
            "name": "lineItems",
            "baseName": "lineItems",
            "type": "Array<Ptsv2intentsOrderInformationLineItems>"
        },
        {
            "name": "invoiceDetails",
            "baseName": "invoiceDetails",
            "type": "Ptsv2intentsOrderInformationInvoiceDetails"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2intentsidOrderInformation.attributeTypeMap;
    }
}

export class Ptsv2intentsidPaymentInformation {
    'paymentType'?: Ptsv2intentsPaymentInformationPaymentType;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "paymentType",
            "baseName": "paymentType",
            "type": "Ptsv2intentsPaymentInformationPaymentType"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2intentsidPaymentInformation.attributeTypeMap;
    }
}

export class Ptsv2intentsidProcessingInformation {
    /**
    * Array of actions (one or more) to be included in the void to invoke bundled services along with void. Possible values: - `AP_UPDATE_ORDER`: Use this when Alternative Payment Update order service is requested. - `AP_EXTEND_ORDER`: Use this when Alternative Payment extend order service is requested. 
    */
    'actionList'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "actionList",
            "baseName": "actionList",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2intentsidProcessingInformation.attributeTypeMap;
    }
}

export class Ptsv2paymentreferencesAgreementInformation {
    /**
    * Indicates whether the transaction is a billing agreement. Possible values - true - false (default) 
    */
    'indicator'?: string;
    /**
    * Description of the billing agreement
    */
    'description'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "indicator",
            "baseName": "indicator",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentreferencesAgreementInformation.attributeTypeMap;
    }
}

export class Ptsv2paymentreferencesBuyerInformation {
    /**
    * Recipient’s date of birth. **Format**: `YYYYMMDD`.  This field is a `pass-through`, which means that CyberSource ensures that the value is eight numeric characters but otherwise does not verify the value or modify it in any way before sending it to the processor. If the field is not required for the transaction, CyberSource does not forward it to the processor. 
    */
    'dateOfBirth'?: string;
    /**
    * Customer's gender. Possible values are F (female), M (male),O (other).
    */
    'gender'?: string;
    /**
    * language setting of the user.  Supports 2-character language codes (e.g., en, fr) and 5-character locale values (e.g., en-US, fr-CA). 
    */
    'language'?: string;
    /**
    * Note to the recipient of the funds in this transaction
    */
    'noteToSeller'?: string;
    'personalIdentification'?: Array<Ptsv2paymentsidcapturesBuyerInformationPersonalIdentification>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "dateOfBirth",
            "baseName": "dateOfBirth",
            "type": "string"
        },
        {
            "name": "gender",
            "baseName": "gender",
            "type": "string"
        },
        {
            "name": "language",
            "baseName": "language",
            "type": "string"
        },
        {
            "name": "noteToSeller",
            "baseName": "noteToSeller",
            "type": "string"
        },
        {
            "name": "personalIdentification",
            "baseName": "personalIdentification",
            "type": "Array<Ptsv2paymentsidcapturesBuyerInformationPersonalIdentification>"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentreferencesBuyerInformation.attributeTypeMap;
    }
}

export class Ptsv2paymentreferencesDeviceInformation {
    /**
    * IP address of the customer.  #### Used by **Authorization, Capture, and Credit** Optional field. 
    */
    'ipAddress'?: string;
    /**
    * The device type at the client side.
    */
    'deviceType'?: string;
    /**
    * ../../../commons/definitions/device.yaml#/properties/id
    */
    'id'?: string;
    /**
    * Customer’s browser as identified from the HTTP header data. For example, `Mozilla` is the value that identifies the Netscape browser. 
    */
    'userAgent'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "ipAddress",
            "baseName": "ipAddress",
            "type": "string"
        },
        {
            "name": "deviceType",
            "baseName": "deviceType",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "userAgent",
            "baseName": "userAgent",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentreferencesDeviceInformation.attributeTypeMap;
    }
}

export class Ptsv2paymentreferencesMerchantInformation {
    'merchantDescriptor'?: Ptsv2paymentsMerchantInformationMerchantDescriptor;
    /**
    * customer would be redirected to this url based on the decision of the transaction
    */
    'cancelUrl'?: string;
    /**
    * customer would be redirected to this url based on the decision of the transaction
    */
    'successUrl'?: string;
    /**
    * customer would be redirected to this url based on the decision of the transaction
    */
    'failureUrl'?: string;
    /**
    * Free-form text field.
    */
    'noteToBuyer'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "merchantDescriptor",
            "baseName": "merchantDescriptor",
            "type": "Ptsv2paymentsMerchantInformationMerchantDescriptor"
        },
        {
            "name": "cancelUrl",
            "baseName": "cancelUrl",
            "type": "string"
        },
        {
            "name": "successUrl",
            "baseName": "successUrl",
            "type": "string"
        },
        {
            "name": "failureUrl",
            "baseName": "failureUrl",
            "type": "string"
        },
        {
            "name": "noteToBuyer",
            "baseName": "noteToBuyer",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentreferencesMerchantInformation.attributeTypeMap;
    }
}

export class Ptsv2paymentreferencesOrderInformation {
    'billTo'?: Ptsv2paymentreferencesOrderInformationBillTo;
    'shipTo'?: Ptsv2paymentreferencesOrderInformationShipTo;
    'amountDetails'?: Ptsv2paymentreferencesOrderInformationAmountDetails;
    'lineItems'?: Array<Ptsv2paymentreferencesOrderInformationLineItems>;
    'invoiceDetails'?: Ptsv2paymentreferencesOrderInformationInvoiceDetails;
    'shippingDetails'?: PtsV2PaymentsOrderPost201ResponseOrderInformationShippingDetails;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "billTo",
            "baseName": "billTo",
            "type": "Ptsv2paymentreferencesOrderInformationBillTo"
        },
        {
            "name": "shipTo",
            "baseName": "shipTo",
            "type": "Ptsv2paymentreferencesOrderInformationShipTo"
        },
        {
            "name": "amountDetails",
            "baseName": "amountDetails",
            "type": "Ptsv2paymentreferencesOrderInformationAmountDetails"
        },
        {
            "name": "lineItems",
            "baseName": "lineItems",
            "type": "Array<Ptsv2paymentreferencesOrderInformationLineItems>"
        },
        {
            "name": "invoiceDetails",
            "baseName": "invoiceDetails",
            "type": "Ptsv2paymentreferencesOrderInformationInvoiceDetails"
        },
        {
            "name": "shippingDetails",
            "baseName": "shippingDetails",
            "type": "PtsV2PaymentsOrderPost201ResponseOrderInformationShippingDetails"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentreferencesOrderInformation.attributeTypeMap;
    }
}

export class Ptsv2paymentreferencesOrderInformationAmountDetails {
    /**
    * Grand total for the order. This value cannot be negative. You can include a decimal point (.), but no other special characters. CyberSource truncates the amount to the correct number of decimal places.  **Note** For CTV, FDCCompass, Paymentech processors, the maximum length for this field is 12.  **Important** Some processors have specific requirements and limitations, such as maximum amounts and maximum field lengths.  If your processor supports zero amount authorizations, you can set this field to 0 for the authorization to check if the card is lost or stolen.   #### Card Present Required to include either this field or `orderInformation.lineItems[].unitPrice` for the order.  #### Invoicing / Pay By Link Required for creating a new invoice or payment link.  #### PIN Debit Amount you requested for the PIN debit purchase. This value is returned for partial authorizations. The issuing bank can approve a partial amount if the balance on the debit card is less than the requested transaction amount.  Required field for PIN Debit purchase and PIN Debit credit requests. Optional field for PIN Debit reversal requests.  #### GPX This field is optional for reversing an authorization or credit; however, for all other processors, these fields are required.  #### DCC with a Third-Party Provider Set this field to the converted amount that was returned by the DCC provider. You must include either this field or the 1st line item in the order and the specific line-order amount in your request.   #### DCC for First Data Not used. 
    */
    'totalAmount'?: string;
    /**
    * Currency used for the order. Use the three-character [ISO Standard Currency Codes.](http://apps.cybersource.com/library/documentation/sbc/quickref/currencies.pdf)  #### Used by **Authorization** Required field.  **Authorization Reversal** For an authorization reversal (`reversalInformation`) or a capture (`processingOptions.capture` is set to `true`), you must use the same currency that you used in your payment authorization request.  #### PIN Debit Currency for the amount you requested for the PIN debit purchase. This value is returned for partial authorizations. The issuing bank can approve a partial amount if the balance on the debit card is less than the requested transaction amount. For the possible values, see the [ISO Standard Currency Codes](https://developer.cybersource.com/library/documentation/sbc/quickref/currencies.pdf). Returned by PIN debit purchase.  For PIN debit reversal requests, you must use the same currency that was used for the PIN debit purchase or PIN debit credit that you are reversing. For the possible values, see the [ISO Standard Currency Codes](https://developer.cybersource.com/library/documentation/sbc/quickref/currencies.pdf).  Required field for PIN Debit purchase and PIN Debit credit requests. Optional field for PIN Debit reversal requests.  #### GPX This field is optional for reversing an authorization or credit.  #### DCC for First Data Your local currency.  #### Tax Calculation Required for international tax and value added tax only. Optional for U.S. and Canadian taxes. Your local currency. 
    */
    'currency'?: string;
    /**
    * Total discount amount applied to the order. 
    */
    'discountAmount'?: string;
    /**
    * Total tax amount for all the items in the order. 
    */
    'taxAmount'?: string;
    /**
    * Total charges for any import or export duties included in the order. 
    */
    'dutyAmount'?: string;
    /**
    * Exchange rate returned by the DCC service. Includes a decimal point and a maximum of 4 decimal places. 
    */
    'exchangeRate'?: string;
    /**
    * Time stamp for the exchange rate. This value is returned by the DCC service.  Format: `YYYYMMDD~HH:MM`  where ~ denotes a space. 
    */
    'exchangeRateTimeStamp'?: string;
    /**
    * This is a multicurrency-only field. It contains a 3-digit numeric code that identifies the currency used by the issuer to bill the cardholder's account. This field is returned for OCT transactions. 
    */
    'settlementCurrency'?: string;
    /**
    * Invoice amount.  The invoice amount issued by the Merchant to the Cardholder, which includes VAT (excluding items such as TIPS or CASHBACK). For transactions that do not have applicable Benefit Laws, the field may be entered as zeros.  This field is only applicable for Uruguay market.  Example: 100.00  Uruguay  The value for this field corresponds to the following data in the TC 33 capture file:  - Record: CP01 TCR9 - Position: 7-18 - Field: Invoice Amount 
    */
    'invoiceAmount'?: string;
    /**
    * giftwrap amount (RFU).
    */
    'giftwrapAmount'?: string;
    /**
    * handling amount (RFU)
    */
    'handlingAmount'?: string;
    /**
    * shipping amount (RFU)
    */
    'shippingAmount'?: string;
    /**
    * shipping discount amount (RFU)
    */
    'shippingDiscountAmount'?: string;
    /**
    * insurance amount (RFU)
    */
    'insuranceAmount'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "totalAmount",
            "baseName": "totalAmount",
            "type": "string"
        },
        {
            "name": "currency",
            "baseName": "currency",
            "type": "string"
        },
        {
            "name": "discountAmount",
            "baseName": "discountAmount",
            "type": "string"
        },
        {
            "name": "taxAmount",
            "baseName": "taxAmount",
            "type": "string"
        },
        {
            "name": "dutyAmount",
            "baseName": "dutyAmount",
            "type": "string"
        },
        {
            "name": "exchangeRate",
            "baseName": "exchangeRate",
            "type": "string"
        },
        {
            "name": "exchangeRateTimeStamp",
            "baseName": "exchangeRateTimeStamp",
            "type": "string"
        },
        {
            "name": "settlementCurrency",
            "baseName": "settlementCurrency",
            "type": "string"
        },
        {
            "name": "invoiceAmount",
            "baseName": "invoiceAmount",
            "type": "string"
        },
        {
            "name": "giftwrapAmount",
            "baseName": "giftwrapAmount",
            "type": "string"
        },
        {
            "name": "handlingAmount",
            "baseName": "handlingAmount",
            "type": "string"
        },
        {
            "name": "shippingAmount",
            "baseName": "shippingAmount",
            "type": "string"
        },
        {
            "name": "shippingDiscountAmount",
            "baseName": "shippingDiscountAmount",
            "type": "string"
        },
        {
            "name": "insuranceAmount",
            "baseName": "insuranceAmount",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentreferencesOrderInformationAmountDetails.attributeTypeMap;
    }
}

export class Ptsv2paymentreferencesOrderInformationBillTo {
    /**
    * Company Name. 
    */
    'name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentreferencesOrderInformationBillTo.attributeTypeMap;
    }
}

export class Ptsv2paymentreferencesOrderInformationInvoiceDetails {
    /**
    * Cost centre of the merchant.
    */
    'costCenter'?: string;
    /**
    * Brief description of item.
    */
    'productDescription'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "costCenter",
            "baseName": "costCenter",
            "type": "string"
        },
        {
            "name": "productDescription",
            "baseName": "productDescription",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentreferencesOrderInformationInvoiceDetails.attributeTypeMap;
    }
}

/**
* List of the line items from the order, which are included in an invoice.
*/
export class Ptsv2paymentreferencesOrderInformationLineItems {
    /**
    * Product identifier code. Also known as the Stock Keeping Unit (SKU) code for the product.  For an authorization or capture transaction (`processingOptions.capture` is set to `true` or `false`), this field is required when `orderInformation.lineItems[].productCode` is not set to **default** or one of the other values that are related to shipping and/or handling.  #### Tax Calculation Optional field for U.S. and Canadian taxes. Not applicable to international and value added taxes. For an authorization or capture transaction (`processingOptions.capture` is set to `true` or `false`), this field is required when `orderInformation.lineItems[].productCode` is not `default` or one of the values related to shipping and/or handling. 
    */
    'productSku'?: string;
    /**
    * For an authorization or capture transaction (`processingOptions.capture` is `true` or `false`), this field is required when `orderInformation.lineItems[].productCode` is not `default` or one of the other values that are related to shipping and/or handling.  #### Tax Calculation Optional field for U.S., Canadian, international tax, and value added taxes. 
    */
    'productName'?: string;
    /**
    * Number of units for this order. Must be a non-negative integer.  The default is `1`. For an authorization or capture transaction (`processingOptions.capture` is set to `true` or `false`), this field is required when `orderInformation.lineItems[].productCode` is not `default` or one of the other values related to shipping and/or handling.  #### Tax Calculation Optional field for U.S., Canadian, international tax, and value added taxes. 
    */
    'quantity'?: number;
    /**
    * Per-item price of the product. This value for this field cannot be negative.  You must include either this field or the request-level field `orderInformation.amountDetails.totalAmount` in your request.  You can include a decimal point (.), but you cannot include any other special characters. The value is truncated to the correct number of decimal places.  #### DCC with a Third-Party Provider Set this field to the converted amount that was returned by the DCC provider. You must include either the 1st line item in the order and this field, or the request-level field `orderInformation.amountDetails.totalAmount` in your request.  #### Tax Calculation Required field for U.S., Canadian, international and value added taxes.  #### Zero Amount Authorizations If your processor supports zero amount authorizations, you can set this field to 0 for the authorization to check if the card is lost or stolen.  #### Maximum Field Lengths For GPN and JCN Gateway: Decimal (10) All other processors: Decimal (15) 
    */
    'unitPrice'?: string;
    /**
    * Discount applied to the item.
    */
    'discountAmount'?: string;
    /**
    * Rate the item is discounted. Maximum of 2 decimal places.  Example 5.25 (=5.25%) 
    */
    'discountRate'?: string;
    /**
    * Total tax to apply to the product. This value cannot be negative. The tax amount and the offer amount must be in the same currency. The tax amount field is additive.  The following example uses a two-exponent currency such as USD:   1. You include each line item in your request.  ..- 1st line item has amount=10.00, quantity=1, and taxAmount=0.80  ..- 2nd line item has amount=20.00, quantity=1, and taxAmount=1.60  2. The total amount authorized will be 32.40, not 30.00 with 2.40 of tax included.  Optional field.  #### Airlines processing Tax portion of the order amount. This value cannot exceed 99999999999999 (fourteen 9s). Format: English characters only. Optional request field for a line item.  #### Tax Calculation Optional field for U.S., Canadian, international tax, and value added taxes.  Note if you send this field in your tax request, the value in the field will override the tax engine 
    */
    'taxAmount'?: string;
    /**
    * Tax rate applied to the item.  **Visa**: Valid range is 0.01 to 0.99 (1% to 99%, with only whole percentage values accepted; values with additional decimal places will be truncated).  **Mastercard**: Valid range is 0.00001 to 0.99999 (0.001% to 99.999%). 
    */
    'taxRate'?: string;
    /**
    * Total amount for the item. Normally calculated as the unit price times quantity.  When `orderInformation.lineItems[].productCode` is \"gift_card\", this is the purchase amount total for prepaid gift cards in major units.  Example: 123.45 USD = 123 
    */
    'totalAmount'?: string;
    /**
    * Type of product. The value for this field is used to identify the product category (electronic, handling, physical, service, or shipping). The default value is `default`.  If you are performing an authorization transaction (`processingOptions.capture` is set to `false`), and you set this field to a value other than `default` or one of the values related to shipping and/or handling, then `orderInformation.lineItems[].quantity`, `orderInformation.lineItems[].productName`, and `orderInformation.lineItems[].productSku` fields are required.  Optional field.  #### Tax Calculation Optional field for U.S., Canadian, international tax, and value added taxes.  The Product Codes for the tax service are located in the Cybersource Tax Codes guide. Contact Customer Support to request the guide. If you don’t send a tax service Product Code in your tax request, product-based rules or exemptions will not be applied and the transaction will default to fully taxable in the locations where you’ve indicated you need to collect tax [by way of nexus, no nexus, or seller registration number fields]. 
    */
    'productCode'?: string;
    /**
    * Brief description of item.
    */
    'productDescription'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "productSku",
            "baseName": "productSku",
            "type": "string"
        },
        {
            "name": "productName",
            "baseName": "productName",
            "type": "string"
        },
        {
            "name": "quantity",
            "baseName": "quantity",
            "type": "number"
        },
        {
            "name": "unitPrice",
            "baseName": "unitPrice",
            "type": "string"
        },
        {
            "name": "discountAmount",
            "baseName": "discountAmount",
            "type": "string"
        },
        {
            "name": "discountRate",
            "baseName": "discountRate",
            "type": "string"
        },
        {
            "name": "taxAmount",
            "baseName": "taxAmount",
            "type": "string"
        },
        {
            "name": "taxRate",
            "baseName": "taxRate",
            "type": "string"
        },
        {
            "name": "totalAmount",
            "baseName": "totalAmount",
            "type": "string"
        },
        {
            "name": "productCode",
            "baseName": "productCode",
            "type": "string"
        },
        {
            "name": "productDescription",
            "baseName": "productDescription",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentreferencesOrderInformationLineItems.attributeTypeMap;
    }
}

export class Ptsv2paymentreferencesOrderInformationShipTo {
    /**
    * Customer's primary email address, including the full domain name. 
    */
    'email'?: string;
    /**
    * The title of the person receiving the product.
    */
    'title'?: string;
    /**
    * First name of the recipient.  #### Litle Maximum length: 25  #### All other processors Maximum length: 60  Optional field. 
    */
    'firstName'?: string;
    /**
    * Middle name of the recipient.  #### Litle Maximum length: 25  #### All other processors Maximum length: 60  Optional field. 
    */
    'middleName'?: string;
    /**
    * Last name of the recipient.  #### Litle Maximum length: 25  #### All other processors Maximum length: 60  Optional field. 
    */
    'lastName'?: string;
    /**
    * Name of the customer’s company. 
    */
    'company'?: string;
    /**
    * First line of the shipping address.  Required field for authorization if any shipping address information is included in the request; otherwise, optional.  #### Tax Calculation Optional field for U.S. and Canadian taxes. Not applicable to international and value added taxes. Billing address objects will be used to determine the cardholder’s location when shipTo objects are not present. 
    */
    'address1'?: string;
    /**
    * Second line of the shipping address.  Optional field.  #### Tax Calculation Optional field for U.S. and Canadian taxes. Not applicable to international and value added taxes. Billing address objects will be used to determine the cardholder’s location when shipTo objects are not present. 
    */
    'address2'?: string;
    /**
    * Neighborhood, community, or region within a city or municipality.
    */
    'district'?: string;
    /**
    * City of the shipping address.  Required field for authorization if any shipping address information is included in the request and shipping to the U.S. or Canada; otherwise, optional.  #### Tax Calculation Optional field for U.S. and Canadian taxes. Not applicable to international and value added taxes. Billing address objects will be used to determine the cardholder’s location when shipTo objects are not present. 
    */
    'locality'?: string;
    /**
    * State or province of the shipping address. Use the [State, Province, and Territory Codes for the United States and Canada](https://developer.cybersource.com/library/documentation/sbc/quickref/states_and_provinces.pdf) (maximum length: 2)   Required field for authorization if any shipping address information is included in the request and shipping to the U.S. or Canada; otherwise, optional.  #### Tax Calculation Optional field for U.S. and Canadian taxes. Not applicable to international and value added taxes. Billing address objects will be used to determine the cardholder’s location when shipTo objects are not present. 
    */
    'administrativeArea'?: string;
    /**
    * Postal code for the shipping address. The postal code must consist of 5 to 9 digits.  Required field for authorization if any shipping address information is included in the request and shipping to the U.S. or Canada; otherwise, optional.  When the billing country is the U.S., the 9-digit postal code must follow this format: [5 digits][dash][4 digits]  Example 12345-6789  When the billing country is Canada, the 6-digit postal code must follow this format: [alpha][numeric][alpha][space][numeric][alpha][numeric]  Example A1B 2C3  #### American Express Direct Before sending the postal code to the processor, all nonalphanumeric characters are removed and, if the remaining value is longer than nine characters, the value is truncated starting from the right side. #### Tax Calculation Optional field for U.S. and Canadian taxes. Not applicable to international and value added taxes. Billing address objects will be used to determine the cardholder’s location when shipTo objects are not present. 
    */
    'postalCode'?: string;
    /**
    * Country of the shipping address. Use the two-character [ISO Standard Country Codes.](http://apps.cybersource.com/library/documentation/sbc/quickref/countries_alpha_list.pdf)  Required field for authorization if any shipping address information is included in the request; otherwise, optional.  #### Tax Calculation Optional field for U.S., Canadian, international tax, and value added taxes. Billing address objects will be used to determine the cardholder’s location when shipTo objects are not present. 
    */
    'country'?: string;
    /**
    * Building number in the street address. For example, the building number is 187 in the following address:  Rua da Quitanda 187 
    */
    'buildingNumber'?: string;
    /**
    * Phone number associated with the shipping address.
    */
    'phoneNumber'?: string;
    /**
    * Indicates whether customers are permitted to edit the shipping address in their PayPal account. Possible values: - true: Customer cannot edit the shipping address. - false (default): Customer can edit the shipping address. 
    */
    'immutable'?: string;
    /**
    * Indicates whether the shipping address is displayed to the customer in their PayPal account. Possible values: - true: Shipping address is not displayed. - false (default): Shipping address is displayed. For example, for digital downloads and services in which a shipping address is not required, set the value to true. 
    */
    'notApplicable'?: string;
    /**
    * U.S. county if available.
    */
    'county'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "firstName",
            "baseName": "firstName",
            "type": "string"
        },
        {
            "name": "middleName",
            "baseName": "middleName",
            "type": "string"
        },
        {
            "name": "lastName",
            "baseName": "lastName",
            "type": "string"
        },
        {
            "name": "company",
            "baseName": "company",
            "type": "string"
        },
        {
            "name": "address1",
            "baseName": "address1",
            "type": "string"
        },
        {
            "name": "address2",
            "baseName": "address2",
            "type": "string"
        },
        {
            "name": "district",
            "baseName": "district",
            "type": "string"
        },
        {
            "name": "locality",
            "baseName": "locality",
            "type": "string"
        },
        {
            "name": "administrativeArea",
            "baseName": "administrativeArea",
            "type": "string"
        },
        {
            "name": "postalCode",
            "baseName": "postalCode",
            "type": "string"
        },
        {
            "name": "country",
            "baseName": "country",
            "type": "string"
        },
        {
            "name": "buildingNumber",
            "baseName": "buildingNumber",
            "type": "string"
        },
        {
            "name": "phoneNumber",
            "baseName": "phoneNumber",
            "type": "string"
        },
        {
            "name": "immutable",
            "baseName": "immutable",
            "type": "string"
        },
        {
            "name": "notApplicable",
            "baseName": "notApplicable",
            "type": "string"
        },
        {
            "name": "county",
            "baseName": "county",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentreferencesOrderInformationShipTo.attributeTypeMap;
    }
}

export class Ptsv2paymentreferencesPaymentInformation {
    'card'?: Ptsv2paymentreferencesPaymentInformationCard;
    'bank'?: Ptsv2paymentreferencesPaymentInformationBank;
    'eWallet'?: Ptsv2paymentreferencesPaymentInformationEWallet;
    'options'?: Ptsv2paymentreferencesPaymentInformationOptions;
    'paymentType'?: Ptsv2paymentsPaymentInformationPaymentType;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "card",
            "baseName": "card",
            "type": "Ptsv2paymentreferencesPaymentInformationCard"
        },
        {
            "name": "bank",
            "baseName": "bank",
            "type": "Ptsv2paymentreferencesPaymentInformationBank"
        },
        {
            "name": "eWallet",
            "baseName": "eWallet",
            "type": "Ptsv2paymentreferencesPaymentInformationEWallet"
        },
        {
            "name": "options",
            "baseName": "options",
            "type": "Ptsv2paymentreferencesPaymentInformationOptions"
        },
        {
            "name": "paymentType",
            "baseName": "paymentType",
            "type": "Ptsv2paymentsPaymentInformationPaymentType"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentreferencesPaymentInformation.attributeTypeMap;
    }
}

export class Ptsv2paymentreferencesPaymentInformationBank {
    /**
    * Bank’s SWIFT code. You can use this field only when scoring a direct debit transaction. Required only for crossborder transactions. 
    */
    'swiftCode'?: string;
    'account'?: Ptsv2paymentreferencesPaymentInformationBankAccount;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "swiftCode",
            "baseName": "swiftCode",
            "type": "string"
        },
        {
            "name": "account",
            "baseName": "account",
            "type": "Ptsv2paymentreferencesPaymentInformationBankAccount"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentreferencesPaymentInformationBank.attributeTypeMap;
    }
}

export class Ptsv2paymentreferencesPaymentInformationBankAccount {
    /**
    * Account number.  When processing encoded account numbers, use this field for the encoded account number. 
    */
    'number'?: string;
    /**
    * International Bank Account Number (IBAN) for the bank account. For some countries you can provide this number instead of the traditional bank account information. You can use this field only when scoring a direct debit transaction. 
    */
    'iban'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "number",
            "baseName": "number",
            "type": "string"
        },
        {
            "name": "iban",
            "baseName": "iban",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentreferencesPaymentInformationBankAccount.attributeTypeMap;
    }
}

export class Ptsv2paymentreferencesPaymentInformationCard {
    /**
    * The customer’s payment card number, also known as the Primary Account Number (PAN). You can also use this field for encoded account numbers.  #### FDMS Nashville Required. String (19)  #### GPX Required if `pointOfSaleInformation.entryMode=keyed`. However, this field is optional if your account is configured for relaxed requirements for address data and expiration date. **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.  #### All other processors Required if `pointOfSaleInformation.entryMode=keyed`. However, this field is optional if your account is configured for relaxed requirements for address data and expiration date. **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting. 
    */
    'number'?: string;
    /**
    * Two-digit month in which the payment card expires.  Format: `MM`.  Valid values: `01` through `12`. Leading 0 is required.  #### Barclays and Streamline For Maestro (UK Domestic) and Maestro (International) cards on Barclays and Streamline, this must be a valid value (`01` through `12`) but is not required to be a valid expiration date. In other words, an expiration date that is in the past does not cause CyberSource to reject your request. However, an invalid expiration date might cause the issuer to reject your request.  #### Encoded Account Numbers For encoded account numbers (_type_=039), if there is no expiration date on the card, use `12`.  #### FDMS Nashville Required field.  #### All other processors Required if `pointOfSaleInformation.entryMode=keyed`. However, this field is optional if your account is configured for relaxed requirements for address data and expiration date. **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.  #### Google Pay transactions For PAN-based Google Pay transactions, this field is returned in the API response. 
    */
    'expirationMonth'?: string;
    /**
    * Four-digit year in which the payment card expires.  Format: `YYYY`.  #### Barclays and Streamline For Maestro (UK Domestic) and Maestro (International) cards on Barclays and Streamline, this must be a valid value (`1900` through `3000`) but is not required to be a valid expiration date. In other words, an expiration date that is in the past does not cause CyberSource to reject your request. However, an invalid expiration date might cause the issuer to reject your request.  #### Encoded Account Numbers For encoded account numbers (**_type_**`=039`), if there is no expiration date on the card, use `2021`.  #### FDMS Nashville Required field.  #### FDC Nashville Global and FDMS South You can send in 2 digits or 4 digits. If you send in 2 digits, they must be the last 2 digits of the year.  #### All other processors Required if `pointOfSaleInformation.entryMode=keyed`. However, this field is optional if your account is configured for relaxed requirements for address data and expiration date. **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.  #### Google Pay transactions For PAN-based Google Pay transactions, this field is returned in the API response. 
    */
    'expirationYear'?: string;
    /**
    * Three-digit value that indicates the card type.  **IMPORTANT** It is strongly recommended that you include the card type field in request messages even if it is optional for your processor and card type. Omitting the card type can cause the transaction to be processed with the wrong card type.  Possible values: - `001`: Visa. Use card type value `001` for Visa Electron. - `002`: Mastercard, Eurocard[^1], which is a European regional brand of Mastercard. - `003`: American Express - `004`: Discover - `005`: Diners Club - `006`: Carte Blanche[^1] - `007`: JCB[^1] - `008`: Optima - `009`: GE Private Label - `010`: Beneficial Private Label - `011`: Twinpay Credit Card - `012`: Twinpay Debit Card - `013`: WalMart - `014`: Enroute[^1] - `015`: Lowe's Consumer - `016`: Home Depot Consumer - `017`: MBNA - `018`: Dick's Sportswear - `019`: Casual Corner - `020`: Sears - `021`: JAL[^1] - `023`: Disney Card - `024`: Maestro (UK Domestic)[^1] - `025`: Sam's Club Consumer - `026`: Sam's Club Business - `027`: Nico's - `028`: Paymentech Bill Me Later - `029`: Bebe - `030`: Restoration Hardware - `031`: Delta Online - `032`: Solo - `033`: Visa Electron[^1]. Do not use this value. Use `001` for all Visa card types. - `034`: Dankort[^1] - `035`: Laser - `036`: Cartes Bancaires[^1,4] - `037`: Carta Si[^1] - `038`: Pinless Debit - `039`: Encoded account number[^1] - `040`: UATP[^1] - `041`: HOUSEHOLD - `042`: Maestro (International)[^1] - `043`: GE MONEY - `044`: Korean Cards - `045`: Style Cards - `046`: JCrew - `047`: Payeasecn eWallet - `048`: Payeasecn Bank Transfer - `049`: Meijer - `050`: Hipercard[^2,3] - `051`: Aura - `052`: Redecard - `053`: Orico card - `054`: Elo[^3] - `055`: Capitol One Private Label - `056`: Carnet - `057`: Costco Private Label - `058`: Carnet - `059`: ValueLink - `060`: MADA - `061`: RuPay - `062`: China UnionPay - `063`: Falabella Private Label - `064`: Prompt Card - `065`: Korean Domestic - `066`: Banricompras - `067`: MEEZA - `068`: PayPak - `070`: EFTPOS - `071`: Codensa - `072`: Olimpica - `073`: Colsubsidio - `074`: Tuya - `075`: Sodexo - `076`: Naranja - `077`: Cabal - `078`: DINELCO - `079`: PANAL - `080`: EPM - `081`: Jaywan  [^1]: For this card type, you must include the `paymentInformation.card.type` or `paymentInformation.tokenizedCard.type` field in your request for an authorization or a stand-alone credit. [^2]: For this card type on Cielo 3.0, you must include the `paymentInformation.card.type` or `paymentInformation.tokenizedCard.type` field in a request for an authorization or a stand-alone credit. This card type is not supported on Cielo 1.5. [^3]: For this card type on Getnet and Rede, you must include the `paymentInformation.card.type` or `paymentInformation.tokenizedCard.type` field in a request for an authorization or a stand-alone credit. [^4]: For this card type, you must include the `paymentInformation.card.type` in your request for any payer authentication services.  #### Used by **Authorization** Required for Carte Blanche and JCB. Optional for all other card types.  #### Card Present reply This field is included in the reply message when the client software that is installed on the POS terminal uses the token management service (TMS) to retrieve tokenized payment details. You must contact customer support to have your account enabled to receive these fields in the credit reply message.  Returned by the Credit service.  This reply field is only supported by the following processors: - American Express Direct - Credit Mutuel-CIC - FDC Nashville Global - OmniPay Direct - SIX  #### Google Pay transactions For PAN-based Google Pay transactions, this field is returned in the API response.  #### GPX This field only supports transactions from the following card types: - Visa - Mastercard - AMEX - Discover - Diners - JCB - Union Pay International 
    */
    'type'?: string;
    /**
    * Card Verification Number.  #### FDMS Nashville Required for American Express or if swiped; otherwise, optional.  #### Ingenico ePayments Do not include this field when `commerceIndicator=recurring`. **Note** Ingenico ePayments was previously called _Global Collect_.  #### TSYS Acquiring Solutions Optional if pointOfSaleInformation.entryMode=keyed; otherwise, not used.  #### GPX Optional.  #### All other processors: Optional. 
    */
    'securityCode'?: string;
    /**
    * Flag that specifies the type of account associated with the card.  This field is available only for China UnionPay, Cielo, Comercio Latino and Visa Platform Connect. The cardholder provides this information during the payment process.  This field is required for:  - Debit transactions on Cielo and Comercio Latino.  - Transactions with Brazilian-issued cards on CyberSource through VisaNet.  **China UnionPayCard Transactions on China UnionPay:** Possible values:  - C: Domestic credit card  - D: Domestic debit card  - F: International credit card  - I: International debit card  When the value is D, the e-commerce indicator and CAVV fields must be included in the authorization request. When the value is C, F or I the card verification number, expiration month and expiration year fields must in included in the authorization request.  **Cielo and Comercio Latino Credit Card Transactions:** On these processors, this field is supported only for authorizations.  Possible values:  - CR: Credit card  - DB: Debit card       **Visa Platform Connect Credit Card Transactions:** This field is supported for all card types on Visa Platform Connect. For combo **card present** transactions with Mastercard on Brazilian-issued cards, possible values:  - CR: Credit card  - DB: Debit Card  For combo **card not present** transactions with Mastercard on Brazilian-issued cards, possible values:  - C: Credit card  - D: Debit card  A value of CR or DB in the useAs field takes precedence over any value in the Source Account Type field. 
    */
    'useAs'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "number",
            "baseName": "number",
            "type": "string"
        },
        {
            "name": "expirationMonth",
            "baseName": "expirationMonth",
            "type": "string"
        },
        {
            "name": "expirationYear",
            "baseName": "expirationYear",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "securityCode",
            "baseName": "securityCode",
            "type": "string"
        },
        {
            "name": "useAs",
            "baseName": "useAs",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentreferencesPaymentInformationCard.attributeTypeMap;
    }
}

export class Ptsv2paymentreferencesPaymentInformationEWallet {
    /**
    * Payment method for the unit purchase.   Possible values:   UNRESTRICTED (default)—this value is   available only when configured by PayPal   for the merchant.   INSTANT. 
    */
    'fundingSource'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "fundingSource",
            "baseName": "fundingSource",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentreferencesPaymentInformationEWallet.attributeTypeMap;
    }
}

export class Ptsv2paymentreferencesPaymentInformationOptions {
    /**
    * Identifier for a PayPal credit transaction. Value: Credit 
    */
    'id'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentreferencesPaymentInformationOptions.attributeTypeMap;
    }
}

export class Ptsv2paymentreferencesProcessingInformation {
    /**
    * Will have 2 values, 'U' (Update) , 'N' (New). Any other values will be rejected. Default will be 'N' 
    */
    'sessionType'?: string;
    /**
    * Whether merchant wants to pass the flow Inline or want to invoke Klarna Hosted Page 
    */
    'paymentFlowMode'?: string;
    /**
    * Possible values are one or more of follows:   - `AP_SESSIONS`: Use this when Alternative Payment Sessions service is requested. 
    */
    'actionList'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "sessionType",
            "baseName": "sessionType",
            "type": "string"
        },
        {
            "name": "paymentFlowMode",
            "baseName": "paymentFlowMode",
            "type": "string"
        },
        {
            "name": "actionList",
            "baseName": "actionList",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentreferencesProcessingInformation.attributeTypeMap;
    }
}

export class Ptsv2paymentreferencesTravelInformation {
    'autoRental'?: Ptsv2paymentreferencesTravelInformationAutoRental;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "autoRental",
            "baseName": "autoRental",
            "type": "Ptsv2paymentreferencesTravelInformationAutoRental"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentreferencesTravelInformation.attributeTypeMap;
    }
}

export class Ptsv2paymentreferencesTravelInformationAutoRental {
    /**
    * Merchant to send their auto rental company name 
    */
    'companyName'?: string;
    /**
    * When merchant wants to send the affiliate name. 
    */
    'affiliateName'?: string;
    'rentalAddress'?: Ptsv2paymentsTravelInformationAutoRentalRentalAddress;
    'returnAddress'?: Ptsv2paymentsTravelInformationAutoRentalReturnAddress;
    /**
    * Date/time the auto was returned to the rental agency. Format: ``yyyy-MM-dd HH-mm-ss z`` This field is supported for Visa, MasterCard, and American Express. 
    */
    'returnDateTime'?: string;
    /**
    * Date/time the auto was picked up from the rental agency. Format: `yyyy-MM-dd HH-mm-ss z` This field is supported for Visa, MasterCard, and American Express. 
    */
    'rentalDateTime'?: string;
    /**
    * Name of the individual making the rental agreement.  Valid data lengths by card:  |Card Specific Validation|VISA|MasterCard|Discover|AMEX| |--- |--- |--- |--- | | Filed Length| 40| 40| 29| 26| | Field Type| AN| ANS| AN| AN| | M/O/C| O| M| M| M| 
    */
    'customerName'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "companyName",
            "baseName": "companyName",
            "type": "string"
        },
        {
            "name": "affiliateName",
            "baseName": "affiliateName",
            "type": "string"
        },
        {
            "name": "rentalAddress",
            "baseName": "rentalAddress",
            "type": "Ptsv2paymentsTravelInformationAutoRentalRentalAddress"
        },
        {
            "name": "returnAddress",
            "baseName": "returnAddress",
            "type": "Ptsv2paymentsTravelInformationAutoRentalReturnAddress"
        },
        {
            "name": "returnDateTime",
            "baseName": "returnDateTime",
            "type": "string"
        },
        {
            "name": "rentalDateTime",
            "baseName": "rentalDateTime",
            "type": "string"
        },
        {
            "name": "customerName",
            "baseName": "customerName",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentreferencesTravelInformationAutoRental.attributeTypeMap;
    }
}

export class Ptsv2paymentreferencesUserInterface {
    /**
    * Border Radius, Allowed Values - Number, Chars, SPACE, Percentage(%), DOT(.), Example '25px 10px 25px 10px'; '2em 1em 0.5em 3em' 
    */
    'borderRadius'?: string;
    /**
    * UI Theme Name/Design Name - Allowed Chars: Alpha Numeric, Dot (.), Hyphen (-), Underscore (_) 
    */
    'theme'?: string;
    'color'?: Ptsv2paymentreferencesUserInterfaceColor;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "borderRadius",
            "baseName": "borderRadius",
            "type": "string"
        },
        {
            "name": "theme",
            "baseName": "theme",
            "type": "string"
        },
        {
            "name": "color",
            "baseName": "color",
            "type": "Ptsv2paymentreferencesUserInterfaceColor"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentreferencesUserInterface.attributeTypeMap;
    }
}

export class Ptsv2paymentreferencesUserInterfaceColor {
    /**
    * Border Color 
    */
    'border'?: string;
    /**
    * Selected Border Color 
    */
    'borderSelected'?: string;
    /**
    * Button Color 
    */
    'button'?: string;
    /**
    * Button Text Color 
    */
    'buttonText'?: string;
    /**
    * Checkbox Color 
    */
    'checkbox'?: string;
    /**
    * Checkbox Checkmark Color 
    */
    'checkboxCheckMark'?: string;
    /**
    * Header Color 
    */
    'header'?: string;
    /**
    * Link Color 
    */
    'link'?: string;
    /**
    * Text Color 
    */
    'text'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "border",
            "baseName": "border",
            "type": "string"
        },
        {
            "name": "borderSelected",
            "baseName": "borderSelected",
            "type": "string"
        },
        {
            "name": "button",
            "baseName": "button",
            "type": "string"
        },
        {
            "name": "buttonText",
            "baseName": "buttonText",
            "type": "string"
        },
        {
            "name": "checkbox",
            "baseName": "checkbox",
            "type": "string"
        },
        {
            "name": "checkboxCheckMark",
            "baseName": "checkboxCheckMark",
            "type": "string"
        },
        {
            "name": "header",
            "baseName": "header",
            "type": "string"
        },
        {
            "name": "link",
            "baseName": "link",
            "type": "string"
        },
        {
            "name": "text",
            "baseName": "text",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentreferencesUserInterfaceColor.attributeTypeMap;
    }
}

export class Ptsv2paymentreferencesidintentsOrderInformation {
    'amountDetails'?: Ptsv2paymentsOrderInformationAmountDetailsOrder;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "amountDetails",
            "baseName": "amountDetails",
            "type": "Ptsv2paymentsOrderInformationAmountDetailsOrder"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentreferencesidintentsOrderInformation.attributeTypeMap;
    }
}

export class Ptsv2paymentreferencesidintentsPaymentInformation {
    'paymentType'?: Ptsv2paymentsidreversalsPaymentInformationPaymentType;
    'eWallet'?: Ptsv2paymentreferencesidintentsPaymentInformationEWallet;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "paymentType",
            "baseName": "paymentType",
            "type": "Ptsv2paymentsidreversalsPaymentInformationPaymentType"
        },
        {
            "name": "eWallet",
            "baseName": "eWallet",
            "type": "Ptsv2paymentreferencesidintentsPaymentInformationEWallet"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentreferencesidintentsPaymentInformation.attributeTypeMap;
    }
}

export class Ptsv2paymentreferencesidintentsPaymentInformationEWallet {
    /**
    * The ID of the customer, passed in the return_url field by PayPal after customer approval.
    */
    'accountId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "accountId",
            "baseName": "accountId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentreferencesidintentsPaymentInformationEWallet.attributeTypeMap;
    }
}

export class Ptsv2paymentreferencesidintentsProcessingInformation {
    /**
    * Array of actions (one or more) to be included in the order to invoke bundled services along with order. Possible values: - `AP_ORDER`: Use this when Alternative Payment Order service is requested. 
    */
    'actionList'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "actionList",
            "baseName": "actionList",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentreferencesidintentsProcessingInformation.attributeTypeMap;
    }
}

export class Ptsv2paymentsAcquirerInformation {
    /**
    * Acquirer bank ID number that  corresponds to a certificate that Cybersource already has.This ID has this format. 4XXXXX for Visa and 5XXXXX for Mastercard. 
    */
    'acquirerBin'?: string;
    /**
    * Issuers need to be aware of the Acquirer's Country Code when the Acquirer country differs from the Merchant country and the Acquirer is in the EEA (European Economic Area). 
    */
    'country'?: string;
    /**
    * Registered password for the Visa directory server. 
    */
    'password'?: string;
    /**
    * Username for the visa directory server that is created when your acquirer sets up your account. This ID might be the same as your merchant ID. the username can be 15 or 23 characters. 
    */
    'merchantId'?: string;
    /**
    * Acquirer assigned merchant id. Check if your processor supports this field. 
    */
    'acquirerMerchantId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "acquirerBin",
            "baseName": "acquirerBin",
            "type": "string"
        },
        {
            "name": "country",
            "baseName": "country",
            "type": "string"
        },
        {
            "name": "password",
            "baseName": "password",
            "type": "string"
        },
        {
            "name": "merchantId",
            "baseName": "merchantId",
            "type": "string"
        },
        {
            "name": "acquirerMerchantId",
            "baseName": "acquirerMerchantId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsAcquirerInformation.attributeTypeMap;
    }
}

export class Ptsv2paymentsAggregatorInformation {
    /**
    * Value that identifies you as a payment aggregator. Get this value from the processor.  #### CyberSource through VisaNet The value for this field corresponds to the following data in the TC 33 capture file5: - Record: CP01 TCR6 - Position: 95-105 - Field: Payment Facilitator ID  This field is supported for Visa, Mastercard and Discover Transactions.  **FDC Compass**\\ This value must consist of uppercase characters. 
    */
    'aggregatorId'?: string;
    /**
    * Your payment aggregator business name.  **American Express Direct**\\ The maximum length of the aggregator name depends on the length of the sub-merchant name. The combined length for both values must not exceed 36 characters.\\  #### CyberSource through VisaNet With American Express, the maximum length of the aggregator name depends on the length of the sub-merchant name. The combined length for both values must not exceed 36 characters. The value for this field does not map to the TC 33 capture file5.  **FDC Compass**\\ This value must consist of uppercase characters. 
    */
    'name'?: string;
    'subMerchant'?: Ptsv2paymentsAggregatorInformationSubMerchant;
    /**
    * Acquirer street name.
    */
    'streetAddress'?: string;
    /**
    * Acquirer city.
    */
    'city'?: string;
    /**
    * Acquirer state.
    */
    'state'?: string;
    /**
    * Acquirer postal code.
    */
    'postalCode'?: string;
    /**
    * Acquirer country.
    */
    'country'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "aggregatorId",
            "baseName": "aggregatorId",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "subMerchant",
            "baseName": "subMerchant",
            "type": "Ptsv2paymentsAggregatorInformationSubMerchant"
        },
        {
            "name": "streetAddress",
            "baseName": "streetAddress",
            "type": "string"
        },
        {
            "name": "city",
            "baseName": "city",
            "type": "string"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "string"
        },
        {
            "name": "postalCode",
            "baseName": "postalCode",
            "type": "string"
        },
        {
            "name": "country",
            "baseName": "country",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsAggregatorInformation.attributeTypeMap;
    }
}

export class Ptsv2paymentsAggregatorInformationSubMerchant {
    /**
    * Unique identifier assigned by the payment card company to the sub-merchant.
    */
    'cardAcceptorId'?: string;
    /**
    * The ID you assigned to your sub-merchant. CyberSource through VisaNet: For American Express transaction, the value for this field corresponds to the following data in the TC 33 capture file: - Record: CP01 TCRB - Position: 65-84 - Field: American Express Seller ID For  Mastercard transactions, the value for this field corresponds to the following data in the TC 33 capture file: - Record: CP01 TCR6 - Position: 117-131 - Field: Sub-Merchant ID FDC Compass: This value must consist of uppercase characters.  American Express Direct: String (20) CyberSource through VisaNet with American Express: String (20) CyberSource through VisaNet with Visa,Mastercard and Discover: String (15) FDC Compass: String (20) FDC Nashville Global: String (14) 
    */
    'id'?: string;
    /**
    * Sub-merchant’s business name.  #### American Express Direct The maximum length of the sub-merchant name depends on the length of the aggregator name. The combined length for both values must not exceed 36 characters.  #### CyberSource through VisaNet With American Express, the maximum length of the sub-merchant name depends on the length of the aggregator name. The combined length for both values must not exceed 36 characters. The value for this field does not map to the TC 33 capture file5.  #### FDC Compass This value must consist of uppercase characters.  #### FDC Nashville Global With Mastercard, the maximum length of the sub-merchant name depends on the length of the aggregator name: - If aggregator name length is 1 through 3, maximum sub-merchant name length is 21. - If aggregator name length is 4 through 7, maximum sub-merchant name length is 17. - If aggregator name length is 8 through 12, maximum sub-merchant name length is 12. 
    */
    'name'?: string;
    /**
    * First line of the sub-merchant’s street address.  #### CyberSource through VisaNet The value for this field does not map to the TC 33 capture file5.  #### FDC Compass This value must consist of uppercase characters. 
    */
    'address1'?: string;
    /**
    * Sub-merchant’s city.  #### CyberSource through VisaNet The value for this field does not map to the TC 33 capture file5.  #### FDC Compass This value must consist of uppercase characters. 
    */
    'locality'?: string;
    /**
    * Sub-merchant’s state or province.  #### CyberSource through VisaNet The value for this field does not map to the TC 33 capture file5.  #### FDC Compass This value must consist of uppercase characters. 
    */
    'administrativeArea'?: string;
    /**
    * Sub-merchant’s region.  **Example**\\ `NE` indicates that the sub-merchant is in the northeast region. 
    */
    'region'?: string;
    /**
    * Partial postal code for the sub-merchant’s address.  #### CyberSource through VisaNet The value for this field does not map to the TC 33 capture file5.  #### FDC Compass This value must consist of uppercase characters. 
    */
    'postalCode'?: string;
    /**
    * Sub-merchant’s country. Use the [ISO Standard Country Codes](https://developer.cybersource.com/library/documentation/sbc/quickref/countries_alpha_list.pdf).  #### CyberSource through VisaNet The value for this field does not map to the TC 33 capture file.  #### FDC Compass This value must consist of uppercase characters. 
    */
    'country'?: string;
    /**
    * Sub-merchant’s email address.  **Maximum length for processors**   - American Express Direct: 40  - CyberSource through VisaNet: 40  - FDC Compass: 40  - FDC Nashville Global: 19  #### CyberSource through VisaNet With American Express, the value for this field corresponds to the following data in the TC 33 capture file: - Record: CP01 TCRB - Position: 25-64 - Field: American Express Seller E-mail Address  **Note** The TC 33 Capture file contains information about the purchases and refunds that a merchant submits to CyberSource. CyberSource through VisaNet creates the TC 33 Capture file at the end of the day and sends it to the merchant’s acquirer, who uses this information to facilitate end-of-day clearing processing with payment card companies. 
    */
    'email'?: string;
    /**
    * Sub-merchant’s telephone number.  **Maximum length for procesors**   - American Express Direct: 20  - CyberSource through VisaNet: 20  - FDC Compass: 13  - FDC Nashville Global: 10  #### CyberSource through VisaNet With American Express, the value for this field corresponds to the following data in the TC 33 capture file5: - Record: CP01 TCRB - Position: 5-24 - Field: American Express Seller Telephone Number  **FDC Compass**\\ This value must consist of uppercase characters. Use one of these recommended formats:\\ `NNN-NNN-NNNN`\\ `NNN-AAAAAAA` 
    */
    'phoneNumber'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "cardAcceptorId",
            "baseName": "cardAcceptorId",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "address1",
            "baseName": "address1",
            "type": "string"
        },
        {
            "name": "locality",
            "baseName": "locality",
            "type": "string"
        },
        {
            "name": "administrativeArea",
            "baseName": "administrativeArea",
            "type": "string"
        },
        {
            "name": "region",
            "baseName": "region",
            "type": "string"
        },
        {
            "name": "postalCode",
            "baseName": "postalCode",
            "type": "string"
        },
        {
            "name": "country",
            "baseName": "country",
            "type": "string"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "phoneNumber",
            "baseName": "phoneNumber",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsAggregatorInformationSubMerchant.attributeTypeMap;
    }
}

export class Ptsv2paymentsAgreementInformation {
    /**
    * Identifier for the mandate being signed for. This mandate id is required for all the subsequent transactions. 
    */
    'agreementId'?: string;
    /**
    * The processor specific billing agreement ID. References an approved recurring payment for goods or services. This value is sent by merchant via Cybersource to processor. The value sent in this field is procured by the merchant from the processor. 
    */
    'id'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "agreementId",
            "baseName": "agreementId",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsAgreementInformation.attributeTypeMap;
    }
}

export class Ptsv2paymentsBuyerInformation {
    /**
    * Your identifier for the customer.  When a subscription or customer profile is being created, the maximum length for this field for most processors is 30. Otherwise, the maximum length is 100.  #### Comercio Latino For recurring payments in Mexico, the value is the customer’s contract number. Note Before you request the authorization, you must inform the issuer of the customer contract numbers that will be used for recurring transactions.  #### Worldpay VAP For a follow-on credit with Worldpay VAP, CyberSource checks the following locations, in the order given, for a customer account ID value and uses the first value it finds: 1. `customer_account_id` value in the follow-on credit request 2. Customer account ID value that was used for the capture that is being credited 3. Customer account ID value that was used for the original authorization If a customer account ID value cannot be found in any of these locations, then no value is used. 
    */
    'merchantCustomerId'?: string;
    /**
    * Recipient’s date of birth. **Format**: `YYYYMMDD`.  This field is a `pass-through`, which means that CyberSource ensures that the value is eight numeric characters but otherwise does not verify the value or modify it in any way before sending it to the processor. If the field is not required for the transaction, CyberSource does not forward it to the processor. 
    */
    'dateOfBirth'?: string;
    /**
    * Customer’s government-assigned tax identification number.  #### Tax Calculation Optional for international and value added taxes only. Not applicable to U.S. and Canadian taxes. 
    */
    'vatRegistrationNumber'?: string;
    /**
    * Company’s tax identifier. This is only used for eCheck service.  ** TeleCheck ** Contact your TeleCheck representative to find out whether this field is required or optional.  ** All Other Processors ** Not used. 
    */
    'companyTaxId'?: string;
    'personalIdentification'?: Array<Ptsv2paymentsBuyerInformationPersonalIdentification>;
    /**
    * The merchant's password that CyberSource hashes and stores as a hashed password. 
    */
    'hashedPassword'?: string;
    /**
    * Customer's gender. Possible values are F (female), M (male),O (other).
    */
    'gender'?: string;
    /**
    * language setting of the user.  Supports 2-character language codes (e.g., en, fr) and 5-character locale values (e.g., en-US, fr-CA). 
    */
    'language'?: string;
    /**
    * Note to the recipient of the funds in this transaction
    */
    'noteToSeller'?: string;
    /**
    * Cardholder’s mobile phone number. **Important** Required for Visa Secure transactions in Brazil. Do not use this request field for any other types of transactions. 
    */
    'mobilePhone'?: number;
    /**
    * The one-time identification code of the Alipay wallet user.  It is scanned from the barcode that is shown by the mobile application. 
    */
    'walletId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "merchantCustomerId",
            "baseName": "merchantCustomerId",
            "type": "string"
        },
        {
            "name": "dateOfBirth",
            "baseName": "dateOfBirth",
            "type": "string"
        },
        {
            "name": "vatRegistrationNumber",
            "baseName": "vatRegistrationNumber",
            "type": "string"
        },
        {
            "name": "companyTaxId",
            "baseName": "companyTaxId",
            "type": "string"
        },
        {
            "name": "personalIdentification",
            "baseName": "personalIdentification",
            "type": "Array<Ptsv2paymentsBuyerInformationPersonalIdentification>"
        },
        {
            "name": "hashedPassword",
            "baseName": "hashedPassword",
            "type": "string"
        },
        {
            "name": "gender",
            "baseName": "gender",
            "type": "string"
        },
        {
            "name": "language",
            "baseName": "language",
            "type": "string"
        },
        {
            "name": "noteToSeller",
            "baseName": "noteToSeller",
            "type": "string"
        },
        {
            "name": "mobilePhone",
            "baseName": "mobilePhone",
            "type": "number"
        },
        {
            "name": "walletId",
            "baseName": "walletId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsBuyerInformation.attributeTypeMap;
    }
}

export class Ptsv2paymentsBuyerInformationPersonalIdentification {
    /**
    * The type of the identification.  Possible values:   - `NATIONAL`   - `CPF`   - `CPNJ`   - `CURP`   - `SSN`   - `DRIVER_LICENSE`   - `PASSPORT_NUMBER`   - `PERSONAL_ID`   - `TAX_ID`   - `BR_CPF`     The individual tax ID type, typically is 11 characters long   - `BR_CNPJ`    The business tax ID type, typically is 14 characters long.  This field is supported only on the following processors.  #### ComercioLatino Set this field to the Cadastro de Pessoas Fisicas (CPF).  #### CyberSource Latin American Processing Supported for Redecard in Brazil. Set this field to the Cadastro de Pessoas Fisicas (CPF), which is required for AVS for Redecard in Brazil. **Note** CyberSource Latin American Processing is the name of a specific processing connection that CyberSource supports. In the CyberSource API documentation, CyberSource Latin American Processing does not refer to the general topic of processing in Latin America. The information in this field description is for the specific processing connection called CyberSource Latin American Processing. It is not for any other Latin American processors that CyberSource supports. 
    */
    'type'?: string;
    /**
    * The value of the identification type. This field is supported only on the following processors.  #### ComercioLatino Set this field to the Cadastro de Pessoas Fisicas (CPF).  #### CyberSource Latin American Processing Supported for Redecard in Brazil. Set this field to the Cadastro de Pessoas Fisicas (CPF), which is required for AVS for Redecard in Brazil. **Note** CyberSource Latin American Processing is the name of a specific processing connection that CyberSource supports. In the CyberSource API documentation, CyberSource Latin American Processing does not refer to the general topic of processing in Latin America. The information in this field description is for the specific processing connection called CyberSource Latin American Processing. It is not for any other Latin American processors that CyberSource supports.               If `type = PASSPORT`, this is the cardholder's passport number. Recommended for Discover ProtectBuy. 
    */
    'id'?: string;
    /**
    * The government agency that issued the driver's license or passport.  If **type**` = DRIVER_LICENSE`, this is the State or province where the customer’s driver’s license was issued.  If **type**` = PASSPORT`, this is the Issuing country for the cardholder’s passport. Recommended for Discover ProtectBuy.  Use the two-character [State, Province, and Territory Codes for the United States and Canada](https://developer.cybersource.com/library/documentation/sbc/quickref/states_and_provinces.pdf).  #### TeleCheck Contact your TeleCheck representative to find out whether this field is required or optional.  #### All Other Processors Not used. 
    */
    'issuedBy'?: string;
    /**
    * Verification results received from Issuer or Card Network for verification transactions. Response Only Field. 
    */
    'verificationResults'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "issuedBy",
            "baseName": "issuedBy",
            "type": "string"
        },
        {
            "name": "verificationResults",
            "baseName": "verificationResults",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsBuyerInformationPersonalIdentification.attributeTypeMap;
    }
}

export class Ptsv2paymentsClientReferenceInformation {
    /**
    * Merchant-generated order reference or tracking number. It is recommended that you send a unique value for each transaction so that you can perform meaningful searches for the transaction.  #### Used by **Authorization** Required field.  #### PIN Debit Requests for PIN debit reversals need to use the same merchant reference number that was used in the transaction that is being reversed.  Required field for all PIN Debit requests (purchase, credit, and reversal).  #### FDC Nashville Global Certain circumstances can cause the processor to truncate this value to 15 or 17 characters for Level II and Level III processing, which can cause a discrepancy between the value you submit and the value included in some processor reports. 
    */
    'code'?: string;
    /**
    * Reference number for the transaction. Depending on how your Cybersource account is configured, this value could either be provided in the API request or generated by CyberSource. The actual value used in the request to the processor is provided back to you by Cybersource in the response. 
    */
    'reconciliationId'?: string;
    /**
    * Used to resume a transaction that was paused for an order modification rule to allow for payer authentication to complete. To resume and continue with the authorization/decision service flow, call the services and include the request id from the prior decision call. 
    */
    'pausedRequestId'?: string;
    /**
    * Identifier that you assign to the transaction. Normally generated by a client server to identify a unique API request.  **Note** Use this field only if you want to support merchant-initiated reversal and void operations.  #### Used by **Authorization, Authorization Reversal, Capture, Credit, and Void** Optional field.  #### PIN Debit For a PIN debit reversal, your request must include a request ID or a merchant transaction identifier. Optional field for PIN debit purchase or credit requests. 
    */
    'transactionId'?: string;
    /**
    * Brief description of the order or any comment you wish to add to the order.
    */
    'comments'?: string;
    'partner'?: Ptsv2paymentsClientReferenceInformationPartner;
    /**
    * The name of the Connection Method client (such as Virtual Terminal or SOAP Toolkit API) that the merchant uses to send a transaction request to CyberSource. 
    */
    'applicationName'?: string;
    /**
    * Version of the CyberSource application or integration used for a transaction. 
    */
    'applicationVersion'?: string;
    /**
    * The entity that is responsible for running the transaction and submitting the processing request to CyberSource. This could be a person, a system, or a connection method. 
    */
    'applicationUser'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        },
        {
            "name": "reconciliationId",
            "baseName": "reconciliationId",
            "type": "string"
        },
        {
            "name": "pausedRequestId",
            "baseName": "pausedRequestId",
            "type": "string"
        },
        {
            "name": "transactionId",
            "baseName": "transactionId",
            "type": "string"
        },
        {
            "name": "comments",
            "baseName": "comments",
            "type": "string"
        },
        {
            "name": "partner",
            "baseName": "partner",
            "type": "Ptsv2paymentsClientReferenceInformationPartner"
        },
        {
            "name": "applicationName",
            "baseName": "applicationName",
            "type": "string"
        },
        {
            "name": "applicationVersion",
            "baseName": "applicationVersion",
            "type": "string"
        },
        {
            "name": "applicationUser",
            "baseName": "applicationUser",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsClientReferenceInformation.attributeTypeMap;
    }
}

export class Ptsv2paymentsClientReferenceInformationPartner {
    /**
    * Value that links the previous transaction to the current follow-on request. This value is assigned by the client software that is installed on the POS terminal, which makes it available to the terminal’s software and to CyberSource. Therefore, you can use this value to reconcile transactions between CyberSource and the terminal’s software.  CyberSource does not forward this value to the processor. Instead, the value is forwarded to the CyberSource reporting functionality.  This field is supported only on these processors: - American Express Direct - Credit Mutuel-CIC - FDC Nashville Global - OmniPay Direct - SIX  Optional field. 
    */
    'originalTransactionId'?: string;
    /**
    * Identifier for the developer that helped integrate a partner solution to CyberSource.  Send this value in all requests that are sent through the partner solutions built by that developer. CyberSource assigns the ID to the developer.  **Note** When you see a developer ID of 999 in reports, the developer ID that was submitted is incorrect. 
    */
    'developerId'?: string;
    /**
    * Identifier for the partner that is integrated to CyberSource.  Send this value in all requests that are sent through the partner solution. CyberSource assigns the ID to the partner.  **Note** When you see a solutionId of 999 in reports, the solutionId that was submitted is incorrect. 
    */
    'solutionId'?: string;
    /**
    * Value that identifies the application vendor and application version for a third party gateway. CyberSource provides you with this value during testing and validation. This field is supported only on CyberSource through VisaNet.  #### Used by **Authorization, Authorization Reversal, Capture, Credit, Incremental Authorization, and Void** Optional field.  #### PIN debit Required field for PIN debit credit, PIN debit purchase, or PIN debit reversal request. 
    */
    'thirdPartyCertificationNumber'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "originalTransactionId",
            "baseName": "originalTransactionId",
            "type": "string"
        },
        {
            "name": "developerId",
            "baseName": "developerId",
            "type": "string"
        },
        {
            "name": "solutionId",
            "baseName": "solutionId",
            "type": "string"
        },
        {
            "name": "thirdPartyCertificationNumber",
            "baseName": "thirdPartyCertificationNumber",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsClientReferenceInformationPartner.attributeTypeMap;
    }
}

export class Ptsv2paymentsConsumerAuthenticationInformation {
    /**
    * Cardholder authentication verification value (CAVV).
    */
    'cavv'?: string;
    /**
    * This field details out the type of transaction. Below are the possible values. 08:GC- Guest Checkout. 
    */
    'transactionFlowIndicator'?: string;
    /**
    * Algorithm used to generate the CAVV for Visa Secure or the UCAF authentication data for Mastercard Identity Check. 
    */
    'cavvAlgorithm'?: string;
    /**
    * Raw electronic commerce indicator (ECI). 
    */
    'eciRaw'?: string;
    /**
    * Payer authentication response status. 
    */
    'paresStatus'?: string;
    /**
    * Verification response enrollment status. 
    */
    'veresEnrolled'?: string;
    /**
    * Transaction identifier. 
    */
    'xid'?: string;
    /**
    * Universal cardholder authentication field (UCAF) collection indicator.  #### CyberSource through VisaNet The value for this field corresponds to the following data in the TC 33 capture file5: - Record: CP01 TCR7 - Position: 5 - Field: Mastercard Electronic Commerce Indicators—UCAF Collection Indicator 
    */
    'ucafCollectionIndicator'?: string;
    /**
    * Universal cardholder authentication field (UCAF) data. 
    */
    'ucafAuthenticationData'?: string;
    'strongAuthentication'?: Ptsv2paymentsConsumerAuthenticationInformationStrongAuthentication;
    /**
    * The Directory Server Transaction ID is generated by the Mastercard Directory Server during the authentication transaction and passed back to the merchant with the authentication results. For Cybersource Through Visanet Gateway: The value for this field corresponds to the following data in the TC 33 capture file3:  Record: CP01 TCR7, Position: 114-149, Field: MC AVV Verification—Directory Server Transaction ID 
    */
    'directoryServerTransactionId'?: string;
    /**
    * This field contains 3DS version that was used for Secured Consumer Authentication (SCA).  The value for this field should be in the format major.minor.patch version.  Valid Values are:  - `2.1.0` (EMV 3D Secure Version 2.1) - `2.2.0` (EMV 3D Secure Version 2.2) - `2.3.0` (EMV 3D Secure Version 2.3) - `2.4.0` (EMV 3D Secure Version 2.4) - `2.5.0` (EMV 3D Secure Version 2.5) - `2.6.0` (EMV 3D Secure Version 2.6) - `2.7.0` (EMV 3D Secure Version 2.7) - `2.8.0` (EMV 3D Secure Version 2.8) - `2.9.0` (EMV 3D Secure Version 2.9)  For Visa Platform Connect:         The value for this field corresponds to the following data in the TC 33 capture file3:  Record: CP01 TCR7, Position: 113 , Field: MC AVV Verification—Program Protocol  It will contain one of the following values: - `1` (3D Secure Version 1.x (3DS 1.0)) - `2` (EMV 3-D Secure (3DS 2.x)) 
    */
    'paSpecificationVersion'?: string;
    /**
    * Indicates the type of authentication that will be used to challenge the card holder.  Possible Values:  01 - Static  02 - Dynamic  03 - OOB (Out of Band)  04 - Decoupled  20 - OTP hosted at merchant end. (Rupay S2S flow) **NOTE**:  EMV 3-D Secure version 2.1.0 supports values 01-03.  Version 2.2.0 supports values 01-04.  Decoupled authentication is not supported at this time. 
    */
    'authenticationType'?: string;
    /**
    * JWT returned by the 3D Secure provider when the authentication is complete. Required for Hybrid integration if you use the Cybersource-generated access token. Note: Max. length of this field is 2048 characters. 
    */
    'responseAccessToken'?: string;
    /**
    * Unique transaction identifier assigned by the ACS to identify a single transaction.  This field is supported for Cartes Bancaires Fast'R transactions on Credit Mutuel-CIC. 
    */
    'acsTransactionId'?: string;
    /**
    * An override field that a merchant can pass in to set the challenge window size to display to the end cardholder.  The ACS (Active Control Server) will reply with content that is formatted appropriately to this window size to allow for the best user experience.  The sizes are width x height in pixels of the window displayed in the cardholder browser window.  01 - 250x400  02 - 390x400  03 - 500x600  04 - 600x400  05 - Full page 
    */
    'acsWindowSize'?: string;
    /**
    * Data that documents and supports a specific authentication process. 
    */
    'alternateAuthenticationData'?: string;
    /**
    * Date and time in UTC of the cardholder authentication. Format: YYYYMMDDHHMM 
    */
    'alternateAuthenticationDate'?: string;
    /**
    * Mechanism used by the cardholder to authenticate to the 3D Secure requestor. Possible values: - `01`: No authentication occurred - `02`: Login using merchant system credentials - `03`: Login using Federated ID - `04`: Login using issuer credentials - `05`: Login using third-party authenticator - `06`: Login using FIDO Authenticator 
    */
    'alternateAuthenticationMethod'?: string;
    /**
    * The date/time of the authentication at the 3DS servers. RISK update authorization service in auth request payload with value returned in `consumerAuthenticationInformation.alternateAuthenticationData` if merchant calls via CYBS or field can be provided by merchant in authorization request if calling an external 3DS provider.  This field is supported for Cartes Bancaires Fast'R transactions on Credit Mutuel-CIC. Format: YYYYMMDDHHMMSS 
    */
    'authenticationDate'?: string;
    /**
    * Payer authentication transaction identifier passed to link the check enrollment and validate authentication messages.For Rupay,this is passed only in Re-Send OTP usecase. **Note**: Required for Standard integration, Rupay Seamless server to server integration for enroll service. Required for Hybrid integration for validate service. 
    */
    'authenticationTransactionId'?: string;
    /**
    * An indicator as to why the transaction was canceled. Possible Values:  - `01`: Cardholder selected Cancel. - `02`: Reserved for future EMVCo use (values invalid until defined by EMVCo). - `03`: Transaction Timed Out—Decoupled Authentication - `04`: Transaction timed out at ACS—other timeouts - `05`: Transaction Timed out at ACS - First CReq not received by ACS - `06`: Transaction Error - `07`: Unknown - `08`: Transaction Timed Out at SDK 
    */
    'challengeCancelCode'?: string;
    /**
    * Possible values: - `01`: No preference - `02`: No challenge request - `03`: Challenge requested (3D Secure requestor preference) - `04`: Challenge requested (mandate) - `05`: No challenge requested (transactional risk analysis is already performed) - `06`: No challenge requested (Data share only) - `07`: No challenge requested (strong consumer authentication is already performed) - `08`: No challenge requested (utilize whitelist exemption if no challenge required) - `09`: Challenge requested (whitelist prompt requested if challenge required) **Note** This field will default to `01` on merchant configuration and can be overridden by the merchant. EMV 3D Secure version 2.1.0 supports values `01-04`. Version 2.2.0 supports values `01-09`. 
    */
    'challengeCode'?: string;
    /**
    * The `consumerAuthenticationInformation.challengeCode` indicates the authentication type/level, or challenge, that was presented to the cardholder at checkout by the merchant when calling the Carte Bancaire 3DS servers via CYBS RISK services. It conveys to the issuer the alternative authentication methods that the consumer used. 
    */
    'challengeStatus'?: string;
    /**
    * An alias that uniquely identifies the customer's account and credit card on file. Note This field is required if Tokenization is enabled in the merchant profile settings. 
    */
    'customerCardAlias'?: string;
    /**
    * Indicates whether the 3DS Requestor requests the ACS to utilize Decoupled Authentication and agrees to utilize Decoupled Authentication if the ACS confirms its use.  Possible Values:  Y - Decoupled Authentication is supported and preferred if challenge is necessary  N - Do not use Decoupled Authentication  **Default Value**: N 
    */
    'decoupledAuthenticationIndicator'?: string;
    /**
    * Indicates the maximum amount of time that the 3DS Requestor will wait for an ACS (Active control server) to provide the results of a Decoupled Authentication transaction (in minutes). Possible Values: Numeric values between 1 and 10080 accepted. 
    */
    'decoupledAuthenticationMaxTime'?: string;
    /**
    * Indicates that the card being used is the one designated as the primary payment card for purchase. Recommended for Discover ProtectBuy. 
    */
    'defaultCard'?: boolean;
    /**
    * Determines the channel that the transaction came through. Possible Values: SDK/Browser/3RI. 3RI - 3DS request initiated. 
    */
    'deviceChannel'?: string;
    /**
    * An integer value greater than 1 indicating the max number of permitted authorizations for installment payments. **Note** This is required if the merchant and cardholder have agreed to installment payments. 
    */
    'installmentTotalCount'?: number;
    /**
    * Calculated by merchants as per PSD2** RTS** (EEA** card fraud divided by all EEA card volumes). Possible Values: 1 = Represents fraud rate <=1  2 = Represents fraud rate >1 and <=6  3 = Represents fraud rate >6 and <=13  4 = Represents fraud rate >13 and <=25  5 = Represents fraud rate >25  EEA** = European Economic Area RTS** = Regulatory Technical Standards PSD2** = Payment Services Directive 
    */
    'merchantFraudRate'?: string;
    /**
    * Indicates whether the customer has opted in for marketing offers. Recommended for Discover ProtectBuy. 
    */
    'marketingOptIn'?: boolean;
    /**
    * Indicates origin of the marketing offer. Recommended for Discover ProtectBuy. 
    */
    'marketingSource'?: string;
    /**
    * Merchant category code. **Important** Required only for Visa Secure transactions in Brazil. Do not use this request field for any other types of transactions. 
    */
    'mcc'?: string;
    /**
    * Risk Score provided by merchants. This is specific for CB transactions. 
    */
    'merchantScore'?: number;
    /**
    * Category of the message for a specific use case. Possible values:  - `01`: PA- payment authentication - `02`: NPA- non-payment authentication - `03-79`: Reserved for EMVCo future use (values invalid until defined by EMVCo) - `80-99`: Reserved for DS use 
    */
    'messageCategory'?: string;
    /**
    * The global score calculated by the CB scoring platform and returned to merchants.  Possible values:  - '00' - '99'  When you request the payer authentication and authorization services separately, get the value for this field from the pa_network_score reply field.         This field is supported only for Cartes Bancaires Fast'R transactions on Credit Mutuel-CIC. 
    */
    'networkScore'?: string;
    /**
    * Non-Payer Authentication Indicator. Possible values: - `01`: Add card - `02`: Maintain card information - `03`: Cardholder verification for EMV token - `04-80` Reserved for EMVCo - `80-90` Reserved DS 
    */
    'npaCode'?: string;
    /**
    * Specifies the Brazilian payment account type used for the transaction. This field overrides other payment types that might be specified in the request. Use one of the following values for this field: - `NA`: Not applicable. Do not override other payment types that are specified in the request. - `CR`: Credit card. - `DB`: Debit card. - `VSAVR`: Visa Vale Refeicao - `VSAVA`: Visa Vale Alimentacao **Important** Required only for Visa Secure transactions in Brazil. Do not use this request field for any other types of transactions. 
    */
    'overridePaymentMethod'?: string;
    /**
    * Two-character [ISO Standard Country Codes](https://developer.cybersource.com/library/documentation/sbc/quickref/countries_alpha_list.pdf).. 
    */
    'overrideCountryCode'?: string;
    /**
    * This field carry data that the ACS can use to verify the authentication process. 
    */
    'priorAuthenticationData'?: string;
    /**
    * Mechanism used by the Cardholder to previously authenticate to the 3DS Requestor.  01 - Frictionless authentication occurred by ACS  02 - Cardholder challenge occurred by ACS  03 - AVS verified  04 - Other issuer methods  05-79 - Reserved for EMVCo future use (values invalid until defined by EMVCo)  80-99 - Reserved for DS use 
    */
    'priorAuthenticationMethod'?: string;
    /**
    * This data element contains a ACS Transaction ID for a prior authenticated transaction. For example, the first recurring transaction that was authenticated with the cardholder 
    */
    'priorAuthenticationReferenceId'?: string;
    /**
    * Date and time in UTC of the prior cardholder authentication. Format – YYYYMMDDHHMM 
    */
    'priorAuthenticationTime'?: string;
    /**
    * Specifies the product code, which designates the type of transaction. Specify one of the following values for this field: - AIR: Airline purchase Important Required for American Express SafeKey (U.S.). - `ACC`: Accommodation Rental - `ACF`: Account funding - `CHA`: Check acceptance - `DIG`: Digital Goods - `DSP`: Cash Dispensing - `GAS`: Fuel - `GEN`: General Retail - `LUX`: Luxury Retail - `PAL`: Prepaid activation and load - `PHY`: Goods or services purchase - `QCT`: Quasi-cash transaction - `REN`: Car Rental - `RES`: Restaurant - `SVC`: Services - `TBD`: Other - `TRA`: Travel **Important** Required for Visa Secure transactions in Brazil. Do not use this request field for any other types of transactions. 
    */
    'productCode'?: string;
    /**
    * The URL of the merchant’s return page. CyberSource adds this return URL to the step-up JWT and returns it in the response of the Payer Authentication enrollment call. The merchant's return URL page serves as a listening URL. Once the bank session completes, the merchant receives a POST to their URL. This response contains the completed bank session’s transactionId. The merchant’s return page should capture the transaction ID and send it in the Payer Authentication validation call. 
    */
    'returnUrl'?: string;
    /**
    * Cardinal's directory server assigned 3DS Requestor ID value
    */
    'requestorId'?: string;
    /**
    * Indicates the type of 3RI request.  Possible Values:  01 - Recurring transaction  02 - Installment transaction  03 - Add card  04 - Maintain card  05 - Account verification  06 - Split/delayed shipment  07 - Top-up  08 - Mail Order  09 - Telephone Order  10 - Whitelist status check  11 - Other payment 
    */
    'requestorInitiatedAuthenticationIndicator'?: string;
    /**
    * Cardinal's directory server assigned 3DS Requestor Name value
    */
    'requestorName'?: string;
    /**
    * Reference ID that corresponds to the device fingerprinting data that was collected previously. Note Required for Hybrid integration. 
    */
    'referenceId'?: string;
    /**
    * This field indicates the maximum amount of time for all 3DS 2.0 messages to be communicated between all components (in minutes).  Possible Values:  Greater than or equal to 05 (05 is the minimum timeout to set)  Cardinal Default is set to 15  NOTE: This field is a required 3DS 2.0 field and Cardinal sends in a default of 15 if nothing is passed 
    */
    'sdkMaxTimeout'?: string;
    /**
    * Indicates dedicated payment processes and procedures were used, potential secure corporate payment exemption applies. Possible Values : 0/1 
    */
    'secureCorporatePaymentIndicator'?: string;
    /**
    * Transaction mode identifier. Identifies the channel from which the transaction originates. Possible values:  - `M`: MOTO (Mail Order Telephone Order) - `R`: Retail - `S`: eCommerce - `P`: Mobile Device - `T`: Tablet 
    */
    'transactionMode'?: string;
    /**
    * Enables the communication of trusted beneficiary/whitelist status between the ACS, the DS and the 3DS Requestor.  Possible Values:  Y - 3DS Requestor is whitelisted by cardholder  N - 3DS Requestor is not whitelisted by cardholder 
    */
    'whiteListStatus'?: string;
    /**
    * Indicates which directory server was used while authentication process, this data is useful in case of scenarios  when domestic scheme directory server is not present and authentication fallbacks to global scheme directory server. Possible values: - VISA - Returned for Mada VISA Co-badged cards, when authentication falls back to VISA Directory Server - MASTERCARD - Returned for Mada MasterCard Co-badged cards, when authentication falls back to MasterCard Directory Server 
    */
    'authenticationBrand'?: string;
    /**
    * This field describes the type of 3DS transaction flow that took place.  It can be one of three possible flows; CH - Challenge FR - Frictionless FD - Frictionless with delegation, (challenge not generated by the issuer but by the scheme on behalf of the issuer). 
    */
    'effectiveAuthenticationType'?: string;
    /**
    * Provides additional information as to why the PAResStatus has a specific value. 
    */
    'signedParesStatusReason'?: string;
    /**
    * Payer authentication result (PARes) message returned by the card-issuing bank. If you need to show proof of enrollment checking, you may need to decrypt and parse the string for the information required by the payment card company. For more information, see \"Storing Payer Authentication Data,\" page 160. Important The value is in base64. You must remove all carriage returns and line feeds before adding the PARes to the request. 
    */
    'signedPares'?: string;
    /**
    * Unique identifier assigned by the EMVCo Secretariat upon Testing and Approval.
    */
    'acsReferenceNumber'?: string;
    /**
    * EMVCo-assigned unique identifier. This field is required in Cardholder Initiated 3DS fully authenticated mada transactions. When you request the payer authentication and authorization services separately, get the value for this field from the payerAuthEnrollReply_dsReferenceNumber or payerAuthValidateReply_dsReferenceNumber response field. 
    */
    'dsReferenceNumber'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "cavv",
            "baseName": "cavv",
            "type": "string"
        },
        {
            "name": "transactionFlowIndicator",
            "baseName": "transactionFlowIndicator",
            "type": "string"
        },
        {
            "name": "cavvAlgorithm",
            "baseName": "cavvAlgorithm",
            "type": "string"
        },
        {
            "name": "eciRaw",
            "baseName": "eciRaw",
            "type": "string"
        },
        {
            "name": "paresStatus",
            "baseName": "paresStatus",
            "type": "string"
        },
        {
            "name": "veresEnrolled",
            "baseName": "veresEnrolled",
            "type": "string"
        },
        {
            "name": "xid",
            "baseName": "xid",
            "type": "string"
        },
        {
            "name": "ucafCollectionIndicator",
            "baseName": "ucafCollectionIndicator",
            "type": "string"
        },
        {
            "name": "ucafAuthenticationData",
            "baseName": "ucafAuthenticationData",
            "type": "string"
        },
        {
            "name": "strongAuthentication",
            "baseName": "strongAuthentication",
            "type": "Ptsv2paymentsConsumerAuthenticationInformationStrongAuthentication"
        },
        {
            "name": "directoryServerTransactionId",
            "baseName": "directoryServerTransactionId",
            "type": "string"
        },
        {
            "name": "paSpecificationVersion",
            "baseName": "paSpecificationVersion",
            "type": "string"
        },
        {
            "name": "authenticationType",
            "baseName": "authenticationType",
            "type": "string"
        },
        {
            "name": "responseAccessToken",
            "baseName": "responseAccessToken",
            "type": "string"
        },
        {
            "name": "acsTransactionId",
            "baseName": "acsTransactionId",
            "type": "string"
        },
        {
            "name": "acsWindowSize",
            "baseName": "acsWindowSize",
            "type": "string"
        },
        {
            "name": "alternateAuthenticationData",
            "baseName": "alternateAuthenticationData",
            "type": "string"
        },
        {
            "name": "alternateAuthenticationDate",
            "baseName": "alternateAuthenticationDate",
            "type": "string"
        },
        {
            "name": "alternateAuthenticationMethod",
            "baseName": "alternateAuthenticationMethod",
            "type": "string"
        },
        {
            "name": "authenticationDate",
            "baseName": "authenticationDate",
            "type": "string"
        },
        {
            "name": "authenticationTransactionId",
            "baseName": "authenticationTransactionId",
            "type": "string"
        },
        {
            "name": "challengeCancelCode",
            "baseName": "challengeCancelCode",
            "type": "string"
        },
        {
            "name": "challengeCode",
            "baseName": "challengeCode",
            "type": "string"
        },
        {
            "name": "challengeStatus",
            "baseName": "challengeStatus",
            "type": "string"
        },
        {
            "name": "customerCardAlias",
            "baseName": "customerCardAlias",
            "type": "string"
        },
        {
            "name": "decoupledAuthenticationIndicator",
            "baseName": "decoupledAuthenticationIndicator",
            "type": "string"
        },
        {
            "name": "decoupledAuthenticationMaxTime",
            "baseName": "decoupledAuthenticationMaxTime",
            "type": "string"
        },
        {
            "name": "defaultCard",
            "baseName": "defaultCard",
            "type": "boolean"
        },
        {
            "name": "deviceChannel",
            "baseName": "deviceChannel",
            "type": "string"
        },
        {
            "name": "installmentTotalCount",
            "baseName": "installmentTotalCount",
            "type": "number"
        },
        {
            "name": "merchantFraudRate",
            "baseName": "merchantFraudRate",
            "type": "string"
        },
        {
            "name": "marketingOptIn",
            "baseName": "marketingOptIn",
            "type": "boolean"
        },
        {
            "name": "marketingSource",
            "baseName": "marketingSource",
            "type": "string"
        },
        {
            "name": "mcc",
            "baseName": "mcc",
            "type": "string"
        },
        {
            "name": "merchantScore",
            "baseName": "merchantScore",
            "type": "number"
        },
        {
            "name": "messageCategory",
            "baseName": "messageCategory",
            "type": "string"
        },
        {
            "name": "networkScore",
            "baseName": "networkScore",
            "type": "string"
        },
        {
            "name": "npaCode",
            "baseName": "npaCode",
            "type": "string"
        },
        {
            "name": "overridePaymentMethod",
            "baseName": "overridePaymentMethod",
            "type": "string"
        },
        {
            "name": "overrideCountryCode",
            "baseName": "overrideCountryCode",
            "type": "string"
        },
        {
            "name": "priorAuthenticationData",
            "baseName": "priorAuthenticationData",
            "type": "string"
        },
        {
            "name": "priorAuthenticationMethod",
            "baseName": "priorAuthenticationMethod",
            "type": "string"
        },
        {
            "name": "priorAuthenticationReferenceId",
            "baseName": "priorAuthenticationReferenceId",
            "type": "string"
        },
        {
            "name": "priorAuthenticationTime",
            "baseName": "priorAuthenticationTime",
            "type": "string"
        },
        {
            "name": "productCode",
            "baseName": "productCode",
            "type": "string"
        },
        {
            "name": "returnUrl",
            "baseName": "returnUrl",
            "type": "string"
        },
        {
            "name": "requestorId",
            "baseName": "requestorId",
            "type": "string"
        },
        {
            "name": "requestorInitiatedAuthenticationIndicator",
            "baseName": "requestorInitiatedAuthenticationIndicator",
            "type": "string"
        },
        {
            "name": "requestorName",
            "baseName": "requestorName",
            "type": "string"
        },
        {
            "name": "referenceId",
            "baseName": "referenceId",
            "type": "string"
        },
        {
            "name": "sdkMaxTimeout",
            "baseName": "sdkMaxTimeout",
            "type": "string"
        },
        {
            "name": "secureCorporatePaymentIndicator",
            "baseName": "secureCorporatePaymentIndicator",
            "type": "string"
        },
        {
            "name": "transactionMode",
            "baseName": "transactionMode",
            "type": "string"
        },
        {
            "name": "whiteListStatus",
            "baseName": "whiteListStatus",
            "type": "string"
        },
        {
            "name": "authenticationBrand",
            "baseName": "authenticationBrand",
            "type": "string"
        },
        {
            "name": "effectiveAuthenticationType",
            "baseName": "effectiveAuthenticationType",
            "type": "string"
        },
        {
            "name": "signedParesStatusReason",
            "baseName": "signedParesStatusReason",
            "type": "string"
        },
        {
            "name": "signedPares",
            "baseName": "signedPares",
            "type": "string"
        },
        {
            "name": "acsReferenceNumber",
            "baseName": "acsReferenceNumber",
            "type": "string"
        },
        {
            "name": "dsReferenceNumber",
            "baseName": "dsReferenceNumber",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsConsumerAuthenticationInformation.attributeTypeMap;
    }
}

export class Ptsv2paymentsConsumerAuthenticationInformationStrongAuthentication {
    'issuerInformation'?: Ptsv2paymentsConsumerAuthenticationInformationStrongAuthenticationIssuerInformation;
    /**
    * This field will contain the low value exemption indicator with one of the following values: Possible values: - `0`  ( low value exemption does not apply to the transaction) - `1` (Transaction exempt from SCA as the merchant/acquirer has determined it to be a low value payment) 
    */
    'lowValueExemptionIndicator'?: string;
    /**
    * This field will contain the transaction risk analysis exemption indicator with one of the following values: Possible values: - `0`  (TRA exemption does not apply to the transaction) - `1` (Transaction exempt from SCA as the merchant/acquirer has determined it to be low risk in accordance with the criteria defined by PSD2/RTS) 
    */
    'riskAnalysisExemptionIndicator'?: string;
    /**
    * Possible values: - `0`  (Trusted merchant exemption does not apply to the transaction) - `1` (Transaction exempt from SCA as it originated at a merchant trusted by the cardholder) 
    */
    'trustedMerchantExemptionIndicator'?: string;
    /**
    * This field will contain the secure corporate payment exemption indicator with one of the following values: Possible values: - `0`  (SCA exemption does not apply to the transaction) - `1` (Transaction exempt from SCA as the merchant/acquirer has determined it as a secure corporate payment) 
    */
    'secureCorporatePaymentIndicator'?: string;
    /**
    * This field will contain the delegated authentication exemption indicator with one of the following values: Possible values: - `0`  (delegated Authentication exemption does not apply to the transaction) - `1` (Transaction exempt from SCA as authentication has been delegated to other provider (PSP,Acquirer)) 
    */
    'delegatedAuthenticationExemptionIndicator'?: string;
    /**
    * This field will contain the outage exemption indicator with one of the following values: Possible values: - `0`  (Outage Authentication exemption does not apply to the transaction) - `1` (Outage exempt from SCA as authentication could not be done due to outage) 
    */
    'outageExemptionIndicator'?: string;
    /**
    * Indicates the type of Authentication request  01 - Payment transaction  02 - Recurring transaction  03 - Installment transaction  04 - Add card  05 - Maintain card  06 - Cardholder verification as part of EMV token ID and V 
    */
    'authenticationIndicator'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "issuerInformation",
            "baseName": "issuerInformation",
            "type": "Ptsv2paymentsConsumerAuthenticationInformationStrongAuthenticationIssuerInformation"
        },
        {
            "name": "lowValueExemptionIndicator",
            "baseName": "lowValueExemptionIndicator",
            "type": "string"
        },
        {
            "name": "riskAnalysisExemptionIndicator",
            "baseName": "riskAnalysisExemptionIndicator",
            "type": "string"
        },
        {
            "name": "trustedMerchantExemptionIndicator",
            "baseName": "trustedMerchantExemptionIndicator",
            "type": "string"
        },
        {
            "name": "secureCorporatePaymentIndicator",
            "baseName": "secureCorporatePaymentIndicator",
            "type": "string"
        },
        {
            "name": "delegatedAuthenticationExemptionIndicator",
            "baseName": "delegatedAuthenticationExemptionIndicator",
            "type": "string"
        },
        {
            "name": "outageExemptionIndicator",
            "baseName": "outageExemptionIndicator",
            "type": "string"
        },
        {
            "name": "authenticationIndicator",
            "baseName": "authenticationIndicator",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsConsumerAuthenticationInformationStrongAuthentication.attributeTypeMap;
    }
}

export class Ptsv2paymentsConsumerAuthenticationInformationStrongAuthenticationIssuerInformation {
    /**
    * Payer authentication exemption indicator for Carte Bancaire exemptions.  This is used with unbundled authentication and authorizations calls, for example: \"low fraud merchant program\". The value for this field maps to the value returned in the payer authentication API response field - `consumerAuthenticationInformation.exemptionDataRaw`. 
    */
    'exemptionDataRaw'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "exemptionDataRaw",
            "baseName": "exemptionDataRaw",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsConsumerAuthenticationInformationStrongAuthenticationIssuerInformation.attributeTypeMap;
    }
}

export class Ptsv2paymentsDeviceInformation {
    /**
    * Value created by the client software that uniquely identifies the POS device. CyberSource does not forward this value to the processor. Instead, the value is forwarded to the CyberSource reporting functionality.  This field is supported only for authorizations and credits on these processors: - American Express Direct - Credit Mutuel-CIC - FDC Nashville Global - OmniPay Direct - SIX  Optional field. String (32) 
    */
    'id'?: string;
    /**
    * DNS resolved hostname from `ipAddress`.
    */
    'hostName'?: string;
    /**
    * IP address of the customer.  #### Used by **Authorization, Capture, and Credit** Optional field. 
    */
    'ipAddress'?: string;
    /**
    * Customer’s browser as identified from the HTTP header data. For example, `Mozilla` is the value that identifies the Netscape browser. 
    */
    'userAgent'?: string;
    /**
    * Field that contains the session ID that you send to Decision Manager to obtain the device fingerprint information. The string can contain uppercase and lowercase letters, digits, hyphen (-), and underscore (_). However, do not use the same uppercase and lowercase letters to indicate different session IDs.  The session ID must be unique for each merchant ID. You can use any string that you are already generating, such as an order number or web session ID.  The session ID must be unique for each page load, regardless of an individual’s web session ID. If a user navigates to a profiled page and is assigned a web session, navigates away from the profiled page, then navigates back to the profiled page, the generated session ID should be different and unique. You may use a web session ID, but it is preferable to use an application GUID (Globally Unique Identifier). This measure ensures that a unique ID is generated every time the page is loaded, even if it is the same user reloading the page. 
    */
    'fingerprintSessionId'?: string;
    /**
    * Boolean that indicates whether request contains the device fingerprint information. Values: - `true`: Use raw fingerprintSessionId when looking up device details. - `false` (default): Use merchant id + fingerprintSessionId as the session id for Device detail collection. 
    */
    'useRawFingerprintSessionId'?: boolean;
    /**
    * The device type at the client side.
    */
    'deviceType'?: string;
    /**
    * This field will contain the deep link that would help the Customer App to wake up. 
    */
    'appUrl'?: string;
    /**
    * Verifies that the payment is originating from a valid, user-approved application and device. Sending this field helps reduce fraud and declined transactions. Note The length is set for a hexadecimal representation of the GUID/UUID. This field accepts a 36-character string (with hyphens) or a 32-character string (without hyphens). Example 123e4567-e89b-12d3-a456-426655440000 Example 123e4567e89b12d3a456426655440000 
    */
    'metadata'?: string;
    'rawData'?: Array<Ptsv2paymentsDeviceInformationRawData>;
    /**
    * Value of the Accept header sent by the customer’s web browser. **Note** If the customer’s browser provides a value, you must include it in your request. 
    */
    'httpAcceptBrowserValue'?: string;
    /**
    * The exact content of the HTTP accept header. 
    */
    'httpAcceptContent'?: string;
    /**
    * Email address set in the customer’s browser, which may differ from customer email. 
    */
    'httpBrowserEmail'?: string;
    /**
    * Value represents the browser language as defined in IETF BCP47. Example:en-US, refer  https://en.wikipedia.org/wiki/IETF_language_tag for more details. 
    */
    'httpBrowserLanguage'?: string;
    /**
    * A Boolean value that represents the ability of the cardholder browser to execute Java. Value is returned from the navigator.javaEnabled property. Possible Values:True/False 
    */
    'httpBrowserJavaEnabled'?: boolean;
    /**
    * A Boolean value that represents the ability of the cardholder browser to execute JavaScript. Possible Values:True/False. **Note**: Merchants should be able to know the values from fingerprint details of cardholder's browser. 
    */
    'httpBrowserJavaScriptEnabled'?: boolean;
    /**
    * Value represents the bit depth of the color palette for displaying images, in bits per pixel. Example : 24, refer https://en.wikipedia.org/wiki/Color_depth for more details 
    */
    'httpBrowserColorDepth'?: string;
    /**
    * Total height of the Cardholder's scree in pixels, example: 864. 
    */
    'httpBrowserScreenHeight'?: string;
    /**
    * Total width of the cardholder's screen in pixels. Example: 1536. 
    */
    'httpBrowserScreenWidth'?: string;
    /**
    * Time difference between UTC time and the cardholder browser local time, in minutes, Example:300 
    */
    'httpBrowserTimeDifference'?: string;
    /**
    * Value of the User-Agent header sent by the customer’s web browser. Note If the customer’s browser provides a value, you must include it in your request. 
    */
    'userAgentBrowserValue'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "hostName",
            "baseName": "hostName",
            "type": "string"
        },
        {
            "name": "ipAddress",
            "baseName": "ipAddress",
            "type": "string"
        },
        {
            "name": "userAgent",
            "baseName": "userAgent",
            "type": "string"
        },
        {
            "name": "fingerprintSessionId",
            "baseName": "fingerprintSessionId",
            "type": "string"
        },
        {
            "name": "useRawFingerprintSessionId",
            "baseName": "useRawFingerprintSessionId",
            "type": "boolean"
        },
        {
            "name": "deviceType",
            "baseName": "deviceType",
            "type": "string"
        },
        {
            "name": "appUrl",
            "baseName": "appUrl",
            "type": "string"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "string"
        },
        {
            "name": "rawData",
            "baseName": "rawData",
            "type": "Array<Ptsv2paymentsDeviceInformationRawData>"
        },
        {
            "name": "httpAcceptBrowserValue",
            "baseName": "httpAcceptBrowserValue",
            "type": "string"
        },
        {
            "name": "httpAcceptContent",
            "baseName": "httpAcceptContent",
            "type": "string"
        },
        {
            "name": "httpBrowserEmail",
            "baseName": "httpBrowserEmail",
            "type": "string"
        },
        {
            "name": "httpBrowserLanguage",
            "baseName": "httpBrowserLanguage",
            "type": "string"
        },
        {
            "name": "httpBrowserJavaEnabled",
            "baseName": "httpBrowserJavaEnabled",
            "type": "boolean"
        },
        {
            "name": "httpBrowserJavaScriptEnabled",
            "baseName": "httpBrowserJavaScriptEnabled",
            "type": "boolean"
        },
        {
            "name": "httpBrowserColorDepth",
            "baseName": "httpBrowserColorDepth",
            "type": "string"
        },
        {
            "name": "httpBrowserScreenHeight",
            "baseName": "httpBrowserScreenHeight",
            "type": "string"
        },
        {
            "name": "httpBrowserScreenWidth",
            "baseName": "httpBrowserScreenWidth",
            "type": "string"
        },
        {
            "name": "httpBrowserTimeDifference",
            "baseName": "httpBrowserTimeDifference",
            "type": "string"
        },
        {
            "name": "userAgentBrowserValue",
            "baseName": "userAgentBrowserValue",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsDeviceInformation.attributeTypeMap;
    }
}

export class Ptsv2paymentsDeviceInformationRawData {
    /**
    * Field that contains the device fingerprint data from the specified provider. The value should be Base64 encoded. 
    */
    'data'?: string;
    /**
    * Possible values: - cardinal - inauth - threatmetrix 
    */
    'provider'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "data",
            "baseName": "data",
            "type": "string"
        },
        {
            "name": "provider",
            "baseName": "provider",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsDeviceInformationRawData.attributeTypeMap;
    }
}

export class Ptsv2paymentsHealthCareInformation {
    /**
    * array for Healthcare fields
    */
    'amountDetails'?: Array<Ptsv2paymentsHealthCareInformationAmountDetails>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "amountDetails",
            "baseName": "amountDetails",
            "type": "Array<Ptsv2paymentsHealthCareInformationAmountDetails>"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsHealthCareInformation.attributeTypeMap;
    }
}

export class Ptsv2paymentsHealthCareInformationAmountDetails {
    /**
    * Total amount that has been spent on healthcare in a transaction. Valid Values for **Visa**: - `healthcare` - Total Amount Healthcare - `healthcare-transit` - Amount Transit - `vision` - Amount Vision/Optical - `prescription` - Amount Prescription/RX - `clinic` - Amount Clinic/Other Qualified Medical - `dental` - Amount Dental   `Note:` -  Prescription, Clinic and dental amounts must be preceded with the total healthcare amount and cannot occur individually.  Vision and Transit must be sent individually and cannot be combined with total healthcare amount or any other amounts. Total Healthcare amount can be sent individually.  Valid Values for **MasterCard**: - `prescription` - Amount Prescription/RX - `eligible-total` - Total Amount Healthcare   `Note:` -  Prescription must be preceded with the total healthcare amount and cannot occur individually. Total Healthcare amount can be sent individually. 
    */
    'amountType'?: string;
    /**
    * Total Amount that has been spent on the corresponding amountType. This is 13 byte field including sign. If the amount is positive, then it is a debit for the customer. If the amount is negative, then it is a credit for the customer. 
    */
    'amount'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "amountType",
            "baseName": "amountType",
            "type": "string"
        },
        {
            "name": "amount",
            "baseName": "amount",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsHealthCareInformationAmountDetails.attributeTypeMap;
    }
}

export class Ptsv2paymentsHostedPaymentInformation {
    /**
    * The title of the hosted payment page, displayed in the browser’s tab. If not set, defaults to the title set in the merchant configuration. 
    */
    'hostName'?: string;
    /**
    * URL of the merchant’s logo to be displayed in Klarna’s hosted payment page. If not set, defaults to the logo set in the merchant configuration. 
    */
    'ipAddress'?: string;
    'userAgent'?: Ptsv2paymentsHostedPaymentInformationUserAgent;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "hostName",
            "baseName": "hostName",
            "type": "string"
        },
        {
            "name": "ipAddress",
            "baseName": "ipAddress",
            "type": "string"
        },
        {
            "name": "userAgent",
            "baseName": "userAgent",
            "type": "Ptsv2paymentsHostedPaymentInformationUserAgent"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsHostedPaymentInformation.attributeTypeMap;
    }
}

/**
* The images to be used as background on Klarna’s payment page (the image best matching the resolution will be used). This is a pass-through field. Check Klarna’s documentation for more information about the correct format. This value can also be set in the merchant configuration. 
*/
export class Ptsv2paymentsHostedPaymentInformationUserAgent {
    /**
    * Url for the image
    */
    'url'?: string;
    /**
    * Width of the image
    */
    'width'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        },
        {
            "name": "width",
            "baseName": "width",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsHostedPaymentInformationUserAgent.attributeTypeMap;
    }
}

export class Ptsv2paymentsInstallmentInformation {
    /**
    * Amount for the current installment payment.  This field is supported only for CyberSource through VisaNet. 
    */
    'amount'?: string;
    /**
    * Frequency of the installment payments. When you do not include this field in a request for a Crediario installment payment, CyberSource sends a space character to the processor.  This field is supported only for CyberSource through VisaNet. Possible values: - `B`: Biweekly - `M`: Monthly - `W`: Weekly  For Crediario installment payments, the value for this field corresponds to the following data in the TC 33 capture file5: - Record: CP01 TCR9 - Position: 41 - Field: Installment Frequency 
    */
    'frequency'?: string;
    /**
    * #### American Express Direct, Cielo, and CyberSource Latin American Processing Flag that indicates the type of funding for the installment plan associated with the payment.  Possible values: - `1`: Merchant-funded installment plan - `2`: Issuer-funded installment plan If you do not include this field in the request, CyberSource uses the value in your CyberSource account.  To change the value in your CyberSource account, contact CyberSource Customer Service.  #### CyberSource through VisaNet and American Express Defined code that indicates the type of installment plan for this transaction.  Contact American Express for: - Information about the kinds of installment plans that American Express provides - Values for this field  For installment payments with American Express in Brazil, the value for this field corresponds to the following data in the TC 33 capture file*: - Record: CP07 TCR3 - Position: 5-6 - Field: Plan Type  * The TC 33 Capture file contains information about the purchases and refunds that a merchant submits to CyberSource. CyberSource through VisaNet creates the TC 33 Capture file at the end of the day and sends it to the merchant’s acquirer, who uses this information to facilitate end-of-day clearing processing with payment card companies.  #### CyberSource through VisaNet with Visa or Mastercard Flag indicating the type of funding for the installment plan associated with the payment. Possible values: - 1 or 01: Merchant-funded installment plan - 2 or 02: Issuer-funded installment plan - 43: Crediario installment plan—only with Visa in Brazil  For installment payments with Visa in Brazil, the value for this field corresponds to the following data in the TC 33 capture file5: - Record: CP07 TCR1 - Position: 5-6 - Field: Installment Type  For all other kinds of installment payments, the value for this field corresponds to the following data in the TC 33 capture file5: - Record: CP01 TCR5 - Position: 39-40 - Field: Installment Plan Type (Issuer or Merchant) 
    */
    'planType'?: string;
    /**
    * Installment number when making payments in installments. Used along with `totalCount` to track which payment is being processed.  For example, the second of 5 payments would be passed to CyberSource as `sequence` = 2 and `totalCount` = 5.  #### Chase Paymentech Solutions and FDC Compass This field is optional because this value is required in the merchant descriptors.  #### CyberSource through VisaNet When you do not include this field in a request for a Crediario installment payment, CyberSource sends a value of 0 to the processor.  For Crediario installment payments, the value for this field corresponds to the following data in the TC 33 capture file*: - Record: CP01 TCR9 - Position: 38-40 - Field: Installment Payment Number  * The TC 33 Capture file contains information about the purchases and refunds that a merchant submits to CyberSource. CyberSource through VisaNet creates the TC 33 Capture file at the end of the day and sends it to the merchant’s acquirer, who uses this information to facilitate end-of-day clearing processing with payment card companies. 
    */
    'sequence'?: number;
    /**
    * Total amount of the loan that is being paid in installments. This field is supported only for CyberSource through VisaNet. 
    */
    'totalAmount'?: string;
    /**
    * Total number of installments when making payments in installments.  #### Chase Paymentech Solutions and FDC Compass This field is optional because this value is required in the merchant descriptors.  #### American Express Direct, Cielo, and Comercio Latino This value is the total number of installments you approved.  #### CyberSource Latin American Processing in Brazil This value is the total number of installments that you approved. The default is 1.  #### All Other Processors This value is used along with _sequence_ to track which payment is being processed.  For example, the second of 5 payments would be passed to CyberSource as _sequence_ = 2 and _totalCount_ = 5.  #### CyberSource through VisaNet For Crediario installment payments, the value for this field corresponds to the following data in the TC 33 capture file*: - Record: CP01 TCR9 - Position: 23-25 - Field: Number of Installments  For installment payments with American Express in Brazil, the value for this field corresponds to the following data in the TC 33 capture file*: - Record: CP07 TCR3 - Position: 7-8 - Field: Number of Installments  For installment payments with Visa in Brazil, the value for this field corresponds to the following data in the TC 33 capture file*: - Record: CP07 TCR1 - Position: 7-8 - Field: Number of Installments  For all other kinds of installment payments, the value for this field corresponds to the following data in the TC 33 capture file*: - Record: CP01 TCR5 - Position: 20-22 - Field: Installment Total Count  **Note** The TC 33 Capture file contains information about the purchases and refunds that a merchant submits to CyberSource. CyberSource through VisaNet creates the TC 33 Capture file at the end of the day and sends it to the merchant’s acquirer, who uses this information to facilitate end-of-day clearing processing with payment card companies. 
    */
    'totalCount'?: number;
    /**
    * Date of the first installment payment. Format: YYMMDD. When you do not include this field, CyberSource sends a string of six zeros (000000) to the processor.  This field is supported only for Crediario installment payments in Brazil on CyberSource through VisaNet.  The value for this field corresponds to the following data in the TC 33 capture file: - Record: CP01 TCR9 - Position: 42-47 - Field: Date of First Installment 
    */
    'firstInstallmentDate'?: string;
    /**
    * Invoice information that you want to provide to the issuer. This value is similar to a tracking number and is the same for all installment payments for one purchase.  This field is supported only for installment payments with Mastercard on CyberSource through VisaNet in Brazil.  The value for this field corresponds to the following data in the TC 33 capture file5: - Record: CP07 TCR4 - Position: 51-70 - Field: Purchase Identification 
    */
    'invoiceData'?: string;
    /**
    * Payment plan for the installments. This field is supported only for installment payments on Visa Platform Connect, RuPay and SPG-KSA seamless flow.  Possible values for a standing-instruction (SI) merchant-initiated transaction (MIT) with Diners Club or Mastercard in India or with an India-issued card: - 1: SI with a fixed amount. - 2: SI with a maximum amount. - 3: Other kind of SI.  Possible values for a type of Installment transaction for on-soil transaction in Kingdom of Saudi Arabia - 1: Registration or first transaction. - 2: Subsequent transaction.  Possible values for other kinds of installment payments: - 0 (default): Regular installment. This value is not allowed for airline transactions. - 1: Installment payment with down payment. - 2: Installment payment without down payment. This value is supported only for airline transactions. - 3: Installment payment; down payment and boarding fee will follow. This value is supported only for airline transactions. - 4: Down payment only; regular installment payment will follow. - 5: Boarding fee only. This value is supported only for airline transactions. - 6: SI de-registration on RuPay for the payer authentication seamless flow. 
    */
    'paymentType'?: string;
    /**
    * Indicates whether the authorization request is a Crediario eligibility inquiry.  Set the value for this field to `Crediario`.  This field is supported only for Crediario installment payments in Brazil on CyberSource through VisaNet. 
    */
    'eligibilityInquiry'?: string;
    /**
    * Grace period requested by the customer before the first installment payment is due.  When you include this field in a request, you must also include the grace period duration type field.  The value for this field corresponds to the following data in the TC 33 capture file3: Record: CP01 TCR5, Position: 100-101, Field: Mastercard Grace Period Details.  This field is supported only for Mastercard installment payments in Brazil and Greece. 
    */
    'gracePeriodDuration'?: string;
    /**
    * Unit for the requested grace period duration.  Possible values: - `D`: Days - `W`: Weeks - `M`: Months  The value for this field corresponds to the following data in the TC 33 capture file3: Record: CP01 TCR5, Position: 99, Field: Mastercard Grace Period Details  This field is supported only for Mastercard installment payments in Brazil and Greece on CyberSource through VisaNet. 
    */
    'gracePeriodDurationType'?: string;
    /**
    * Amount of the first installment payment. The issuer provides this value when the first installment payment is successful. This field is supported for Mastercard installment payments on CyberSource through VisaNet in all countries except Brazil,Croatia, Georgia, and Greece. The value for this field corresponds to the following data in the TC 33 capture file: - Record: CP01 TCR5 - Position: 23-34 - Field: Amount of Each Installment 
    */
    'firstInstallmentAmount'?: string;
    /**
    * Standing Instruction/Installment validation indicator. - '1': Prevalidated - '2': Not Validated 
    */
    'validationIndicator'?: string;
    /**
    * Standing Instruction/Installment identifier. 
    */
    'identifier'?: string;
    /**
    * Annual interest rate.  This field is returned only for two kinds of installment payments on Visa Platform Connect: - Crediario with Visa in Brazil: this field is included in the authorization response for the Crediario eligibility request when the issuer approves the customer's request for Crediario installment payments. - Mastercard in all countries except Brazil, Croatia, Georgia, and Greece.   Example: A value of 1.0 specifies 1%.  Example: A value of 4.0 specifies 4%.  #### Brazil The value for this field corresponds to the following data in the TC 33 capture file: - Record: CP01 TCR9 - Position: 151-157 - Field: Annual Interest Rate   #### Other Countries The value for this field corresponds to the following data in the TC 33 capture file: - Record: CP01 TCR5 - Position: 58-62 SCMP API Fields| 216 - Field: Mastercard Annual Percentage Rate 
    */
    'annualInterestRate'?: string;
    /**
    * Indicates if the installment plan has interest.  Possible values: -Y - with interest -N - without interest -NULL - Do not send the field if no information available 
    */
    'interestIndicator'?: string;
    /**
    * Indicates if an installment plan is a government sponsored or part of a government program.  Possible values:  -true -false  This field defaults to false when no value is provided. 
    */
    'isGovernmentPlan'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "amount",
            "baseName": "amount",
            "type": "string"
        },
        {
            "name": "frequency",
            "baseName": "frequency",
            "type": "string"
        },
        {
            "name": "planType",
            "baseName": "planType",
            "type": "string"
        },
        {
            "name": "sequence",
            "baseName": "sequence",
            "type": "number"
        },
        {
            "name": "totalAmount",
            "baseName": "totalAmount",
            "type": "string"
        },
        {
            "name": "totalCount",
            "baseName": "totalCount",
            "type": "number"
        },
        {
            "name": "firstInstallmentDate",
            "baseName": "firstInstallmentDate",
            "type": "string"
        },
        {
            "name": "invoiceData",
            "baseName": "invoiceData",
            "type": "string"
        },
        {
            "name": "paymentType",
            "baseName": "paymentType",
            "type": "string"
        },
        {
            "name": "eligibilityInquiry",
            "baseName": "eligibilityInquiry",
            "type": "string"
        },
        {
            "name": "gracePeriodDuration",
            "baseName": "gracePeriodDuration",
            "type": "string"
        },
        {
            "name": "gracePeriodDurationType",
            "baseName": "gracePeriodDurationType",
            "type": "string"
        },
        {
            "name": "firstInstallmentAmount",
            "baseName": "firstInstallmentAmount",
            "type": "string"
        },
        {
            "name": "validationIndicator",
            "baseName": "validationIndicator",
            "type": "string"
        },
        {
            "name": "identifier",
            "baseName": "identifier",
            "type": "string"
        },
        {
            "name": "annualInterestRate",
            "baseName": "annualInterestRate",
            "type": "string"
        },
        {
            "name": "interestIndicator",
            "baseName": "interestIndicator",
            "type": "string"
        },
        {
            "name": "isGovernmentPlan",
            "baseName": "isGovernmentPlan",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsInstallmentInformation.attributeTypeMap;
    }
}

/**
* invoice Details
*/
export class Ptsv2paymentsInvoiceDetails {
    /**
    * Barcode ID scanned from the Payment Application.
    */
    'barcodeNumber'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "barcodeNumber",
            "baseName": "barcodeNumber",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsInvoiceDetails.attributeTypeMap;
    }
}

export class Ptsv2paymentsIssuerInformation {
    /**
    * Data defined by the issuer.  The value for this reply field will probably be the same as the value that you submitted in the authorization request, but it is possible for the processor, issuer, or acquirer to modify the value.  This field is supported only for Visa transactions on **CyberSource through VisaNet**. 
    */
    'discretionaryData'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "discretionaryData",
            "baseName": "discretionaryData",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsIssuerInformation.attributeTypeMap;
    }
}

export class Ptsv2paymentsMerchantDefinedInformation {
    /**
    * The number you assign for as the key for your merchant-defined data field. Valid values are 0 to 100.  For example, to set or access the key for the 2nd merchant-defined data field in the array, you would reference `merchantDefinedInformation[1].key`.  #### CyberSource through VisaNet For installment payments with Mastercard in Brazil, use `merchantDefinedInformation[0].key` and `merchantDefinedInformation[1].key` for data that you want to provide to the issuer to identify the transaction. 
    */
    'key'?: string;
    /**
    * The value you assign for your merchant-defined data field.  **Warning** Merchant-defined data fields are not intended to and must not be used to capture personally identifying information. Accordingly, merchants are prohibited from capturing, obtaining, and/or transmitting any personally identifying information in or via the merchant-defined data fields. Personally identifying information includes, but is not limited to, address, credit card number, social security number, driver's license number, state-issued identification number, passport number, and card verification numbers (CVV, CVC2, CVV2, CID, CVN). In the event CyberSource discovers that a merchant is capturing and/or transmitting personally identifying information via the merchant-defined data fields, whether or not intentionally, CyberSource will immediately suspend the merchant's account, which will result in a rejection of any and all transaction requests submitted by the merchant after the point of suspension.  #### CyberSource through VisaNet For installment payments with Mastercard in Brazil, use `merchantDefinedInformation[0].value` and `merchantDefinedInformation[1].value` for data that you want to provide to the issuer to identify the transaction.   For installment payments with Mastercard in Brazil: - The value for merchantDefinedInformation[0].value corresponds to the following data in the TC 33 capture file5:   - Record: CP07 TCR5   - Position: 25-44   - Field: Reference Field 2 - The value for merchantDefinedInformation[1].value corresponds to the following data in the TC 33 capture file5:   - Record: CP07 TCR5   - Position: 45-64   - Field: Reference Field 3 
    */
    'value'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "key",
            "baseName": "key",
            "type": "string"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsMerchantDefinedInformation.attributeTypeMap;
    }
}

/**
* The object containing the secure data that the merchant defines. 
*/
export class Ptsv2paymentsMerchantDefinedSecureInformation {
    /**
    * The value you assign for your merchant-secure data field 1. 
    */
    'secure1'?: string;
    /**
    * The value you assign for your merchant-secure data field 2. 
    */
    'secure2'?: string;
    /**
    * The value you assign for your merchant-secure data field 3. 
    */
    'secure3'?: string;
    /**
    * The value you assign for your merchant-secure data field 4. 
    */
    'secure4'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "secure1",
            "baseName": "secure1",
            "type": "string"
        },
        {
            "name": "secure2",
            "baseName": "secure2",
            "type": "string"
        },
        {
            "name": "secure3",
            "baseName": "secure3",
            "type": "string"
        },
        {
            "name": "secure4",
            "baseName": "secure4",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsMerchantDefinedSecureInformation.attributeTypeMap;
    }
}

export class Ptsv2paymentsMerchantInformation {
    'merchantDescriptor'?: Ptsv2paymentsMerchantInformationMerchantDescriptor;
    /**
    * This field will contain either the merchant url or the reverse domain as per the requirement for DSRP Format 3. This might vary transaction to transaction and might not be static. Merchant needs to have access to send this value for all DSRP program. 
    */
    'domainName'?: string;
    /**
    * Company ID assigned to an independent sales organization. Get this value from Mastercard.  #### CyberSource through VisaNet The value for this field corresponds to the following data in the TC 33 capture file: - Record: CP01 TCR6 - Position: 106-116 - Field: Independent Sales Organization ID  This field is supported for Visa, Mastercard and Discover Transactions.  **Note** The TC 33 Capture file contains information about the purchases and refunds that a merchant submits to CyberSource. CyberSource through VisaNet creates the TC 33 Capture file at the end of the day and sends it to the merchant’s acquirer, who uses this information to facilitate end-of-day clearing processing with payment card companies. 
    */
    'salesOrganizationId'?: string;
    /**
    * The value for this field is a four-digit number that the payment card industry uses to classify merchants into market segments. A payment card company assigned one or more of these values to your business when you started accepting the payment card company’s cards. When you do not include this field in your request, CyberSource uses the value in your CyberSource account.  #### CyberSource through VisaNet The value for this field corresponds to the following data in the TC 33 capture file5: - Record: CP01 TCR4 - Position: 150-153 - Field: Merchant Category Code 
    */
    'categoryCode'?: number;
    /**
    * Merchant category code for domestic transactions. The value for this field is a four-digit number that the payment card industry uses to classify merchants into market segments. A payment card company assigned one or more of these values to your business when you started accepting the payment card company’s cards. Including this field in a request for a domestic transaction might reduce interchange fees.  When you include this field in a request: - Do not include the `merchant_category_code` field. - The value for this field overrides the value in your CyberSource account.  This field is supported only for: - Domestic transactions with Mastercard in Spain. Domestic means that you and the cardholder are in the same country. - Merchants enrolled in the OmniPay Direct interchange program. - First Data Merchant Solutions (Europe) on OmniPay Direct. 
    */
    'categoryCodeDomestic'?: number;
    /**
    * Your Cadastro Nacional da Pessoa Jurídica (CNPJ) number.  This field is supported only for BNDES transactions on CyberSource through VisaNet.  The value for this field corresponds to the following data in the TC 33 capture file5: - Record: CP07 TCR6 - Position: 40-59 - Field: BNDES Reference Field 1 
    */
    'taxId'?: string;
    /**
    * Your government-assigned tax identification number.  #### Tax Calculation Required field for value added tax only. Not applicable to U.S. and Canadian taxes.  #### CyberSource through VisaNet For CtV processors, the maximum length is 20. 
    */
    'vatRegistrationNumber'?: string;
    /**
    * Reference number that facilitates card acceptor/corporation communication and record keeping. 
    */
    'cardAcceptorReferenceNumber'?: string;
    /**
    * Date and time at your physical location.  Format: `YYYYMMDDhhmmss`, where:  - `YYYY` = year  - `MM` = month  - `DD` = day  - `hh` = hour  - `mm` = minutes  - `ss` = seconds  #### Used by **Authorization** Required for these processors: - American Express Direct                                                                                                                                                                                                                                                                                                                         - American Express Direct - Credit Mutuel-CIC - FDC Nashville Global - SIX  Optional for all other processors. 
    */
    'transactionLocalDateTime'?: string;
    'serviceFeeDescriptor'?: Ptsv2paymentsMerchantInformationServiceFeeDescriptor;
    /**
    * customer would be redirected to this url based on the decision of the transaction
    */
    'cancelUrl'?: string;
    /**
    * customer would be redirected to this url based on the decision of the transaction
    */
    'successUrl'?: string;
    /**
    * customer would be redirected to this url based on the decision of the transaction
    */
    'failureUrl'?: string;
    /**
    * URL for displaying payment results to the consumer (notifications) after the transaction is processed. Usually this URL belongs to merchant and its behavior is defined by merchant 
    */
    'returnUrl'?: string;
    /**
    * #### Visa Platform Connect This field may be used for transactions on accounts issued under co-branding agreements when one of the co-branding partners. 
    */
    'partnerIdCode'?: string;
    'serviceLocation'?: Ptsv2paymentsMerchantInformationServiceLocation;
    /**
    * Free-form text field. 
    */
    'noteToBuyer'?: string;
    /**
    * Use this field only if you are requesting payment with Payer Authentication serice together.  Your company’s name as you want it to appear to the customer in the issuing bank’s authentication form. This value overrides the value specified by your merchant bank. 
    */
    'merchantName'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "merchantDescriptor",
            "baseName": "merchantDescriptor",
            "type": "Ptsv2paymentsMerchantInformationMerchantDescriptor"
        },
        {
            "name": "domainName",
            "baseName": "domainName",
            "type": "string"
        },
        {
            "name": "salesOrganizationId",
            "baseName": "salesOrganizationId",
            "type": "string"
        },
        {
            "name": "categoryCode",
            "baseName": "categoryCode",
            "type": "number"
        },
        {
            "name": "categoryCodeDomestic",
            "baseName": "categoryCodeDomestic",
            "type": "number"
        },
        {
            "name": "taxId",
            "baseName": "taxId",
            "type": "string"
        },
        {
            "name": "vatRegistrationNumber",
            "baseName": "vatRegistrationNumber",
            "type": "string"
        },
        {
            "name": "cardAcceptorReferenceNumber",
            "baseName": "cardAcceptorReferenceNumber",
            "type": "string"
        },
        {
            "name": "transactionLocalDateTime",
            "baseName": "transactionLocalDateTime",
            "type": "string"
        },
        {
            "name": "serviceFeeDescriptor",
            "baseName": "serviceFeeDescriptor",
            "type": "Ptsv2paymentsMerchantInformationServiceFeeDescriptor"
        },
        {
            "name": "cancelUrl",
            "baseName": "cancelUrl",
            "type": "string"
        },
        {
            "name": "successUrl",
            "baseName": "successUrl",
            "type": "string"
        },
        {
            "name": "failureUrl",
            "baseName": "failureUrl",
            "type": "string"
        },
        {
            "name": "returnUrl",
            "baseName": "returnUrl",
            "type": "string"
        },
        {
            "name": "partnerIdCode",
            "baseName": "partnerIdCode",
            "type": "string"
        },
        {
            "name": "serviceLocation",
            "baseName": "serviceLocation",
            "type": "Ptsv2paymentsMerchantInformationServiceLocation"
        },
        {
            "name": "noteToBuyer",
            "baseName": "noteToBuyer",
            "type": "string"
        },
        {
            "name": "merchantName",
            "baseName": "merchantName",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsMerchantInformation.attributeTypeMap;
    }
}

export class Ptsv2paymentsMerchantInformationMerchantDescriptor {
    /**
    * Your merchant name.  **Note** For Paymentech processor using Cybersource Payouts, the maximum data length is 22.  #### PIN debit Your business name. This name is displayed on the cardholder’s statement. When you include more than one consecutive space, extra spaces are removed.  When you do not include this value in your PIN debit request, the merchant name from your account is used. **Important** This value must consist of English characters.  Optional field for PIN debit credit or PIN debit purchase requests.  #### Airline processing Your merchant name. This name is displayed on the cardholder’s statement. When you include more than one consecutive space, extra spaces are removed.  **Note** Some airline fee programs may require the original ticket number (ticket identifier) or the ancillary service description in positions 13 through 23 of this field.  **Important** This value must consist of English characters.  Required for captures and credits. 
    */
    'name'?: string;
    /**
    * An alternate name for the merchant. 
    */
    'alternateName'?: string;
    /**
    * Contact information for the merchant.  **Note** These are the maximum data lengths for the following payment processors: - FDCCompass (13) - Paymentech (13) 
    */
    'contact'?: string;
    /**
    * First line of merchant's address. 
    */
    'address1'?: string;
    /**
    * Merchant's City.  #### PIN debit City for your business location. This value might be displayed on the cardholder’s statement.  When you do not include this value in your PIN debit request, the merchant name from your account is used. **Important** This value must consist of English characters.  Optional field for PIN debit credit or PIN debit purchase requests. 
    */
    'locality'?: string;
    /**
    * Merchant's country.  #### PIN debit Country code for your business location. Use the [ISO Standard Country Codes](https://developer.cybersource.com/library/documentation/sbc/quickref/countries_alpha_list.pdf) This value might be displayed on the cardholder’s statement.  When you do not include this value in your PIN debit request, the merchant name from your account is used. **Important** This value must consist of English characters. **Note** If your business is located in the U.S. or Canada and you include this field in a request, you must also include `merchantInformation.merchantDescriptor.administrativeArea`.  Optional field for PIN debit credit or PIN debit purchase. 
    */
    'country'?: string;
    /**
    * Merchant's postal code.  #### PIN debit Postal code for your business location. This value might be displayed on the cardholder’s statement.  If your business is domiciled in the U.S., you can use a 5-digit or 9-digit postal code. A 9-digit postal code must follow this format: [5 digits][dash][4 digits] Example: `12345-6789`  If your business is domiciled in Canada, you can use a 6-digit or 9-digit postal code. A 6-digit postal code must follow this format: [alpha][numeric][alpha][space] [numeric][alpha][numeric] Example: `A1B 2C3`  When you do not include this value in your PIN debit request, the merchant name from your account is used. **Important** This value must consist of English characters.  **Note** This field is supported only for businesses located in the U.S. or Canada. **Important** Mastercard requires a postal code for any country that uses postal codes. You can provide the postal code in your account or you can include this field in your request.  Optional field for PIN debit credit or PIN debit purchase. 
    */
    'postalCode'?: string;
    /**
    * The state where the merchant is located.  #### PIN debit State code or region code for your business. Use the Use the [State, Province, and Territory Codes for the United States and Canada](https://developer.cybersource.com/library/documentation/sbc/quickref/states_and_provinces.pdf) This value might be displayed on the cardholder’s statement.  When you do not include this value in your PIN debit request, the merchant name from your account is used. **Important** This value must consist of English characters.  **Note** This field is supported only for businesses located in the U.S. or Canada.  Optional field for PIN debit credit or PIN debit purchase. 
    */
    'administrativeArea'?: string;
    /**
    * Merchant phone as contact information for CNP transactions 
    */
    'phone'?: string;
    /**
    * Address of company's website provided by merchant 
    */
    'url'?: string;
    /**
    * #### Visa Platform Connect This field will indicate merchant country of origin 
    */
    'countryOfOrigin'?: string;
    /**
    * The identifier of the store. 
    */
    'storeId'?: string;
    /**
    * The name of the store. 
    */
    'storeName'?: string;
    /**
    * #### Visa Platform Connect Indicates customer service phone number of Merchant. 
    */
    'customerServicePhoneNumber'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "alternateName",
            "baseName": "alternateName",
            "type": "string"
        },
        {
            "name": "contact",
            "baseName": "contact",
            "type": "string"
        },
        {
            "name": "address1",
            "baseName": "address1",
            "type": "string"
        },
        {
            "name": "locality",
            "baseName": "locality",
            "type": "string"
        },
        {
            "name": "country",
            "baseName": "country",
            "type": "string"
        },
        {
            "name": "postalCode",
            "baseName": "postalCode",
            "type": "string"
        },
        {
            "name": "administrativeArea",
            "baseName": "administrativeArea",
            "type": "string"
        },
        {
            "name": "phone",
            "baseName": "phone",
            "type": "string"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        },
        {
            "name": "countryOfOrigin",
            "baseName": "countryOfOrigin",
            "type": "string"
        },
        {
            "name": "storeId",
            "baseName": "storeId",
            "type": "string"
        },
        {
            "name": "storeName",
            "baseName": "storeName",
            "type": "string"
        },
        {
            "name": "customerServicePhoneNumber",
            "baseName": "customerServicePhoneNumber",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsMerchantInformationMerchantDescriptor.attributeTypeMap;
    }
}

export class Ptsv2paymentsMerchantInformationServiceFeeDescriptor {
    /**
    * Name of the service provider that is collecting the service fee. The service provider name must consist of 3, 7, or 12 characters followed by an asterisk (*). This value must also include the words “Service Fee.”  When you include more than one consecutive space, extra spaces are removed. Use one of the following formats for this value: - <3-character name>*Service Fee - <7-character name>*Service Fee - <12-character name>*Service Fee  When payments are made in installments, this value must also include installment information such as “1 of 5” or “3 of 7.” For installment payments, use one of the following formats for this value: - <3-character name>*Service Fee*<N> of <M> - <7-character name>*Service Fee*<N> of <M> - <12-character name>*Service Fee*<N> of <M>  where <N> is the payment number and <M> is the total number of payments.  When you do not include this value in your request, CyberSource uses the value that is in your CyberSource account.  This value might be displayed on the cardholder’s statement. 
    */
    'name'?: string;
    /**
    * Contact information for the service provider that is collecting the service fee. when you include more than one consecutive space, extra spaces are removed.  When you do not include this value in your request, CyberSource uses the value that is in your CyberSource account.  This value might be displayed on the cardholder’s statement. 
    */
    'contact'?: string;
    /**
    * State or territory in which the service provider is located.  When you do not include this value in your request, CyberSource uses the value that is in your CyberSource account.  This value might be displayed on the cardholder’s statement. 
    */
    'state'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "contact",
            "baseName": "contact",
            "type": "string"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsMerchantInformationServiceFeeDescriptor.attributeTypeMap;
    }
}

export class Ptsv2paymentsMerchantInformationServiceLocation {
    /**
    * #### Visa Platform Connect  Merchant’s service location city name. When merchant provides services from a location other than the location identified as merchant location. 
    */
    'locality'?: string;
    /**
    * #### Visa Platform Connect  Merchant’s service location country subdivision code. When merchant provides services from a location other than the location identified as merchant location. 
    */
    'countrySubdivisionCode'?: string;
    /**
    * #### Visa Platform Connect  Merchant’s service location country code. When merchant provides services from a location other than the location identified as merchant location. 
    */
    'countryCode'?: string;
    /**
    * #### Visa Platform Connect  Merchant’s service location postal code. When merchant provides services from a location other than the location identified as merchant location. 
    */
    'postalCode'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "locality",
            "baseName": "locality",
            "type": "string"
        },
        {
            "name": "countrySubdivisionCode",
            "baseName": "countrySubdivisionCode",
            "type": "string"
        },
        {
            "name": "countryCode",
            "baseName": "countryCode",
            "type": "string"
        },
        {
            "name": "postalCode",
            "baseName": "postalCode",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsMerchantInformationServiceLocation.attributeTypeMap;
    }
}

export class Ptsv2paymentsOrderInformation {
    'amountDetails'?: Ptsv2paymentsOrderInformationAmountDetails;
    'billTo'?: Ptsv2paymentsOrderInformationBillTo;
    'shipTo'?: Ptsv2paymentsOrderInformationShipTo;
    'lineItems'?: Array<Ptsv2paymentsOrderInformationLineItems>;
    'invoiceDetails'?: Ptsv2paymentsOrderInformationInvoiceDetails;
    'shippingDetails'?: Ptsv2paymentsOrderInformationShippingDetails;
    /**
    * This is only needed when you are requesting both payment and DM service at same time.  Boolean that indicates whether returns are accepted for this order. This field can contain one of the following values: - true: Returns are accepted for this order. - false: Returns are not accepted for this order. 
    */
    'returnsAccepted'?: boolean;
    /**
    * #### Visa Platform Connect : This API will contain the Flag that specifies whether the payment is for the purchase of cryptocurrency. Additional values to add : This API will contain the Flag that specifies whether the payment is for the purchase of cryptocurrency. valid values are - Y/y, true - N/n, false 
    */
    'isCryptocurrencyPurchase'?: string;
    /**
    * Starting date and time for an event or a journey that is independent of which transportation mechanism, in UTC. The cutoffDateTime will supersede travelInformation.transit.airline.legs[].departureDate and travelInformation.transit.airline.legs[].departureTime if these fields are supplied in the request. Format: YYYY-MM-DDThh:mm:ssZ. Example 2016-08-11T22:47:57Z equals August 11, 2016, at 22:47:57 (10:47:57 p.m.). The T separates the date and the time. The Z indicates UTC. 
    */
    'cutoffDateTime'?: string;
    /**
    * Indicates whether cardholder is placing an order with a future availability or release date. This field can contain one of these values: - MERCHANDISE_AVAILABLE: Merchandise available - FUTURE_AVAILABILITY: Future availability 
    */
    'preOrder'?: string;
    /**
    * Expected date that a pre-ordered purchase will be available. Format: YYYYMMDD 
    */
    'preOrderDate'?: string;
    /**
    * Indicates whether the cardholder is reordering previously purchased merchandise. This field can contain one of these values: - false: First time ordered - true: Reordered 
    */
    'reordered'?: boolean;
    /**
    * Total number of articles/items in the order as a numeric decimal count. Possible values: 00 - 99 
    */
    'totalOffersCount'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "amountDetails",
            "baseName": "amountDetails",
            "type": "Ptsv2paymentsOrderInformationAmountDetails"
        },
        {
            "name": "billTo",
            "baseName": "billTo",
            "type": "Ptsv2paymentsOrderInformationBillTo"
        },
        {
            "name": "shipTo",
            "baseName": "shipTo",
            "type": "Ptsv2paymentsOrderInformationShipTo"
        },
        {
            "name": "lineItems",
            "baseName": "lineItems",
            "type": "Array<Ptsv2paymentsOrderInformationLineItems>"
        },
        {
            "name": "invoiceDetails",
            "baseName": "invoiceDetails",
            "type": "Ptsv2paymentsOrderInformationInvoiceDetails"
        },
        {
            "name": "shippingDetails",
            "baseName": "shippingDetails",
            "type": "Ptsv2paymentsOrderInformationShippingDetails"
        },
        {
            "name": "returnsAccepted",
            "baseName": "returnsAccepted",
            "type": "boolean"
        },
        {
            "name": "isCryptocurrencyPurchase",
            "baseName": "isCryptocurrencyPurchase",
            "type": "string"
        },
        {
            "name": "cutoffDateTime",
            "baseName": "cutoffDateTime",
            "type": "string"
        },
        {
            "name": "preOrder",
            "baseName": "preOrder",
            "type": "string"
        },
        {
            "name": "preOrderDate",
            "baseName": "preOrderDate",
            "type": "string"
        },
        {
            "name": "reordered",
            "baseName": "reordered",
            "type": "boolean"
        },
        {
            "name": "totalOffersCount",
            "baseName": "totalOffersCount",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsOrderInformation.attributeTypeMap;
    }
}

export class Ptsv2paymentsOrderInformationAmountDetails {
    /**
    * Amount being charged as gift wrap fee. 
    */
    'giftWrapAmount'?: string;
    /**
    * Invoice amount.  The invoice amount issued by the Merchant to the Cardholder, which includes VAT (excluding items such as TIPS or CASHBACK). For transactions that do not have applicable Benefit Laws, the field may be entered as zeros.  This field is only applicable for Uruguay market.  Example: 100.00  Uruguay  The value for this field corresponds to the following data in the TC 33 capture file:  - Record: CP01 TCR9 - Position: 7-18 - Field: Invoice Amount 
    */
    'invoiceAmount'?: string;
    /**
    * Grand total for the order. This value cannot be negative. You can include a decimal point (.), but no other special characters. CyberSource truncates the amount to the correct number of decimal places.  **Note** For CTV, FDCCompass, Paymentech processors, the maximum length for this field is 12.  **Important** Some processors have specific requirements and limitations, such as maximum amounts and maximum field lengths.  If your processor supports zero amount authorizations, you can set this field to 0 for the authorization to check if the card is lost or stolen.   #### Card Present Required to include either this field or `orderInformation.lineItems[].unitPrice` for the order.  #### Invoicing / Pay By Link Required for creating a new invoice or payment link.  #### PIN Debit Amount you requested for the PIN debit purchase. This value is returned for partial authorizations. The issuing bank can approve a partial amount if the balance on the debit card is less than the requested transaction amount.  Required field for PIN Debit purchase and PIN Debit credit requests. Optional field for PIN Debit reversal requests.  #### GPX This field is optional for reversing an authorization or credit; however, for all other processors, these fields are required.  #### DCC with a Third-Party Provider Set this field to the converted amount that was returned by the DCC provider. You must include either this field or the 1st line item in the order and the specific line-order amount in your request.   #### DCC for First Data Not used. 
    */
    'totalAmount'?: string;
    /**
    * Subtotal amount of all the items.This amount (which is the value of all items in the cart, not including the additional amounts such as tax, shipping, etc.) cannot change after a sessions request. When there is a change to any of the additional amounts, this field should be resent in the order request. When the sub total amount changes, you must initiate a new transaction starting with a sessions request. Note The amount value must be a non-negative number containing 2 decimal places and limited to 7 digits before the decimal point. This value can not be changed after a sessions request. 
    */
    'subTotalAmount'?: string;
    /**
    * Currency used for the order. Use the three-character [ISO Standard Currency Codes.](http://apps.cybersource.com/library/documentation/sbc/quickref/currencies.pdf)  #### Used by **Authorization** Required field.  **Authorization Reversal** For an authorization reversal (`reversalInformation`) or a capture (`processingOptions.capture` is set to `true`), you must use the same currency that you used in your payment authorization request.  #### PIN Debit Currency for the amount you requested for the PIN debit purchase. This value is returned for partial authorizations. The issuing bank can approve a partial amount if the balance on the debit card is less than the requested transaction amount. For the possible values, see the [ISO Standard Currency Codes](https://developer.cybersource.com/library/documentation/sbc/quickref/currencies.pdf). Returned by PIN debit purchase.  For PIN debit reversal requests, you must use the same currency that was used for the PIN debit purchase or PIN debit credit that you are reversing. For the possible values, see the [ISO Standard Currency Codes](https://developer.cybersource.com/library/documentation/sbc/quickref/currencies.pdf).  Required field for PIN Debit purchase and PIN Debit credit requests. Optional field for PIN Debit reversal requests.  #### GPX This field is optional for reversing an authorization or credit.  #### DCC for First Data Your local currency.  #### Tax Calculation Required for international tax and value added tax only. Optional for U.S. and Canadian taxes. Your local currency. 
    */
    'currency'?: string;
    /**
    * Total discount amount applied to the order. 
    */
    'discountAmount'?: string;
    /**
    * Total charges for any import or export duties included in the order. 
    */
    'dutyAmount'?: string;
    /**
    * Gratuity or tip amount for restaurants. Allowed only when industryDatatype=restaurant. When your customer uses a debit card or prepaid card, and you receive a partial authorization, the payment networks recommend that you do not submit a capture amount that is higher than the authorized amount. When the capture amount exceeds the partial amount that was approved, the issuer has chargeback rights for the excess amount.  Used by **Capture** Optional field.  #### CyberSource through VisaNet Restaurant data is supported only on CyberSource through VisaNet when card is present. 
    */
    'gratuityAmount'?: string;
    /**
    * Total tax amount for all the items in the order. 
    */
    'taxAmount'?: string;
    /**
    * Flag that indicates whether a national tax is included in the order total.  Possible values:   - **0**: national tax not included  - **1**: national tax included 
    */
    'nationalTaxIncluded'?: string;
    /**
    * Flag that indicates how the merchant manages discounts.  Possible values:   - **0**: no invoice level discount included  - **1**: tax calculated on the postdiscount invoice total  - **2**: tax calculated on the prediscount invoice total 
    */
    'taxAppliedAfterDiscount'?: string;
    /**
    * Flag that indicates how you calculate tax.  Possible values:   - **0**: net prices with tax calculated at line item level  - **1**: net prices with tax calculated at invoice level  - **2**: gross prices with tax provided at line item level  - **3**: gross prices with tax provided at invoice level  - **4**: no tax applies on the invoice for the transaction 
    */
    'taxAppliedLevel'?: string;
    /**
    * For tax amounts that can be categorized as one tax type.  This field contains the tax type code that corresponds to the entry in the _lineItems.taxAmount_ field.  Possible values:   - **056**: sales tax (U.S only)  - **TX~**: all taxes (Canada only)   Note ~ = space. 
    */
    'taxTypeCode'?: string;
    /**
    * Total freight or shipping and handling charges for the order. When you include this field in your request, you must also include the **totalAmount** field. 
    */
    'freightAmount'?: string;
    /**
    * Set this field to the converted amount that was returned by the DCC provider. 
    */
    'foreignAmount'?: string;
    /**
    * Set this field to the converted amount that was returned by the DCC provider. 
    */
    'foreignCurrency'?: string;
    /**
    * Exchange rate returned by the DCC service. Includes a decimal point and a maximum of 4 decimal places. 
    */
    'exchangeRate'?: string;
    /**
    * Time stamp for the exchange rate. This value is returned by the DCC service.  Format: `YYYYMMDD~HH:MM`  where ~ denotes a space. 
    */
    'exchangeRateTimeStamp'?: string;
    'surcharge'?: Ptsv2paymentsOrderInformationAmountDetailsSurcharge;
    /**
    * This is a multicurrency field. It contains the transaction amount (field 4), converted to the Currency used to bill the cardholder’s account. This field is returned for OCT transactions. 
    */
    'settlementAmount'?: string;
    /**
    * This is a multicurrency-only field. It contains a 3-digit numeric code that identifies the currency used by the issuer to bill the cardholder's account. This field is returned for OCT transactions. 
    */
    'settlementCurrency'?: string;
    'amexAdditionalAmounts'?: Array<Ptsv2paymentsOrderInformationAmountDetailsAmexAdditionalAmounts>;
    'taxDetails'?: Array<Ptsv2paymentsOrderInformationAmountDetailsTaxDetails>;
    /**
    * Service fee. Required for service fee transactions. 
    */
    'serviceFeeAmount'?: string;
    /**
    * Amount in your original local pricing currency.  This value cannot be negative. You can include a decimal point (.) in this field to denote the currency exponent, but you cannot include any other special characters.  If needed, CyberSource truncates the amount to the correct number of decimal places. 
    */
    'originalAmount'?: string;
    /**
    * Your local pricing currency code.  For the possible values, see the [ISO Standard Currency Codes.](http://apps.cybersource.com/library/documentation/sbc/quickref/currencies.pdf) 
    */
    'originalCurrency'?: string;
    /**
    * Cashback amount in the acquirer’s currency. If a cashback amount is included in the request, it must be included in the `orderInformation.amountDetails.totalAmount` value.  This field is supported only on CyberSource through VisaNet.  #### Used by **Authorization** Optional. **Authorization Reversal** Optional.  #### PIN debit Optional field for PIN debit purchase, PIN debit credit or PIN debit reversal. 
    */
    'cashbackAmount'?: string;
    'currencyConversion'?: Ptsv2paymentsOrderInformationAmountDetailsCurrencyConversion;
    'octSurcharge'?: Ptsv2paymentsOrderInformationAmountDetailsOctsurcharge;
    'order'?: Ptsv2paymentsOrderInformationAmountDetailsOrder;
    /**
    * This API Field contains the anticipated amount details. This supports use cases where the Merchant does not wish to have funds held against the account, but needs to confirm an amount prior to authorization, such as for a trial subscription, reservation service, or loyalty program. In an account verification, the anticipated amount is used to confirm the account has availability to accept purchases. 
    */
    'anticipatedAmount'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "giftWrapAmount",
            "baseName": "giftWrapAmount",
            "type": "string"
        },
        {
            "name": "invoiceAmount",
            "baseName": "invoiceAmount",
            "type": "string"
        },
        {
            "name": "totalAmount",
            "baseName": "totalAmount",
            "type": "string"
        },
        {
            "name": "subTotalAmount",
            "baseName": "subTotalAmount",
            "type": "string"
        },
        {
            "name": "currency",
            "baseName": "currency",
            "type": "string"
        },
        {
            "name": "discountAmount",
            "baseName": "discountAmount",
            "type": "string"
        },
        {
            "name": "dutyAmount",
            "baseName": "dutyAmount",
            "type": "string"
        },
        {
            "name": "gratuityAmount",
            "baseName": "gratuityAmount",
            "type": "string"
        },
        {
            "name": "taxAmount",
            "baseName": "taxAmount",
            "type": "string"
        },
        {
            "name": "nationalTaxIncluded",
            "baseName": "nationalTaxIncluded",
            "type": "string"
        },
        {
            "name": "taxAppliedAfterDiscount",
            "baseName": "taxAppliedAfterDiscount",
            "type": "string"
        },
        {
            "name": "taxAppliedLevel",
            "baseName": "taxAppliedLevel",
            "type": "string"
        },
        {
            "name": "taxTypeCode",
            "baseName": "taxTypeCode",
            "type": "string"
        },
        {
            "name": "freightAmount",
            "baseName": "freightAmount",
            "type": "string"
        },
        {
            "name": "foreignAmount",
            "baseName": "foreignAmount",
            "type": "string"
        },
        {
            "name": "foreignCurrency",
            "baseName": "foreignCurrency",
            "type": "string"
        },
        {
            "name": "exchangeRate",
            "baseName": "exchangeRate",
            "type": "string"
        },
        {
            "name": "exchangeRateTimeStamp",
            "baseName": "exchangeRateTimeStamp",
            "type": "string"
        },
        {
            "name": "surcharge",
            "baseName": "surcharge",
            "type": "Ptsv2paymentsOrderInformationAmountDetailsSurcharge"
        },
        {
            "name": "settlementAmount",
            "baseName": "settlementAmount",
            "type": "string"
        },
        {
            "name": "settlementCurrency",
            "baseName": "settlementCurrency",
            "type": "string"
        },
        {
            "name": "amexAdditionalAmounts",
            "baseName": "amexAdditionalAmounts",
            "type": "Array<Ptsv2paymentsOrderInformationAmountDetailsAmexAdditionalAmounts>"
        },
        {
            "name": "taxDetails",
            "baseName": "taxDetails",
            "type": "Array<Ptsv2paymentsOrderInformationAmountDetailsTaxDetails>"
        },
        {
            "name": "serviceFeeAmount",
            "baseName": "serviceFeeAmount",
            "type": "string"
        },
        {
            "name": "originalAmount",
            "baseName": "originalAmount",
            "type": "string"
        },
        {
            "name": "originalCurrency",
            "baseName": "originalCurrency",
            "type": "string"
        },
        {
            "name": "cashbackAmount",
            "baseName": "cashbackAmount",
            "type": "string"
        },
        {
            "name": "currencyConversion",
            "baseName": "currencyConversion",
            "type": "Ptsv2paymentsOrderInformationAmountDetailsCurrencyConversion"
        },
        {
            "name": "octSurcharge",
            "baseName": "oct-surcharge",
            "type": "Ptsv2paymentsOrderInformationAmountDetailsOctsurcharge"
        },
        {
            "name": "order",
            "baseName": "order",
            "type": "Ptsv2paymentsOrderInformationAmountDetailsOrder"
        },
        {
            "name": "anticipatedAmount",
            "baseName": "anticipatedAmount",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsOrderInformationAmountDetails.attributeTypeMap;
    }
}

export class Ptsv2paymentsOrderInformationAmountDetailsAmexAdditionalAmounts {
    /**
    * Additional amount type. This field is supported only for **American Express Direct**. 
    */
    'code'?: string;
    /**
    * Additional amount. This field is supported only for **American Express Direct**. 
    */
    'amount'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        },
        {
            "name": "amount",
            "baseName": "amount",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsOrderInformationAmountDetailsAmexAdditionalAmounts.attributeTypeMap;
    }
}

export class Ptsv2paymentsOrderInformationAmountDetailsCurrencyConversion {
    /**
    * Flag indicating that DCC Lookup has been performed before this transaction. Set this field to 1 when cardholders opts to use DCC on the transaction. 
    */
    'indicator'?: string;
    /**
    * Unique identifier generated by the DCC provider. 
    */
    'reconciliationId'?: string;
    /**
    * Value of the Cybersource request ID returned in a DCC Lookup transaction. 
    */
    'id'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "indicator",
            "baseName": "indicator",
            "type": "string"
        },
        {
            "name": "reconciliationId",
            "baseName": "reconciliationId",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsOrderInformationAmountDetailsCurrencyConversion.attributeTypeMap;
    }
}

export class Ptsv2paymentsOrderInformationAmountDetailsOctsurcharge {
    /**
    * The surcharge amount is included in the total transaction amount but is passed in a separate field to the issuer and acquirer for tracking.  The issuer can provide information about the surcharge amount to the customer.   If the amount is positive, then it is a debit for the customer.   If the amount is negative, then it is a credit for the customer. 
    */
    'amount'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "amount",
            "baseName": "amount",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsOrderInformationAmountDetailsOctsurcharge.attributeTypeMap;
    }
}

export class Ptsv2paymentsOrderInformationAmountDetailsOrder {
    /**
    * Grand total for the order. This value cannot be negative. You can include a decimal point (.), but you cannot include any other special characters. CyberSource truncates the amount to the correct number of decimal places 
    */
    'totalAmount'?: string;
    /**
    * Currency used for the order 
    */
    'currency'?: string;
    /**
    * Shipping discount amount for the transaction. If this amount has changed since the initial sessions request, you must include the new value in the order request. You must also include all additional amount fields that apply to the order and ensure the total amount equals the purchaseTotals_grandTotalAmount value. 
    */
    'subTotalAmount'?: string;
    /**
    * Aggregate handling charges for the transaction. If this amount has changed since the initial sessions request, you must include the new value in the order request. You must also include all additional amount fields that apply to the order and ensure the total amount equals the purchaseTotals_grandTotalAmount value. 
    */
    'handlingAmount'?: string;
    /**
    * Aggregate shipping charges for the transaction If this amount has changed since the initial sessions request, you must include the new value in the order request. You must also include all additional amount fields that apply to the order and ensure the total amount equals the purchaseTotals_grandTotalAmount value. 
    */
    'shippingAmount'?: string;
    /**
    * Shipping discount amount for the transaction. If this amount has changed since the initial sessions request, you must include the new value in the order request. You must also include all additional amount fields that apply to the order and ensure the total amount equals the purchaseTotals_grandTotalAmount value. 
    */
    'shippingDiscountAmount'?: string;
    /**
    * Total tax amount. When the purchaseTotals_ taxAmount and ap_subtotalAmount fields are included in the request, do not include the tax amount as part of the subtotal amount calculation. 
    */
    'taxAmount'?: string;
    /**
    * Amount being charged for the insurance fee. Only supported when the payment_method is set to paypal. 
    */
    'insuranceAmount'?: string;
    /**
    * Amount being charged as gift wrap fee.            
    */
    'giftWrapAmount'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "totalAmount",
            "baseName": "totalAmount",
            "type": "string"
        },
        {
            "name": "currency",
            "baseName": "currency",
            "type": "string"
        },
        {
            "name": "subTotalAmount",
            "baseName": "subTotalAmount",
            "type": "string"
        },
        {
            "name": "handlingAmount",
            "baseName": "handlingAmount",
            "type": "string"
        },
        {
            "name": "shippingAmount",
            "baseName": "shippingAmount",
            "type": "string"
        },
        {
            "name": "shippingDiscountAmount",
            "baseName": "shippingDiscountAmount",
            "type": "string"
        },
        {
            "name": "taxAmount",
            "baseName": "taxAmount",
            "type": "string"
        },
        {
            "name": "insuranceAmount",
            "baseName": "insuranceAmount",
            "type": "string"
        },
        {
            "name": "giftWrapAmount",
            "baseName": "giftWrapAmount",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsOrderInformationAmountDetailsOrder.attributeTypeMap;
    }
}

export class Ptsv2paymentsOrderInformationAmountDetailsSurcharge {
    /**
    * The surcharge amount is included in the total transaction amount but is passed in a separate field to the issuer and acquirer for tracking. The issuer can provide information about the surcharge amount to the customer.  If the amount is positive, then it is a debit for the customer. If the amount is negative, then it is a credit for the customer.  **NOTE**: This field is supported only for CyberSource through VisaNet (CtV) for Payouts. For CtV, the maximum string length is 8.  #### PIN debit Surcharge amount that you are charging the customer for this transaction. If you include a surcharge amount in the request, you must also include the surcharge amount in the value for `orderInformation.amountDetails.totalAmount`.  Optional field for transactions that use PIN debit credit or PIN debit purchase. 
    */
    'amount'?: string;
    /**
    * Merchant-defined field for describing the surcharge amount.
    */
    'description'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "amount",
            "baseName": "amount",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsOrderInformationAmountDetailsSurcharge.attributeTypeMap;
    }
}

export class Ptsv2paymentsOrderInformationAmountDetailsTaxDetails {
    /**
    * Indicates the type of tax data for the _taxDetails_ object.  Possible values:  - `alternate` - `local` - `national` - `vat` - `other` - `green` 
    */
    'type'?: string;
    /**
    * Indicates the amount of tax based on the `type` field as described in the table below:  | type      | type description | | ------------- |:-------------:| | `alternate` | Total amount of alternate tax for the order. | | `local`     | Sales tax for the order. | | `national`  | National tax for the order. | | `vat`       | Total amount of value added tax (VAT) included in the order. | | `other`     | Other tax. | | `green`     | Green tax amount for Korean Processing. | 
    */
    'amount'?: string;
    /**
    * Rate of VAT or other tax for the order.  Example 0.040 (=4%)  Valid range: 0.01 to 0.99 (1% to 99%, with only whole percentage values accepted; values with additional decimal places will be truncated) 
    */
    'rate'?: string;
    /**
    * Type of tax being applied to the item.  #### FDC Nashville Global - `alternate_tax_type_applied` - `alternate_tax_type_identifier`  #### Worldpay VAP - `alternate_tax_type_identifier`  #### RBS WorldPay Atlanta - `tax_type_applied`  #### TSYS Acquiring Solutions - `tax_type_applied` - `local_tax_indicator`  #### Chase Paymentech Solutions - `tax_type_applied`  #### Elavon Americas - `local_tax_indicator`  #### FDC Compass - `tax_type_applied`  #### OmniPay Direct - `local_tax_indicator` 
    */
    'code'?: string;
    /**
    * Your tax ID number to use for the alternate tax amount. Required if you set alternate tax amount to any value, including zero. You may send this field without sending alternate tax amount. 
    */
    'taxId'?: string;
    /**
    * Flag that indicates whether the alternate tax amount (`orderInformation.amountDetails.taxDetails[].amount`) is included in the request.  Possible values: - `false`: alternate tax amount is not included in the request. - `true`: alternate tax amount is included in the request. 
    */
    'applied'?: boolean;
    /**
    * Status code for exemption from sales and use tax. This field is a pass-through, which means that CyberSource does not verify the value or modify it in any way before sending it to the processor. 
    */
    'exemptionCode'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "amount",
            "baseName": "amount",
            "type": "string"
        },
        {
            "name": "rate",
            "baseName": "rate",
            "type": "string"
        },
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        },
        {
            "name": "taxId",
            "baseName": "taxId",
            "type": "string"
        },
        {
            "name": "applied",
            "baseName": "applied",
            "type": "boolean"
        },
        {
            "name": "exemptionCode",
            "baseName": "exemptionCode",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsOrderInformationAmountDetailsTaxDetails.attributeTypeMap;
    }
}

export class Ptsv2paymentsOrderInformationBillTo {
    /**
    * Customer’s first name. This name must be the same as the name on the card.  **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.  #### SEPA Required for Create Mandate and Import Mandate #### BACS Required for Import Mandate  #### CyberSource Latin American Processing **Important** For an authorization request, CyberSource Latin American Processing concatenates `orderInformation.billTo.firstName` and `orderInformation.billTo.lastName`. If the concatenated value exceeds 30 characters, CyberSource Latin American Processing declines the authorization request.\\ **Note** CyberSource Latin American Processing is the name of a specific processing connection that CyberSource supports. In the CyberSource API documentation, CyberSource Latin American Processing does not refer to the general topic of processing in Latin America. The information in this field description is for the specific processing connection called _CyberSource Latin American Processing_. It is not for any other Latin American processors that CyberSource supports.  #### CyberSource through VisaNet Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.  #### For Payouts: This field may be sent only for FDC Compass.  #### Chase Paymentech Solutions Optional field.  ####  Credit Mutuel-CIC Optional field.  #### OmniPay Direct Optional field.  #### SIX Optional field.  #### TSYS Acquiring Solutions Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.  #### Worldpay VAP Optional field.  #### All other processors Not used. 
    */
    'firstName'?: string;
    /**
    * Customer’s last name. This name must be the same as the name on the card.  **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.  #### SEPA Required for Create Mandate and Import Mandate #### BACS Required for Import Mandate #### Chase Paymentech Solutions Optional field.  ####  Credit Mutuel-CIC Optional field.  #### CyberSource Latin American Processing **Important** For an authorization request, CyberSource Latin American Processing concatenates `orderInformation.billTo.firstName` and `orderInformation.billTo.lastName`. If the concatenated value exceeds 30 characters, CyberSource Latin American Processing declines the authorization request.\\ **Note** CyberSource Latin American Processing is the name of a specific processing connection that CyberSource supports. In the CyberSource API documentation, CyberSource Latin American Processing does not refer to the general topic of processing in Latin America. The information in this field description is for the specific processing connection called CyberSource Latin American Processing. It is not for any other Latin American processors that CyberSource supports.  #### CyberSource through VisaNet Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.  #### For Payouts: This field may be sent only for FDC Compass.  #### OmniPay Direct Optional field.  #### RBS WorldPay Atlanta Optional field.  #### SIX Optional field.  #### TSYS Acquiring Solutions Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.  #### Worldpay VAP Optional field.  #### All other processors Not used. 
    */
    'lastName'?: string;
    /**
    * Customer’s middle name. 
    */
    'middleName'?: string;
    /**
    * Customer’s name suffix. 
    */
    'nameSuffix'?: string;
    /**
    * Title. 
    */
    'title'?: string;
    'company'?: Ptsv2paymentsOrderInformationBillToCompany;
    /**
    * Payment card billing street address as it appears on the credit card issuer’s records.  #### SEPA Required for Create Mandate and Import Mandate  #### Atos This field must not contain colons (:).  #### CyberSource through VisaNet **Important** When you populate orderInformation.billTo.address1 and orderInformation.billTo.address2, CyberSource through VisaNet concatenates the two values. If the concatenated value exceeds 40 characters, CyberSource through VisaNet truncates the value at 40 characters before sending it to Visa and the issuing bank. Truncating this value affects AVS results and therefore might also affect risk decisions and chargebacks. Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.  #### FDMS Nashville When the street name is numeric, it must be sent in numeric format. For example, if the address is _One First Street_, it must be sent as _1 1st Street_.  Required if keyed; not used if swiped.  String (20)  #### TSYS Acquiring Solutions Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.  #### All other processors: Optional. String (60)  #### For Payouts This field may be sent only for FDC Compass.  **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting. 
    */
    'address1'?: string;
    /**
    * Used for additional address information. For example: _Attention: Accounts Payable_ Optional field.  For Payouts: This field may be sent only for FDC Compass.  #### Atos This field must not contain colons (:).  #### CyberSource through VisaNet **Important** When you populate `orderInformation.billTo.address1` and `orderInformation.billTo.address2`, CyberSource through VisaNet concatenates the two values. If the concatenated value exceeds 40 characters, CyberSource through VisaNet truncates the value at 40 characters before sending it to Visa and the issuing bank. Truncating this value affects AVS results and therefore might also affect risk decisions and chargebacks. Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.  #### Chase Paymentech Solutions, FDC Compass, and TSYS Acquiring Solutions This value is used for AVS.  #### FDMS Nashville `orderInformation.billTo.address1` and `orderInformation.billTo.address2` together cannot exceed 20 characters. String (20)  #### All Other Processors String (60) 
    */
    'address2'?: string;
    /**
    * Additional address information (third line of the billing address) 
    */
    'address3'?: string;
    /**
    * Additional address information (fourth line of the billing address) 
    */
    'address4'?: string;
    /**
    * Payment card billing city.  #### SEPA Required for Create Mandate and Import Mandate  #### Atos This field must not contain colons (:).  #### CyberSource through VisaNet Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.  #### For Payouts: This field may be sent only for FDC Compass.  #### Chase Paymentech Solutions Optional field.  ####  Credit Mutuel-CIC Optional field.  #### OmniPay Direct Optional field.  #### SIX Optional field.  #### TSYS Acquiring Solutions Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.  #### Worldpay VAP Optional field.  #### All other processors Not used. 
    */
    'locality'?: string;
    /**
    * State or province of the billing address. Use the [State, Province, and Territory Codes for the United States and Canada](https://developer.cybersource.com/library/documentation/sbc/quickref/states_and_provinces.pdf).  For Payouts: This field may be sent only for FDC Compass.  ##### CyberSource through VisaNet Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.  **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.  #### Chase Paymentech Solutions Optional field.  ####  Credit Mutuel-CIC Optional field.  #### OmniPay Direct Optional field.  #### SIX Optional field.  #### TSYS Acquiring Solutions Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.  #### Worldpay VAP Optional field.  #### All other processors Not used. 
    */
    'administrativeArea'?: string;
    /**
    * Postal code for the billing address. The postal code must consist of 5 to 9 digits.  When the billing country is the U.S., the 9-digit postal code must follow this format: [5 digits][dash][4 digits]  **Example** `12345-6789`  When the billing country is Canada, the 6-digit postal code must follow this format: [alpha][numeric][alpha][space][numeric][alpha][numeric]  **Example** `A1B 2C3`  **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.  #### SEPA Required for Create Mandate and Import Mandate  #### For Payouts:  This field may be sent only for FDC Compass.  #### American Express Direct Before sending the postal code to the processor, CyberSource removes all nonalphanumeric characters and, if the remaining value is longer than nine characters, truncates the value starting from the right side.  #### Atos This field must not contain colons (:).  #### CyberSource through VisaNet Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.  #### FDMS Nashville Required if `pointOfSaleInformation.entryMode=keyed` and the address is in the U.S. or Canada. Optional if `pointOfSaleInformation.entryMode=keyed` and the address is **not** in the U.S. or Canada. Not used if swiped.  #### RBS WorldPay Atlanta: For best card-present keyed rates, send the postal code if `pointOfSaleInformation.entryMode=keyed`.  #### TSYS Acquiring Solutions Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.  #### All other processors: Optional field. 
    */
    'postalCode'?: string;
    /**
    * U.S. county if available.
    */
    'county'?: string;
    /**
    * Payment card billing country. Use the two-character [ISO Standard Country Codes](http://apps.cybersource.com/library/documentation/sbc/quickref/countries_alpha_list.pdf).  #### SEPA/BACS Required for Create Mandate and Import Mandate  #### CyberSource through VisaNet Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.  **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.  #### Chase Paymentech Solutions Optional field.  ####  Credit Mutuel-CIC Optional field.  #### OmniPay Direct Optional field.  #### SIX Optional field.  #### TSYS Acquiring Solutions Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.  #### Worldpay VAP Optional field.  #### All other processors Not used. 
    */
    'country'?: string;
    /**
    * Customer’s neighborhood, community, or region (a barrio in Brazil) within the city or municipality. This field is available only on **Cielo**. 
    */
    'district'?: string;
    /**
    * Building number in the street address.  For example, if the street address is: Rua da Quitanda 187 then the building number is 187.  This field is supported only for:  - Cielo transactions.  - Redecard customer validation with CyberSource Latin American Processing. 
    */
    'buildingNumber'?: string;
    /**
    * Customer's email address, including the full domain name.  #### CyberSource through VisaNet Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.  **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.  #### Invoicing Email address for the customer for sending the invoice. If the invoice is in SENT status and email is updated, the old email customer payment link won't work and you must resend the invoice with the new payment link.  #### Chase Paymentech Solutions Optional field.  ####  Credit Mutuel-CIC Optional field.  #### OmniPay Direct Optional field.  #### SIX Optional field.  #### TSYS Acquiring Solutions Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.  #### Worldpay VAP Optional field.  #### All other processors Not used. 
    */
    'email'?: string;
    /**
    * Email domain of the customer. The domain of the email address comprises all characters that follow the @ symbol, such as mail.example.com. For the Risk Update service, if the email address and the domain are sent in the request, the domain supersedes the email address. 
    */
    'emailDomain'?: string;
    /**
    * Customer’s phone number.  It is recommended that you include the country code when the order is from outside the U.S.  #### Chase Paymentech Solutions Optional field.  ####  Credit Mutuel-CIC Optional field.  #### CyberSource through VisaNet Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.  #### For Payouts: This field may be sent only for FDC Compass.  #### OmniPay Direct Optional field.  #### SIX Optional field.  #### TSYS Acquiring Solutions Optional field.  #### Worldpay VAP Optional field.  #### All other processors Not used. 
    */
    'phoneNumber'?: string;
    /**
    * Customer's phone number type.  #### For Payouts: This field may be sent only for FDC Compass.  Possible Values: * day * home * night * work 
    */
    'phoneType'?: string;
    /**
    * Whether buyer has verified their identity. Used in case of PayPal transactions.  Possible Values: * VERIFIED * UNVERIFIED 
    */
    'verificationStatus'?: string;
    /**
    * #### Visa Platform Connect contains customer’s alternate phone number. 
    */
    'alternatePhoneNumber'?: string;
    /**
    * #### Visa Platform Connect contains customer’s alternate email address. 
    */
    'alternateEmail'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "firstName",
            "baseName": "firstName",
            "type": "string"
        },
        {
            "name": "lastName",
            "baseName": "lastName",
            "type": "string"
        },
        {
            "name": "middleName",
            "baseName": "middleName",
            "type": "string"
        },
        {
            "name": "nameSuffix",
            "baseName": "nameSuffix",
            "type": "string"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "company",
            "baseName": "company",
            "type": "Ptsv2paymentsOrderInformationBillToCompany"
        },
        {
            "name": "address1",
            "baseName": "address1",
            "type": "string"
        },
        {
            "name": "address2",
            "baseName": "address2",
            "type": "string"
        },
        {
            "name": "address3",
            "baseName": "address3",
            "type": "string"
        },
        {
            "name": "address4",
            "baseName": "address4",
            "type": "string"
        },
        {
            "name": "locality",
            "baseName": "locality",
            "type": "string"
        },
        {
            "name": "administrativeArea",
            "baseName": "administrativeArea",
            "type": "string"
        },
        {
            "name": "postalCode",
            "baseName": "postalCode",
            "type": "string"
        },
        {
            "name": "county",
            "baseName": "county",
            "type": "string"
        },
        {
            "name": "country",
            "baseName": "country",
            "type": "string"
        },
        {
            "name": "district",
            "baseName": "district",
            "type": "string"
        },
        {
            "name": "buildingNumber",
            "baseName": "buildingNumber",
            "type": "string"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "emailDomain",
            "baseName": "emailDomain",
            "type": "string"
        },
        {
            "name": "phoneNumber",
            "baseName": "phoneNumber",
            "type": "string"
        },
        {
            "name": "phoneType",
            "baseName": "phoneType",
            "type": "string"
        },
        {
            "name": "verificationStatus",
            "baseName": "verificationStatus",
            "type": "string"
        },
        {
            "name": "alternatePhoneNumber",
            "baseName": "alternatePhoneNumber",
            "type": "string"
        },
        {
            "name": "alternateEmail",
            "baseName": "alternateEmail",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsOrderInformationBillTo.attributeTypeMap;
    }
}

export class Ptsv2paymentsOrderInformationBillToCompany {
    /**
    * Name of the customer’s company.  **CyberSource through VisaNet** Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks. 
    */
    'name'?: string;
    /**
    * First line in the street address of the company purchasing the product.
    */
    'address1'?: string;
    /**
    * Additional address information for the company purchasing the product.
    */
    'address2'?: string;
    /**
    * City in the address of the company purchasing the product.
    */
    'locality'?: string;
    /**
    * State or province in the address of the company purchasing the product. Use the State, Province, and Territory Codes for the United States and Canada. 
    */
    'administrativeArea'?: string;
    /**
    * Postal code in the address of the company purchasing the product. The postal code must consist of 5 to 9 digits.  When the company country is the U.S., the 9-digit postal code must follow this format: **[5 digits][dash][4 digits]** #### Example `12345-6789`  When the company country is Canada, the 6-digit postal code must follow this format: **[alpha][numeric][alpha][space][numeric][alpha][numeric]** #### Example `A1B 2C3` 
    */
    'postalCode'?: string;
    /**
    * Country in the address of the company purchasing the product. Use the [ISO Standard Country Codes](https://developer.cybersource.com/library/documentation/sbc/quickref/countries_alpha_list.pdf). 
    */
    'country'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "address1",
            "baseName": "address1",
            "type": "string"
        },
        {
            "name": "address2",
            "baseName": "address2",
            "type": "string"
        },
        {
            "name": "locality",
            "baseName": "locality",
            "type": "string"
        },
        {
            "name": "administrativeArea",
            "baseName": "administrativeArea",
            "type": "string"
        },
        {
            "name": "postalCode",
            "baseName": "postalCode",
            "type": "string"
        },
        {
            "name": "country",
            "baseName": "country",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsOrderInformationBillToCompany.attributeTypeMap;
    }
}

export class Ptsv2paymentsOrderInformationInvoiceDetails {
    /**
    * Invoice Number.
    */
    'invoiceNumber'?: string;
    /**
    * Barcode Number.
    */
    'barcodeNumber'?: string;
    /**
    * Expiration Date.
    */
    'expirationDate'?: string;
    /**
    * Value used by your customer to identify the order. This value is typically a purchase order number. CyberSource recommends that you do not populate the field with all zeros or nines. 
    */
    'purchaseOrderNumber'?: string;
    /**
    * Date the order was processed. `Format: YYYY-MM-DD`. 
    */
    'purchaseOrderDate'?: string;
    /**
    * The name of the individual or the company contacted for company authorized purchases. 
    */
    'purchaseContactName'?: string;
    /**
    * Flag that indicates whether an order is taxable. This value must be true if the sum of all _lineItems[].taxAmount_ values > 0.  If you do not include any `lineItems[].taxAmount` values in your request, CyberSource does not include `invoiceDetails.taxable` in the data it sends to the processor.  Possible values:  - **true**  - **false** 
    */
    'taxable'?: boolean;
    /**
    * VAT invoice number associated with the transaction. 
    */
    'vatInvoiceReferenceNumber'?: string;
    /**
    * International description code of the overall order’s goods or services or the Categorizes purchases for VAT reporting. Contact your acquirer for a list of codes. 
    */
    'commodityCode'?: string;
    /**
    * Identifier for the merchandise. This field is supported only on the processors listed in this field description.  #### American Express Direct Possible value: - 1000: Gift card  #### CyberSource through VisaNet This value must be right justified. In Japan, this value is called a _goods code_.  #### JCN Gateway This value must be right justified. In Japan, this value is called a _goods code_. 
    */
    'merchandiseCode'?: number;
    'transactionAdviceAddendum'?: Array<Ptsv2paymentsOrderInformationInvoiceDetailsTransactionAdviceAddendum>;
    /**
    * Code that identifies the value of the `referenceDataNumber` field.  This field is a pass-through, which means that CyberSource does not verify the value or modify it in any way before sending it to the processor. 
    */
    'referenceDataCode'?: string;
    /**
    * Reference number. The meaning of this value is identified by the value of the `referenceDataCode` field.  This field is a pass-through, which means that CyberSource does not verify the value or modify it in any way before sending it to the processor. 
    */
    'referenceDataNumber'?: string;
    /**
    * Transaction identifier that is generated. You have the option of printing the sales slip number on the receipt. This field is supported only on Cybersource through Visanet and JCN gateway.  Optional field.  #### Card Present processing message If you included this field in the request, the returned value is the value that you sent in the request. If you did not include this field in the request, the system generated this value for you.  The difference between this reply field and the `processorInformation.systemTraceAuditNumber` field is that the system generates the system trace audit number (STAN), and you must print the receipt number on the receipt; whereas you can generate the sales slip number, and you can choose to print the sales slip number on the receipt. 
    */
    'salesSlipNumber'?: number;
    /**
    * Date of the tax calculation. Use format YYYYMMDD. You can provide a date in the past if you are calculating tax for a refund and want to know what the tax was on the date the order was placed. You can provide a date in the future if you are calculating the tax for a future date, such as an upcoming tax holiday.  The default is the date, in Pacific time, that the bank receives the request. Keep this in mind if you are in a different time zone and want the tax calculated with the rates that are applicable on a specific date.  #### Tax Calculation Optional field for U.S., Canadian, international tax, and value added taxes. 
    */
    'invoiceDate'?: string;
    /**
    * Cost centre of the merchant
    */
    'costCenter'?: string;
    /**
    * Text message from the issuer. If you give the customer a receipt, display this value on the receipt.
    */
    'issuerMessage'?: string;
    /**
    * Brief description of item.
    */
    'productDescription'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "invoiceNumber",
            "baseName": "invoiceNumber",
            "type": "string"
        },
        {
            "name": "barcodeNumber",
            "baseName": "barcodeNumber",
            "type": "string"
        },
        {
            "name": "expirationDate",
            "baseName": "expirationDate",
            "type": "string"
        },
        {
            "name": "purchaseOrderNumber",
            "baseName": "purchaseOrderNumber",
            "type": "string"
        },
        {
            "name": "purchaseOrderDate",
            "baseName": "purchaseOrderDate",
            "type": "string"
        },
        {
            "name": "purchaseContactName",
            "baseName": "purchaseContactName",
            "type": "string"
        },
        {
            "name": "taxable",
            "baseName": "taxable",
            "type": "boolean"
        },
        {
            "name": "vatInvoiceReferenceNumber",
            "baseName": "vatInvoiceReferenceNumber",
            "type": "string"
        },
        {
            "name": "commodityCode",
            "baseName": "commodityCode",
            "type": "string"
        },
        {
            "name": "merchandiseCode",
            "baseName": "merchandiseCode",
            "type": "number"
        },
        {
            "name": "transactionAdviceAddendum",
            "baseName": "transactionAdviceAddendum",
            "type": "Array<Ptsv2paymentsOrderInformationInvoiceDetailsTransactionAdviceAddendum>"
        },
        {
            "name": "referenceDataCode",
            "baseName": "referenceDataCode",
            "type": "string"
        },
        {
            "name": "referenceDataNumber",
            "baseName": "referenceDataNumber",
            "type": "string"
        },
        {
            "name": "salesSlipNumber",
            "baseName": "salesSlipNumber",
            "type": "number"
        },
        {
            "name": "invoiceDate",
            "baseName": "invoiceDate",
            "type": "string"
        },
        {
            "name": "costCenter",
            "baseName": "costCenter",
            "type": "string"
        },
        {
            "name": "issuerMessage",
            "baseName": "issuerMessage",
            "type": "string"
        },
        {
            "name": "productDescription",
            "baseName": "productDescription",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsOrderInformationInvoiceDetails.attributeTypeMap;
    }
}

export class Ptsv2paymentsOrderInformationInvoiceDetailsTransactionAdviceAddendum {
    /**
    * Four Transaction Advice Addendum (TAA) fields. These fields are used to display descriptive information about a transaction on the customer’s American Express card statement. When you send TAA fields, start with amexdata_taa1, then ...taa2, and so on. Skipping a TAA field causes subsequent TAA fields to be ignored.  To use these fields, contact CyberSource Customer Support to have your account enabled for this feature. 
    */
    'data'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "data",
            "baseName": "data",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsOrderInformationInvoiceDetailsTransactionAdviceAddendum.attributeTypeMap;
    }
}

export class Ptsv2paymentsOrderInformationLineItems {
    /**
    * Type of product. The value for this field is used to identify the product category (electronic, handling, physical, service, or shipping). The default value is `default`.  If you are performing an authorization transaction (`processingOptions.capture` is set to `false`), and you set this field to a value other than `default` or one of the values related to shipping and/or handling, then `orderInformation.lineItems[].quantity`, `orderInformation.lineItems[].productName`, and `orderInformation.lineItems[].productSku` fields are required.  Optional field.  #### Tax Calculation Optional field for U.S., Canadian, international tax, and value added taxes.  The Product Codes for the tax service are located in the Cybersource Tax Codes guide. Contact Customer Support to request the guide. If you don’t send a tax service Product Code in your tax request, product-based rules or exemptions will not be applied and the transaction will default to fully taxable in the locations where you’ve indicated you need to collect tax [by way of nexus, no nexus, or seller registration number fields]. 
    */
    'productCode'?: string;
    /**
    * For an authorization or capture transaction (`processingOptions.capture` is `true` or `false`), this field is required when `orderInformation.lineItems[].productCode` is not `default` or one of the other values that are related to shipping and/or handling.  #### Tax Calculation Optional field for U.S., Canadian, international tax, and value added taxes. 
    */
    'productName'?: string;
    /**
    * Product identifier code. Also known as the Stock Keeping Unit (SKU) code for the product.  For an authorization or capture transaction (`processingOptions.capture` is set to `true` or `false`), this field is required when `orderInformation.lineItems[].productCode` is not set to **default** or one of the other values that are related to shipping and/or handling.  #### Tax Calculation Optional field for U.S. and Canadian taxes. Not applicable to international and value added taxes. For an authorization or capture transaction (`processingOptions.capture` is set to `true` or `false`), this field is required when `orderInformation.lineItems[].productCode` is not `default` or one of the values related to shipping and/or handling. 
    */
    'productSku'?: string;
    /**
    * Number of units for this order. Must be a non-negative integer.  The default is `1`. For an authorization or capture transaction (`processingOptions.capture` is set to `true` or `false`), this field is required when `orderInformation.lineItems[].productCode` is not `default` or one of the other values related to shipping and/or handling.  #### Tax Calculation Optional field for U.S., Canadian, international tax, and value added taxes. 
    */
    'quantity'?: number;
    /**
    * Per-item price of the product. This value for this field cannot be negative.  You must include either this field or the request-level field `orderInformation.amountDetails.totalAmount` in your request.  You can include a decimal point (.), but you cannot include any other special characters. The value is truncated to the correct number of decimal places.  #### DCC with a Third-Party Provider Set this field to the converted amount that was returned by the DCC provider. You must include either the 1st line item in the order and this field, or the request-level field `orderInformation.amountDetails.totalAmount` in your request.  #### Tax Calculation Required field for U.S., Canadian, international and value added taxes.  #### Zero Amount Authorizations If your processor supports zero amount authorizations, you can set this field to 0 for the authorization to check if the card is lost or stolen.  #### Maximum Field Lengths For GPN and JCN Gateway: Decimal (10) All other processors: Decimal (15) 
    */
    'unitPrice'?: string;
    /**
    * Unit of measure, or unit of measure code, for the item. 
    */
    'unitOfMeasure'?: string;
    /**
    * Total amount for the item. Normally calculated as the unit price times quantity.  When `orderInformation.lineItems[].productCode` is \"gift_card\", this is the purchase amount total for prepaid gift cards in major units.  Example: 123.45 USD = 123 
    */
    'totalAmount'?: string;
    /**
    * Total tax to apply to the product. This value cannot be negative. The tax amount and the offer amount must be in the same currency. The tax amount field is additive.  The following example uses a two-exponent currency such as USD:   1. You include each line item in your request.  ..- 1st line item has amount=10.00, quantity=1, and taxAmount=0.80  ..- 2nd line item has amount=20.00, quantity=1, and taxAmount=1.60  2. The total amount authorized will be 32.40, not 30.00 with 2.40 of tax included.  Optional field.  #### Airlines processing Tax portion of the order amount. This value cannot exceed 99999999999999 (fourteen 9s). Format: English characters only. Optional request field for a line item.  #### Tax Calculation Optional field for U.S., Canadian, international tax, and value added taxes.  Note if you send this field in your tax request, the value in the field will override the tax engine 
    */
    'taxAmount'?: string;
    /**
    * Tax rate applied to the item.  **Visa**: Valid range is 0.01 to 0.99 (1% to 99%, with only whole percentage values accepted; values with additional decimal places will be truncated).  **Mastercard**: Valid range is 0.00001 to 0.99999 (0.001% to 99.999%). 
    */
    'taxRate'?: string;
    /**
    * Flag to indicate how you handle discount at the line item level.   - 0: no line level discount provided  - 1: tax was calculated on the post-discount line item total  - 2: tax was calculated on the pre-discount line item total  `Note` Visa will inset 0 (zero) if an invalid value is included in this field.  This field relates to the value in the _lineItems[].discountAmount_ field. 
    */
    'taxAppliedAfterDiscount'?: string;
    /**
    * Flag to indicate whether tax is exempted or not included.   - 0: tax not included  - 1: tax included  - 2: transaction is not subject to tax 
    */
    'taxStatusIndicator'?: string;
    /**
    * Type of tax being applied to the item.  #### FDC Nashville Global - `alternate_tax_type_applied` - `alternate_tax_type_identifier`  #### Worldpay VAP - `alternate_tax_type_identifier`  #### RBS WorldPay Atlanta - `tax_type_applied`  #### TSYS Acquiring Solutions - `tax_type_applied` - `local_tax_indicator`  #### Chase Paymentech Solutions - `tax_type_applied`  #### Elavon Americas - `local_tax_indicator`  #### FDC Compass - `tax_type_applied`  #### OmniPay Direct - `local_tax_indicator` 
    */
    'taxTypeCode'?: string;
    /**
    * Flag that indicates whether the tax amount is included in the Line Item Total.  Possible values:  - **true**  - **false** 
    */
    'amountIncludesTax'?: boolean;
    /**
    * Flag to indicate whether the purchase is categorized as goods or services. Possible values:   - 00: goods  - 01: services 
    */
    'typeOfSupply'?: string;
    /**
    * Commodity code or International description code used to classify the item. Contact your acquirer for a list of codes. 
    */
    'commodityCode'?: string;
    /**
    * Discount applied to the item.
    */
    'discountAmount'?: string;
    /**
    * Flag that indicates whether the amount is discounted.  If you do not provide a value but you set Discount Amount to a value greater than zero, then CyberSource sets this field to **true**.  Possible values:  - **true**  - **false** 
    */
    'discountApplied'?: boolean;
    /**
    * Rate the item is discounted. Maximum of 2 decimal places.  Example 5.25 (=5.25%) 
    */
    'discountRate'?: string;
    /**
    * Field to support an invoice number for a transaction. You must specify the number of line items that will include an invoice number. By default, the first line item will include an invoice number field. The invoice number field can be included for up to 10 line items. 
    */
    'invoiceNumber'?: string;
    'taxDetails'?: Array<Ptsv2paymentsOrderInformationAmountDetailsTaxDetails>;
    /**
    * Information about the product code used for the line item. Possible values: - `E`: The product code is `electronic_software`. - `P`: The product code is not `electronic_software`.  For details, see the `fulfillmentType` field description in [Business Center Reporting User Guide.] (https://apps.cybersource.com/library/documentation/dev_guides/reporting_and_reconciliation/Reporting_User/html/) 
    */
    'fulfillmentType'?: string;
    /**
    * Weight of the item. 
    */
    'weight'?: string;
    /**
    * Type of weight.  Possible values: - B: Billed weight - N: Actual net weight 
    */
    'weightIdentifier'?: string;
    /**
    * Code that specifies the unit of measurement for the weight amount. For example, `OZ` specifies ounce and `LB` specifies pound. The possible values are defined by the ANSI Accredited Standards Committee (ASC). 
    */
    'weightUnit'?: string;
    /**
    * Code that identifies the value of the corresponding `orderInformation.lineItems[].referenceDataNumber` field.  Possible values: - AN: Client-defined asset code - MG: Manufacturer's part number - PO: Purchase order number - SK: Supplier stock keeping unit number - UP: Universal product code - VC: Supplier catalog number - VP: Vendor part number  This field is a pass-through, which means that CyberSource does not verify the value or modify it in any way before sending it to the processor. 
    */
    'referenceDataCode'?: string;
    /**
    * Reference number.  The meaning of this value is identified by the value of the corresponding `referenceDataCode` field. See Numbered Elements.  The maximum length for this field depends on the value of the corresponding `referenceDataCode` field: - When the code is `PO`, the maximum length for the reference number is 22. - When the code is `VC`, the maximum length for the reference number is 20. - For all other codes, the maximum length for the reference number is 30.  This field is a pass-through, which means that CyberSource does not verify the value or modify it in any way before sending it to the processor. 
    */
    'referenceDataNumber'?: string;
    /**
    * Per-item tax amount of the product. Note The amount value must be a non-negative number containing 2 decimal places and limited to 7 digits before the decimal point. 
    */
    'unitTaxAmount'?: string;
    /**
    * This field would contain measurement of a line item. 
    */
    'measurement'?: string;
    /**
    * Brief description of item.
    */
    'productDescription'?: string;
    /**
    * When `orderInformation.lineItems[].productCode` is \"gift_card\", this is the currency used for the gift card purchase.  For the possible values, see the [ISO Standard Currency Codes.](http://apps.cybersource.com/library/documentation/sbc/quickref/currencies.pdf) 
    */
    'giftCardCurrency'?: number;
    /**
    * Destination to where the item will be shipped. Example: Commercial, Residential, Store 
    */
    'shippingDestinationTypes'?: string;
    /**
    * This field is only used in DM service.  Determines whether to assign risk to the order if the billing and shipping addresses specify different cities, states, or countries. This field can contain one of the following values: - true: Orders are assigned only slight additional risk if billing and shipping addresses are different. - false: Orders are assigned higher additional risk if billing and shipping addresses are different. 
    */
    'gift'?: boolean;
    'passenger'?: Ptsv2paymentsOrderInformationPassenger;
    'allowedExportCountries'?: Array<string>;
    'restrictedExportCountries'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "productCode",
            "baseName": "productCode",
            "type": "string"
        },
        {
            "name": "productName",
            "baseName": "productName",
            "type": "string"
        },
        {
            "name": "productSku",
            "baseName": "productSku",
            "type": "string"
        },
        {
            "name": "quantity",
            "baseName": "quantity",
            "type": "number"
        },
        {
            "name": "unitPrice",
            "baseName": "unitPrice",
            "type": "string"
        },
        {
            "name": "unitOfMeasure",
            "baseName": "unitOfMeasure",
            "type": "string"
        },
        {
            "name": "totalAmount",
            "baseName": "totalAmount",
            "type": "string"
        },
        {
            "name": "taxAmount",
            "baseName": "taxAmount",
            "type": "string"
        },
        {
            "name": "taxRate",
            "baseName": "taxRate",
            "type": "string"
        },
        {
            "name": "taxAppliedAfterDiscount",
            "baseName": "taxAppliedAfterDiscount",
            "type": "string"
        },
        {
            "name": "taxStatusIndicator",
            "baseName": "taxStatusIndicator",
            "type": "string"
        },
        {
            "name": "taxTypeCode",
            "baseName": "taxTypeCode",
            "type": "string"
        },
        {
            "name": "amountIncludesTax",
            "baseName": "amountIncludesTax",
            "type": "boolean"
        },
        {
            "name": "typeOfSupply",
            "baseName": "typeOfSupply",
            "type": "string"
        },
        {
            "name": "commodityCode",
            "baseName": "commodityCode",
            "type": "string"
        },
        {
            "name": "discountAmount",
            "baseName": "discountAmount",
            "type": "string"
        },
        {
            "name": "discountApplied",
            "baseName": "discountApplied",
            "type": "boolean"
        },
        {
            "name": "discountRate",
            "baseName": "discountRate",
            "type": "string"
        },
        {
            "name": "invoiceNumber",
            "baseName": "invoiceNumber",
            "type": "string"
        },
        {
            "name": "taxDetails",
            "baseName": "taxDetails",
            "type": "Array<Ptsv2paymentsOrderInformationAmountDetailsTaxDetails>"
        },
        {
            "name": "fulfillmentType",
            "baseName": "fulfillmentType",
            "type": "string"
        },
        {
            "name": "weight",
            "baseName": "weight",
            "type": "string"
        },
        {
            "name": "weightIdentifier",
            "baseName": "weightIdentifier",
            "type": "string"
        },
        {
            "name": "weightUnit",
            "baseName": "weightUnit",
            "type": "string"
        },
        {
            "name": "referenceDataCode",
            "baseName": "referenceDataCode",
            "type": "string"
        },
        {
            "name": "referenceDataNumber",
            "baseName": "referenceDataNumber",
            "type": "string"
        },
        {
            "name": "unitTaxAmount",
            "baseName": "unitTaxAmount",
            "type": "string"
        },
        {
            "name": "measurement",
            "baseName": "measurement",
            "type": "string"
        },
        {
            "name": "productDescription",
            "baseName": "productDescription",
            "type": "string"
        },
        {
            "name": "giftCardCurrency",
            "baseName": "giftCardCurrency",
            "type": "number"
        },
        {
            "name": "shippingDestinationTypes",
            "baseName": "shippingDestinationTypes",
            "type": "string"
        },
        {
            "name": "gift",
            "baseName": "gift",
            "type": "boolean"
        },
        {
            "name": "passenger",
            "baseName": "passenger",
            "type": "Ptsv2paymentsOrderInformationPassenger"
        },
        {
            "name": "allowedExportCountries",
            "baseName": "allowedExportCountries",
            "type": "Array<string>"
        },
        {
            "name": "restrictedExportCountries",
            "baseName": "restrictedExportCountries",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsOrderInformationLineItems.attributeTypeMap;
    }
}

/**
* Contains travel-related passenger details used by DM service only.
*/
export class Ptsv2paymentsOrderInformationPassenger {
    /**
    * Passenger classification associated with the price of the ticket. You can use one of the following values: - `ADT`: Adult - `CNN`: Child - `INF`: Infant - `YTH`: Youth - `STU`: Student - `SCR`: Senior Citizen - `MIL`: Military 
    */
    'type'?: string;
    /**
    * Your company's passenger classification, such as with a frequent flyer program. In this case, you might use values such as `standard`, `gold`, or `platinum`. 
    */
    'status'?: string;
    /**
    * Passenger's phone number. If the order is from outside the U.S., CyberSource recommends that you include the [ISO Standard Country Codes](https://developer.cybersource.com/library/documentation/sbc/quickref/countries_alpha_list.pdf). 
    */
    'phone'?: string;
    /**
    * Passenger's first name.
    */
    'firstName'?: string;
    /**
    * Passenger's last name.
    */
    'lastName'?: string;
    /**
    * ID of the passenger to whom the ticket was issued. For example, you can use this field for the frequent flyer number. 
    */
    'id'?: string;
    /**
    * Passenger's email address, including the full domain name, such as jdoe@example.com.
    */
    'email'?: string;
    /**
    * Passenger's nationality country. Use the two character [ISO Standard Country Codes](https://developer.cybersource.com/library/documentation/sbc/quickref/countries_alpha_list.pdf).
    */
    'nationality'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "phone",
            "baseName": "phone",
            "type": "string"
        },
        {
            "name": "firstName",
            "baseName": "firstName",
            "type": "string"
        },
        {
            "name": "lastName",
            "baseName": "lastName",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "nationality",
            "baseName": "nationality",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsOrderInformationPassenger.attributeTypeMap;
    }
}

export class Ptsv2paymentsOrderInformationShipTo {
    /**
    * The title of the person receiving the product.
    */
    'title'?: string;
    /**
    * First name of the recipient.  #### Litle Maximum length: 25  #### All other processors Maximum length: 60  Optional field. 
    */
    'firstName'?: string;
    /**
    * Middle name of the recipient.  #### Litle Maximum length: 25  #### All other processors Maximum length: 60  Optional field. 
    */
    'middleName'?: string;
    /**
    * Last name of the recipient.  #### Litle Maximum length: 25  #### All other processors Maximum length: 60  Optional field. 
    */
    'lastName'?: string;
    /**
    * First line of the shipping address.  Required field for authorization if any shipping address information is included in the request; otherwise, optional.  #### Tax Calculation Optional field for U.S. and Canadian taxes. Not applicable to international and value added taxes. Billing address objects will be used to determine the cardholder’s location when shipTo objects are not present. 
    */
    'address1'?: string;
    /**
    * Second line of the shipping address.  Optional field.  #### Tax Calculation Optional field for U.S. and Canadian taxes. Not applicable to international and value added taxes. Billing address objects will be used to determine the cardholder’s location when shipTo objects are not present. 
    */
    'address2'?: string;
    /**
    * City of the shipping address.  Required field for authorization if any shipping address information is included in the request and shipping to the U.S. or Canada; otherwise, optional.  #### Tax Calculation Optional field for U.S. and Canadian taxes. Not applicable to international and value added taxes. Billing address objects will be used to determine the cardholder’s location when shipTo objects are not present. 
    */
    'locality'?: string;
    /**
    * State or province of the shipping address. Use the [State, Province, and Territory Codes for the United States and Canada](https://developer.cybersource.com/library/documentation/sbc/quickref/states_and_provinces.pdf) (maximum length: 2)   Required field for authorization if any shipping address information is included in the request and shipping to the U.S. or Canada; otherwise, optional.  #### Tax Calculation Optional field for U.S. and Canadian taxes. Not applicable to international and value added taxes. Billing address objects will be used to determine the cardholder’s location when shipTo objects are not present. 
    */
    'administrativeArea'?: string;
    /**
    * Postal code for the shipping address. The postal code must consist of 5 to 9 digits.  Required field for authorization if any shipping address information is included in the request and shipping to the U.S. or Canada; otherwise, optional.  When the billing country is the U.S., the 9-digit postal code must follow this format: [5 digits][dash][4 digits]  Example 12345-6789  When the billing country is Canada, the 6-digit postal code must follow this format: [alpha][numeric][alpha][space][numeric][alpha][numeric]  Example A1B 2C3  #### American Express Direct Before sending the postal code to the processor, all nonalphanumeric characters are removed and, if the remaining value is longer than nine characters, the value is truncated starting from the right side. #### Tax Calculation Optional field for U.S. and Canadian taxes. Not applicable to international and value added taxes. Billing address objects will be used to determine the cardholder’s location when shipTo objects are not present. 
    */
    'postalCode'?: string;
    /**
    * U.S. county if available.
    */
    'county'?: string;
    /**
    * Country of the shipping address. Use the two-character [ISO Standard Country Codes.](http://apps.cybersource.com/library/documentation/sbc/quickref/countries_alpha_list.pdf)  Required field for authorization if any shipping address information is included in the request; otherwise, optional.  #### Tax Calculation Optional field for U.S., Canadian, international tax, and value added taxes. Billing address objects will be used to determine the cardholder’s location when shipTo objects are not present. 
    */
    'country'?: string;
    /**
    * Neighborhood, community, or region within a city or municipality.
    */
    'district'?: string;
    /**
    * Building number in the street address. For example, the building number is 187 in the following address:  Rua da Quitanda 187 
    */
    'buildingNumber'?: string;
    /**
    * Phone number associated with the shipping address.
    */
    'phoneNumber'?: string;
    /**
    * Email of the recipient. 
    */
    'email'?: string;
    /**
    * Name of the customer’s company. 
    */
    'company'?: string;
    /**
    * Shipping destination of item. Example: Commercial, Residential, Store 
    */
    'destinationTypes'?: string;
    /**
    * Indicates destination chosen for the transaction. Possible values: - 01- Ship to cardholder billing address - 02- Ship to another verified address on file with merchant - 03- Ship to address that is different than billing address - 04- Ship to store (store address should be populated on request) - 05- Digital goods - 06- Travel and event tickets, not shipped - 07- Other 
    */
    'destinationCode'?: number;
    /**
    * Shipping method for the product. Possible values: - lowcost: Lowest-cost service - sameday: Courier or same-day service - oneday: Next-day or overnight service - twoday: Two-day service - threeday: Three-day service - pickup: Store pick-up - other: Other shipping method - none: No shipping method because product is a service or subscription Required for American Express SafeKey (U.S.). 
    */
    'method'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "firstName",
            "baseName": "firstName",
            "type": "string"
        },
        {
            "name": "middleName",
            "baseName": "middleName",
            "type": "string"
        },
        {
            "name": "lastName",
            "baseName": "lastName",
            "type": "string"
        },
        {
            "name": "address1",
            "baseName": "address1",
            "type": "string"
        },
        {
            "name": "address2",
            "baseName": "address2",
            "type": "string"
        },
        {
            "name": "locality",
            "baseName": "locality",
            "type": "string"
        },
        {
            "name": "administrativeArea",
            "baseName": "administrativeArea",
            "type": "string"
        },
        {
            "name": "postalCode",
            "baseName": "postalCode",
            "type": "string"
        },
        {
            "name": "county",
            "baseName": "county",
            "type": "string"
        },
        {
            "name": "country",
            "baseName": "country",
            "type": "string"
        },
        {
            "name": "district",
            "baseName": "district",
            "type": "string"
        },
        {
            "name": "buildingNumber",
            "baseName": "buildingNumber",
            "type": "string"
        },
        {
            "name": "phoneNumber",
            "baseName": "phoneNumber",
            "type": "string"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "company",
            "baseName": "company",
            "type": "string"
        },
        {
            "name": "destinationTypes",
            "baseName": "destinationTypes",
            "type": "string"
        },
        {
            "name": "destinationCode",
            "baseName": "destinationCode",
            "type": "number"
        },
        {
            "name": "method",
            "baseName": "method",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsOrderInformationShipTo.attributeTypeMap;
    }
}

/**
* Contains shipping information not related to address.
*/
export class Ptsv2paymentsOrderInformationShippingDetails {
    /**
    * Boolean that indicates whether the customer requested gift wrapping for this purchase. This field can contain one of the following values: - true: The customer requested gift wrapping. - false: The customer did not request gift wrapping. 
    */
    'giftWrap'?: boolean;
    /**
    * Shipping method for the product. Possible values:   - `lowcost`: Lowest-cost service  - `sameday`: Courier or same-day service  - `oneday`: Next-day or overnight service  - `twoday`: Two-day service  - `threeday`: Three-day service  - `pickup`: Store pick-up  - `other`: Other shipping method  - `none`: No shipping method because product is a service or subscription 
    */
    'shippingMethod'?: string;
    /**
    * Postal code for the address from which the goods are shipped, which is used to establish nexus. The default is the postal code associated with your CyberSource account.  The postal code must consist of 5 to 9 digits. When the billing country is the U.S., the 9-digit postal code must follow this format:  `[5 digits][dash][4 digits]`  Example 12345-6789  When the billing country is Canada, the 6-digit postal code must follow this format:  `[alpha][numeric][alpha][space] [numeric][alpha][numeric]`  Example A1B 2C3  This field is frequently used for Level II and Level III transactions. 
    */
    'shipFromPostalCode'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "giftWrap",
            "baseName": "giftWrap",
            "type": "boolean"
        },
        {
            "name": "shippingMethod",
            "baseName": "shippingMethod",
            "type": "string"
        },
        {
            "name": "shipFromPostalCode",
            "baseName": "shipFromPostalCode",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsOrderInformationShippingDetails.attributeTypeMap;
    }
}

export class Ptsv2paymentsPaymentInformation {
    'card'?: Ptsv2paymentsPaymentInformationCard;
    'tokenizedCard'?: Ptsv2paymentsPaymentInformationTokenizedCard;
    'tokenizedPaymentMethod'?: Ptsv2paymentsPaymentInformationTokenizedPaymentMethod;
    'directDebit'?: Ptsv2paymentsPaymentInformationDirectDebit;
    'fluidData'?: Ptsv2paymentsPaymentInformationFluidData;
    'customer'?: Ptsv2paymentsPaymentInformationCustomer;
    'paymentInstrument'?: Ptsv2paymentsPaymentInformationPaymentInstrument;
    'instrumentIdentifier'?: Ptsv2paymentsPaymentInformationInstrumentIdentifier;
    'shippingAddress'?: Ptsv2paymentsPaymentInformationShippingAddress;
    'legacyToken'?: Ptsv2paymentsPaymentInformationLegacyToken;
    'bank'?: Ptsv2paymentsPaymentInformationBank;
    'options'?: Ptsv2paymentsPaymentInformationOptions;
    'paymentType'?: Ptsv2paymentsPaymentInformationPaymentType;
    /**
    * Mastercard-defined code that indicates how the account information was obtained.  - `00`: Card - `01`: Mobile Network Operator (MNO) controlled removable secure element (SIM or UICC) personalized for use with a mobile phone or smartphone - `02`: Key fob - `03`: Watch using a contactless chip or a fixed (non-removable) secure element not controlled by the MNO - `04`: Mobile tag - `05`: Wristband - `06`: Mobile phone case or sleeve - `07`: Mobile phone or smartphone with a fixed (non-removable) secure element controlled by the MNO,for example, code division multiple access (CDMA) - `08`: Removable secure element not controlled by the MNO, for example, memory card personalized forused with a mobile phone or smartphone - `09`: Mobile Phone or smartphone with a fixed (non-removable) secure element not controlled by the MNO - `10`: MNO controlled removable secure element (SIM or UICC) personalized for use with a tablet or e-book - `11`: Tablet or e-book with a fixed (non-removable) secure element controlled by the MNO - `12`: Removable secure element not controlled by the MNO, for example, memory card personalized foruse with a tablet or e-book - `13`: Tablet or e-book with fixed (non-removable) secure element not controlled by the MNO - `14`: Mobile phone or smartphone with a payment application running in a host processor - `15`: Tablet or e-book with a payment application running in a host processor - `16`: Mobile phone or smartphone with a payment application running in the Trusted ExecutionEnvironment (TEE) of a host processor - `17`: Tablet or e-book with a payment application running in the TEE of a host processor - `18`: Watch with a payment application running in the TEE of a host processor - `19`: Watch with a payment application running in a host processor  Values from 20–99 exclusively indicate the form factor only without also indicating the storage technology  - `20`: Card - `21`: Phone e.g. Mobile Phone - `22`: Tablet/e-reader - `23`: Watch/Wristband e.g. Watch or wristband, including a fitness band, smart strap, disposable band, watch add-on, and security/ID band - `24`: Sticker - `25`: PC - `26`: Device Peripheral e.g. mobile phone case or sleeve - `27`: Tag e.g. key fob or mobile tag - `28`: Jewelry e.g. ring, bracelet, necklace and cuff links - `29`: Fashion Accessory e.g. handbag, bag charm and glasses - `30`: Garment e.g. dress - `31`: Domestic Appliance e.g refrigerator, washing machine - `32`: Vehicle e.g. vehicle, including vehicle attached devices - `33`: Media/Gaming Device e.g. media or gaming device, including a set top box, media player and television  34–99 are reserved for future form factors. Any value in this range may occur within form factor and transaction data without prior notice.  This field is supported only for Mastercard on CyberSource through VisaNet. When initiation channel is not provided via this API field, the value is extracted from EMV tag 9F6E for Mastercard transactions. To enable this feature please call support.  #### Used by **Authorization** Optional field. 
    */
    'initiationChannel'?: string;
    'sepa'?: Ptsv2paymentsPaymentInformationSepa;
    'eWallet'?: Ptsv2paymentsPaymentInformationEWallet;
    'paymentAccountReference'?: Ptsv2paymentsPaymentInformationPaymentAccountReference;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "card",
            "baseName": "card",
            "type": "Ptsv2paymentsPaymentInformationCard"
        },
        {
            "name": "tokenizedCard",
            "baseName": "tokenizedCard",
            "type": "Ptsv2paymentsPaymentInformationTokenizedCard"
        },
        {
            "name": "tokenizedPaymentMethod",
            "baseName": "tokenizedPaymentMethod",
            "type": "Ptsv2paymentsPaymentInformationTokenizedPaymentMethod"
        },
        {
            "name": "directDebit",
            "baseName": "directDebit",
            "type": "Ptsv2paymentsPaymentInformationDirectDebit"
        },
        {
            "name": "fluidData",
            "baseName": "fluidData",
            "type": "Ptsv2paymentsPaymentInformationFluidData"
        },
        {
            "name": "customer",
            "baseName": "customer",
            "type": "Ptsv2paymentsPaymentInformationCustomer"
        },
        {
            "name": "paymentInstrument",
            "baseName": "paymentInstrument",
            "type": "Ptsv2paymentsPaymentInformationPaymentInstrument"
        },
        {
            "name": "instrumentIdentifier",
            "baseName": "instrumentIdentifier",
            "type": "Ptsv2paymentsPaymentInformationInstrumentIdentifier"
        },
        {
            "name": "shippingAddress",
            "baseName": "shippingAddress",
            "type": "Ptsv2paymentsPaymentInformationShippingAddress"
        },
        {
            "name": "legacyToken",
            "baseName": "legacyToken",
            "type": "Ptsv2paymentsPaymentInformationLegacyToken"
        },
        {
            "name": "bank",
            "baseName": "bank",
            "type": "Ptsv2paymentsPaymentInformationBank"
        },
        {
            "name": "options",
            "baseName": "options",
            "type": "Ptsv2paymentsPaymentInformationOptions"
        },
        {
            "name": "paymentType",
            "baseName": "paymentType",
            "type": "Ptsv2paymentsPaymentInformationPaymentType"
        },
        {
            "name": "initiationChannel",
            "baseName": "initiationChannel",
            "type": "string"
        },
        {
            "name": "sepa",
            "baseName": "sepa",
            "type": "Ptsv2paymentsPaymentInformationSepa"
        },
        {
            "name": "eWallet",
            "baseName": "eWallet",
            "type": "Ptsv2paymentsPaymentInformationEWallet"
        },
        {
            "name": "paymentAccountReference",
            "baseName": "paymentAccountReference",
            "type": "Ptsv2paymentsPaymentInformationPaymentAccountReference"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsPaymentInformation.attributeTypeMap;
    }
}

export class Ptsv2paymentsPaymentInformationBank {
    'account'?: Ptsv2paymentsPaymentInformationBankAccount;
    /**
    * Bank routing number. This is also called the _transit number_. 
    */
    'routingNumber'?: string;
    /**
    * International Bank Account Number (IBAN) for the bank account. For some countries you can provide this number instead of the traditional bank account information. You can use this field only when scoring a direct debit transaction. 
    */
    'iban'?: string;
    /**
    * Bank’s SWIFT code. You can use this field only when scoring a direct debit transaction. Required only for crossborder transactions. 
    */
    'swiftCode'?: string;
    /**
    * Bank code of the consumer’s account 
    */
    'code'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "account",
            "baseName": "account",
            "type": "Ptsv2paymentsPaymentInformationBankAccount"
        },
        {
            "name": "routingNumber",
            "baseName": "routingNumber",
            "type": "string"
        },
        {
            "name": "iban",
            "baseName": "iban",
            "type": "string"
        },
        {
            "name": "swiftCode",
            "baseName": "swiftCode",
            "type": "string"
        },
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsPaymentInformationBank.attributeTypeMap;
    }
}

export class Ptsv2paymentsPaymentInformationBankAccount {
    /**
    * Account type.  Possible values:  - **C**: Checking.  - **G**: General ledger. This value is supported only on Wells Fargo ACH.  - **S**: Savings (U.S. dollars only).  - **X**: Corporate checking (U.S. dollars only). 
    */
    'type'?: string;
    /**
    * Account number.  When processing encoded account numbers, use this field for the encoded account number. 
    */
    'number'?: string;
    /**
    * Identifier for the bank that provided the customer’s encoded account number.  To obtain the bank identifier, contact your processor. 
    */
    'encoderId'?: string;
    /**
    * Check number.  Chase Paymentech Solutions - Optional. CyberSource ACH Service - Not used. RBS WorldPay Atlanta - Optional on debits. Required on credits. TeleCheck - Strongly recommended on debit requests. Optional on credits. 
    */
    'checkNumber'?: string;
    /**
    * Image reference number associated with the check. You cannot include any special characters. 
    */
    'checkImageReferenceNumber'?: string;
    /**
    * International Bank Account Number (IBAN) for the bank account. For some countries you can provide this number instead of the traditional bank account information. You can use this field only when scoring a direct debit transaction. 
    */
    'iban'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "number",
            "baseName": "number",
            "type": "string"
        },
        {
            "name": "encoderId",
            "baseName": "encoderId",
            "type": "string"
        },
        {
            "name": "checkNumber",
            "baseName": "checkNumber",
            "type": "string"
        },
        {
            "name": "checkImageReferenceNumber",
            "baseName": "checkImageReferenceNumber",
            "type": "string"
        },
        {
            "name": "iban",
            "baseName": "iban",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsPaymentInformationBankAccount.attributeTypeMap;
    }
}

export class Ptsv2paymentsPaymentInformationCard {
    /**
    * The customer’s payment card number, also known as the Primary Account Number (PAN). You can also use this field for encoded account numbers.  #### FDMS Nashville Required. String (19)  #### GPX Required if `pointOfSaleInformation.entryMode=keyed`. However, this field is optional if your account is configured for relaxed requirements for address data and expiration date. **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.  #### All other processors Required if `pointOfSaleInformation.entryMode=keyed`. However, this field is optional if your account is configured for relaxed requirements for address data and expiration date. **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting. 
    */
    'number'?: string;
    /**
    * Two-digit month in which the payment card expires.  Format: `MM`.  Valid values: `01` through `12`. Leading 0 is required.  #### Barclays and Streamline For Maestro (UK Domestic) and Maestro (International) cards on Barclays and Streamline, this must be a valid value (`01` through `12`) but is not required to be a valid expiration date. In other words, an expiration date that is in the past does not cause CyberSource to reject your request. However, an invalid expiration date might cause the issuer to reject your request.  #### Encoded Account Numbers For encoded account numbers (_type_=039), if there is no expiration date on the card, use `12`.  #### FDMS Nashville Required field.  #### All other processors Required if `pointOfSaleInformation.entryMode=keyed`. However, this field is optional if your account is configured for relaxed requirements for address data and expiration date. **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.  #### Google Pay transactions For PAN-based Google Pay transactions, this field is returned in the API response. 
    */
    'expirationMonth'?: string;
    /**
    * Four-digit year in which the payment card expires.  Format: `YYYY`.  #### Barclays and Streamline For Maestro (UK Domestic) and Maestro (International) cards on Barclays and Streamline, this must be a valid value (`1900` through `3000`) but is not required to be a valid expiration date. In other words, an expiration date that is in the past does not cause CyberSource to reject your request. However, an invalid expiration date might cause the issuer to reject your request.  #### Encoded Account Numbers For encoded account numbers (**_type_**`=039`), if there is no expiration date on the card, use `2021`.  #### FDMS Nashville Required field.  #### FDC Nashville Global and FDMS South You can send in 2 digits or 4 digits. If you send in 2 digits, they must be the last 2 digits of the year.  #### All other processors Required if `pointOfSaleInformation.entryMode=keyed`. However, this field is optional if your account is configured for relaxed requirements for address data and expiration date. **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.  #### Google Pay transactions For PAN-based Google Pay transactions, this field is returned in the API response. 
    */
    'expirationYear'?: string;
    /**
    * Three-digit value that indicates the card type.  **IMPORTANT** It is strongly recommended that you include the card type field in request messages even if it is optional for your processor and card type. Omitting the card type can cause the transaction to be processed with the wrong card type.  Possible values: - `001`: Visa. Use card type value `001` for Visa Electron. - `002`: Mastercard, Eurocard[^1], which is a European regional brand of Mastercard. - `003`: American Express - `004`: Discover - `005`: Diners Club - `006`: Carte Blanche[^1] - `007`: JCB[^1] - `008`: Optima - `009`: GE Private Label - `010`: Beneficial Private Label - `011`: Twinpay Credit Card - `012`: Twinpay Debit Card - `013`: WalMart - `014`: Enroute[^1] - `015`: Lowe's Consumer - `016`: Home Depot Consumer - `017`: MBNA - `018`: Dick's Sportswear - `019`: Casual Corner - `020`: Sears - `021`: JAL[^1] - `023`: Disney Card - `024`: Maestro (UK Domestic)[^1] - `025`: Sam's Club Consumer - `026`: Sam's Club Business - `027`: Nico's - `028`: Paymentech Bill Me Later - `029`: Bebe - `030`: Restoration Hardware - `031`: Delta Online - `032`: Solo - `033`: Visa Electron[^1]. Do not use this value. Use `001` for all Visa card types. - `034`: Dankort[^1] - `035`: Laser - `036`: Cartes Bancaires[^1,4] - `037`: Carta Si[^1] - `038`: Pinless Debit - `039`: Encoded account number[^1] - `040`: UATP[^1] - `041`: HOUSEHOLD - `042`: Maestro (International)[^1] - `043`: GE MONEY - `044`: Korean Cards - `045`: Style Cards - `046`: JCrew - `047`: Payeasecn eWallet - `048`: Payeasecn Bank Transfer - `049`: Meijer - `050`: Hipercard[^2,3] - `051`: Aura - `052`: Redecard - `053`: Orico card - `054`: Elo[^3] - `055`: Capitol One Private Label - `056`: Carnet - `057`: Costco Private Label - `058`: Carnet - `059`: ValueLink - `060`: MADA - `061`: RuPay - `062`: China UnionPay - `063`: Falabella Private Label - `064`: Prompt Card - `065`: Korean Domestic - `066`: Banricompras - `067`: MEEZA - `068`: PayPak - `070`: EFTPOS - `071`: Codensa - `072`: Olimpica - `073`: Colsubsidio - `074`: Tuya - `075`: Sodexo - `076`: Naranja - `077`: Cabal - `078`: DINELCO - `079`: PANAL - `080`: EPM - `081`: Jaywan  [^1]: For this card type, you must include the `paymentInformation.card.type` or `paymentInformation.tokenizedCard.type` field in your request for an authorization or a stand-alone credit. [^2]: For this card type on Cielo 3.0, you must include the `paymentInformation.card.type` or `paymentInformation.tokenizedCard.type` field in a request for an authorization or a stand-alone credit. This card type is not supported on Cielo 1.5. [^3]: For this card type on Getnet and Rede, you must include the `paymentInformation.card.type` or `paymentInformation.tokenizedCard.type` field in a request for an authorization or a stand-alone credit. [^4]: For this card type, you must include the `paymentInformation.card.type` in your request for any payer authentication services.  #### Used by **Authorization** Required for Carte Blanche and JCB. Optional for all other card types.  #### Card Present reply This field is included in the reply message when the client software that is installed on the POS terminal uses the token management service (TMS) to retrieve tokenized payment details. You must contact customer support to have your account enabled to receive these fields in the credit reply message.  Returned by the Credit service.  This reply field is only supported by the following processors: - American Express Direct - Credit Mutuel-CIC - FDC Nashville Global - OmniPay Direct - SIX  #### Google Pay transactions For PAN-based Google Pay transactions, this field is returned in the API response.  #### GPX This field only supports transactions from the following card types: - Visa - Mastercard - AMEX - Discover - Diners - JCB - Union Pay International 
    */
    'type'?: string;
    /**
    * Flag that specifies the type of account associated with the card.  This field is available only for China UnionPay, Cielo, Comercio Latino and Visa Platform Connect. The cardholder provides this information during the payment process.  This field is required for:  - Debit transactions on Cielo and Comercio Latino.  - Transactions with Brazilian-issued cards on CyberSource through VisaNet.  **China UnionPayCard Transactions on China UnionPay:** Possible values:  - C: Domestic credit card  - D: Domestic debit card  - F: International credit card  - I: International debit card  When the value is D, the e-commerce indicator and CAVV fields must be included in the authorization request. When the value is C, F or I the card verification number, expiration month and expiration year fields must in included in the authorization request.  **Cielo and Comercio Latino Credit Card Transactions:** On these processors, this field is supported only for authorizations.  Possible values:  - CR: Credit card  - DB: Debit card       **Visa Platform Connect Credit Card Transactions:** This field is supported for all card types on Visa Platform Connect. For combo **card present** transactions with Mastercard on Brazilian-issued cards, possible values:  - CR: Credit card  - DB: Debit Card  For combo **card not present** transactions with Mastercard on Brazilian-issued cards, possible values:  - C: Credit card  - D: Debit card  A value of CR or DB in the useAs field takes precedence over any value in the Source Account Type field. 
    */
    'useAs'?: string;
    /**
    * Flag that specifies the type of account associated with the card.  The cardholder provides this information during the payment process.  This field is required in the following cases:   - Debit transactions on Cielo and Comercio Latino.   - Transactions with Brazilian-issued cards on CyberSource through VisaNet.   - Applicable only for CyberSource through VisaNet (CtV).  **Note** Combo cards in Brazil contain credit and debit functionality in a single card. Visa systems use a credit bank identification number (BIN) for this type of card. Using the BIN to determine whether a card is debit or credit can cause transactions with these cards to be processed incorrectly. CyberSource strongly recommends that you include this field for combo card transactions.  Possible values include the following.   - `CH`: Checking account  - `CR`: Credit card account  - `SA`: Saving account  - `LI`: Line of credit or credit portion of combo card  - `PP`: Prepaid card account or prepaid portion of combo card  - `UA`: Universal account  If useAs is set to credit/debit and there is a value in SourceAccountType, the value in the SourceAccountType field will take precedence. If useAs is set to CR/DB and there is a value in SourceAccountType, the value in the useAs field will take precedence. 
    */
    'sourceAccountType'?: string;
    /**
    * Type of account that is being used when the value for the override_payment_method field is line of credit (LI) or prepaid card (PP). Possible values for line of credit: - `AGRC`: Visa Agro Custeio - `AGRE`: Visa Agro Electron - `AGRI`: Visa Agro Investimento - `AGRO`: Visa Agro Possible values for prepaid card: - `VVA`: Visa Vale Alimentacao - `VVF`: Visa Vale Flex - `VVR`: Visa Vale Refeicao This field is supported only for combo card transactions in Brazil on CyberSource through VisaNet. 
    */
    'sourceAccountTypeDetails'?: string;
    /**
    * Card Verification Number.  #### FDMS Nashville Required for American Express or if swiped; otherwise, optional.  #### Ingenico ePayments Do not include this field when `commerceIndicator=recurring`. **Note** Ingenico ePayments was previously called _Global Collect_.  #### TSYS Acquiring Solutions Optional if pointOfSaleInformation.entryMode=keyed; otherwise, not used.  #### GPX Optional.  #### All other processors: Optional. 
    */
    'securityCode'?: string;
    /**
    * Indicates whether a CVN code was sent. Possible values:   - `0` (default): CVN service not requested. This default value is used when you do not include      `securityCode` field in the request.  - `1` (default): CVN service requested and supported. This default value is used when you include      `securityCode` field in the request.  - `2`: CVN on credit card is illegible.  - `9`: CVN was not imprinted on credit card.  #### FDMS Nashville Required for American Express cards; otherwise, optional.  #### TSYS Acquiring Solutions Optional if `pointOfSaleInformation.entryMode=keyed`; otherwise, not used.  #### All other processors Optional. 
    */
    'securityCodeIndicator'?: string;
    /**
    * Identifier for the issuing bank that provided the customer’s encoded account number. Contact your processor for the bank’s ID. 
    */
    'accountEncoderId'?: string;
    /**
    * Number of times a Maestro (UK Domestic) card has been issued to the account holder. The card might or might not have an issue number. The number can consist of one or two digits, and the first digit might be a zero. When you include this value in your request, include exactly what is printed on the card. A value of 2 is different than a value of 02. Do not include the field, even with a blank value, if the card is not a Maestro (UK Domestic) card.  **Note** The issue number is not required for Maestro (UK Domestic) transactions. 
    */
    'issueNumber'?: string;
    /**
    * Month of the start of the Maestro (UK Domestic) card validity period. Do not include the field, even with a blank value, if the card is not a Maestro (UK Domestic) card. `Format: MM`. Possible values: 01 through 12.  **Note** The start date is not required for Maestro (UK Domestic) transactions. 
    */
    'startMonth'?: string;
    /**
    * Year of the start of the Maestro (UK Domestic) card validity period. Do not include the field, even with a blank value, if the card is not a Maestro (UK Domestic) card. `Format: YYYY`.  **Note** The start date is not required for Maestro (UK Domestic) transactions. 
    */
    'startYear'?: string;
    /**
    * Name of the card product.  Possible value: - BNDES  This field is supported only for BNDES transactions on CyberSource through VisaNet.  The value for this field corresponds to the following data in the TC 33 capture file5: - Record: CP07 TCR4 - Position: 115-120 - Field: Brazil Country Data 
    */
    'productName'?: string;
    /**
    * This field would contain the indicator for transaction type  Possible values: - AC: Agriculture Maintenance Account - AE: Agriculture Debit Account/Electron  - AG: Agriculture  - AI: Agriculture Investment Loan - CG: Brazil Cargo - CS: Construction  - DS: Distribution  - HC: Healthcare - LP: Visa Large Purchase Advantage - MA: Visa Mobile Agent - MB: Interoperable Mobile Branchless Banking - MG: Visa Mobile General - VA: Visa Vale - Supermarket - VF: Visa Vale - Fuel - VR: Visa Vale - Restaurant 
    */
    'productSubtype'?: string;
    /**
    * Flag that identifies how the card type was selected.  Possible values: - 0: Card type was selected based on default acquirer settings. - 1: Customer selected the card type. 
    */
    'typeSelectionIndicator'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "number",
            "baseName": "number",
            "type": "string"
        },
        {
            "name": "expirationMonth",
            "baseName": "expirationMonth",
            "type": "string"
        },
        {
            "name": "expirationYear",
            "baseName": "expirationYear",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "useAs",
            "baseName": "useAs",
            "type": "string"
        },
        {
            "name": "sourceAccountType",
            "baseName": "sourceAccountType",
            "type": "string"
        },
        {
            "name": "sourceAccountTypeDetails",
            "baseName": "sourceAccountTypeDetails",
            "type": "string"
        },
        {
            "name": "securityCode",
            "baseName": "securityCode",
            "type": "string"
        },
        {
            "name": "securityCodeIndicator",
            "baseName": "securityCodeIndicator",
            "type": "string"
        },
        {
            "name": "accountEncoderId",
            "baseName": "accountEncoderId",
            "type": "string"
        },
        {
            "name": "issueNumber",
            "baseName": "issueNumber",
            "type": "string"
        },
        {
            "name": "startMonth",
            "baseName": "startMonth",
            "type": "string"
        },
        {
            "name": "startYear",
            "baseName": "startYear",
            "type": "string"
        },
        {
            "name": "productName",
            "baseName": "productName",
            "type": "string"
        },
        {
            "name": "productSubtype",
            "baseName": "productSubtype",
            "type": "string"
        },
        {
            "name": "typeSelectionIndicator",
            "baseName": "typeSelectionIndicator",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsPaymentInformationCard.attributeTypeMap;
    }
}

export class Ptsv2paymentsPaymentInformationCustomer {
    /**
    * Unique identifier for the customer's card and billing information.  When you use Payment Tokenization or Recurring Billing and you include this value in your request, many of the fields that are normally required for an authorization or credit become optional.  **NOTE** When you use Payment Tokenization or Recurring Billing, the value for the Customer ID is actually the Cybersource payment token for a customer. This token stores information such as the consumer’s card number so it can be applied towards bill payments, recurring payments, or one-time payments. By using this token in a payment API request, the merchant doesn't need to pass in data such as the card number or expiration date in the request itself. 
    */
    'customerId'?: string;
    /**
    * Unique identifier for the Customer token used in the transaction. When you include this value in your request, many of the fields that are normally required for an authorization or credit become optional. 
    */
    'id'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "customerId",
            "baseName": "customerId",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsPaymentInformationCustomer.attributeTypeMap;
    }
}

export class Ptsv2paymentsPaymentInformationDirectDebit {
    'mandate'?: Ptsv2paymentsPaymentInformationDirectDebitMandate;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "mandate",
            "baseName": "mandate",
            "type": "Ptsv2paymentsPaymentInformationDirectDebitMandate"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsPaymentInformationDirectDebit.attributeTypeMap;
    }
}

export class Ptsv2paymentsPaymentInformationDirectDebitMandate {
    /**
    * This is the date on which the SEPA DD should be executed. Debit date: the day on which the payer's account is debited. 
    */
    'clearingDate'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "clearingDate",
            "baseName": "clearingDate",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsPaymentInformationDirectDebitMandate.attributeTypeMap;
    }
}

export class Ptsv2paymentsPaymentInformationEWallet {
    /**
    * The ID of the customer, passed in the return_url field by PayPal after customer approval.
    */
    'accountId'?: string;
    /**
    * Payment method for the unit purchase. Possible values: - `UNRESTRICTED (default)—this value is only available if configured by PayPal for the merchant.` - `INSTANT` 
    */
    'fundingSource'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "accountId",
            "baseName": "accountId",
            "type": "string"
        },
        {
            "name": "fundingSource",
            "baseName": "fundingSource",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsPaymentInformationEWallet.attributeTypeMap;
    }
}

export class Ptsv2paymentsPaymentInformationFluidData {
    /**
    * The encoded or encrypted value that a payment solution returns for an authorization request. For details about the valid values for a key, see [Creating an Online Authorization](https://developer.cybersource.com/api/developer-guides/dita-payments/CreatingOnlineAuth.html) 
    */
    'keySerialNumber'?: string;
    /**
    * The identifier for a payment solution, which is sending the encrypted payment data for decryption. Valid values: Samsung Pay: RklEPUNPTU1PTi5TQU1TVU5HLklOQVBQLlBBWU1FTlQ= Note: For other payment solutions, the value may be specific to the terminal or device initiatinf the payment. For example, the descriptor for a Bluefin payment encryption would be a device-generated descriptor. Used by Authorization and Standalone Credits. Required for authorizations and standalone credits.  Card Present processing: Format of the encrypted payment data. The value for Bluefin PCI P2PE is `Ymx1ZWZpbg==`. paymentInformation.fluidData.encoding must be `Base64`. The value for Cybersource P2PE decryption depends on the encoding method used and identified in encoding field. If paymentInformation.fluidData.encoding is `Base64`, the value is: `RklEPUVNVi5QQVlNRU5ULkFQSQ==` If paymentInformation.fluidData.encoding is `HEX`, the value is: `4649443D454D562E5041594D454E542E41504` 
    */
    'descriptor'?: string;
    /**
    * Represents the encrypted payment data BLOB. The entry for this field is dependent on the payment solution used by the merchant. Used by Authorization and Standalone Credits. Required for authorizations and standalone credits that use a Cybersource suppored Point-to-Point encryption method. Card Present processing This field represents the encrypted payment data generated by the payment terminal/device. 
    */
    'value'?: string;
    /**
    * Encoding method used to encrypt the payment data. Valid values: `Base64`, `HEX` If no value is provided, `Base64` is taken as the default value. And the `Base64` descriptor is used for paymentInformation.fluidData.encoding 
    */
    'encoding'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "keySerialNumber",
            "baseName": "keySerialNumber",
            "type": "string"
        },
        {
            "name": "descriptor",
            "baseName": "descriptor",
            "type": "string"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "string"
        },
        {
            "name": "encoding",
            "baseName": "encoding",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsPaymentInformationFluidData.attributeTypeMap;
    }
}

export class Ptsv2paymentsPaymentInformationInstrumentIdentifier {
    /**
    * Unique identifier for the Instrument Identifier token used in the transaction. When you include this value in your request, many of the fields that can be supplied for an authorization or credit become optional. 
    */
    'id'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsPaymentInformationInstrumentIdentifier.attributeTypeMap;
    }
}

export class Ptsv2paymentsPaymentInformationLegacyToken {
    /**
    * Unique identifier for the legacy Secure Storage token used in the transaction. When you include this value in your request, many of the fields that are normally required for an authorization or credit become optional. 
    */
    'id'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsPaymentInformationLegacyToken.attributeTypeMap;
    }
}

export class Ptsv2paymentsPaymentInformationOptions {
    /**
    * Payment option ID name. This is the bank’s swift code.Include the option ID name returned in the Options service response. 
    */
    'id'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsPaymentInformationOptions.attributeTypeMap;
    }
}

export class Ptsv2paymentsPaymentInformationPaymentAccountReference {
    /**
    * A Payment Account Reference number (PAR) is a unique reference value associated with a specific card holder PAN. It identifies the card account, not just a card. PAR is a non-payment identifier that can be associated to PANs and tokens, as defined by EMVCo. PAR allows all participants in the payments chain to have a single, non-sensitive value assigned to a consumer. This value can be used in place of sensitive card holder identification fields, and transmitted across the payments ecosystem to facilitate card holder identification. 
    */
    'id'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsPaymentInformationPaymentAccountReference.attributeTypeMap;
    }
}

export class Ptsv2paymentsPaymentInformationPaymentInstrument {
    /**
    * Unique identifier for the Payment Instrument token used in the transaction. When you include this value in your request, many of the fields that are normally required for an authorization or credit become optional. 
    */
    'id'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsPaymentInformationPaymentInstrument.attributeTypeMap;
    }
}

export class Ptsv2paymentsPaymentInformationPaymentType {
    /**
    * A Payment Type is an agreed means for a payee to receive legal tender from a payer. The way one pays for a commercial financial transaction. Examples: Card, Bank Transfer, Digital, Direct Debit. Possible values: - `CARD` (use this for a PIN debit transaction) - `CHECK` (use this for all eCheck payment transactions - ECP Debit, ECP Follow-on Credit, ECP StandAlone Credit) - `bankTransfer` (use for Online Bank Transafer for methods such as P24, iDeal, Estonia Bank, KCP) - `localCard` (KCP Local card via Altpay) - `carrierBilling` (KCP Carrier Billing via Altpay) 
    */
    'name'?: string;
    /**
    * In case the APM supports multiple modes of initiation (e.g. Alipay via QR Code or Barcode) 
    */
    'subTypeName'?: string;
    'method'?: Ptsv2paymentsPaymentInformationPaymentTypeMethod;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "subTypeName",
            "baseName": "subTypeName",
            "type": "string"
        },
        {
            "name": "method",
            "baseName": "method",
            "type": "Ptsv2paymentsPaymentInformationPaymentTypeMethod"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsPaymentInformationPaymentType.attributeTypeMap;
    }
}

export class Ptsv2paymentsPaymentInformationPaymentTypeMethod {
    /**
    * A Payment Type is enabled through a Method. Examples: Visa, Master Card, ApplePay, iDeal, 7Eleven, alfamart, bofaPayByBank, payToPayByBank, etc  For Japan Payment Processing Valid Values: - 1 Banking Data - 2 Authorization Data  #### Via KCP - `KCP` : Local Card, Bank Transfer and Carrier Billing. - `PAYCO` - `KAKAOPAY` - `NAVERPAY` 
    */
    'name'?: string;
    /**
    * The payment channel that facilitates the transactions. This parameter can be used if the payment channels are listed on the merchant’s site, and the payment channel is known.  Possible Values:  #### Via PPRO - `alfaVa` - `kredivo` - `consumerBarCode` - `merchantQrCode` - `dokuWallet` 
    */
    'type'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsPaymentInformationPaymentTypeMethod.attributeTypeMap;
    }
}

export class Ptsv2paymentsPaymentInformationSepa {
    'directDebit'?: Ptsv2paymentsPaymentInformationSepaDirectDebit;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "directDebit",
            "baseName": "directDebit",
            "type": "Ptsv2paymentsPaymentInformationSepaDirectDebit"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsPaymentInformationSepa.attributeTypeMap;
    }
}

export class Ptsv2paymentsPaymentInformationSepaDirectDebit {
    /**
    * Mandate reference as returned on the first transaction in the sequence 
    */
    'reference'?: string;
    /**
    * Date of the initial transaction, format is YYYY-MM-DD. Date can be taken from the finaltimestamp of the SUCCEEDED notification for the first transaction in the sequence. 
    */
    'signatureDate'?: string;
    /**
    * Valid URL pointing to the SEPA mandate, needs to be accessible by our risk and compliance department. 
    */
    'url'?: string;
    /**
    * Sequence type of the direct debit, defaults to “oneOff”. Valid values: oneOff The direct debit is executed once. first First direct debit in a series of recurring ones. 
    */
    'type'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "reference",
            "baseName": "reference",
            "type": "string"
        },
        {
            "name": "signatureDate",
            "baseName": "signatureDate",
            "type": "string"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsPaymentInformationSepaDirectDebit.attributeTypeMap;
    }
}

export class Ptsv2paymentsPaymentInformationShippingAddress {
    /**
    * Unique identifier for the Customers Shipping Address token used in the transaction. When you include this value in your request, many of the shipping fields that can be supplied for an authorization or credit become optional. 
    */
    'id'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsPaymentInformationShippingAddress.attributeTypeMap;
    }
}

export class Ptsv2paymentsPaymentInformationTokenizedCard {
    /**
    * Customer’s payment network token value. 
    */
    'number'?: string;
    /**
    * One of two possible meanings: - The two-digit month in which a token expires. - The two-digit month in which a card expires. Format: `MM` Possible values: `01` through `12`  **NOTE** The meaning of this field is dependent on the payment processor that is returning the value in an authorization reply. Please see the processor-specific details below.  #### Barclays and Streamline For Maestro (UK Domestic) and Maestro (International) cards on Barclays and Streamline, this must be a valid value (`01` through `12`) but is not required to be a valid expiration date. In other words, an expiration date that is in the past does not cause CyberSource to reject your request. However, an invalid expiration date might cause the issuer to reject your request.  #### Encoded Account Numbers For encoded account numbers (`card_type=039`), if there is no expiration date on the card, use `12`.\\ **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.  #### Samsung Pay and Apple Pay Month in which the token expires. CyberSource includes this field in the reply message when it decrypts the payment blob for the tokenized transaction. 
    */
    'expirationMonth'?: string;
    /**
    * One of two possible meanings: - The four-digit year in which a token expires. - The four-digit year in which a card expires. Format: `YYYY` Possible values: `1900` through `3000` Data type: Non-negative integer  **NOTE** The meaning of this field is dependent on the payment processor that is returning the value in an authorization reply. Please see the processor-specific details below.  #### Barclays and Streamline For Maestro (UK Domestic) and Maestro (International) cards on Barclays and Streamline, this must be a valid value (1900 through 3000) but is not required to be a valid expiration date. In other words, an expiration date that is in the past does not cause CyberSource to reject your request. However, an invalid expiration date might cause the issuer to reject your request.  #### Encoded Account Numbers For encoded account numbers (`card_ type=039`), if there is no expiration date on the card, use `2021`.  #### FDC Nashville Global and FDMS South You can send in 2 digits or 4 digits. When you send in 2 digits, they must be the last 2 digits of the year.  #### Samsung Pay and Apple Pay Year in which the token expires. CyberSource includes this field in the reply message when it decrypts the payment blob for the tokenized transaction.  **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting. 
    */
    'expirationYear'?: string;
    /**
    * Three-digit value that indicates the card type.  **IMPORTANT** It is strongly recommended that you include the card type field in request messages even if it is optional for your processor and card type. Omitting the card type can cause the transaction to be processed with the wrong card type.  Possible values: - `001`: Visa. Use card type value `001` for Visa Electron. - `002`: Mastercard, Eurocard[^1], which is a European regional brand of Mastercard. - `003`: American Express - `004`: Discover - `005`: Diners Club - `006`: Carte Blanche[^1] - `007`: JCB[^1] - `008`: Optima - `009`: GE Private Label - `010`: Beneficial Private Label - `011`: Twinpay Credit Card - `012`: Twinpay Debit Card - `013`: WalMart - `014`: Enroute[^1] - `015`: Lowe's Consumer - `016`: Home Depot Consumer - `017`: MBNA - `018`: Dick's Sportswear - `019`: Casual Corner - `020`: Sears - `021`: JAL[^1] - `023`: Disney Card - `024`: Maestro (UK Domestic)[^1] - `025`: Sam's Club Consumer - `026`: Sam's Club Business - `027`: Nico's - `028`: Paymentech Bill Me Later - `029`: Bebe - `030`: Restoration Hardware - `031`: Delta Online - `032`: Solo - `033`: Visa Electron[^1]. Do not use this value. Use `001` for all Visa card types. - `034`: Dankort[^1] - `035`: Laser - `036`: Cartes Bancaires[^1,4] - `037`: Carta Si[^1] - `038`: Pinless Debit - `039`: Encoded account number[^1] - `040`: UATP[^1] - `041`: HOUSEHOLD - `042`: Maestro (International)[^1] - `043`: GE MONEY - `044`: Korean Cards - `045`: Style Cards - `046`: JCrew - `047`: Payeasecn eWallet - `048`: Payeasecn Bank Transfer - `049`: Meijer - `050`: Hipercard[^2,3] - `051`: Aura - `052`: Redecard - `053`: Orico card - `054`: Elo[^3] - `055`: Capitol One Private Label - `056`: Carnet - `057`: Costco Private Label - `058`: Carnet - `059`: ValueLink - `060`: MADA - `061`: RuPay - `062`: China UnionPay - `063`: Falabella Private Label - `064`: Prompt Card - `065`: Korean Domestic - `066`: Banricompras - `067`: MEEZA - `068`: PayPak - `070`: EFTPOS - `071`: Codensa - `072`: Olimpica - `073`: Colsubsidio - `074`: Tuya - `075`: Sodexo - `076`: Naranja - `077`: Cabal - `078`: DINELCO - `079`: PANAL - `080`: EPM - `081`: Jaywan  [^1]: For this card type, you must include the `paymentInformation.card.type` or `paymentInformation.tokenizedCard.type` field in your request for an authorization or a stand-alone credit. [^2]: For this card type on Cielo 3.0, you must include the `paymentInformation.card.type` or `paymentInformation.tokenizedCard.type` field in a request for an authorization or a stand-alone credit. This card type is not supported on Cielo 1.5. [^3]: For this card type on Getnet and Rede, you must include the `paymentInformation.card.type` or `paymentInformation.tokenizedCard.type` field in a request for an authorization or a stand-alone credit. [^4]: For this card type, you must include the `paymentInformation.card.type` in your request for any payer authentication services.  #### Used by **Authorization** Required for Carte Blanche and JCB. Optional for all other card types.  #### Card Present reply This field is included in the reply message when the client software that is installed on the POS terminal uses the token management service (TMS) to retrieve tokenized payment details. You must contact customer support to have your account enabled to receive these fields in the credit reply message.  Returned by the Credit service.  This reply field is only supported by the following processors: - American Express Direct - Credit Mutuel-CIC - FDC Nashville Global - OmniPay Direct - SIX  #### Google Pay transactions For PAN-based Google Pay transactions, this field is returned in the API response.  #### GPX This field only supports transactions from the following card types: - Visa - Mastercard - AMEX - Discover - Diners - JCB - Union Pay International 
    */
    'type'?: string;
    /**
    * This field contains token information.
    */
    'cryptogram'?: string;
    /**
    * Value that identifies your business and indicates that the cardholder’s account number is tokenized. This value is assigned by the token service provider and is unique within the token service provider’s database.  **Note** This field is supported only for **CyberSource through VisaNet** and **FDC Nashville Global**.  #### PIN debit Optional field for PIN debit credit or PIN debit purchase transactions that use payment network tokens; otherwise, not used. 
    */
    'requestorId'?: string;
    /**
    * Type of transaction that provided the token data. This value does not specify the token service provider; it specifies the entity that provided you with information about the token.  Possible value: - `2`: Near-field communication (NFC) transaction. The customer’s mobile device provided the token data for a contactless EMV transaction. For recurring transactions, use this value if the original transaction was a contactless EMV transaction.  #### Visa Platform Connect - `1`: For Rupay and In App tokenization. Example: InApp apple pay. - `3`: Card/Credential On File Tokenization.  **NOTE** No CyberSource through VisaNet acquirers support EMV at this time.  Required field for PIN debit credit or PIN debit purchase transactions that use payment network tokens; otherwise, not used.  #### Rupay - `3`: Card/Credential On File Tokenization. - `4`: Tokenizined Transaction. Should be used for Guest Checkout transactions with token. 
    */
    'transactionType'?: string;
    /**
    * Confidence level of the tokenization. This value is assigned by the token service provider.  **Note** This field is supported only for **CyberSource through VisaNet** and **FDC Nashville Global**.  Returned by PIN debit credit or PIN debit purchase.  **Note** Merchants supported for **CyberSource through VisaNet**_/_**Visa Platform Connect** are advised not to use this field. 
    */
    'assuranceLevel'?: string;
    /**
    * Type of technology used in the device to store token data. Possible values:  - `001`: Secure Element (SE). Smart card or memory with restricted access and encryption to prevent data tampering. For storing payment    credentials, a SE is tested against a set of requirements defined by the payment networks.     **Note** This field is supported only for _FDC Compass_.  - 002: Host Card Emulation (HCE). Emulation of a smart card by using software to create a virtual and exact representation of the card. Sensitive data is stored in a database that is hosted in the cloud. For storing payment credentials, a database must meet very stringent security requirements that exceed PCI DSS.  **Note** This field is supported only for _FDC Compass_. 
    */
    'storageMethod'?: string;
    /**
    * Card Verification Number (CVN).  #### Ingenico ePayments Do not include this field when **commerceIndicator=recurring**. **Note** Ingenico ePayments was previously called _Global Collect_. 
    */
    'securityCode'?: string;
    /**
    * Indicates whether a CVN code was sent. Possible values:   - `0` (default): CVN service not requested. This default value is used when you do not include      `securityCode` field in the request.  - `1` (default): CVN service requested and supported. This default value is used when you include      `securityCode` field in the request.  - `2`: CVN on credit card is illegible.  - `9`: CVN was not imprinted on credit card.  #### FDMS Nashville Required for American Express cards; otherwise, optional.  #### TSYS Acquiring Solutions Optional if `pointOfSaleInformation.entryMode=keyed`; otherwise, not used.  #### All other processors Optional. 
    */
    'securityCodeIndicator'?: string;
    /**
    * Confidence level of the tokenization. This value is assigned by the token service provider.  **Note** This field is supported only for **Visa Platform Connect** 
    */
    'assuranceMethod'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "number",
            "baseName": "number",
            "type": "string"
        },
        {
            "name": "expirationMonth",
            "baseName": "expirationMonth",
            "type": "string"
        },
        {
            "name": "expirationYear",
            "baseName": "expirationYear",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "cryptogram",
            "baseName": "cryptogram",
            "type": "string"
        },
        {
            "name": "requestorId",
            "baseName": "requestorId",
            "type": "string"
        },
        {
            "name": "transactionType",
            "baseName": "transactionType",
            "type": "string"
        },
        {
            "name": "assuranceLevel",
            "baseName": "assuranceLevel",
            "type": "string"
        },
        {
            "name": "storageMethod",
            "baseName": "storageMethod",
            "type": "string"
        },
        {
            "name": "securityCode",
            "baseName": "securityCode",
            "type": "string"
        },
        {
            "name": "securityCodeIndicator",
            "baseName": "securityCodeIndicator",
            "type": "string"
        },
        {
            "name": "assuranceMethod",
            "baseName": "assuranceMethod",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsPaymentInformationTokenizedCard.attributeTypeMap;
    }
}

export class Ptsv2paymentsPaymentInformationTokenizedPaymentMethod {
    /**
    * The PayPal-generated ID for the token. 
    */
    'id'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsPaymentInformationTokenizedPaymentMethod.attributeTypeMap;
    }
}

export class Ptsv2paymentsPointOfSaleInformation {
    /**
    * Identifier for the terminal at your retail location. You can define this value yourself, but consult the processor for requirements.  #### CyberSource through VisaNet A list of all possible values is stored in your CyberSource account. If terminal ID validation is enabled for your CyberSource account, the value you send for this field is validated against the list each time you include the field in a request. To enable or disable terminal ID validation, contact CyberSource Customer Support.  When you do not include this field in a request, CyberSource uses the default value that is defined in your CyberSource account.  #### FDC Nashville Global To have your account configured to support this field, contact CyberSource Customer Support. This value must be a value that FDC Nashville Global issued to you.  #### For Payouts This field is applicable for CyberSource through VisaNet.  #### GPX Identifier for the terminal at your retail location. A list of all possible values is stored in your account. If terminal ID validation is enabled for your account, the value you send for this field is validated against the list each time you include the field in a request. To enable or disable terminal ID validation, contact customer support.  When you do not include this field in a request, the default value that is defined in your account is used.  Optional for authorizations.  #### Used by **Authorization** Optional for the following processors. When you do not include this field in a request, the default value that is defined in your account is used.   - American Express Direct   - Credit Mutuel-CIC   - FDC Nashville Global   - SIX - Chase Paymentech Solutions: Optional field. If you include this field in your request, you must also include `pointOfSaleInformation.catLevel`. - FDMS Nashville: The default value that is defined in your account is used. - GPX - OmniPay Direct: Optional field.  For the following processors, this field is not used. - GPN - JCN Gateway - RBS WorldPay Atlanta - TSYS Acquiring Solutions - Worldpay VAP  #### Card Present reply Terminal identifier assigned by the acquirer. This value must be printed on the receipt. 
    */
    'terminalId'?: string;
    /**
    * Terminal serial number assigned by the hardware manufacturer. This value is provided by the client software that is installed on the POS terminal.  This value is not forwarded to the processor. Instead, the value is forwarded to the reporting functionality.  #### Used by **Authorization and Credit** Optional. This field is supported only by client software that is installed on your POS terminals for the following processors: - American Express Direct - Credit Mutuel-CIC - FDC Nashville Global - OmniPay Direct - SIX 
    */
    'terminalSerialNumber'?: string;
    /**
    * Method that was used to verify the cardholder's identity. Possible values:    - `0`: No verification   - `1`: Signature   - `2`: PIN   - `3`: Cardholder device CVM   - `4`: Biometric   - `5`: OTP 
    */
    'cardholderVerificationMethodUsed'?: number;
    /**
    * Identifier for an alternate terminal at your retail location. You define the value for this field.  This field is supported only for MasterCard transactions on FDC Nashville Global. Otherwise, this field is not used by all other processors. Use the `terminalId` field to identify the main terminal at your retail location. If your retail location has multiple terminals, use this `laneNumber` field to identify the terminal used for the transaction.  This field is a pass-through, which means that the value is not checked or modified in any way before sending it to the processor.  Optional field.  #### Card present reply messaging Identifier for an alternate terminal at your retail location. You defined the value for this field in the request message. This value must be printed on the receipt.  This field is supported only for MasterCard transactions on FDC Nashville Global. 
    */
    'laneNumber'?: string;
    /**
    * Type of cardholder-activated terminal. Possible values:   - 1: Automated dispensing machine  - 2: Self-service terminal  - 3: Limited amount terminal  - 4: In-flight commerce (IFC) terminal  - 5: Radio frequency device  - 6: Mobile acceptance terminal  - 7: Electronic cash register  - 8: E-commerce device at your location  - 9: Terminal or cash register that uses a dialup connection to connect to the transaction processing network  - 10: Card Activated Fuel Dispenser  - 11: Travel ticket vending machine #### Chase Paymentech Solutions Only values 1, 2, and 3 are supported.  Required if `pointOfSaleInformation.terminalID` is included in the request; otherwise, optional.  #### CyberSource through VisaNet Values 1 through 6 are supported on CyberSource through VisaNet, but some acquirers do not support all six values.  Optional field.  #### FDC Nashville Global Only values 7, 8, and 9 are supported.  Optional field for EMV transactions; otherwise, not used.  #### GPN Only values 6, 7, 8, and 9 are supported.  Required field.  #### JCN Gateway Only values 6, 7, 8, and 9 are supported.  Required field.  #### TSYS Acquiring Solutions Only value 6 is supported.  Required for transactions from mobile devices; otherwise, not used.  #### All other processors Not used.  Nonnegative integer. 
    */
    'catLevel'?: number;
    /**
    * Method of entering payment card information into the POS terminal. Possible values:   - `contact`: Read from direct contact with chip card.  - `contactless`: Read from a contactless interface using chip data.  - `keyed`: Manually keyed into POS terminal. This value is not supported on OmniPay Direct.  - `msd`: Read from a contactless interface using magnetic stripe data (MSD). This value is not supported on OmniPay Direct.  - `swiped`: Read from credit card magnetic stripe.  The `contact`, `contactless`, and `msd` values are supported only for EMV transactions.  #### Used by **Authorization** Required field.  #### Card Present Card present information about EMV applies only to credit card processing and PIN debit processing. All other card present information applies only to credit card processing.  #### PIN debit Required for a PIN debit purchase and a PIN debit credit request. 
    */
    'entryMode'?: string;
    /**
    * POS terminal’s capability. Possible values:   - `1`: Terminal has a magnetic stripe reader only.  - `2`: Terminal has a magnetic stripe reader and manual entry capability.  - `3`: Terminal has manual entry capability only.  - `4`: Terminal can read chip cards.  - `5`: Terminal can read contactless chip cards; cannot use contact to read chip cards.  For an EMV transaction, the value of this field must be `4` or `5`.  #### PIN debit Required for PIN debit purchase and PIN debit credit request.  #### Used by **Authorization** Required for the following processors: - American Express Direct - Chase Paymentech Solutions - Credit Mutuel-CIC - FDC Nashville Global - FDMS Nashville - OmniPay Direct - SIX - Worldpay VAP  Optional for the following processors: - CyberSource through VisaNet - GPN - GPX - JCN Gateway - RBS WorldPay Atlanta - TSYS Acquiring Solutions 
    */
    'terminalCapability'?: number;
    /**
    * Operating environment.  Possible values for all card types except Mastercard: - `0`: No terminal used or unknown environment. - `1`: On merchant premises, attended. - `2`: On merchant premises, unattended. Examples: oil, kiosks, self-checkout, mobile telephone, personal digital assistant (PDA). - `3`: Off merchant premises, attended. Examples: portable POS devices at trade shows, at service calls, or in taxis. - `4`: Off merchant premises, unattended. Examples: vending machines, home computer, mobile telephone, PDA. - `5`: On premises of cardholder, unattended. - `9`: Unknown delivery mode. - `S`: Electronic delivery of product. Examples: music, software, or eTickets that are downloaded over the internet. - `T`: Physical delivery of product. Examples: music or software that is delivered by mail or by a courier.  #### Possible values for Mastercard: - `2`: On merchant premises, unattended, or cardholder terminal. Examples: oil, kiosks, self-checkout, home computer, mobile telephone, personal digital assistant (PDA). Cardholder terminal is supported only for Mastercard transactions on CyberSource through VisaNet. - `4`: Off merchant premises, unattended, or cardholder terminal. Examples: vending machines, home computer, mobile telephone, PDA. Cardholder terminal is supported only for Mastercard transactions on CyberSource through VisaNet.  This field is supported only for American Express Direct and CyberSource through VisaNet. 
    */
    'operatingEnvironment'?: string;
    'emv'?: Ptsv2paymentsPointOfSaleInformationEmv;
    /**
    * Point-of-sale details for the transaction. This value is returned only for **American Express Direct**. CyberSource generates this value, which consists of a series of codes that identify terminal capability, security data, and specific conditions present at the time the transaction occurred. To comply with the CAPN requirements, this value must be included in all subsequent follow-on requests, such as captures and follow-on credits.  When you perform authorizations, captures, and credits through CyberSource, CyberSource passes this value from the authorization service to the subsequent services for you. However, when you perform authorizations through CyberSource and perform subsequent services through other financial institutions, you must ensure that your requests for captures and credits include this value. 
    */
    'amexCapnData'?: string;
    /**
    * Card’s track 1 and 2 data. For all processors except FDMS Nashville, this value consists of one of the following:   - Track 1 data  - Track 2 data  - Data for both tracks 1 and 2  For FDMS Nashville, this value consists of one of the following:  - Track 1 data  - Data for both tracks 1 and 2  Example: %B4111111111111111^SMITH/JOHN ^1612101976110000868000000?;4111111111111111=16121019761186800000?  #### Used by **Authorization** Required for Chase Paymentech Solutions, Credit Mutuel-CIC, CyberSource through VisaNet, FDC Nashville Global, JCN Gateway, OmniPay Direct, and SIX if `pointOfSaleInformation.entryMode` is equal to one of these values: - `contact` - `contactless` - `msd` - `swiped` Otherwise, this field not used.  Required for all other processors if `pointOfSaleInformation.entryMode=swiped`; otherwise, this field is not used.  #### GPX This field only supports transactions from the following card types: - Visa - Mastercard - AMEX - Discover - Diners - JCB - Union Pay International  #### PIN debit Track 2 data from the debit card. The sentinels are required. Required field for a PIN debit purchase and a PIN debit credit. 
    */
    'trackData'?: string;
    /**
    * When connectivity is unavailable, the client software that is installed on the POS terminal can store a transaction in its memory and send it for authorization when connectivity is restored. This value is provided by the client software that is installed on the POS terminal.  This value is not forwarded to the processor. Instead, the value is forwarded to the reporting functionality.  Possible values: - `Y`: Transaction was stored and then forwarded. - `N` (default): Transaction was not stored and then forwarded.  For authorizations and credits, this field is supported only on these processors: - American Express Direct - FDC Nashville Global - OmniPay Direct - SIX  Optional field. 
    */
    'storeAndForwardIndicator'?: string;
    /**
    * Complete list of cardholder verification methods (CVMs) supported by the terminal. Optional field. Possible values: - `PIN`: For terminals with a PIN Pad - `Signature`: For terminals capable of receiving a signature - `pinOnGlass`: For terminals where PIN is entered on a glass-based capture mechanism  **EXAMPLE**: [\"PIN\",\"Signature\"]; [\"pinOnGlass\",\"Signature\"] 
    */
    'cardholderVerificationMethod'?: Array<string>;
    /**
    * Indicates the type of terminal.   Possible values: - `AFD`: Automated Fuel Dispenser 
    */
    'terminalCategory'?: string;
    /**
    * Complete list of card input methods supported by the terminal.  Possible values: - `Keyed`: Terminal can accept card data that is entered manually. - `Swiped`: Terminal can accept card data from a magnetic stripe reader. - `Contact`: Terminal can accept card data in EMV contact mode (\"dipping a card\"). - `Contactless`: Terminal can accept card data in EMV contactless mode (\"tapping a card\"). - `BarCode`: Terminal can read bar codes. - `QRcode`: Terminal can read or scan QR codes. - `OCR`: Terminal can perform optical character recognition (OCT) on the card.  **EXAMPLE**: [\"Keyed\",\"Swiped\",\"Contact\",\"Contactless\"]  #### Used by **Authorization and Credit** Optional. This field is supported only by client software that is installed on your POS terminals for the following processors: - American Express Direct - Credit Mutuel-CIC - FDC Nashville Global - OmniPay Direct - SIX 
    */
    'terminalInputCapability'?: Array<string>;
    /**
    * Indicates whether the terminal can capture the card.  Possible values: - `1`: Terminal can capture card. - `0`: Terminal cannot capture card.  For authorizations and credits, this field is supported only by these processors: - American Express Direct - Credit Mutuel-CIC - OmniPay Direct  Optional field. 
    */
    'terminalCardCaptureCapability'?: string;
    /**
    * Indicates whether the terminal can print or display messages.  Possible values: - 1: Neither - 2: Print only - 3: Display only - 4: Print and display - 5: Merchant terminal supports purchase only approvals  This field is supported for authorizations and credits only on the following processors: - American Express Direct - Credit Mutuel-CIC - FDC Nashville Global - OmniPay Direct - SIX - VisaNet  Optional field. 
    */
    'terminalOutputCapability'?: string;
    /**
    * Maximum PIN length that the terminal can capture.  Possible values: -  0: No PIN capture capability -  1: PIN capture capability unknown -  2: PIN Pad down -  4: Four characters -  5: Five characters -  6: Six characters -  7: Seven characters -  8: Eight characters -  9: Nine characters - 10: Ten characters - 11: Eleven characters - 12: Twelve characters  This field is supported for authorizations and credits only on the following processors: - American Express Direct - Credit Mutuel-CIC - OmniPay Direct - SIX - Visa Platform Connect  Required field for authorization or credit of PIN transactions. 
    */
    'terminalPinCapability'?: number;
    /**
    * This field will contain the type of Pin Pad the terminal has.  Possible values: -   PCI-SPoC: Where the pin is being put on screen -   PCI-PTS: Where the pin is being put on actual hardware pin pad 
    */
    'pinEntrySolution'?: string;
    /**
    * Value created by the client software that uniquely identifies the POS device. This value is provided by the client software that is installed on the POS terminal.  CyberSource does not forward this value to the processor. Instead, the value is forwarded to the CyberSource reporting functionality.  This field is supported only on American Express Direct, FDC Nashville Global, and SIX. 
    */
    'deviceId'?: string;
    /**
    * Format that is used to encode the PIN block. This value is provided by the client software that is installed on the POS terminal.  Possible values: - `0`: ISO 9564 format 0 - `1`: ISO 9564 format 1 - `2`: ISO 9564 format 2 - `3`: ISO 9564 format 3  #### Used by **Authorization, PIN Debit** - Required when the cardholder enters a PIN and the card cannot verify the PIN, which means that the issuer must verify the PIN. - Required for PIN debit credit or PIN debit purchase.  For authorizations, this field is supported only on these processors: - American Express Direct - Credit Mutuel-CIC - FDC Nashville Global - OmniPay Direct - SIX  This field is also supported by processors that support chip and online PIN transactions. The following table lists the EMV Cards and Cardholder Verification Methods (CVMs) that these processors support:  | Processor | Chip and Offline PIN | Chip and Online PIN | Chip and Signature | | --- | --- | --- | --- | | American Express Direct | Yes | Yes | Yes | | Chase Paymentech Solutions | No | No | Yes | | Credit Mutuel-CIC | Yes | Yes | Yes | | CyberSource through VisaNet | Yes | No | Yes | | FDC Nashville Global | Yes | Yes | Yes | | GPN | No | No | Yes | | OmniPay Direct | Yes | No | Yes | | SIX | Yes | Yes | Yes |  #### GPX For chip and online PIN transactions for authorization, GPX supports the following EMV Cards and Cardholder Verification Methods (CVMs): - Chip and Offline PIN - Chip and Signature  For PIN Debit Purchase and Credit Service transactions, GPX supports the following EMV Cards and Cardholder Verification Methods (CVMs): - Chip and Online PIN 
    */
    'pinBlockEncodingFormat'?: number;
    /**
    * Encrypted PIN.  This value is provided by the client software that is installed on the POS terminal.  #### Used by **Authorization, PIN Debit** Required when the cardholder enters a PIN and the card cannot verify the PIN, which means that the issuer must verify the PIN. Required for PIN debit credit or PIN debit purchase. Required for online PIN transactions.  For authorizations, this field is supported only on these processors: - American Express Direct - Credit Mutuel-CIC - FDC Nashville Global - OmniPay Direct - SIX  This field is also used by processors that support chip and online PIN transactions. The following table lists the EMV Cards and Cardholder Verification Methods (CVMs) that these processors support:  | Processor | Chip and Offline PIN | Chip and Online PIN | Chip and Signature | | --- | --- | --- | --- | | American Express Direct | Yes | Yes | Yes | | Chase Paymentech Solutions | No | No | Yes | | Credit Mutuel-CIC | Yes | Yes | Yes | | CyberSource through VisaNet | Yes | No | Yes | | FDC Nashville Global | Yes | Yes | Yes | | GPN | No | No | Yes | | OmniPay Direct | Yes | No | Yes | | SIX | Yes | Yes | Yes | 
    */
    'encryptedPin'?: string;
    /**
    * Combination of the device's unique identifier and a transaction counter that is used in the process of decrypting the encrypted PIN. The entity that injected the PIN encryption keys into the terminal decrypts the encrypted PIN and creates this value.  For all terminals that are using derived unique key per transaction (DUKPT) encryption, this is generated as a single number within the terminal.  #### Used by **Authorization, PIN Debit** - Required when the cardholder enters a PIN and the card cannot verify the PIN, which means that the issuer must verify the PIN. - Required for PIN debit credit or PIN debit purchase. - Required for online PIN transactions  For authorizations, this field is supported only on these processors: - American Express Direct - Credit Mutuel-CIC - FDC Nashville Global - OmniPay Direct - SIX  This field is also used by processors that support chip and online PIN transactions. The following table lists the EMV Cards and Cardholder Verification Methods (CVMs) that these processors support:  | Processor | Chip and Offline PIN | Chip and Online PIN | Chip and Signature | | --- | --- | --- | --- | | American Express Direct | Yes | Yes | Yes | | Chase Paymentech Solutions | No | No | Yes | | Credit Mutuel-CIC | Yes | Yes | Yes | | CyberSource through VisaNet | Yes | No | Yes | | FDC Nashville Global | Yes | Yes | Yes | | GPN | No | No | Yes | | OmniPay Direct | Yes | No | Yes | | SIX | Yes | Yes | Yes | 
    */
    'encryptedKeySerialNumber'?: string;
    /**
    * Version of the software installed on the POS terminal. This value is provided by the client software that is installed on the POS terminal.  CyberSource does not forward this value to the processor. Instead, the value is forwarded to the CyberSource reporting functionality.  This field is supported only on American Express Direct, FDC Nashville Global, and SIX.  For authorizations and credits, this field is supported only on these processors: - American Express Direct - Credit Mutuel-CIC - FDC Nashville Global - OmniPay Direct - SIX 
    */
    'partnerSdkVersion'?: string;
    /**
    * This 32 byte length-maximum EBCDIC-K value is used to identify which chip application was performed between the terminal and the chip product. The included values are the Application Identifier (AID) and the Dedicated File (DF) name. It is available to early- or full-option VSDC issuers. Only single byte Katakana characters that can map to the EBCDIC-K table expected in the name. 
    */
    'emvApplicationIdentifierAndDedicatedFileName'?: string;
    /**
    * Flag that indicates whether the terminal is compliant with standards mandated by the Reserve Bank of India for card-present domestic transactions in India.  Format: - First character indicates whether the terminal supports terminal line encryption (TLE). Possible values:   - 1: Not certified   - 2: Certified - Second character indicates whether the terminal supports Unique Key Per Transaction (UKPT) and Derived Unique Key Per Transaction (DUKPT). Possible values:   - 1: Not certified   - 2: Certified  **Example** `21` indicates that the terminal supports TLE but does not support UKPT/DUKPT.  You and the terminal vendors are responsible for terminal certification. If you have questions, contact your acquirer.  This field is supported only for Mastercard transactions on CyberSource through VisaNet.  **Note** On CyberSource through VisaNet, the value for this field corresponds to the following data in the TC 33 capture file: - Record: CP01 TCR6 - Position: 92-93 - Field: Mastercard Terminal Compliance Indicator  The TC 33 Capture file contains information about the purchases and refunds that a merchant submits to CyberSource. CyberSource through VisaNet creates the TC 33 Capture file at the end of the day and sends it to the merchant’s acquirer, who uses this information to facilitate end-of-day clearing processing with payment networks.  #### Used by **Authorization** Required for card-present transactions in India. Otherwise, not used. 
    */
    'terminalCompliance'?: string;
    /**
    * Type of mPOS device. Possible values: - 0: Dongle - 1: Phone or tablet  This optional field is supported only for Mastercard transactions on CyberSource through VisaNet.  The value for this field corresponds to the following data in the TC 33 capture file: - Record: CP01 TCR6 - Position: 141 - Field: Mastercard mPOS Transaction  The TC 33 Capture file contains information about the purchases and refunds that a merchant submits to CyberSource. CyberSource through VisaNet creates the TC 33 Capture file at the end of the day and sends it to the merchant’s acquirer, who uses this information to facilitate end-of-day clearing processing with payment networks. 
    */
    'isDedicatedHardwareTerminal'?: string;
    /**
    * This is the model name of the reader which is used to accept the payment. Possible values:  - E3555  - P400  - A920 
    */
    'terminalModel'?: string;
    /**
    * This is the manufacturer name of the reader which is used to accept the payment. Possible values:  - PAX  - Verifone  - Ingenico 
    */
    'terminalMake'?: string;
    /**
    * #### Visa Platform Connect Mastercard service code that is included in the track data.  This field is supported only for Mastercard on Visa Platform Connect.   You can extract the service code from the track data and provide it in this API field.   When not provided it will be extracted from:   - Track2Data for MSR transactions   - EMV tag 5F30 for EMV transactions  To enable this feature please call support. 
    */
    'serviceCode'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "terminalId",
            "baseName": "terminalId",
            "type": "string"
        },
        {
            "name": "terminalSerialNumber",
            "baseName": "terminalSerialNumber",
            "type": "string"
        },
        {
            "name": "cardholderVerificationMethodUsed",
            "baseName": "cardholderVerificationMethodUsed",
            "type": "number"
        },
        {
            "name": "laneNumber",
            "baseName": "laneNumber",
            "type": "string"
        },
        {
            "name": "catLevel",
            "baseName": "catLevel",
            "type": "number"
        },
        {
            "name": "entryMode",
            "baseName": "entryMode",
            "type": "string"
        },
        {
            "name": "terminalCapability",
            "baseName": "terminalCapability",
            "type": "number"
        },
        {
            "name": "operatingEnvironment",
            "baseName": "operatingEnvironment",
            "type": "string"
        },
        {
            "name": "emv",
            "baseName": "emv",
            "type": "Ptsv2paymentsPointOfSaleInformationEmv"
        },
        {
            "name": "amexCapnData",
            "baseName": "amexCapnData",
            "type": "string"
        },
        {
            "name": "trackData",
            "baseName": "trackData",
            "type": "string"
        },
        {
            "name": "storeAndForwardIndicator",
            "baseName": "storeAndForwardIndicator",
            "type": "string"
        },
        {
            "name": "cardholderVerificationMethod",
            "baseName": "cardholderVerificationMethod",
            "type": "Array<string>"
        },
        {
            "name": "terminalCategory",
            "baseName": "terminalCategory",
            "type": "string"
        },
        {
            "name": "terminalInputCapability",
            "baseName": "terminalInputCapability",
            "type": "Array<string>"
        },
        {
            "name": "terminalCardCaptureCapability",
            "baseName": "terminalCardCaptureCapability",
            "type": "string"
        },
        {
            "name": "terminalOutputCapability",
            "baseName": "terminalOutputCapability",
            "type": "string"
        },
        {
            "name": "terminalPinCapability",
            "baseName": "terminalPinCapability",
            "type": "number"
        },
        {
            "name": "pinEntrySolution",
            "baseName": "pinEntrySolution",
            "type": "string"
        },
        {
            "name": "deviceId",
            "baseName": "deviceId",
            "type": "string"
        },
        {
            "name": "pinBlockEncodingFormat",
            "baseName": "pinBlockEncodingFormat",
            "type": "number"
        },
        {
            "name": "encryptedPin",
            "baseName": "encryptedPin",
            "type": "string"
        },
        {
            "name": "encryptedKeySerialNumber",
            "baseName": "encryptedKeySerialNumber",
            "type": "string"
        },
        {
            "name": "partnerSdkVersion",
            "baseName": "partnerSdkVersion",
            "type": "string"
        },
        {
            "name": "emvApplicationIdentifierAndDedicatedFileName",
            "baseName": "emvApplicationIdentifierAndDedicatedFileName",
            "type": "string"
        },
        {
            "name": "terminalCompliance",
            "baseName": "terminalCompliance",
            "type": "string"
        },
        {
            "name": "isDedicatedHardwareTerminal",
            "baseName": "isDedicatedHardwareTerminal",
            "type": "string"
        },
        {
            "name": "terminalModel",
            "baseName": "terminalModel",
            "type": "string"
        },
        {
            "name": "terminalMake",
            "baseName": "terminalMake",
            "type": "string"
        },
        {
            "name": "serviceCode",
            "baseName": "serviceCode",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsPointOfSaleInformation.attributeTypeMap;
    }
}

export class Ptsv2paymentsPointOfSaleInformationEmv {
    /**
    * EMV data that is transmitted from the chip card to the issuer, and from the issuer to the chip card. The EMV data is in the tag-length-value format and includes chip card tags, terminal tags, and transaction detail tags.  For information about the individual tags, see the “Application Specification” section in the EMV 4.3 Specifications: http://emvco.com  **Note** Card present information about EMV applies only to credit card processing and PIN debit processing. All other card present information applies only to credit card processing. PIN debit processing is available only on FDC Nashville Global.  **Important** The following tags contain sensitive information and **must not** be included in this field:   - `56`: Track 1 equivalent data  - `57`: Track 2 equivalent data  - `5A`: Application PAN  - `5F20`: Cardholder name  - `5F24`: Application expiration date (This sensitivity has been relaxed for Credit Mutuel-CIC, American Express Direct, FDC Nashville Global, First Data Merchant Solutions, and SIX)  - `99`: Transaction PIN  - `9F0B`: Cardholder name (extended)  - `9F1F`: Track 1 discretionary data  - `9F20`: Track 2 discretionary data  For captures, this field is required for contact EMV transactions. Otherwise, it is optional.  For credits, this field is required for contact EMV stand-alone credits and contactless EMV stand-alone credits. Otherwise, it is optional.  **Important** For contact EMV captures, contact EMV stand-alone credits, and contactless EMV stand-alone credits, you must include the following tags in this field. For all other types of EMV transactions, the following tags are optional.   - `95`: Terminal verification results  - `9F10`: Issuer application data  - `9F26`: Application cryptogram   #### CyberSource through VisaNet - In Japan: 199 bytes - In other countries: String (252)  For Mastercard Transactions, Optionally Tag 9F60 (Authenticated Application Data) and  Tag 96 (Kernel Identifier - Terminal) can be included in the Field.  #### GPX This field only supports transactions from the following card types: - Visa - Mastercard - AMEX - Discover - Diners - JCB - Union Pay International  #### JCN Gateway The following tags must be included: - `4F`: Application identifier - `84`: Dedicated file name  Data length: 199 bytes  #### All other processors: String (999)  #### Used by Authorization: Optional Authorization Reversal: Optional Credit: Optional PIN Debit processing (purchase, credit and reversal): Optional 
    */
    'tags'?: string;
    /**
    * Method that was used to verify the cardholder's identity.  Possible values:  - `0`: No verification  - `1`: Signature  This field is supported only on **American Express Direct**. 
    */
    'cardholderVerificationMethodUsed'?: number;
    /**
    * Number assigned to a specific card when two or more cards are associated with the same primary account number.  This value enables issuers to distinguish among multiple cards that are linked to the same account.  This value can also act as a tracking tool when reissuing cards.   When this value is available, it is provided by the chip reader.   When the chip reader does not provide this value, do not include this field in your request.  When sequence number is not provided via this API field, the value is extracted from EMV tag 5F34 for Visa and Mastercard transactions. To enable this feature please call support.  **Note** Card present information about EMV applies only to credit card processing and PIN debit processing.  All other card present information applies only to credit card processing.   PIN debit processing is available only on CyberSource through VisaNet and FDC Nashville Global.  #### Used by Authorization: Optional PIN Debit processing: Optional  #### GPX  This field only supports transactions from the following card types: - Visa - Mastercard - AMEX - Discover - Diners - JCB - Union Pay International 
    */
    'cardSequenceNumber'?: string;
    /**
    * Indicates whether a fallback method was used to enter credit card information into the POS terminal. When a technical problem prevents a successful exchange of information between a chip card and a chip-capable terminal:   1. Swipe the card or key the credit card information into the POS terminal.  2. Use the pointOfSaleInformation.entryMode field to indicate whether the information was swiped or keyed.   Possible values: - `true`: Fallback method was used. - `false` (default): Fallback method was not used.  This field is supported only on American Express Direct, Chase Paymentech Solutions, CyberSource through VisaNet, FDC Nashville Global, GPN, JCN Gateway, OmniPay Direct, and SIX. 
    */
    'fallback'?: boolean;
    /**
    * Reason for the EMV fallback transaction. An EMV fallback transaction occurs when an EMV transaction fails for one of these reasons:   - Technical failure: the EMV terminal or EMV card cannot read and process chip data.  - Empty candidate list failure: the EMV terminal does not have any applications in common with the EMV card.    EMV terminals are coded to determine whether the terminal and EMV card have any applications in common.    EMV terminals provide this information to you.  Possible values:   - `1`: Transaction was initiated with information from a magnetic stripe, and the previous transaction at the     EMV terminal either used information from a successful chip read or it was not a chip transaction.  - `2`: Transaction was initiated with information from a magnetic stripe, and the previous transaction at the     EMV terminal was an EMV fallback transaction because the attempted chip read was unsuccessful.  This field is supported only on **GPN** and **JCN Gateway**. **NOTE**: This field is required when an EMV transaction fails for a technical reason. Do not include this field when the EMV terminal does not have any applications in common with the EMV card. 
    */
    'fallbackCondition'?: number;
    /**
    * #### Visa Platform Connect Value “true” indicates this transaction is intentionally duplicated . The field contains value “true” which indicates that merchant has intentionally duplicated single tap transaction. Merchant is intentionally sending a duplicate auth request for a single tap txn because the issuer requested a PIN. 
    */
    'isRepeat'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "tags",
            "baseName": "tags",
            "type": "string"
        },
        {
            "name": "cardholderVerificationMethodUsed",
            "baseName": "cardholderVerificationMethodUsed",
            "type": "number"
        },
        {
            "name": "cardSequenceNumber",
            "baseName": "cardSequenceNumber",
            "type": "string"
        },
        {
            "name": "fallback",
            "baseName": "fallback",
            "type": "boolean"
        },
        {
            "name": "fallbackCondition",
            "baseName": "fallbackCondition",
            "type": "number"
        },
        {
            "name": "isRepeat",
            "baseName": "isRepeat",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsPointOfSaleInformationEmv.attributeTypeMap;
    }
}

export class Ptsv2paymentsProcessingInformation {
    /**
    * Array of actions (one or more) to be included in the payment to invoke bundled services along with payment.  Possible values are one or more of follows:   - `DECISION_SKIP`: Use this when you want to skip Decision Manager service(s).   - `TOKEN_CREATE`: Use this when you want to create a token from the card/bank data in your payment request.   - `CONSUMER_AUTHENTICATION`: Use this when you want to check if a card is enrolled in Payer Authentication along with your payment request.   - `VALIDATE_CONSUMER_AUTHENTICATION`: Use this after you acquire a Payer Authentication result that needs to be included for your payment request.    - `AP_INITIATE`: Use this when Alternative Payment Initiate service is requested.   - `WATCHLIST_SCREENING` : Use this when you want to call Watchlist Screening service.   - `AP_SALE` : Use this when Alternative Payment Sale service is requested.    - `AP_AUTH` : Use this when Alternative Payment Authorize service is requested.   - `AP_REAUTH` : Use this when Alternative Payment Reauthorize service is requested. 
    */
    'actionList'?: Array<string>;
    /**
    * Indicates whether to use the customer’s escrow agreement. Possible values: - `true`: yes, use the customer’s escrow agreement. - `false`: no, do not use the customer’s escrow agreement.  
    */
    'enableEscrowOption'?: boolean;
    /**
    * CyberSource tokens types you are performing a create on. If not supplied the default token type for the merchants token vault will be used.  Valid values: - customer - paymentInstrument - instrumentIdentifier - shippingAddress 
    */
    'actionTokenTypes'?: Array<string>;
    /**
    * Bin Source File Identifier. Possible values: - itmx - rupay 
    */
    'binSource'?: string;
    /**
    * Indicates whether to also include a capture  in the submitted authorization request or not.  Possible values: - `true`: Include a capture with an authorization request. - `false`: (default) Do not include a capture with an authorization request.  #### Used by **Authorization and Capture** Optional field. 
    */
    'capture'?: boolean;
    /**
    * Value that identifies the processor/acquirer to use for the transaction. This value is supported only for **CyberSource through VisaNet**.  Contact CyberSource Customer Support to get the value for this field. 
    */
    'processorId'?: string;
    /**
    * Required for AFT and OCT transactions.  Given below is a list of all the BAI values available. However, the processors may support only few specific BAI values.  - AA : Account-to-account  - BB : Supplier Payments - BI : Bank-Initiated P2P Money Transfer - BP : Non-Card Bill Pay/Bill Pay - CD : Cash Deposit - CP : Credit card Bill Payment - FD : Funds disbursement  - FT : Funds transfer - GD : Government Disbursement - GP : Gambling payout (non-online gambling) - LO : Loyalty credits and rebates - MD : Merchant Settlement - OG : Online Gambling Payout - PD : Payroll and pension disbursement - PP : Person-to-Person or Peer-to-Peer - TU : Top up, prepaid load - WT : Digital wallet  
    */
    'businessApplicationId'?: string;
    /**
    * Type of transaction. Some payment card companies use this information when determining discount rates.  #### Used by **Authorization** Required payer authentication transactions; otherwise, optional. **Credit** Required for standalone credits on Chase Paymentech solutions; otherwise, optional.  The list of valid values in this field depends on your processor.  #### Ingenico ePayments When you omit this field for Ingenico ePayments, the processor uses the default transaction type they have on file for you instead of the default value   #### Card Present You must set this field to `retail`. This field is required for a card-present transaction. Note that this should ONLY be used when the cardholder and card are present at the time of the transaction. For all keyed transactions originated from a POS terminal where the cardholder and card are not present, commerceIndicator should be submitted as “moto\" 
    */
    'commerceIndicator'?: string;
    /**
    * Type of transaction. Some payment card companies use this information when determining discount rates.  #### Used by **Authorization** Required payer authentication transactions; otherwise, optional. **Credit** Required for standalone credits on Chase Paymentech solutions; otherwise, optional.  The list of valid values in this field depends on your processor.  #### Ingenico ePayments When you omit this field for Ingenico ePayments, the processor uses the default transaction type they have on file for you instead of the default value   #### Card Present You must set this field to `retail`. This field is required for a card-present transaction. Note that this should ONLY be used when the cardholder and card are present at the time of the transaction. For all keyed transactions originated from a POS terminal where the cardholder and card are not present, commerceIndicator should be submitted as `moto` 
    */
    'commerceIndicatorLabel'?: string;
    /**
    * Type of digital payment solution for the transaction. Possible Values:   - `visacheckout`: Visa Checkout. This value is required for Visa Checkout transactions. For details, see `payment_solution` field description in [Visa Checkout Using the REST API.](https://developer.cybersource.com/content/dam/docs/cybs/en-us/apifields/reference/all/rest/api-fields.pdf)  - `001`: Apple Pay.  - `004`: Cybersource In-App Solution.  - `005`: Masterpass. This value is required for Masterpass transactions on OmniPay Direct.   - `006`: Android Pay.  - `007`: Chase Pay.  - `008`: Samsung Pay.  - `012`: Google Pay.  - `013`: Cybersource P2PE Decryption  - `014`: Mastercard credential on file (COF) payment network token. Returned in authorizations that use a payment network token associated with a TMS token.  - `015`: Visa credential on file (COF) payment network token. Returned in authorizations that use a payment network token associated with a TMS token.  - `027`: Click to Pay. 
    */
    'paymentSolution'?: string;
    /**
    * Please check with Cybersource customer support to see if your merchant account is configured correctly so you can include this field in your request. * For Payouts: max length for FDCCompass is String (22). 
    */
    'reconciliationId'?: string;
    /**
    * Value that links the current authorization request to the original authorization request. Set this value to the ID that was returned in the reply message from the original authorization request.  This value is used for:  - Partial authorizations - Split shipments 
    */
    'linkId'?: string;
    /**
    * Set this field to 3 to indicate that the request includes Level III data.
    */
    'purchaseLevel'?: string;
    /**
    * The time-out limit in seconds for the transaction. The time-out limit starts when the customer is directed to the merchant URL that is included in the sale service response. The maximum value is 99999 (about 27 hours). When the transaction times out, the payment system changes the status to abandoned.
    */
    'transactionTimeout'?: number;
    /**
    * Set to the value of the requestID field returned in the order service response.
    */
    'intentsId'?: string;
    /**
    * Attribute that lets you define custom grouping for your processor reports. This field is supported only for **Worldpay VAP**. 
    */
    'reportGroup'?: string;
    /**
    * Identifier for the **Visa Checkout** order. Visa Checkout provides a unique order ID for every transaction in the Visa Checkout **callID** field. 
    */
    'visaCheckoutId'?: string;
    /**
    * Indicates that the transaction includes industry-specific data.  Possible Values: - `airline` - `restaurant` - `lodging` - `auto_rental` - `transit` - `healthcare_medical` - `healthcare_transit` - `transit`  #### Card Present, Airlines and Auto Rental You must set this field to `airline` in order for airline data to be sent to the processor. For example, if this field is not set to `airline` or is not included in the request, no airline data is sent to the processor.  You must set this field to `restaurant` in order for restaurant data to be sent to the processor. When this field is not set to `restaurant` or is not included in the request, no restaurant data is sent to the processor.  You must set this field to `auto_rental` in order for auto rental data to be sent to the processor. For example, if this field is not set to `auto_rental` or is not included in the request, no auto rental data is sent to the processor.  Restaurant data is supported only on CyberSource through VisaNet. 
    */
    'industryDataType'?: string;
    'authorizationOptions'?: Ptsv2paymentsProcessingInformationAuthorizationOptions;
    'captureOptions'?: Ptsv2paymentsProcessingInformationCaptureOptions;
    'recurringOptions'?: Ptsv2paymentsProcessingInformationRecurringOptions;
    'bankTransferOptions'?: Ptsv2paymentsProcessingInformationBankTransferOptions;
    'purchaseOptions'?: Ptsv2paymentsProcessingInformationPurchaseOptions;
    'electronicBenefitsTransfer'?: Ptsv2paymentsProcessingInformationElectronicBenefitsTransfer;
    'loanOptions'?: Ptsv2paymentsProcessingInformationLoanOptions;
    /**
    * This field carries the wallet type in authorization requests and credit requests. Possible value are: - `101`: Masterpass remote payment. The customer created the wallet by manually interacting with a customer-controlled device such as a computer, tablet, or phone. This value is supported only for Masterpass transactions on Chase Paymentech Solutions and CyberSource through VisaNet. - `102`: Masterpass remote near field communication (NFC) payment. The customer created the wallet by tapping a PayPass card or customer-controlled device at a contactless card reader. This value is supported only for card-present Masterpass transactions on CyberSource through VisaNet. - `103`: Masterpass Apple Pay payment. The payment was made with a combination of Masterpass and Apple Pay. This value is supported only for Masterpass Apple Pay transactions on CyberSource through VisaNet. - `216`: Masterpass Google Pay payment. The payment was made with a combination of Masterpass and Google Pay. This value is supported only for Masterpass Google Pay transactions on CyberSource through VisaNet. - `217`: Masterpass Samsung Pay payment. The payment was made with a combination of Masterpass and Samsung Pay. This value is supported only for Masterpass Samsung Pay transactions on CyberSource through VisaNet. - `SDW`: Staged digital wallet. An issuer or operator created the wallet. This value is supported only for Masterpass transactions on Chase Paymentech Solutions. - `VCIND`: Visa Checkout payment. This value is supported only on CyberSource through VisaNet, FDC Compass, FDC Nashville Global, FDI Australia, and TSYS Acquiring Solutions. See Getting Started with Visa Checkout. For Visa Checkout transactions, the way CyberSource processes the value for this field depends on the processor. See the Visa Checkout section below. For all other values, this field is a passthrough; therefore, CyberSource does not verify the value or modify it in any way before sending it to the processor. Masterpass (101, 102, 103, 216, and 217): The Masterpass platform generates the wallet type value and passes it to you along with the customer’s checkout information.  Visa Checkout: This field is optional for Visa Checkout authorizations on FDI Australia. For all other processors, this field is required for Visa Checkout authorizations. For Visa Checkout transactions on the following processors, CyberSource sends the value that the processor expects for this field:FDC Compass,FDC Nashville Global,FDI Australia,TSYS Acquiring Solutions For all other processors, this field is a passthrough; therefore, CyberSource does not verify the value or modify it in any way before sending it to the processor. For incremental authorizations, this field is supported only for Mastercard and the supported values are 101 and 102. Payment card companies can introduce new values without notice. Your order management system should be able to process new values without problems.  CyberSource through VisaNet When the value for this field is 101, 102, 103, 216, or 217, it corresponds to the following data in the TC 33 capture file5: Record: CP01 TCR6, Position: 88-90,  Field: Mastercard Wallet Identifier. When the value for this field is VCIND, it corresponds to the following data in the TC 33 capture file5: Record: CP01 TCR8, Position: 72-76, Field: Agent Unique ID. 
    */
    'walletType'?: string;
    /**
    * Supplementary domestic transaction information provided by the acquirer for National Net Settlement Service (NNSS) transactions. NNSS is a settlement service that Visa provides. For transactions on CyberSource through VisaNet in countries that subscribe to NNSS: VisaNet clears transactions; VisaNet transfers funds to the acquirer after deducting processing fees and interchange fees. VisaNet settles transactions in the local pricing currency through a local financial institution. This field is supported only on CyberSource through VisaNet for domestic data in Colombia 
    */
    'nationalNetDomesticData'?: string;
    'japanPaymentOptions'?: Ptsv2paymentsProcessingInformationJapanPaymentOptions;
    /**
    * Type of payment initiated from a cardholder's mobile device. Possible values: - `1` :  Consumer-initiated remote purchase, face-to-face - `2` :  Consumer-initiated remote purchase, e-commerce - `3` :  Consumer-initiated remote purchase, mail order / telephone order - `4` :  Consumer-initiated bill pay - `5` :  Consumer-initiated top up - `6` :  Consumer-initiated cash out - `7` :  ATM triggered or agent-initiated cash out - `8` :  Merchant-initiated remote purchase, face-to-face - `9` :  Merchant-initiated remote purchase, e-commerce  This field is supported only for Mastercard transactions on CyberSource through VisaNet.  Optional field.  **Note** On CyberSource through VisaNet, the value for this field corresponds to the following data in the TC 33 capture file: - Record: CP01 TCR6 - Position: 94 - Field: Mastercard Mobile Remote Payment Program Indicator  The TC 33 Capture file contains information about the purchases and refunds that a merchant submits to CyberSource. CyberSource through VisaNet creates the TC 33 Capture file at the end of the day and sends it to the merchant’s acquirer, who uses this information to facilitate end-of-day clearing processing with payment networks. 
    */
    'mobileRemotePaymentType'?: string;
    /**
    * A private national-use field submitted by acquirers and issuers in South Africa for South Africa-domestic (intra-country) authorizations and financial requests. Values for this field are 00 through 99. 
    */
    'extendedCreditTotalCount'?: string;
    /**
    * On PIN Debit Gateways: This U.S.-only field is optionally used by  participants (merchants and acquirers) to specify the network access priority. VisaNet checks to determine if there are issuer routing preferences for any of the networks specified by the sharing group code. If an issuer preference exists for one of the specified debit networks, VisaNet makes a routing selection based on the issuer’s preference. If an issuer preference exists for more than one of the specified debit networks, or if no issuer preference exists, VisaNet makes a selection based on the acquirer’s routing priorities.  #### PIN debit Priority order of the networks through which he transaction will be routed. Set this value to a series of one-character network codes in your preferred order. This is a list of the network codes:  | Network | Code | | --- | --- | | Accel | E | | AFFN | U | | Alaska Option | 3 | | CU24 | C | | Interlink | G | | Maestro | 8 | | NETS | P | | NYCE | F | | Pulse | H | | Shazam | 7 | | Star | M | | Visa | V |  For example, if the Star network is your first preference and Pulse is your second preference, set this field to a value of `MH`.  When you do not include this value in your PIN debit request, the list of network codes from your account is used. **Note** This field is supported only for businesses located in the U.S.  Optional field for PIN debit credit or PIN debit purchase. 
    */
    'networkRoutingOrder'?: string;
    /**
    * Flag that indicates if the transaction is pay by points transaction true: Transaction uses loyalty points false: Transaction does not use loyalty points Default: false 
    */
    'payByPointsIndicator'?: boolean;
    /**
    * Minutes until a pending MyBank transaction will be timed out. Value must be between 5 and 30. Default is 5. 
    */
    'timeout'?: number;
    /**
    * Flag that indicates the functionality we are having for merchants for which auth is done through Cybersource but settlement is done by themselves. true: functionality is supported. Processor should send raw processor auth response to Merchant. false: functionality is not supported. Default: false 
    */
    'isReturnAuthRecordEnabled'?: boolean;
    /**
    * Merchant payment gateway ID that is assigned by Mastercard and is provided by the acquirer when a registered merchant payment gateway service provider is involved in the transaction.  This field is supported for Visa Platform Connect. 
    */
    'networkPartnerId'?: string;
    /**
    * Identifier for the payment type. 
    */
    'paymentType'?: string;
    /**
    * Enablers are payment processing entities that are not acquiring members and are often the primary relationship owner with merchants and originators. Enablers own technical solutions through which the merchant or originator will access acceptance. The Enabler ID is a five-character hexadecimal identifier that will be used by Visa to identify enablers. Enabler ID assignment will be determined by Visa. Visa will communicate Enablers assignments to enablers. 
    */
    'enablerId'?: string;
    /**
    * The instruction to process an order. - default value: 'NO_INSTRUCTION' - 'ORDER_SAVED_EXPLICITLY' 
    */
    'processingInstruction'?: string;
    /**
    * This field is used identify the type of payment transaction taking place. This field is applicable for MasterCard transactions only. Possible values: - 201- Mastercard Rebate - 202- rePower Load Value - 203- Gaming Re-pay - 204- General Person-to-Person - 205- General Transfer to Own Account - 206- Agent Cash Out - 207- Payment of Own Credit Card Bill - 208- Business Disbursement - 209- Government/Non-Profit Disbursement - 210- Rapid Merchant Settlement - 211- Cash in at ATM (Usage limited to specific countries) - 212- Cash in at Point of Sale (Usage limited to specific countries) - 213- General Business to Business Transfer - 214- Mastercard Merchant Presented QR - 215- Mastercard Merchant Presented QR Refund Payment - 216- Utility Payments (for Brazil domestic use only) - 217- Government Services (for Brazil domestic use only) - 218- Mobile phone top-ups (for Brazil domestic use only) - 219- Coupon booklet payments (for Brazil domestic use only) - 220- General Person-to-Person Transfer - 221- Person-to-Person Transfer to Card Account - 222- General Transfer to Own Account - 223- Agent Cash Out - 224- Payment of Own Credit Card Bill - 225- Business Disbursement - 226- Transfer to Own Staged Digital Wallet Account - 227- Transfer to Own Debit or Prepaid Account - 228- General Business-to-Business Transfer - 229- Installment-based repayment - 230- Mastercard ATM Cash Pick-Up Transaction - 231- Cryptocurrency - 232- High-risk Securities 
    */
    'transactionTypeIndicator'?: string;
    /**
    * This field is applicable for AFT and OCT transactions. For list of supported values, please refer to Developer Guide. 
    */
    'purposeOfPayment'?: string;
    /**
    * Contains the ISO 639-2 defined language Code 
    */
    'languageCode'?: string;
    /**
    * This value is used for linking Authorization extension transaction to the original Authorization transaction  and for linking MIT (Merchant initiated transaction) with the respective CIT (Customer initiated transaction). 
    */
    'originalPaymentId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "actionList",
            "baseName": "actionList",
            "type": "Array<string>"
        },
        {
            "name": "enableEscrowOption",
            "baseName": "enableEscrowOption",
            "type": "boolean"
        },
        {
            "name": "actionTokenTypes",
            "baseName": "actionTokenTypes",
            "type": "Array<string>"
        },
        {
            "name": "binSource",
            "baseName": "binSource",
            "type": "string"
        },
        {
            "name": "capture",
            "baseName": "capture",
            "type": "boolean"
        },
        {
            "name": "processorId",
            "baseName": "processorId",
            "type": "string"
        },
        {
            "name": "businessApplicationId",
            "baseName": "businessApplicationId",
            "type": "string"
        },
        {
            "name": "commerceIndicator",
            "baseName": "commerceIndicator",
            "type": "string"
        },
        {
            "name": "commerceIndicatorLabel",
            "baseName": "commerceIndicatorLabel",
            "type": "string"
        },
        {
            "name": "paymentSolution",
            "baseName": "paymentSolution",
            "type": "string"
        },
        {
            "name": "reconciliationId",
            "baseName": "reconciliationId",
            "type": "string"
        },
        {
            "name": "linkId",
            "baseName": "linkId",
            "type": "string"
        },
        {
            "name": "purchaseLevel",
            "baseName": "purchaseLevel",
            "type": "string"
        },
        {
            "name": "transactionTimeout",
            "baseName": "transactionTimeout",
            "type": "number"
        },
        {
            "name": "intentsId",
            "baseName": "intentsId",
            "type": "string"
        },
        {
            "name": "reportGroup",
            "baseName": "reportGroup",
            "type": "string"
        },
        {
            "name": "visaCheckoutId",
            "baseName": "visaCheckoutId",
            "type": "string"
        },
        {
            "name": "industryDataType",
            "baseName": "industryDataType",
            "type": "string"
        },
        {
            "name": "authorizationOptions",
            "baseName": "authorizationOptions",
            "type": "Ptsv2paymentsProcessingInformationAuthorizationOptions"
        },
        {
            "name": "captureOptions",
            "baseName": "captureOptions",
            "type": "Ptsv2paymentsProcessingInformationCaptureOptions"
        },
        {
            "name": "recurringOptions",
            "baseName": "recurringOptions",
            "type": "Ptsv2paymentsProcessingInformationRecurringOptions"
        },
        {
            "name": "bankTransferOptions",
            "baseName": "bankTransferOptions",
            "type": "Ptsv2paymentsProcessingInformationBankTransferOptions"
        },
        {
            "name": "purchaseOptions",
            "baseName": "purchaseOptions",
            "type": "Ptsv2paymentsProcessingInformationPurchaseOptions"
        },
        {
            "name": "electronicBenefitsTransfer",
            "baseName": "electronicBenefitsTransfer",
            "type": "Ptsv2paymentsProcessingInformationElectronicBenefitsTransfer"
        },
        {
            "name": "loanOptions",
            "baseName": "loanOptions",
            "type": "Ptsv2paymentsProcessingInformationLoanOptions"
        },
        {
            "name": "walletType",
            "baseName": "walletType",
            "type": "string"
        },
        {
            "name": "nationalNetDomesticData",
            "baseName": "nationalNetDomesticData",
            "type": "string"
        },
        {
            "name": "japanPaymentOptions",
            "baseName": "japanPaymentOptions",
            "type": "Ptsv2paymentsProcessingInformationJapanPaymentOptions"
        },
        {
            "name": "mobileRemotePaymentType",
            "baseName": "mobileRemotePaymentType",
            "type": "string"
        },
        {
            "name": "extendedCreditTotalCount",
            "baseName": "extendedCreditTotalCount",
            "type": "string"
        },
        {
            "name": "networkRoutingOrder",
            "baseName": "networkRoutingOrder",
            "type": "string"
        },
        {
            "name": "payByPointsIndicator",
            "baseName": "payByPointsIndicator",
            "type": "boolean"
        },
        {
            "name": "timeout",
            "baseName": "timeout",
            "type": "number"
        },
        {
            "name": "isReturnAuthRecordEnabled",
            "baseName": "isReturnAuthRecordEnabled",
            "type": "boolean"
        },
        {
            "name": "networkPartnerId",
            "baseName": "networkPartnerId",
            "type": "string"
        },
        {
            "name": "paymentType",
            "baseName": "paymentType",
            "type": "string"
        },
        {
            "name": "enablerId",
            "baseName": "enablerId",
            "type": "string"
        },
        {
            "name": "processingInstruction",
            "baseName": "processingInstruction",
            "type": "string"
        },
        {
            "name": "transactionTypeIndicator",
            "baseName": "transactionTypeIndicator",
            "type": "string"
        },
        {
            "name": "purposeOfPayment",
            "baseName": "purposeOfPayment",
            "type": "string"
        },
        {
            "name": "languageCode",
            "baseName": "languageCode",
            "type": "string"
        },
        {
            "name": "originalPaymentId",
            "baseName": "originalPaymentId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsProcessingInformation.attributeTypeMap;
    }
}

export class Ptsv2paymentsProcessingInformationAuthorizationOptions {
    /**
    * Authorization type. Possible values:   - `AUTOCAPTURE`: automatic capture.  - `STANDARDCAPTURE`: standard capture.  - `VERBAL`: forced capture. Include it in the payment request for a forced capture. Include it in the capture request for a verbal payment.  #### Asia, Middle East, and Africa Gateway; Cielo; Comercio Latino; and CyberSource Latin American Processing Set this field to `AUTOCAPTURE` and include it in a bundled request to indicate that you are requesting an automatic capture. If your account is configured to enable automatic captures, set this field to `STANDARDCAPTURE` and include it in a standard authorization or bundled request to indicate that you are overriding an automatic capture.  #### Forced Capture Set this field to `VERBAL` and include it in the authorization request to indicate that you are performing a forced capture; therefore, you receive the authorization code outside the CyberSource system.  #### Verbal Authorization Set this field to `VERBAL` and include it in the capture request to indicate that the request is for a verbal authorization.  #### for PayPal ptsV2CreateOrderPost400Response Set this field to 'AUTHORIZE' or 'CAPTURE' depending on whether you want to invoke delayed capture or sale respectively. 
    */
    'authType'?: string;
    /**
    * #### Visa Platform Connect The field contains the PAN translation indicator for American Express Contactless Transaction. Valid value is   1- Expresspay Translation, PAN request 2- Expresspay Translation, PAN and Expiry date request 
    */
    'panReturnIndicator'?: string;
    /**
    * Authorization code.  #### Forced Capture Use this field to send the authorization code you received from a payment that you authorized outside the CyberSource system.  #### PIN debit Authorization code that is returned by the processor.  Returned by PIN debit purchase.  #### Verbal Authorization Use this field in CAPTURE API to send the verbally received authorization code. 
    */
    'verbalAuthCode'?: string;
    /**
    * Transaction ID (TID).  #### FDMS South This field is required for verbal authorizations and forced captures with the American Express card type to comply with the CAPN requirements: - Forced capture: Obtain the value for this field from the authorization response. - Verbal authorization: You cannot obtain a value for this field so CyberSource uses the default value of `000000000000000` (15 zeros). 
    */
    'verbalAuthTransactionId'?: string;
    /**
    * Flag that specifies the purpose of the authorization.  Possible values:  - **0**: Preauthorization  - **1**: Final authorization  To set the default for this field, contact CyberSource Customer Support.  #### Barclays and Elavon The default for Barclays and Elavon is 1 (final authorization). To change the default for this field, contact CyberSource Customer Support.  #### CyberSource through VisaNet When the value for this field is 0, it corresponds to the following data in the TC 33 capture file:  - Record: CP01 TCR0  - Position: 164  - Field: Additional Authorization Indicators When the value for this field is 1, it does not correspond to any data in the TC 33 capture file. 
    */
    'authIndicator'?: string;
    /**
    * Flag that indicates whether the transaction is enabled for partial authorization. When the request includes this field, this value overrides the information in your account. Possible values: - `true`: Enable the transaction for partial authorization. - `false`: Do not enable the transaction for partial authorization.  #### PIN debit Required field for partial authorizations that use PIN debit purchase; otherwise, not used.  #### Used by **Authorization** Optional field.  #### CyberSource through VisaNet To set the default for this field, contact CyberSource Customer Support. The value for this field corresponds to the following data in the TC 33 capture file5: - Record: CP01 TCR0 - Position: 164 - Field: Additional Authorization Indicators 
    */
    'partialAuthIndicator'?: boolean;
    /**
    * Indicates Authorization extension transaction. Extension transaction is used to prolong the settlement period by one additional settlement cycle period.  Possible values: - true: Transaction is an Authorization Extension transaction.  - false: Transaction is not an Authorization Extension transaction. 
    */
    'extendAuthIndicator'?: string;
    /**
    * Flag that indicates whether to return balance information.  Possible values: - `true`: Return balance information. - `false`: Do not return balance information.  #### Used by **Authorization** Required for a balance inquiry; otherwise, not used.  #### PIN debit Required for a balance inquiry request of a PIN debit purchase; otherwise, not used. 
    */
    'balanceInquiry'?: boolean;
    /**
    * Flag for a sale request that indicates whether to allow the capture service to run even when the authorization receives an AVS decline, as indicated by a reply flag value of DAVSNO.  Possible values: - `true`: Ignore the results of AVS checking and run the capture service. - `false` (default): If the authorization receives an AVS decline, do not run the capture service. When the value of this field is `true`, the list in the `processingInformation.authorizationOptions.declineAvsFlags` field is ignored.  #### Used by **Authorization** Optional field. String (3) 
    */
    'ignoreAvsResult'?: boolean;
    /**
    * Comma-separated list of AVS flags that cause the reply flag `DAVSNO` to be returned.  **Important** To receive declines for the AVS code `N`, you must include the value `N` in the comma-separated list.    ### AVS Codes for Cielo 3.0 and CyberSource Latin American Processing    **Note** CyberSource Latin American Processing is the name of a specific processing connection that CyberSource supports.   In the CyberSource API documentation, CyberSource Latin American Processing does not refer to the general topic of processing in Latin America.   The information in this section is for the specific processing connection called CyberSource Latin American Processing.   It is not for any other Latin American processors that CyberSource supports.  |AVS Code|Description| |--- |--- | |D|Partial match: postal code and address match.| |E|Not supported: AVS is not supported for this card type. _or_ Invalid: the acquirer returned an unrecognized value for the AVS response.| |F|Partial match: postal code matches, but CPF and address do not match.*| |G|Not supported: AVS not supported or not verified.| |I|No match: AVS information is not available.| |K|Partial match: CPF matches, but postal code and address do not match.*| |L|Partial match: postal code and CPF match, but address does not match.*| |N|No match: postal code, CPF, and address do not match.*| |O|Partial match: CPF and address match, but postal code does not match.*| |R|Not supported: your implementation does not support AVS _or_ System unavailable.| |T|Partial match: address matches, but postal code and CPF do not match.*| |V|Match: postal code, CPF, and address match.*| |* CPF (Cadastro de Pessoas Fisicas) is required only for Redecard in Brazil.||  ### AVS Codes for All Other Processors  **Note** The list of AVS codes for all other processors follows these descriptions of the processor-specific information for these codes.  #### American Express Cards For American Express cards only, you can receive Visa and CyberSource AVS codes in addition to the American Express AVS codes.  **Note** For CyberSource through VisaNet, the American Express AVS codes are converted to Visa AVS codes before they are returned to you. As a result, you will not receive American Express AVS codes for the American Express card type.<br/><br/>  _American Express Card codes_: `F`, `H`, `K`, `L`, `O`, `T`, `V`  #### Domestic and International Visa Cards The international and domestic alphabetic AVS codes are the Visa standard AVS codes. CyberSource maps the standard AVS return codes for other types of payment cards, including American Express cards, to the Visa standard AVS codes.  AVS is considered either domestic or international, depending on the location of the bank that issued the customer's payment card: - When the bank is in the U.S., the AVS is domestic. - When the bank is outside the U.S., the AVS is international.  You should be prepared to handle both domestic and international AVS result codes: - For international cards, you can receive domestic AVS codes in addition to the international AVS codes. - For domestic cards, you can receive international AVS codes in addition to the domestic AVS codes.  _International Visa Codes_: `B`, `C`, `D`, `G`, `I`, `M`, `P`  _Domestic Visa Codes_: `A`, `E`,`N`, `R`, `S`, `U`, `W`, `X`, `Y`, `Z`  #### CyberSource Codes The numeric AVS codes are created by CyberSource and are not standard Visa codes. These AVS codes can be returned for any card type.  _CyberSource Codes_: `1`, `2`, `3`, `4`  ### Table of AVS Codes for All Other Processors  |AVS Code|Description| |--- |--- | |A|Partial match: street address matches, but 5-digit and 9-digit postal codes do not match.| |B|Partial match: street address matches, but postal code is not verified. Returned only for Visa cards not issued in the U.S.| |C|No match: street address and postal code do not match. Returned only for Visa cards not issued in the U.S.| |D & M|Match: street address and postal code match. Returned only for Visa cards not issued in the U.S.| |E|Invalid: AVS data is invalid or AVS is not allowed for this card type.| |F|Partial match: card member’s name does not match, but billing postal code matches.| |G|Not supported: issuing bank outside the U.S. does not support AVS.| |H|Partial match: card member’s name does not match, but street address and postal code match. Returned only for the American Express card type.| |I|No match: address not verified. Returned only for Visa cards not issued in the U.S.| |K|Partial match: card member’s name matches, but billing address and billing postal code do not match. Returned only for the American Express card type.| |L|Partial match: card member’s name and billing postal code match, but billing address does not match. Returned only for the American Express card type.| |M|See the entry for D & M.| |N|No match: one of the following: street address and postal code do not match _or_ (American Express card type only) card member’s name, street address, and postal code do not match.| |O|Partial match: card member’s name and billing address match, but billing postal code does not match. Returned only for the American Express card type.| |P|Partial match: postal code matches, but street address not verified. Returned only for Visa cards not issued in the U.S.| |R|System unavailable.| |S|Not supported: issuing bank in the U.S. does not support AVS.| |T|Partial match: card member’s name does not match, but street address matches. Returned only for the American Express card type.| |U|System unavailable: address information unavailable for one of these reasons: The U.S. bank does not support AVS outside the U.S. _or_ The AVS in a U.S. bank is not functioning properly.| |V|Match: card member’s name, billing address, and billing postal code match. Returned only for the American Express card type.| |W|Partial match: street address does not match, but 9-digit postal code matches.| |X|Match: street address and 9-digit postal code match.| |Y|Match: street address and 5-digit postal code match.| |Z|Partial match: street address does not match, but 5-digit postal code matches.| |1|Not supported: one of the following: AVS is not supported for this processor or card type _or_ AVS is disabled for your CyberSource account. To enable AVS, contact CyberSource Customer Support.| |2|Unrecognized: the processor returned an unrecognized value for the AVS response.| |3|Match: address is confirmed. Returned only for PayPal Express Checkout.| |4|No match: address is not confirmed. Returned only for PayPal Express Checkout.| |5|No match: no AVS code was returned by the processor.| 
    */
    'declineAvsFlags'?: Array<string>;
    /**
    * Flag for a sale request that indicates whether to allow the capture service to run even when the authorization receives a CVN decline, as indicated by an `processorInformation.cardVerification.resultCode` value of `D` or `N`. Possible values: - `true`: Ignore the results of CVN checking and run the capture service. - `false` (default): If the authorization receives a CVN decline, do not run the capture service.  #### Used by **Authorization** Optional field. 
    */
    'ignoreCvResult'?: boolean;
    'initiator'?: Ptsv2paymentsProcessingInformationAuthorizationOptionsInitiator;
    /**
    * Indicates payment for bill or payment towards existing contractual loan.  Possible values: - `true`: Bill payment or loan payment. - `false` (default): Not a bill payment or loan payment.  Optional request field. 
    */
    'billPayment'?: boolean;
    /**
    * Reason for the payment.  Possible values: - 001: Public utilities / Utility payment - 002: Government services - 003: Cellular / Mobile phone top-up - 004: Coupon payment - 005: Installment based repayment - 006: Billing payment - 007: Tax payment - 008: Tax payment refunds  The value for this field corresponds to the following data in the TC 33A capture file (applicable to Brazil): - Record: CP07 TCR0 - Position: 48-50 - Field: Bill Payment Transaction Type Identifier  The value for this field corresponds to the following data in the TC 33A capture file (applicable to Installment) based Repayment): - Record: CP01 TCR6 - Position: 154-156 - Field: Bill Payment Transaction Type Identifier   This field is supported for 1. Bill payments in Brazil with Mastercard on CyberSource through VisaNet. 2. Installment based repayment transactions on Cybersource through VisaNet. 
    */
    'billPaymentType'?: string;
    /**
    * Flag that indicates the payment request is a redemption inquiry.  Possible values:   - `true`   - `false` 
    */
    'redemptionInquiry'?: boolean;
    /**
    * Type of transportation mode :  Possible Values: - 00 = Unknown - 01 = Urban bus - 02 = Interurban bus - 03=Lighttrainmasstransit(Underground Metro LTR) - 04 = Train - 05 = Commuter train - 06 = Water-borne vehicle - 07 = Toll - 08 = Parking - 09 = Taxi - 10 = High-speed train - 11 = Rural bus - 12 = Express commuter train - 13 = Para transit - 14 = Self drive vehicle - 15 = Coach - 16 = Locomotive - 17 = Powered motor coach - 18 = Trailer - 19 = Regional train - 20 = Inter-city - 21 = Funicular train - 22 = Cable car 
    */
    'transportationMode'?: string;
    /**
    * Indicates if transaction is an aggregated auth  Possible values: - **true** - **false** 
    */
    'aggregatedAuthIndicator'?: string;
    /**
    * Indicates if transaction is a debt recovery request  Possible values: - **true** - **false** 
    */
    'debtRecoveryIndicator'?: string;
    /**
    * Flag that indicates whether the authorization request was delayed because connectivity was interrupted.  Possible values:   - `true` (Deferred authorization)   - `false` (default: Not a deferred authorization) 
    */
    'deferredAuthIndicator'?: boolean;
    /**
    * This API field enables the merchant to indicate that a given transaction is Cash Advance.  Cash advance or Cash disbursement functionality allows a merchant to dispense cash at a point of sale. It provides the ability of a POS system to act like an ATM. These terminals are typically seen in bank branches where customers can use their card and withdraw cash or at merchant locations where ATMs are sparse.  Possible values:   - `true` (Cash advance is supported)   - `false` (default: cash advance is not supported) 
    */
    'cashAdvanceIndicator'?: boolean;
    /**
    * #### Visa Platform Connect Indicates split payment transaction. A split payment allows the use of two payment methods for a single transaction.  Possible values:   - `true` (split payment transaction is supported)   - `false` (default: split payment transaction is not supported) 
    */
    'splitPaymentTransaction'?: boolean;
    /**
    * This API field will indicate whether a card verification check is being performed during the transaction  Possible values:   - `true`   - `false` (default value) 
    */
    'cardVerificationIndicator'?: boolean;
    /**
    * Transaction mode identifier. Identifies the specific channel from which the transaction originates.  Possible values: - M – Mobile Order - T – Telephone Order 
    */
    'transactionMode'?: string;
    /**
    * Indicates whether the transaction is an Account Funding Transaction (AFT).  This field is mandatory for Account Funding Transactions (AFT).   Possible values:   - `true` (This is an AFT transaction)   - `false` (default value) (This is not an AFT transaction) 
    */
    'aftIndicator'?: boolean;
    /**
    * Field is used for back-to-back funding transaction and can be defined as a payment flow that automatically transfers funds through a real-time  funding or a live-load. This type of transaction can also be connected to a purchase.  In back-to-back funding of general purpose card that is used to make a purchase, two separate accounts are involved:  - account one is used to make the purchase - account two is used to automatically fund or reimburse account one  Possible values: - 0B = back to back funding transaction - 00 = normal transaction - 01 = originator hold - 02 = Visa deferred OCT hold, default interval - 03 = Visa deferred OCT hold, user-defined interval - 09 = Cancel pending deferred OCT request - 0I = Visa Direct custom program 1 - 0Q = uery the status of the deferred OCT - A0 = Alias Directory 2 
    */
    'serviceType'?: string;
    /**
    * Merchant to inform Cybersource whether a transaction is Money load with Balance Update.  Possible values:   - `true` (This is a Money load with balance update transaction)   - `false` (default value) (This is not a Money load with balance update transaction) 
    */
    'balanceUpdate'?: boolean;
    /**
    * Merchant to inform Cybersource whether a transaction is Money load with Money load only.  Possible values:   - `true` (This is a money load transaction)   - `false` (default value) (This is not a money load transaction) 
    */
    'moneyLoad'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "authType",
            "baseName": "authType",
            "type": "string"
        },
        {
            "name": "panReturnIndicator",
            "baseName": "panReturnIndicator",
            "type": "string"
        },
        {
            "name": "verbalAuthCode",
            "baseName": "verbalAuthCode",
            "type": "string"
        },
        {
            "name": "verbalAuthTransactionId",
            "baseName": "verbalAuthTransactionId",
            "type": "string"
        },
        {
            "name": "authIndicator",
            "baseName": "authIndicator",
            "type": "string"
        },
        {
            "name": "partialAuthIndicator",
            "baseName": "partialAuthIndicator",
            "type": "boolean"
        },
        {
            "name": "extendAuthIndicator",
            "baseName": "extendAuthIndicator",
            "type": "string"
        },
        {
            "name": "balanceInquiry",
            "baseName": "balanceInquiry",
            "type": "boolean"
        },
        {
            "name": "ignoreAvsResult",
            "baseName": "ignoreAvsResult",
            "type": "boolean"
        },
        {
            "name": "declineAvsFlags",
            "baseName": "declineAvsFlags",
            "type": "Array<string>"
        },
        {
            "name": "ignoreCvResult",
            "baseName": "ignoreCvResult",
            "type": "boolean"
        },
        {
            "name": "initiator",
            "baseName": "initiator",
            "type": "Ptsv2paymentsProcessingInformationAuthorizationOptionsInitiator"
        },
        {
            "name": "billPayment",
            "baseName": "billPayment",
            "type": "boolean"
        },
        {
            "name": "billPaymentType",
            "baseName": "billPaymentType",
            "type": "string"
        },
        {
            "name": "redemptionInquiry",
            "baseName": "redemptionInquiry",
            "type": "boolean"
        },
        {
            "name": "transportationMode",
            "baseName": "transportationMode",
            "type": "string"
        },
        {
            "name": "aggregatedAuthIndicator",
            "baseName": "aggregatedAuthIndicator",
            "type": "string"
        },
        {
            "name": "debtRecoveryIndicator",
            "baseName": "debtRecoveryIndicator",
            "type": "string"
        },
        {
            "name": "deferredAuthIndicator",
            "baseName": "deferredAuthIndicator",
            "type": "boolean"
        },
        {
            "name": "cashAdvanceIndicator",
            "baseName": "cashAdvanceIndicator",
            "type": "boolean"
        },
        {
            "name": "splitPaymentTransaction",
            "baseName": "splitPaymentTransaction",
            "type": "boolean"
        },
        {
            "name": "cardVerificationIndicator",
            "baseName": "cardVerificationIndicator",
            "type": "boolean"
        },
        {
            "name": "transactionMode",
            "baseName": "transactionMode",
            "type": "string"
        },
        {
            "name": "aftIndicator",
            "baseName": "aftIndicator",
            "type": "boolean"
        },
        {
            "name": "serviceType",
            "baseName": "serviceType",
            "type": "string"
        },
        {
            "name": "balanceUpdate",
            "baseName": "balanceUpdate",
            "type": "boolean"
        },
        {
            "name": "moneyLoad",
            "baseName": "moneyLoad",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsProcessingInformationAuthorizationOptions.attributeTypeMap;
    }
}

export class Ptsv2paymentsProcessingInformationAuthorizationOptionsInitiator {
    /**
    * This field indicates whether the transaction is a merchant-initiated transaction or customer-initiated transaction.  Valid values: - **customer** - **merchant** 
    */
    'type'?: string;
    /**
    * Indicates to the issuing bank two things: - The merchant has received consent from the cardholder to store their card details on file - The merchant wants the issuing bank to check out the card details before the merchant initiates their first transaction for this cardholder. The purpose of the merchant-initiated transaction is to ensure that the cardholder’s credentials are valid (that the card is not stolen or has restrictions) and that the card details are good to be stored on the merchant’s file for future transactions.  Valid values: - `true` means merchant will use this transaction to store payment credentials for follow-up merchant-initiated transactions. - `false` means merchant will not use this transaction to store payment credentials for follow-up merchant-initiated transactions.  **NOTE:** The value for this field does not correspond to any data in the TC 33 capture file5.  This field is supported only for Visa transactions on CyberSource through VisaNet. 
    */
    'credentialStoredOnFile'?: boolean;
    /**
    * Indicates to an issuing bank whether a merchant-initiated transaction came from a card that was already stored on file.  Possible values: - **true** means the merchant-initiated transaction came from a card that was already stored on file. - **false**  means the merchant-initiated transaction came from a card that was not stored on file. 
    */
    'storedCredentialUsed'?: boolean;
    'merchantInitiatedTransaction'?: Ptsv2paymentsProcessingInformationAuthorizationOptionsInitiatorMerchantInitiatedTransaction;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "credentialStoredOnFile",
            "baseName": "credentialStoredOnFile",
            "type": "boolean"
        },
        {
            "name": "storedCredentialUsed",
            "baseName": "storedCredentialUsed",
            "type": "boolean"
        },
        {
            "name": "merchantInitiatedTransaction",
            "baseName": "merchantInitiatedTransaction",
            "type": "Ptsv2paymentsProcessingInformationAuthorizationOptionsInitiatorMerchantInitiatedTransaction"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsProcessingInformationAuthorizationOptionsInitiator.attributeTypeMap;
    }
}

export class Ptsv2paymentsProcessingInformationAuthorizationOptionsInitiatorMerchantInitiatedTransaction {
    /**
    * Reason for the merchant-initiated transaction or incremental authorization. Possible values: - `1`: Resubmission - `2`: Delayed charge - `3`: Reauthorization for split shipment - `4`: No show - `5`: Account top up This field is required only for the five kinds of transactions in the preceding list. This field is supported only for merchant-initiated transactions and incremental authorizations.  #### CyberSource through VisaNet The value for this field corresponds to the following data in the TC 33 capture file5: - Record: CP01 TCR0 - Position: 160-163 - Field: Message Reason Code 
    */
    'reason'?: string;
    /**
    * Network transaction identifier that was returned in the payment response field _processorInformation.transactionID_ in the reply message for either the original merchant-initiated payment in the series or the previous merchant-initiated payment in the series.  If the current payment request includes a token instead of an account number, the following time limits apply for the value of this field: - For a **resubmission**, the transaction ID must be less than 14 days old. - For a **delayed charge** or **reauthorization**, the transaction ID must be less than 30 days old.  **NOTE**: The value for this field does not correspond to any data in the TC 33 capture file5. This field is supported only for Visa transactions on CyberSource through VisaNet. 
    */
    'previousTransactionId'?: string;
    /**
    * Amount of the original authorization.  This field is supported only for Apple Pay, Google Pay, and Samsung Pay transactions with Discover on FDC Nashville Global and Chase Paymentech. 
    */
    'originalAuthorizedAmount'?: string;
    /**
    * An API to carry the agreement ID generated for recurring and unscheduled Card on file transaction. the merchant generates this per card holder or per payment agreement and shares the generated unique ID in the subsequent transactions. This can contain foreign/arabic character set also. Cybersource forwards this value to the Saudi Payment processor. 
    */
    'agreementId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "reason",
            "baseName": "reason",
            "type": "string"
        },
        {
            "name": "previousTransactionId",
            "baseName": "previousTransactionId",
            "type": "string"
        },
        {
            "name": "originalAuthorizedAmount",
            "baseName": "originalAuthorizedAmount",
            "type": "string"
        },
        {
            "name": "agreementId",
            "baseName": "agreementId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsProcessingInformationAuthorizationOptionsInitiatorMerchantInitiatedTransaction.attributeTypeMap;
    }
}

export class Ptsv2paymentsProcessingInformationBankTransferOptions {
    /**
    * Space-separated list of AVS flags that cause the request to be declined for AVS reasons.  **Important** To receive declines for the AVS code `N`, you must include the value `N` in the space-separated list.  ### AVS Codes for Cielo 3.0 and CyberSource Latin American Processing  **Note** CyberSource Latin American Processing is the name of a specific processing connection that CyberSource supports. In the CyberSource API documentation, CyberSource Latin American Processing does not refer to the general topic of processing in Latin America. The information in this section is for the specific processing connection called CyberSource Latin American Processing. It is not for any other Latin American processors that CyberSource supports.  |AVS Code|Description| |--- |--- | |D|Partial match: postal code and address match.| |E|Not supported: AVS is not supported for this card type. _or_ Invalid: the acquirer returned an unrecognized value for the AVS response.| |F|Partial match: postal code matches, but CPF and address do not match.*| |G|Not supported: AVS not supported or not verified.| |I|No match: AVS information is not available.| |K|Partial match: CPF matches, but postal code and address do not match.*| |L|Partial match: postal code and CPF match, but address does not match.*| |N|No match: postal code, CPF, and address do not match.*| |O|Partial match: CPF and address match, but postal code does not match.*| |R|Not supported: your implementation does not support AVS _or_ System unavailable.| |T|Partial match: address matches, but postal code and CPF do not match.*| |V|Match: postal code, CPF, and address match.*| |* CPF (Cadastro de Pessoas Fisicas) is required only for Redecard in Brazil.||  ### AVS Codes for All Other Processors  **Note** The list of AVS codes for all other processors follows these descriptions of the processor-specific information for these codes.  #### American Express Cards For American Express cards only, you can receive Visa and CyberSource AVS codes in addition to the American Express AVS codes.  **Note** For CyberSource through VisaNet, the American Express AVS codes are converted to Visa AVS codes before they are returned to you. As a result, you will not receive American Express AVS codes for the American Express card type.  _American Express Card codes_: `F`, `H`, `K`, `L`, `O`, `T`, `V`  #### Domestic and International Visa Cards The international and domestic alphabetic AVS codes are the Visa standard AVS codes. CyberSource maps the standard AVS return codes for other types of payment cards, including American Express cards, to the Visa standard AVS codes.  AVS is considered either domestic or international, depending on the location of the bank that issued the customer’s payment card: - When the bank is in the U.S., the AVS is domestic. - When the bank is outside the U.S., the AVS is international.  You should be prepared to handle both domestic and international AVS result codes: - For international cards, you can receive domestic AVS codes in addition to the international AVS codes. - For domestic cards, you can receive international AVS codes in addition to the domestic AVS codes.  _International Visa Codes_: `B`, `C`, `D`, `G`, `I`, `M`, `P`  _Domestic Visa Codes_: `A`, `E`,`N`, `R`, `S`, `U`, `W`, `X`, `Y`, `Z`  #### CyberSource Codes The numeric AVS codes are created by CyberSource and are not standard Visa codes. These AVS codes can be returned for any card type.  _CyberSource Codes_: `1`, `2`, `3`, `4`  ### Table of AVS Codes for All Other Processors  |AVS Code|Description| |--- |--- | |A|Partial match: street address matches, but 5-digit and 9-digit postal codes do not match.| |B|Partial match: street address matches, but postal code is not verified. Returned only for Visa cards not issued in the U.S.| |C|No match: street address and postal code do not match. Returned only for Visa cards not issued in the U.S.| |D & M|Match: street address and postal code match. Returned only for Visa cards not issued in the U.S.| |E|Invalid: AVS data is invalid or AVS is not allowed for this card type.| |F|Partial match: card member’s name does not match, but billing postal code matches.| |G|Not supported: issuing bank outside the U.S. does not support AVS.| |H|Partial match: card member’s name does not match, but street address and postal code match. Returned only for the American Express card type.| |I|No match: address not verified. Returned only for Visa cards not issued in the U.S.| |K|Partial match: card member’s name matches, but billing address and billing postal code do not match. Returned only for the American Express card type.| |L|Partial match: card member’s name and billing postal code match, but billing address does not match. Returned only for the American Express card type.| |M|See the entry for D & M.| |N|No match: one of the following: street address and postal code do not match _or_ (American Express card type only) card member’s name, street address, and postal code do not match.| |O|Partial match: card member’s name and billing address match, but billing postal code does not match. Returned only for the American Express card type.| |P|Partial match: postal code matches, but street address not verified. Returned only for Visa cards not issued in the U.S.| |R|System unavailable.| |S|Not supported: issuing bank in the U.S. does not support AVS.| |T|Partial match: card member’s name does not match, but street address matches. Returned only for the American Express card type.| |U|System unavailable: address information unavailable for one of these reasons: The U.S. bank does not support AVS outside the U.S. _or_ The AVS in a U.S. bank is not functioning properly.| |V|Match: card member’s name, billing address, and billing postal code match. Returned only for the American Express card type.| |W|Partial match: street address does not match, but 9-digit postal code matches.| |X|Match: street address and 9-digit postal code match.| |Y|Match: street address and 5-digit postal code match.| |Z|Partial match: street address does not match, but 5-digit postal code matches.| |1|Not supported: one of the following: AVS is not supported for this processor or card type _or_ AVS is disabled for your CyberSource account. To enable AVS, contact CyberSource Customer Support.| |2|Unrecognized: the processor returned an unrecognized value for the AVS response.| |3|Match: address is confirmed. Returned only for PayPal Express Checkout.| |4|No match: address is not confirmed. Returned only for PayPal Express Checkout.| |5|No match: no AVS code was returned by the processor.| 
    */
    'declineAvsFlags'?: string;
    /**
    * Specifies the authorization method for the transaction.  #### TeleCheck Accepts only the following values: - `ARC`: account receivable conversion - `CCD`: corporate cash disbursement - `POP`: point of purchase conversion - `PPD`: prearranged payment and deposit entry - `TEL`: telephone-initiated entry - `WEB`: internet-initiated entry 
    */
    'secCode'?: string;
    /**
    * City in which the terminal is located. If more than four alphanumeric characters are submitted, the transaction will be declined.  You cannot include any special characters. 
    */
    'terminalCity'?: string;
    /**
    * State in which the terminal is located. If more than two alphanumeric characters are submitted, the transaction will be declined.  You cannot include any special characters. 
    */
    'terminalState'?: string;
    /**
    * Effective date for the transaction. The effective date must be within 45 days of the current day. If you do not include this value, CyberSource sets the effective date to the next business day.  Format: `MMDDYYYY`  Supported only for the CyberSource ACH Service. 
    */
    'effectiveDate'?: string;
    /**
    * Identifier for a partial payment or partial credit.  The value for each debit request or credit request must be unique within the scope of the order. 
    */
    'partialPaymentId'?: string;
    /**
    * Payment related information.  This information is included on the customer’s statement. 
    */
    'customerMemo'?: string;
    /**
    * Flag that indicates whether to process the payment.  Use with deferred payments.  Possible values: - `0`: Standard debit with immediate payment (default). - `1`: For deferred payments, indicates that this is a deferred payment and that you will send a debit request with `paymentCategoryCode = 2` in the future. - `2`: For deferred payments, indicates notification to initiate payment.  #### Chase Paymentech Solutions and TeleCheck Use for deferred and partial payments.  #### CyberSource ACH Service Not used.  #### RBS WorldPay Atlanta Not used. 
    */
    'paymentCategoryCode'?: string;
    /**
    * Method used for settlement.  Possible values: - `A`: Automated Clearing House (default for credits and for transactions using Canadian dollars) - `F`: Facsimile draft (U.S. dollars only) - `B`: Best possible (U.S. dollars only) (default if the field has not already been configured for your merchant ID) 
    */
    'settlementMethod'?: string;
    /**
    * Level of fraud screening.  Possible values: - `1`: Validation — default if the field has not already been configured for your merchant ID - `2`: Verification 
    */
    'fraudScreeningLevel'?: string;
    /**
    * Indicates whether a customer is physically present and whether the customer is enrolling in CyberSource Recurring Billing.  Possible values: - `1`: Customer is present and not enrolling. - `2`: Customer is not present and not enrolling. - `3`: Customer is present and enrolling. - `4`: Customer is not present and enrolling. 
    */
    'customerPresent'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "declineAvsFlags",
            "baseName": "declineAvsFlags",
            "type": "string"
        },
        {
            "name": "secCode",
            "baseName": "secCode",
            "type": "string"
        },
        {
            "name": "terminalCity",
            "baseName": "terminalCity",
            "type": "string"
        },
        {
            "name": "terminalState",
            "baseName": "terminalState",
            "type": "string"
        },
        {
            "name": "effectiveDate",
            "baseName": "effectiveDate",
            "type": "string"
        },
        {
            "name": "partialPaymentId",
            "baseName": "partialPaymentId",
            "type": "string"
        },
        {
            "name": "customerMemo",
            "baseName": "customerMemo",
            "type": "string"
        },
        {
            "name": "paymentCategoryCode",
            "baseName": "paymentCategoryCode",
            "type": "string"
        },
        {
            "name": "settlementMethod",
            "baseName": "settlementMethod",
            "type": "string"
        },
        {
            "name": "fraudScreeningLevel",
            "baseName": "fraudScreeningLevel",
            "type": "string"
        },
        {
            "name": "customerPresent",
            "baseName": "customerPresent",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsProcessingInformationBankTransferOptions.attributeTypeMap;
    }
}

export class Ptsv2paymentsProcessingInformationCaptureOptions {
    /**
    * Capture number when requesting multiple partial captures for one authorization. Used along with `totalCaptureCount` to track which capture is being processed.  For example, the second of five captures would be passed to CyberSource as:   - `captureSequenceNumber_ = 2`, and   - `totalCaptureCount = 5` 
    */
    'captureSequenceNumber'?: number;
    /**
    * Total number of captures when requesting multiple partial captures for one payment. Used along with `captureSequenceNumber` field to track which capture is being processed.  For example, the second of five captures would be passed to CyberSource as:   - `captureSequenceNumber = 2`, and   - `totalCaptureCount = 5` 
    */
    'totalCaptureCount'?: number;
    /**
    * Date on which you want the capture to occur. This field is supported only for CyberSource through VisaNet. Format: `MMDD`  #### Used by **Authorization** Optional field. 
    */
    'dateToCapture'?: string;
    /**
    * Indicates whether to release the authorization hold on the remaining funds.   Possible Values: - `true` - `false` 
    */
    'isFinal'?: string;
    /**
    * An informational note about this settlement. Appears in both the payer's transaction history and the emails that the payer receives. 
    */
    'notes'?: string;
    /**
    * Used for authbill request when capture field equals true
    */
    'reconciliationId'?: string;
    /**
    * Used by Nike merchant to send 12 digit order number
    */
    'reconciliationIdAlternate'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "captureSequenceNumber",
            "baseName": "captureSequenceNumber",
            "type": "number"
        },
        {
            "name": "totalCaptureCount",
            "baseName": "totalCaptureCount",
            "type": "number"
        },
        {
            "name": "dateToCapture",
            "baseName": "dateToCapture",
            "type": "string"
        },
        {
            "name": "isFinal",
            "baseName": "isFinal",
            "type": "string"
        },
        {
            "name": "notes",
            "baseName": "notes",
            "type": "string"
        },
        {
            "name": "reconciliationId",
            "baseName": "reconciliationId",
            "type": "string"
        },
        {
            "name": "reconciliationIdAlternate",
            "baseName": "reconciliationIdAlternate",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsProcessingInformationCaptureOptions.attributeTypeMap;
    }
}

export class Ptsv2paymentsProcessingInformationElectronicBenefitsTransfer {
    /**
    * Flag that specifies the category for the EBT transaction.  Possible values: - `CASH`: Cash benefits, which can be used to purchase any item at a participating retailer, as well as to obtain cash-back or make a cash withdrawal from a participating ATM. - `FOOD`: Food stamp benefits, which can be used only to purchase food items authorized by the USDA SNAP program.  #### PIN debit Required field for EBT transactions that use PIN debit credit or PIN debit purchase; otherwise, not used. 
    */
    'category'?: string;
    /**
    * The serial number printed on the EBT voucher.  #### PIN debit Required field for EBT voucher transactions that use PIN debit purchase; otherwise, not used. 
    */
    'voucherSerialNumber'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "category",
            "baseName": "category",
            "type": "string"
        },
        {
            "name": "voucherSerialNumber",
            "baseName": "voucherSerialNumber",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsProcessingInformationElectronicBenefitsTransfer.attributeTypeMap;
    }
}

export class Ptsv2paymentsProcessingInformationJapanPaymentOptions {
    /**
    * This value is a 2-digit code indicating the payment method. Use Payment Method Code value that applies to the tranasction. - 10 (One-time payment) - 21, 22, 23, 24  (Bonus(one-time)payment) - 61 (Installment payment) - 31, 32, 33, 34  (Integrated (Bonus + Installment)payment) - 80 (Revolving payment) 
    */
    'paymentMethod'?: string;
    /**
    * An array of objects, each of which contains a bonus month and bonus amount.  Length of bonuses array is equal to the number of bonuses.  Max length = 6.  In case of bonus month and amount not specified, null objects to be returned in the array. Example: bonuses : [ {\"month\": \"1\",\"amount\": \"200\"}, {\"month\": \"3\",\"amount\": \"2500\"}, null] 
    */
    'bonuses'?: Array<Ptsv2paymentsProcessingInformationJapanPaymentOptionsBonuses>;
    /**
    * This will contain the details of the kind of transaction that has been processe. Used only for Japan. Possible Values: - 0 = Normal (authorization with amount and clearing/settlement; data capture or paper draft) - 1 = Negative card authorization (authorization-only with 0 or 1 amount) - 2 = Reservation of authorization (authorization-only with amount) - 3 = Cancel transaction - 4 = Merchant-initiated reversal/refund transactions - 5 = Cancel reservation of authorization - 6 = Post authorization 
    */
    'preapprovalType'?: string;
    /**
    * Number of Installments. 
    */
    'installments'?: string;
    /**
    * Unique Japan Credit Card Association (JCCA) terminal identifier.  The difference between this field and the `pointOfSaleInformation.terminalID` field is that you can define `pointOfSaleInformation.terminalID`, but `processingInformation.japanPaymentOptions.terminalId` is defined by the JCCA and is used only in Japan.  This field is supported only on CyberSource through VisaNet and JCN Gateway.  Optional field. 
    */
    'terminalId'?: string;
    /**
    * Billing month in MM format. 
    */
    'firstBillingMonth'?: string;
    /**
    * Business name in Japanese characters. This field is supported only on JCN Gateway and for the Sumitomo Mitsui Card Co. acquirer on CyberSource through VisaNet. 
    */
    'businessName'?: string;
    /**
    * Business name in Katakana characters. This field is supported only on JCN Gateway and for the Sumitomo Mitsui Card Co. acquirer on CyberSource through VisaNet. 
    */
    'businessNameKatakana'?: string;
    /**
    * Japanese Industrial Standard Type 2 (JIS2) track data from the front of the card.  This field is supported only on CyberSource through VisaNet and JCN Gateway.  Optional field. 
    */
    'jis2TrackData'?: string;
    /**
    * Business name in alphanumeric characters. This field is supported only on JCN Gateway and for the Sumitomo Mitsui Card Co. acquirer on CyberSource through VisaNet. 
    */
    'businessNameAlphaNumeric'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "paymentMethod",
            "baseName": "paymentMethod",
            "type": "string"
        },
        {
            "name": "bonuses",
            "baseName": "bonuses",
            "type": "Array<Ptsv2paymentsProcessingInformationJapanPaymentOptionsBonuses>"
        },
        {
            "name": "preapprovalType",
            "baseName": "preapprovalType",
            "type": "string"
        },
        {
            "name": "installments",
            "baseName": "installments",
            "type": "string"
        },
        {
            "name": "terminalId",
            "baseName": "terminalId",
            "type": "string"
        },
        {
            "name": "firstBillingMonth",
            "baseName": "firstBillingMonth",
            "type": "string"
        },
        {
            "name": "businessName",
            "baseName": "businessName",
            "type": "string"
        },
        {
            "name": "businessNameKatakana",
            "baseName": "businessNameKatakana",
            "type": "string"
        },
        {
            "name": "jis2TrackData",
            "baseName": "jis2TrackData",
            "type": "string"
        },
        {
            "name": "businessNameAlphaNumeric",
            "baseName": "businessNameAlphaNumeric",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsProcessingInformationJapanPaymentOptions.attributeTypeMap;
    }
}

export class Ptsv2paymentsProcessingInformationJapanPaymentOptionsBonuses {
    /**
    * This value is a 2-digit code indicating the first bonus month. Valid value from 1 to 12. 
    */
    'month'?: string;
    /**
    * This value contains the bonus amount of the first month. Maximum value without decimal 99999999. 
    */
    'amount'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "month",
            "baseName": "month",
            "type": "string"
        },
        {
            "name": "amount",
            "baseName": "amount",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsProcessingInformationJapanPaymentOptionsBonuses.attributeTypeMap;
    }
}

export class Ptsv2paymentsProcessingInformationLoanOptions {
    /**
    * Type of loan based on an agreement between you and the issuer. Examples: AGROCUSTEIO, AGRO-INVEST, BNDES-Type1, CBN, FINAME. This field is supported only for these kinds of payments: - BNDES transactions on CyberSource through VisaNet. - Installment payments with Mastercard on CyberSource through VisaNet in Brazil.  For BNDES transactions, the value for this field corresponds to the following data in the TC 33 capture file: - Record: CP07 TCR2, Position: 27-46, Field: Loan Type  For installment payments with Mastercard in Brazil, the value for this field corresponds to the following data in the TC 33 capture file: - Record: CP07 TCR4, Position: 5-24,Field: Financing Type 
    */
    'type'?: string;
    /**
    * Indicates whether a loan is for a recoverable item or a non-recoverable item. Possible values: - `N`: non-recoverable item - `R`: recoverable item This field is supported only for BNDES transactions on CyberSource through VisaNet. The value for this field corresponds to the following data in the TC 33 capture file5:  Record: CP07 TCR2, Position: 26, Field: Asset Indicator 
    */
    'assetType'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "assetType",
            "baseName": "assetType",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsProcessingInformationLoanOptions.attributeTypeMap;
    }
}

export class Ptsv2paymentsProcessingInformationPurchaseOptions {
    /**
    * Flag that indicates whether this transaction is an EBT transaction. Possible values: - `true` - `false`  #### PIN debit Required field for EBT and EBT voucher transactions that use PIN debit credit or PIN debit purchase; otherwise, not used. 
    */
    'isElectronicBenefitsTransfer'?: boolean;
    /**
    * Flag that indicates an EBT voucher transaction. Possible value: - `EBT_VOUCHER`: Indicates the PIN debit transaction is an EBT voucher. - `BUY` - `RENT` - `BOOK` - `SUBSCRIBE` - `DOWNLOAD` - `ORDER` - `CONTINUE`  #### PIN debit Required field for EBT voucher transactions that use PIN debit purchase; otherwise, not used. 
    */
    'type'?: string;
    /**
    * This field contains installment data defined by MasterCard. Possible values:   - Y = eligible   - N = not eligile 
    */
    'eligibilityIndicator'?: string;
    /**
    * Workplace benefit amount.
    */
    'benefitAmount'?: string;
    /**
    * Workplace benefit type. Possible values: - 70 = employee benefit - 4T = transportation / transit - 52 = general benefit - 53 = meal voucher - 54 = fuel - 55 = ecological / sustainability - 58 = philanthropy / patronage / consumption - 59 = gift - 5S = sport / culture - 5T = book / education 
    */
    'benefitType'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "isElectronicBenefitsTransfer",
            "baseName": "isElectronicBenefitsTransfer",
            "type": "boolean"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "eligibilityIndicator",
            "baseName": "eligibilityIndicator",
            "type": "string"
        },
        {
            "name": "benefitAmount",
            "baseName": "benefitAmount",
            "type": "string"
        },
        {
            "name": "benefitType",
            "baseName": "benefitType",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsProcessingInformationPurchaseOptions.attributeTypeMap;
    }
}

export class Ptsv2paymentsProcessingInformationRecurringOptions {
    /**
    * Flag that indicates whether this is a payment towards an existing contractual loan.  Possible values: - `true`: Loan payment - `false`: (default) Not a loan payment 
    */
    'loanPayment'?: boolean;
    /**
    * Flag that indicates whether this transaction is the first in a series of recurring payments.  This field is supported only for **Atos**, **FDC Nashville Global**, and **OmniPay Direct**.  Possible values:  - `true` Indicates this is the first payment in a series of recurring payments  - `false` (default) Indicates this is not the first payment in a series of recurring payments. 
    */
    'firstRecurringPayment'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "loanPayment",
            "baseName": "loanPayment",
            "type": "boolean"
        },
        {
            "name": "firstRecurringPayment",
            "baseName": "firstRecurringPayment",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsProcessingInformationRecurringOptions.attributeTypeMap;
    }
}

/**
* Processor Information
*/
export class Ptsv2paymentsProcessorInformation {
    /**
    * Token received in original session service.
    */
    'preApprovalToken'?: string;
    'authorizationOptions'?: Ptsv2paymentsProcessorInformationAuthorizationOptions;
    'reversal'?: Ptsv2paymentsProcessorInformationReversal;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "preApprovalToken",
            "baseName": "preApprovalToken",
            "type": "string"
        },
        {
            "name": "authorizationOptions",
            "baseName": "authorizationOptions",
            "type": "Ptsv2paymentsProcessorInformationAuthorizationOptions"
        },
        {
            "name": "reversal",
            "baseName": "reversal",
            "type": "Ptsv2paymentsProcessorInformationReversal"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsProcessorInformation.attributeTypeMap;
    }
}

export class Ptsv2paymentsProcessorInformationAuthorizationOptions {
    /**
    * #### Visa Platform Connect The field contains the PAN translation indicator for American Express Contactless Transaction. Valid value is   1- Expresspay Translation, PAN request 2- Expresspay Translation, PAN and Expiry date request 
    */
    'panReturnIndicator'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "panReturnIndicator",
            "baseName": "panReturnIndicator",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsProcessorInformationAuthorizationOptions.attributeTypeMap;
    }
}

export class Ptsv2paymentsProcessorInformationReversal {
    /**
    * This is a token generated by PSP, which is received in response to the Sessions service. This token should be sent in the following transactions.
    */
    'preApprovalToken'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "preApprovalToken",
            "baseName": "preApprovalToken",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsProcessorInformationReversal.attributeTypeMap;
    }
}

export class Ptsv2paymentsPromotionInformation {
    /**
    * Additional rental agency marketed coupons for consumers to discount the rate of the vehicle rental agreement. 
    */
    'additionalCode'?: string;
    /**
    * Code for a promotion or discount. 
    */
    'code'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "additionalCode",
            "baseName": "additionalCode",
            "type": "string"
        },
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsPromotionInformation.attributeTypeMap;
    }
}

export class Ptsv2paymentsRecipientInformation {
    /**
    * Identifier for the recipient’s account. This field is applicable for AFT transactions. 
    */
    'accountId'?: string;
    /**
    * Identifies the recipient’s account type. This field is applicable for AFT transactions.  Valid values are:   - `00` for Other   - `01` for Routing Transit Number (RTN) + Bank Account Number (BAN)   - `02` for International Bank Account Number (IBAN)   - `03` for Card Account   - `06` for Bank Account Number (BAN) + Bank Identification Code (BIC), also known as a SWIFT code 
    */
    'accountType'?: string;
    /**
    * First name of the recipient. This field is applicable for AFT transactions.    Only alpha numeric values are supported. Special characters not in the standard ASCII character set, are not supported and will be stripped before being sent to sent to the processor. 
    */
    'firstName'?: string;
    /**
    * Middle name of the recipient. This field is applicable for AFT transactions.  Only alpha numeric values are supported. Special characters not in the standard ASCII character set, are not supported and will be stripped before being sent to sent to the processor. 
    */
    'middleName'?: string;
    /**
    * Last name of the recipient. This field is applicable for AFT transactions.  Only alpha numeric values are supported. Special characters not in the standard ASCII character set, are not supported and will be stripped before being sent to sent to the processor. 
    */
    'lastName'?: string;
    /**
    * The street address of the recipient This field is applicable for AFT and OCT transactions.  Only alpha numeric values are supported. Special characters not in the standard ASCII character set are not supported and will be stripped before being sent to sent to the processor.          
    */
    'address1'?: string;
    /**
    * The state or province of the recipient. This field is applicable for AFT transactions when the recipient country is US or CA. Else it is optional.  Must be a two character value 
    */
    'administrativeArea'?: string;
    /**
    * Partial postal code for the recipient’s address. For example, if the postal code is **NN5 7SG**, the value for this field should be the first part of the postal code: **NN5**. This field is a _pass-through_, which means that CyberSource does not verify the value or modify it in any way before sending it to the processor. If the field is not required for the transaction, CyberSource does not forward it to the processor. 
    */
    'postalCode'?: string;
    /**
    * The country associated with the address of the recipient. This field is applicable for AFT and OCT transactions.  Must be a two character ISO country code.  For example, see [ISO Country Code](https://developer.cybersource.com/docs/cybs/en-us/country-codes/reference/all/na/country-codes/country-codes.html) 
    */
    'country'?: string;
    /**
    * Recipient’s date of birth. **Format**: `YYYYMMDD`.  This field is a `pass-through`, which means that CyberSource ensures that the value is eight numeric characters but otherwise does not verify the value or modify it in any way before sending it to the processor. If the field is not required for the transaction, CyberSource does not forward it to the processor. 
    */
    'dateOfBirth'?: string;
    /**
    * Only for e-wallets: ID, username, hash or anything uniquely identifying the ultimate beneficiary. 
    */
    'beneficiaryId'?: string;
    /**
    * Only for e-wallets: The ultimate beneficiary’s full name. 
    */
    'beneficiaryName'?: string;
    /**
    * Only for e-wallets: The ultimate beneficiary’s street address (street, zip code, city), excluding the country. Example: “Main street 1, 12345, Barcelona 
    */
    'beneficiaryAddress'?: string;
    /**
    * Account owner alias name. 
    */
    'aliasName'?: string;
    /**
    * Account Owner Nationality
    */
    'nationality'?: string;
    /**
    * Account Owner Country of Birth
    */
    'countryOfBirth'?: string;
    /**
    * Account Owner Occupation
    */
    'occupation'?: string;
    /**
    * Account Owner email address
    */
    'email'?: string;
    /**
    * The city of the recipient. This field is applicable for AFT transactions.  Only alpha numeric values are supported. Special characters not in the standard ASCII character set are not supported and will be stripped before being sent to sent to the processor. 
    */
    'locality'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "accountId",
            "baseName": "accountId",
            "type": "string"
        },
        {
            "name": "accountType",
            "baseName": "accountType",
            "type": "string"
        },
        {
            "name": "firstName",
            "baseName": "firstName",
            "type": "string"
        },
        {
            "name": "middleName",
            "baseName": "middleName",
            "type": "string"
        },
        {
            "name": "lastName",
            "baseName": "lastName",
            "type": "string"
        },
        {
            "name": "address1",
            "baseName": "address1",
            "type": "string"
        },
        {
            "name": "administrativeArea",
            "baseName": "administrativeArea",
            "type": "string"
        },
        {
            "name": "postalCode",
            "baseName": "postalCode",
            "type": "string"
        },
        {
            "name": "country",
            "baseName": "country",
            "type": "string"
        },
        {
            "name": "dateOfBirth",
            "baseName": "dateOfBirth",
            "type": "string"
        },
        {
            "name": "beneficiaryId",
            "baseName": "beneficiaryId",
            "type": "string"
        },
        {
            "name": "beneficiaryName",
            "baseName": "beneficiaryName",
            "type": "string"
        },
        {
            "name": "beneficiaryAddress",
            "baseName": "beneficiaryAddress",
            "type": "string"
        },
        {
            "name": "aliasName",
            "baseName": "aliasName",
            "type": "string"
        },
        {
            "name": "nationality",
            "baseName": "nationality",
            "type": "string"
        },
        {
            "name": "countryOfBirth",
            "baseName": "countryOfBirth",
            "type": "string"
        },
        {
            "name": "occupation",
            "baseName": "occupation",
            "type": "string"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "locality",
            "baseName": "locality",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsRecipientInformation.attributeTypeMap;
    }
}

/**
* This object contains recurring payment information.
*/
export class Ptsv2paymentsRecurringPaymentInformation {
    /**
    * The date after which no further recurring authorizations should be performed. Format: `YYYY-MM-DD` **Note** This field is required for recurring transactions. 
    */
    'endDate': string;
    /**
    * Integer value indicating the minimum number of days between recurring authorizations. A frequency of monthly is indicated by the value 28. Multiple of 28 days will be used to indicate months.  Example: 6 months = 168  Example values accepted (31 days): - 31 - 031 - 0031  **Note** This field is required for recurring transactions. 
    */
    'frequency': number;
    /**
    * Total number of payments for the duration of the recurring subscription. 
    */
    'numberOfPayments'?: number;
    /**
    * Date of original purchase. Required for recurring transactions. Format: `YYYY-MM-DDTHH:MM:SSZ` **Note**: If this field is empty, the current date is used. 
    */
    'originalPurchaseDate'?: string;
    /**
    * This field is mandatory for Cartes Bancaires recurring transactions on Credit Mutuel-CIC.       This field records recurring sequence, e.g. 1st for initial,  2 for subsequent, 3 etc 
    */
    'sequenceNumber'?: number;
    /**
    * This contains the type of recurring payment. Valid Values : 1 - Registration/First transaction 2 - Subsequent transaction 3 - Modification 4 - Cancellation 
    */
    'type'?: string;
    /**
    * This value indicates how often a recurring payment occurs. Valid Values : • 01 (Daily) • 02 (Twice weekly) • 03 (Weekly) • 04 (Ten days) • 05 (Fortnightly) • 06 (Monthly) • 07 (Every two months) • 08 (Trimester) • 09 (Quarterly) • 10 (Twice yearly) • 11 (Annually) • 12 (Unscheduled) 
    */
    'occurrence'?: string;
    /**
    * This tag will contain a value that indicates whether or not the recurring payment transaction has been validated. Valid values : 0- Not validated 1- Validated 
    */
    'validationIndicator'?: string;
    /**
    * Indicates recurring amount type agreed by the cardholder Valid Values : 1- Fixed amount recurring payment 2- Recurring payment with maximum amount 
    */
    'amountType'?: string;
    /**
    * This API field will contain the maximum amount agreed to by the cardholder. The currency of this amount will be specified in Field 49—Currency Code,Transaction. 
    */
    'maximumAmount'?: string;
    /**
    * This will contain a unique reference number for the recurring payment transaction. 
    */
    'referenceNumber'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "endDate",
            "baseName": "endDate",
            "type": "string"
        },
        {
            "name": "frequency",
            "baseName": "frequency",
            "type": "number"
        },
        {
            "name": "numberOfPayments",
            "baseName": "numberOfPayments",
            "type": "number"
        },
        {
            "name": "originalPurchaseDate",
            "baseName": "originalPurchaseDate",
            "type": "string"
        },
        {
            "name": "sequenceNumber",
            "baseName": "sequenceNumber",
            "type": "number"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "occurrence",
            "baseName": "occurrence",
            "type": "string"
        },
        {
            "name": "validationIndicator",
            "baseName": "validationIndicator",
            "type": "string"
        },
        {
            "name": "amountType",
            "baseName": "amountType",
            "type": "string"
        },
        {
            "name": "maximumAmount",
            "baseName": "maximumAmount",
            "type": "string"
        },
        {
            "name": "referenceNumber",
            "baseName": "referenceNumber",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsRecurringPaymentInformation.attributeTypeMap;
    }
}

/**
* This object is only needed when you are requesting both payment and DM services at same time.
*/
export class Ptsv2paymentsRiskInformation {
    'profile'?: Ptsv2paymentsRiskInformationProfile;
    /**
    * Specifies one of the following types of events: - login - account_creation - account_update For regular payment transactions, do not send this field. 
    */
    'eventType'?: string;
    'buyerHistory'?: Ptsv2paymentsRiskInformationBuyerHistory;
    'auxiliaryData'?: Array<Ptsv2paymentsRiskInformationAuxiliaryData>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "profile",
            "baseName": "profile",
            "type": "Ptsv2paymentsRiskInformationProfile"
        },
        {
            "name": "eventType",
            "baseName": "eventType",
            "type": "string"
        },
        {
            "name": "buyerHistory",
            "baseName": "buyerHistory",
            "type": "Ptsv2paymentsRiskInformationBuyerHistory"
        },
        {
            "name": "auxiliaryData",
            "baseName": "auxiliaryData",
            "type": "Array<Ptsv2paymentsRiskInformationAuxiliaryData>"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsRiskInformation.attributeTypeMap;
    }
}

/**
* Contains auxiliary key-value pairs.
*/
export class Ptsv2paymentsRiskInformationAuxiliaryData {
    /**
    * Fields that you can use to send additional data to Risk services. **Warning** Auxiliary fields are not intended to and MUST NOT be used to capture personally identifying information. Accordingly, merchants are prohibited from capturing, obtaining, and/or transmitting any personally identifying information in or via the auxiliary data fields. Personally identifying information includes, but is not limited to, address, credit card number, social security number, driver's license number, state-issued identification number, passport number, and card verification numbers (CVV, CVC2, CVV2, CID, CVN). In the event CyberSource discovers that a merchant is capturing and/or transmitting personally identifying information via the auxiliary data fields, whether or not intentionally, CyberSource WILL immediately suspend the merchant's account, which will result in a rejection of any and all transaction requests submitted by the merchant after the point of suspension. 
    */
    'key'?: string;
    /**
    * String value for the key
    */
    'value'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "key",
            "baseName": "key",
            "type": "string"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsRiskInformationAuxiliaryData.attributeTypeMap;
    }
}

export class Ptsv2paymentsRiskInformationBuyerHistory {
    'customerAccount'?: Ptsv2paymentsRiskInformationBuyerHistoryCustomerAccount;
    'accountHistory'?: Ptsv2paymentsRiskInformationBuyerHistoryAccountHistory;
    /**
    * Number of purchases with this cardholder account during the previous six months. Recommended for Discover ProtectBuy. 
    */
    'accountPurchases'?: number;
    /**
    * Number of add card attempts in the last 24 hours. Recommended for Discover ProtectBuy. 
    */
    'addCardAttempts'?: number;
    /**
    * Indicates whether the merchant experienced suspicious activity (including previous fraud) on the account. Recommended for Discover ProtectBuy. 
    */
    'priorSuspiciousActivity'?: boolean;
    /**
    * This only applies for NEW_ACCOUNT and EXISTING_ACCOUNT in creationHistory. Possible values are: - PAYMENT_ACCOUNT_EXISTS - PAYMENT_ACCOUNT_ADDED_NOW 
    */
    'paymentAccountHistory'?: string;
    /**
    * Date applicable only for PAYMENT_ACCOUNT_EXISTS in paymentAccountHistory 
    */
    'paymentAccountDate'?: number;
    /**
    * Number of transaction (successful or abandoned) for this cardholder account within the last 24 hours. Recommended for Discover ProtectBuy. 
    */
    'transactionCountDay'?: number;
    /**
    * Number of transaction (successful or abandoned) for this cardholder account within the last year. Recommended for Discover ProtectBuy. 
    */
    'transactionCountYear'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "customerAccount",
            "baseName": "customerAccount",
            "type": "Ptsv2paymentsRiskInformationBuyerHistoryCustomerAccount"
        },
        {
            "name": "accountHistory",
            "baseName": "accountHistory",
            "type": "Ptsv2paymentsRiskInformationBuyerHistoryAccountHistory"
        },
        {
            "name": "accountPurchases",
            "baseName": "accountPurchases",
            "type": "number"
        },
        {
            "name": "addCardAttempts",
            "baseName": "addCardAttempts",
            "type": "number"
        },
        {
            "name": "priorSuspiciousActivity",
            "baseName": "priorSuspiciousActivity",
            "type": "boolean"
        },
        {
            "name": "paymentAccountHistory",
            "baseName": "paymentAccountHistory",
            "type": "string"
        },
        {
            "name": "paymentAccountDate",
            "baseName": "paymentAccountDate",
            "type": "number"
        },
        {
            "name": "transactionCountDay",
            "baseName": "transactionCountDay",
            "type": "number"
        },
        {
            "name": "transactionCountYear",
            "baseName": "transactionCountYear",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsRiskInformationBuyerHistory.attributeTypeMap;
    }
}

export class Ptsv2paymentsRiskInformationBuyerHistoryAccountHistory {
    /**
    * Applicable when this is not a guest account. 
    */
    'firstUseOfShippingAddress'?: boolean;
    /**
    * Date when the shipping address for this transaction was first used. Recommended for Discover ProtectBuy. If `firstUseOfShippingAddress` is false and not a guest account, then this date is entered. 
    */
    'shippingAddressUsageDate'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "firstUseOfShippingAddress",
            "baseName": "firstUseOfShippingAddress",
            "type": "boolean"
        },
        {
            "name": "shippingAddressUsageDate",
            "baseName": "shippingAddressUsageDate",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsRiskInformationBuyerHistoryAccountHistory.attributeTypeMap;
    }
}

export class Ptsv2paymentsRiskInformationBuyerHistoryCustomerAccount {
    /**
    * Date the cardholder’s account was last changed. This includes changes to the billing or shipping address, new payment accounts or new users added. Recommended for Discover ProtectBuy. 
    */
    'lastChangeDate'?: string;
    /**
    * The values from the enum can be: - GUEST - NEW_ACCOUNT - EXISTING_ACCOUNT 
    */
    'creationHistory'?: string;
    /**
    * This field is applicable only in case of EXISTING_ACCOUNT in creationHistory. Possible values: - ACCOUNT_UPDATED_NOW - ACCOUNT_UPDATED_PAST 
    */
    'modificationHistory'?: string;
    /**
    * This only applies for EXISTING_ACCOUNT in creationHistory. The values from the enum can be: - PASSWORD_CHANGED_NOW - PASSWORD_CHANGED_PAST - PASSWORD_NEVER_CHANGED 
    */
    'passwordHistory'?: string;
    /**
    * Date the cardholder opened the account. Recommended for Discover ProtectBuy. This only applies for EXISTING_ACCOUNT in creationHistory. 
    */
    'createDate'?: string;
    /**
    * Date the cardholder last changed or reset password on account. Recommended for Discover ProtectBuy. This only applies for PASSWORD_CHANGED_PAST in passwordHistory. 
    */
    'passwordChangeDate'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "lastChangeDate",
            "baseName": "lastChangeDate",
            "type": "string"
        },
        {
            "name": "creationHistory",
            "baseName": "creationHistory",
            "type": "string"
        },
        {
            "name": "modificationHistory",
            "baseName": "modificationHistory",
            "type": "string"
        },
        {
            "name": "passwordHistory",
            "baseName": "passwordHistory",
            "type": "string"
        },
        {
            "name": "createDate",
            "baseName": "createDate",
            "type": "string"
        },
        {
            "name": "passwordChangeDate",
            "baseName": "passwordChangeDate",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsRiskInformationBuyerHistoryCustomerAccount.attributeTypeMap;
    }
}

/**
* Identifies a risk profile.
*/
export class Ptsv2paymentsRiskInformationProfile {
    /**
    * Name of the active profile chosen by the profile selector. If no profile selector exists, the default active profile is chosen.  **Note** By default, your default profile is the active profile, or the Profile Selector chooses the active profile. Use this field only if you want to specify the name of a different profile. The passed-in profile will then become the active profile. 
    */
    'name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsRiskInformationProfile.attributeTypeMap;
    }
}

export class Ptsv2paymentsSenderInformation {
    /**
    * First name of the sender. This field is applicable for AFT and OCT transactions.   Only alpha numeric values are supported.Special characters not in the standard ASCII character set, are not supported and will be stripped before being sent to the processor. 
    */
    'firstName'?: string;
    /**
    * Middle name of the sender. This field is applicable for AFT and OCT transactions.   Only alpha numeric values are supported. Special characters not in the standard ASCII character set, are not supported and will be stripped before being sent to sent to the processor. 
    */
    'middleName'?: string;
    /**
    * Last name of the sender. This field is applicable for AFT and OCT transactions.  Only alpha numeric values are supported. Special characters not in the standard ASCII character set, are not supported and will be stripped before being sent to sent to the processor. 
    */
    'lastName'?: string;
    /**
    * The street address of the sender. This field is applicable for AFT transactions.     Only alpha numeric values are supported.  Special characters not in the standard ASCII character set are not supported and will be stripped before being sent to sent to the processor. 
    */
    'address1'?: string;
    /**
    * The city or locality of the sender. This field is applicable for AFT transactions.  Only alpha numeric values are supported.  Special characters not in the standard ASCII character set are not supported and will be stripped before being sent to sent to the processor. 
    */
    'locality'?: string;
    /**
    * The state or province of the sender. This field is applicable for AFT transactions when the sender country is US or CA. Else it is optional.  Must be a two character value 
    */
    'administrativeArea'?: string;
    /**
    * The country associated with the address of the sender. This field is applicable for AFT transactions.   Must be a two character ISO country code.  For example, see [ISO Country Code](https://developer.cybersource.com/docs/cybs/en-us/country-codes/reference/all/na/country-codes/country-codes.html) 
    */
    'countryCode'?: string;
    /**
    * Sender's alias name.
    */
    'aliasName'?: string;
    /**
    * This field is applicable for AFT transactions.   Contains a transaction reference number provided by the Merchant. Only alpha numeric values are supported. 
    */
    'referenceNumber'?: string;
    'account'?: Ptsv2paymentsSenderInformationAccount;
    /**
    * Postal code of sender. 
    */
    'postalCode'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "firstName",
            "baseName": "firstName",
            "type": "string"
        },
        {
            "name": "middleName",
            "baseName": "middleName",
            "type": "string"
        },
        {
            "name": "lastName",
            "baseName": "lastName",
            "type": "string"
        },
        {
            "name": "address1",
            "baseName": "address1",
            "type": "string"
        },
        {
            "name": "locality",
            "baseName": "locality",
            "type": "string"
        },
        {
            "name": "administrativeArea",
            "baseName": "administrativeArea",
            "type": "string"
        },
        {
            "name": "countryCode",
            "baseName": "countryCode",
            "type": "string"
        },
        {
            "name": "aliasName",
            "baseName": "aliasName",
            "type": "string"
        },
        {
            "name": "referenceNumber",
            "baseName": "referenceNumber",
            "type": "string"
        },
        {
            "name": "account",
            "baseName": "account",
            "type": "Ptsv2paymentsSenderInformationAccount"
        },
        {
            "name": "postalCode",
            "baseName": "postalCode",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsSenderInformation.attributeTypeMap;
    }
}

export class Ptsv2paymentsSenderInformationAccount {
    /**
    * The account number of the entity funding the transaction. The value for this field can be a payment card account number or bank account number. 
    */
    'number'?: string;
    /**
    * Identifies the sender’s account type. This field is applicable for AFT transactions.  Valid values are:   - `00` for Other   - `01` for Routing Transit Number (RTN) + Bank Account Number (BAN)   - `02` for International Bank Account Number (IBAN)   - `03` for Card Account   - `04` for Email   - `05` for Phone Number   - `06` for Bank Account Number (BAN) + Bank Identification Code (BIC), also known as a SWIFT code   - `07` for Wallet ID   - `08` for Social Network ID 
    */
    'type'?: string;
    /**
    * Source of funds. Possible Values:  - `01`: Credit.  - `02`: Debit.  - `03`: Prepaid.  - `04`: Deposit Account.  - `05`: Mobile Money Account.  - `06`: Cash.  - `07`: Other.  - `V5`: Debits / deposit access other than those linked to the cardholders’ scheme.  - `V6`: Credit accounts other than those linked to the cardholder’s scheme. 
    */
    'fundsSource'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "number",
            "baseName": "number",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "fundsSource",
            "baseName": "fundsSource",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsSenderInformationAccount.attributeTypeMap;
    }
}

export class Ptsv2paymentsTokenInformation {
    /**
    * TMS Transient Token, 64 hexadecimal id value representing captured payment credentials (including Sensitive Authentication Data, e.g. CVV). 
    */
    'jti'?: string;
    /**
    * Flex API Transient Token encoded as JWT (JSON Web Token), e.g. Flex microform or Unified Payment checkout result. 
    */
    'transientTokenJwt'?: string;
    'paymentInstrument'?: Ptsv2paymentsTokenInformationPaymentInstrument;
    'shippingAddress'?: Ptsv2paymentsTokenInformationShippingAddress;
    /**
    * Indicates whether a payment network token associated with a TMS token should be used for authorization. This field can contain one of following values:  - `ignore`: Use a tokenized card number for an authorization, even if the TMS token has an associated payment network token. - `prefer`: (Default) Use an associated payment network token for an authorization if the TMS token has one; otherwise, use the tokenized card number. 
    */
    'networkTokenOption'?: string;
    'tokenProvisioningInformation'?: Ptsv2paymentsTokenInformationTokenProvisioningInformation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "jti",
            "baseName": "jti",
            "type": "string"
        },
        {
            "name": "transientTokenJwt",
            "baseName": "transientTokenJwt",
            "type": "string"
        },
        {
            "name": "paymentInstrument",
            "baseName": "paymentInstrument",
            "type": "Ptsv2paymentsTokenInformationPaymentInstrument"
        },
        {
            "name": "shippingAddress",
            "baseName": "shippingAddress",
            "type": "Ptsv2paymentsTokenInformationShippingAddress"
        },
        {
            "name": "networkTokenOption",
            "baseName": "networkTokenOption",
            "type": "string"
        },
        {
            "name": "tokenProvisioningInformation",
            "baseName": "tokenProvisioningInformation",
            "type": "Ptsv2paymentsTokenInformationTokenProvisioningInformation"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsTokenInformation.attributeTypeMap;
    }
}

export class Ptsv2paymentsTokenInformationPaymentInstrument {
    /**
    * Flag that specifies if the Payment Instrument should be made the Customers default. Possible values: - true - false : (default) 
    */
    '_default'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_default",
            "baseName": "default",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsTokenInformationPaymentInstrument.attributeTypeMap;
    }
}

export class Ptsv2paymentsTokenInformationShippingAddress {
    /**
    * Flag that specifies if the Shipping Address should be made the Customers default. Possible values: - true - false : (default) 
    */
    '_default'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_default",
            "baseName": "default",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsTokenInformationShippingAddress.attributeTypeMap;
    }
}

export class Ptsv2paymentsTokenInformationTokenProvisioningInformation {
    /**
    * Flag that indicates whether the user consented to the tokenization of their credentials. Required for card network tokenization in certain markets, such as India. Possible Values: - `true`: Consumer has consented to tokenization of their credentials. - `false`: Consumer has not consented to tokenization of their credentials. 
    */
    'consumerConsentObtained'?: boolean;
    /**
    * Flag that indicates whether AFA (Additional Factor of Authentication) for the PAN was completed. Required for card network tokenization in certain markets, such as India. Possible Values: - `true`: Consumer has been authenticated by the issuer. - `false`: Consumer has not been authenticated by the issuer. 
    */
    'multiFactorAuthenticated'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "consumerConsentObtained",
            "baseName": "consumerConsentObtained",
            "type": "boolean"
        },
        {
            "name": "multiFactorAuthenticated",
            "baseName": "multiFactorAuthenticated",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsTokenInformationTokenProvisioningInformation.attributeTypeMap;
    }
}

export class Ptsv2paymentsTravelInformation {
    /**
    * Duration of the auto rental or lodging rental.  #### Auto rental This field is supported for Visa, MasterCard, and American Express. **Important** If this field is not included when the `processingInformation.industryDataType` is auto rental, the transaction is declined. 
    */
    'duration'?: string;
    'agency'?: Ptsv2paymentsTravelInformationAgency;
    'autoRental'?: Ptsv2paymentsTravelInformationAutoRental;
    'lodging'?: Ptsv2paymentsTravelInformationLodging;
    'transit'?: Ptsv2paymentsTravelInformationTransit;
    'vehicleData'?: Ptsv2paymentsTravelInformationVehicleData;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "duration",
            "baseName": "duration",
            "type": "string"
        },
        {
            "name": "agency",
            "baseName": "agency",
            "type": "Ptsv2paymentsTravelInformationAgency"
        },
        {
            "name": "autoRental",
            "baseName": "autoRental",
            "type": "Ptsv2paymentsTravelInformationAutoRental"
        },
        {
            "name": "lodging",
            "baseName": "lodging",
            "type": "Ptsv2paymentsTravelInformationLodging"
        },
        {
            "name": "transit",
            "baseName": "transit",
            "type": "Ptsv2paymentsTravelInformationTransit"
        },
        {
            "name": "vehicleData",
            "baseName": "vehicleData",
            "type": "Ptsv2paymentsTravelInformationVehicleData"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsTravelInformation.attributeTypeMap;
    }
}

export class Ptsv2paymentsTravelInformationAgency {
    /**
    * International Air Transport Association (IATA) code of travel agency that made the vehicle rental reservation. 
    */
    'code'?: string;
    /**
    * Name of travel agency that made the reservation. 
    */
    'name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsTravelInformationAgency.attributeTypeMap;
    }
}

export class Ptsv2paymentsTravelInformationAutoRental {
    /**
    * No Show Indicator provides an indicator noting that the individual did not show up after making a reservation for a vehicle. Possible values: - true - false 
    */
    'noShowIndicator'?: boolean;
    /**
    * Name of the individual making the rental agreement.  Valid data lengths by card:  |Card Specific Validation|VISA|MasterCard|Discover|AMEX| |--- |--- |--- |--- | | Filed Length| 40| 40| 29| 26| | Field Type| AN| ANS| AN| AN| | M/O/C| O| M| M| M| 
    */
    'customerName'?: string;
    /**
    * Classification of the rented auto.  **NOTE** For VISA, this is a 2-byte optional code.  Valid values for American Express & MasterCard:  |American Express |MasterCard |Description| |--- |--- |--- | | 0001| 0001| Mini| | 0002| 0002| Subcompact| | 0003| 0003| Economy| | 0004| 0004| Compact| | 0005| 0005| Midsize| | 0006| 0006| Intermediate| | 0007| 0007| Standard| | 0008| 0008| Fulll size| | 0009| 0009| Luxury| | 0010| 0010| Premium| | 0011| 0011| Minivan| | 0012| 0012| 12-passenger van| | 0013| 0013| Moving van| | 0014| 0014| 15-passenger van| | 0015| 0015| Cargo van| | 0016| 0016| 12-foot truck| | 0017| 0017| 20-foot truck| | 0018| 0018| 24-foot truck| | 0019| 0019| 26-foot truck| | 0020| 0020| Moped| | 0021| 0021| Stretch| | 0022| 0022| Regular| | 0023| 0023| Unique| | 0024| 0024| Exotic| | 0025| 0025| Small/medium truck| | 0026| 0026| Large truck| | 0027| 0027| Small SUV| | 0028| 0028| Medium SUV| | 0029| 0029| Large SUV| | 0030| 0030| Exotic SUV| | 9999| 9999| Miscellaneous|  Additional Values allowed **only** for `American Express`:  |American Express|MasterCard|Description| |--- |--- |--- | | 0031| NA| Four Wheel Drive| | 0032| NA| Special| | 0099| NA| Taxi| 
    */
    'vehicleClass'?: string;
    /**
    * Total number of miles driven by the customer. This field is supported only for MasterCard and American Express. 
    */
    'distanceTravelled'?: string;
    /**
    * Miles/Kilometers Indicator shows whether the “miles” fields are expressed in miles or kilometers.  Allowed values: - `K` - Kilometers - `M` - Miles 
    */
    'distanceUnit'?: string;
    /**
    * Date/time the auto was returned to the rental agency. Format: ``yyyy-MM-dd HH-mm-ss z`` This field is supported for Visa, MasterCard, and American Express. 
    */
    'returnDateTime'?: string;
    /**
    * Date/time the auto was picked up from the rental agency. Format: `yyyy-MM-dd HH-mm-ss z` This field is supported for Visa, MasterCard, and American Express. 
    */
    'rentalDateTime'?: string;
    /**
    * Maximum number of free miles or kilometers allowed to a customer for the duration of the auto rental agreement. This field is supported only for MasterCard and American Express. 
    */
    'maxFreeDistance'?: string;
    /**
    * Used for MC and Discover  Valid values: - `true` - Yes (insurance was purchased) - `false` - No (insurance was not purchased) 
    */
    'insuranceIndicator'?: boolean;
    /**
    * Used to identify special circumstances applicable to the Card Transaction or Cardholder, such as \"renter” or ”show”.  This code is `2 digit` value agreed by Merchant and processor. 
    */
    'programCode'?: string;
    'returnAddress'?: Ptsv2paymentsTravelInformationAutoRentalReturnAddress;
    'rentalAddress'?: Ptsv2paymentsTravelInformationAutoRentalRentalAddress;
    /**
    * Auto rental agency’s agreement (invoice) number provided to the customer. It is used to trace any inquiries about transactions. This field is supported for Visa, MasterCard, and American Express. This Merchant-defined value, which may be composed of any combination of characters and/or numerals, may become part of the descriptive bill on the Cardmember's statement. 
    */
    'agreementNumber'?: string;
    /**
    * Odometer reading at time of vehicle rental. 
    */
    'odometerReading'?: string;
    /**
    * This field contains a unique identifier assigned by the company to the vehicle. 
    */
    'vehicleIdentificationNumber'?: string;
    /**
    * Corporate Identifier provides the unique identifier of the corporation or entity renting the vehicle:  |Card Specific Validation|VISA|MasterCard|Discover|AMEX| |--- |--- |--- |--- | | Filed Length| NA| 12| NA| NA| | Field Type| NA| AN| NA| NA| | M/O/C| NA| O| NA| NA| 
    */
    'companyId'?: string;
    /**
    * The number of additional drivers included on the rental agreement not including the individual who signed the rental agreement. 
    */
    'numberOfAdditionalDrivers'?: string;
    /**
    * Age of the driver renting the vehicle. 
    */
    'driverAge'?: string;
    /**
    * Program code used to identify special circumstances, such as “frequent renter” or “no show” status for the renter. Possible values: - `0`: not applicable (default) - `1`: frequent renter - `2`: no show  For authorizations, this field is supported only for Visa.  For captures, this field is supported for Visa, MasterCard, and American Express.  Code for special programs applicable to the Card Transaction or the Cardholder. 
    */
    'specialProgramCode'?: string;
    /**
    * Make of the vehicle being rented (e.g., Chevrolet or Ford). 
    */
    'vehicleMake'?: string;
    /**
    * Model of the vehicle being rented (e.g., Cavalier or Focus). 
    */
    'vehicleModel'?: string;
    /**
    * Indicates the time period for which the vehicle rental rate applies (e.g., daily, weekly or monthly). Daily, Weekly and Monthly are valid values. 
    */
    'timePeriod'?: string;
    /**
    * Commodity code or International description code used to classify the item. Contact your acquirer for a list of codes. 
    */
    'commodityCode'?: string;
    /**
    * Customer service telephone number that is used to resolve questions or disputes. Include the area code, exchange, and number. This field is supported only for MasterCard and American Express. 
    */
    'customerServicePhoneNumber'?: string;
    'taxDetails'?: Ptsv2paymentsTravelInformationAutoRentalTaxDetails;
    /**
    * Insurance charges. Field is conditional and can include decimal point. 
    */
    'insuranceAmount'?: string;
    /**
    * Extra charges incurred for a one-way rental agreement for the auto. This field is supported only for Visa. 
    */
    'oneWayDropOffAmount'?: string;
    /**
    * For **MasterCard** and **Discover**: Adjusted amount indicator code that indicates any miscellaneous charges incurred after the auto was returned. Possible values: - `A` - Drop-off charges - `B` - Delivery charges - `C` - Parking expenses - `D` - Extra hours - `E` - Violations - `X` - More than one of the above charges  For **American Express**: Audit indicator code that indicates any adjustment for mileage, fuel, auto damage, etc. made to a rental agreement and whether the cardholder was notified.  Possible value for the authorization service: - `A` (default): adjustment amount greater than 0 (zero)  Possible values for the capture service: - `X` - Multiple adjustments - `Y` - One adjustment only; Cardmember notified - `Z` - One adjustment only; Cardmember not notified. This value is used as the default if the request does not include this field and includes an adjustment amount greater than 0 (zero). This is an optional field. 
    */
    'adjustedAmountIndicator'?: string;
    /**
    * Adjusted Amount indicates whether any miscellaneous charges were incurred after the vehicle was returned.  For authorizations, this field is supported only for American Express.  For captures, this field is supported only for MasterCard and American Express. **NOTE** For American Express, this field is required if the `travelInformation.autoRental.adjustedAmountIndicator` field is included in the request and has a value; otherwise, this field is optional.  For all other card types, this field is ignored. 
    */
    'adjustedAmount'?: string;
    /**
    * Extra gasoline charges that extend beyond the basic rental agreement. This field is supported only for Visa. 
    */
    'fuelCharges'?: string;
    /**
    * Weekly Rental Amount provides the amount charged for a seven-day rental period. Field - Time Period needs to be populated with Weekly if this field is present 
    */
    'weeklyRentalRate'?: string;
    /**
    * Daily auto rental rate charged. This field is supported only for MasterCard and American Express.  Field - Time Period needs to be populated with Daily if this field is present 
    */
    'dailyRentalRate'?: string;
    /**
    * Rate charged for each mile. This field is supported only for MasterCard and American Express. 
    */
    'ratePerMile'?: string;
    /**
    * Regular Mileage Charge provides the amount charged for regular miles traveled during vehicle rental. Two decimal places 
    */
    'mileageCharge'?: string;
    /**
    * Extra mileage charges that extend beyond the basic rental agreement. This field is supported only for Visa. 
    */
    'extraMileageCharge'?: string;
    /**
    * Extra charges related to a late return of the rented auto. This field is supported only for Visa. 
    */
    'lateFeeAmount'?: string;
    /**
    * (Towing Charges) provides the amount charged to tow the rental vehicle. 
    */
    'towingCharge'?: string;
    /**
    * (Extra Charges) provides the extra charges associated with the vehicle rental. 
    */
    'extraCharge'?: string;
    /**
    * Amount charged for renting a Global Positioning Service (GPS). 
    */
    'gpsCharge'?: string;
    /**
    * Additional charges incurred for phone usage included on the total bill. 
    */
    'phoneCharge'?: string;
    /**
    * Extra charges incurred due to a parking violation for the auto. This field is supported only for Visa. 
    */
    'parkingViolationCharge'?: string;
    /**
    * Total amount charged for all other miscellaneous charges not previously defined. 
    */
    'otherCharges'?: string;
    /**
    * Merchant to send their auto rental company name 
    */
    'companyName'?: string;
    /**
    * When merchant wants to send the affiliate name. 
    */
    'affiliateName'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "noShowIndicator",
            "baseName": "noShowIndicator",
            "type": "boolean"
        },
        {
            "name": "customerName",
            "baseName": "customerName",
            "type": "string"
        },
        {
            "name": "vehicleClass",
            "baseName": "vehicleClass",
            "type": "string"
        },
        {
            "name": "distanceTravelled",
            "baseName": "distanceTravelled",
            "type": "string"
        },
        {
            "name": "distanceUnit",
            "baseName": "distanceUnit",
            "type": "string"
        },
        {
            "name": "returnDateTime",
            "baseName": "returnDateTime",
            "type": "string"
        },
        {
            "name": "rentalDateTime",
            "baseName": "rentalDateTime",
            "type": "string"
        },
        {
            "name": "maxFreeDistance",
            "baseName": "maxFreeDistance",
            "type": "string"
        },
        {
            "name": "insuranceIndicator",
            "baseName": "insuranceIndicator",
            "type": "boolean"
        },
        {
            "name": "programCode",
            "baseName": "programCode",
            "type": "string"
        },
        {
            "name": "returnAddress",
            "baseName": "returnAddress",
            "type": "Ptsv2paymentsTravelInformationAutoRentalReturnAddress"
        },
        {
            "name": "rentalAddress",
            "baseName": "rentalAddress",
            "type": "Ptsv2paymentsTravelInformationAutoRentalRentalAddress"
        },
        {
            "name": "agreementNumber",
            "baseName": "agreementNumber",
            "type": "string"
        },
        {
            "name": "odometerReading",
            "baseName": "odometerReading",
            "type": "string"
        },
        {
            "name": "vehicleIdentificationNumber",
            "baseName": "vehicleIdentificationNumber",
            "type": "string"
        },
        {
            "name": "companyId",
            "baseName": "companyId",
            "type": "string"
        },
        {
            "name": "numberOfAdditionalDrivers",
            "baseName": "numberOfAdditionalDrivers",
            "type": "string"
        },
        {
            "name": "driverAge",
            "baseName": "driverAge",
            "type": "string"
        },
        {
            "name": "specialProgramCode",
            "baseName": "specialProgramCode",
            "type": "string"
        },
        {
            "name": "vehicleMake",
            "baseName": "vehicleMake",
            "type": "string"
        },
        {
            "name": "vehicleModel",
            "baseName": "vehicleModel",
            "type": "string"
        },
        {
            "name": "timePeriod",
            "baseName": "timePeriod",
            "type": "string"
        },
        {
            "name": "commodityCode",
            "baseName": "commodityCode",
            "type": "string"
        },
        {
            "name": "customerServicePhoneNumber",
            "baseName": "customerServicePhoneNumber",
            "type": "string"
        },
        {
            "name": "taxDetails",
            "baseName": "taxDetails",
            "type": "Ptsv2paymentsTravelInformationAutoRentalTaxDetails"
        },
        {
            "name": "insuranceAmount",
            "baseName": "insuranceAmount",
            "type": "string"
        },
        {
            "name": "oneWayDropOffAmount",
            "baseName": "oneWayDropOffAmount",
            "type": "string"
        },
        {
            "name": "adjustedAmountIndicator",
            "baseName": "adjustedAmountIndicator",
            "type": "string"
        },
        {
            "name": "adjustedAmount",
            "baseName": "adjustedAmount",
            "type": "string"
        },
        {
            "name": "fuelCharges",
            "baseName": "fuelCharges",
            "type": "string"
        },
        {
            "name": "weeklyRentalRate",
            "baseName": "weeklyRentalRate",
            "type": "string"
        },
        {
            "name": "dailyRentalRate",
            "baseName": "dailyRentalRate",
            "type": "string"
        },
        {
            "name": "ratePerMile",
            "baseName": "ratePerMile",
            "type": "string"
        },
        {
            "name": "mileageCharge",
            "baseName": "mileageCharge",
            "type": "string"
        },
        {
            "name": "extraMileageCharge",
            "baseName": "extraMileageCharge",
            "type": "string"
        },
        {
            "name": "lateFeeAmount",
            "baseName": "lateFeeAmount",
            "type": "string"
        },
        {
            "name": "towingCharge",
            "baseName": "towingCharge",
            "type": "string"
        },
        {
            "name": "extraCharge",
            "baseName": "extraCharge",
            "type": "string"
        },
        {
            "name": "gpsCharge",
            "baseName": "gpsCharge",
            "type": "string"
        },
        {
            "name": "phoneCharge",
            "baseName": "phoneCharge",
            "type": "string"
        },
        {
            "name": "parkingViolationCharge",
            "baseName": "parkingViolationCharge",
            "type": "string"
        },
        {
            "name": "otherCharges",
            "baseName": "otherCharges",
            "type": "string"
        },
        {
            "name": "companyName",
            "baseName": "companyName",
            "type": "string"
        },
        {
            "name": "affiliateName",
            "baseName": "affiliateName",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsTravelInformationAutoRental.attributeTypeMap;
    }
}

export class Ptsv2paymentsTravelInformationAutoRentalRentalAddress {
    /**
    * City in which the auto was rented.  For authorizations, this field is supported for Visa, MasterCard, and American Express.  For captures, this field is supported only for American Express.  For all other card types, this field is ignored. 
    */
    'city'?: string;
    /**
    * State in which the auto was rented. Use the [State, Province, and Territory Codes for the United States and Canada](https://developer.cybersource.com/library/documentation/sbc/quickref/states_and_provinces.pdf). 
    */
    'state'?: string;
    /**
    * Country where the auto was rented. Use the [ISO Standard Country Codes.](https://developer.cybersource.com/library/documentation/sbc/quickref/countries_alpha_list.pdf) This field is supported only for American Express. 
    */
    'country'?: string;
    /**
    * The agency code, address, phone number, etc., used to identify the location where the vehicle was rented. 
    */
    'locationId'?: string;
    /**
    * Address from where the vehicle was rented. 
    */
    'address1'?: string;
    /**
    * Address from where the vehicle was rented. 
    */
    'address2'?: string;
    /**
    * When merchant wants to send the rental address's postal code. 
    */
    'postalCode'?: string;
    /**
    * This field contains the location where a taxi passenger was picked up or where an auto rental vehicle was picked up. In most cases, this is the rental agency's business name that appears on the storefront and/or customer receipts, commonly referred to as the DBA (Doing Business As) name. However, if the vehicle was picked up at another location (e.g., a hotel,auto dealership, repair shop, etc.), the name of that location should be used. This entry must be easily recognized by the Cardmember to avoid unnecessary inquiries. If the name is more than 38  characters, use proper and meaningful abbreviation, when possible. 
    */
    'location'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "city",
            "baseName": "city",
            "type": "string"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "string"
        },
        {
            "name": "country",
            "baseName": "country",
            "type": "string"
        },
        {
            "name": "locationId",
            "baseName": "locationId",
            "type": "string"
        },
        {
            "name": "address1",
            "baseName": "address1",
            "type": "string"
        },
        {
            "name": "address2",
            "baseName": "address2",
            "type": "string"
        },
        {
            "name": "postalCode",
            "baseName": "postalCode",
            "type": "string"
        },
        {
            "name": "location",
            "baseName": "location",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsTravelInformationAutoRentalRentalAddress.attributeTypeMap;
    }
}

export class Ptsv2paymentsTravelInformationAutoRentalReturnAddress {
    /**
    * City where the auto was returned to the rental agency. 
    */
    'city'?: string;
    /**
    * State in which the auto was returned to the rental agency. Use the [State, Province, and Territory Codes for the United States and Canada](https://developer.cybersource.com/library/documentation/sbc/quickref/states_and_provinces.pdf).  For authorizations, this field is supported for Visa, MasterCard, and American Express.  For captures, this field is supported only for MasterCard and American Express. 
    */
    'state'?: string;
    /**
    * Country where the auto was returned to the rental agency. Use the [ISO Standard Country Codes](https://developer.cybersource.com/library/documentation/sbc/quickref/countries_alpha_list.pdf). 
    */
    'country'?: string;
    /**
    * Code, address, phone number, etc. used to identify the location of the auto rental return. This field is supported only for MasterCard and American Express. 
    */
    'locationId'?: string;
    /**
    * When merchant wants to send the rental address's street address. 
    */
    'address1'?: string;
    /**
    * When merchant wants to send the return address's postal code. 
    */
    'postalCode'?: string;
    /**
    * This field contains the location where the taxi passenger was dropped off or where the auto rental vehicle was returned. 
    */
    'location'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "city",
            "baseName": "city",
            "type": "string"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "string"
        },
        {
            "name": "country",
            "baseName": "country",
            "type": "string"
        },
        {
            "name": "locationId",
            "baseName": "locationId",
            "type": "string"
        },
        {
            "name": "address1",
            "baseName": "address1",
            "type": "string"
        },
        {
            "name": "postalCode",
            "baseName": "postalCode",
            "type": "string"
        },
        {
            "name": "location",
            "baseName": "location",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsTravelInformationAutoRentalReturnAddress.attributeTypeMap;
    }
}

export class Ptsv2paymentsTravelInformationAutoRentalTaxDetails {
    /**
    * Indicates the amount of tax based on the `type` field as described in the table below: 
    */
    'amount'?: string;
    /**
    * Rate of VAT or other tax for the order.  Example 0.040 (=4%)  Valid range: 0.01 to 0.99 (1% to 99%, with only whole percentage values accepted; values with additional decimal places will be truncated) 
    */
    'rate'?: string;
    /**
    * Flag that indicates whether the tax amount (`travelInformation.autoRental.taxDetails.amount`) is included in the request.  Possible values: - `false`: tax amount is not included in the request. - `true`:  tax amount is included in the request. 
    */
    'applied'?: boolean;
    /**
    * Status code for exemption from sales and use tax. This field is a pass-through, which means that CyberSource does not verify the value or modify it in any way before sending it to the processor. 
    */
    'exemptionCode'?: string;
    /**
    * Different taxes the rental agency applies to the rental agreement such as tourist tax, airport tax, or rental tax. 
    */
    'taxType'?: string;
    /**
    * Summary of all tax types 
    */
    'taxSummary'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "amount",
            "baseName": "amount",
            "type": "string"
        },
        {
            "name": "rate",
            "baseName": "rate",
            "type": "string"
        },
        {
            "name": "applied",
            "baseName": "applied",
            "type": "boolean"
        },
        {
            "name": "exemptionCode",
            "baseName": "exemptionCode",
            "type": "string"
        },
        {
            "name": "taxType",
            "baseName": "taxType",
            "type": "string"
        },
        {
            "name": "taxSummary",
            "baseName": "taxSummary",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsTravelInformationAutoRentalTaxDetails.attributeTypeMap;
    }
}

export class Ptsv2paymentsTravelInformationLodging {
    /**
    * Date on which the guest checked in. In the case of a no-show or a reservation, the scheduled arrival date. Format: `MMDDYY`. For best interchange rates, make sure it is a valid date. 
    */
    'checkInDate'?: string;
    /**
    * Date on which the guest checked out. Format: `MMDDYY`. For best interchange rates, make sure it is a valid date. 
    */
    'checkOutDate'?: string;
    /**
    * The object containing the number of nights and the daily rate that applies for that no of nights. 
    */
    'room'?: Array<Ptsv2paymentsTravelInformationLodgingRoom>;
    /**
    * Smoking preference of the guest. Possible values: - `Y`: smoking room - `N`: non-smoking room 
    */
    'smokingPreference'?: string;
    /**
    * Number of rooms booked by the cardholder. 
    */
    'numberOfRooms'?: number;
    /**
    * Number of guests staying in the room. 
    */
    'numberOfGuests'?: number;
    /**
    * Type of room, such as queen, king, or two doubles. 
    */
    'roomBedType'?: string;
    /**
    * Type of tax, such as tourist or hotel. 
    */
    'roomTaxType'?: string;
    /**
    * Type of rate, such as corporate or senior citizen. 
    */
    'roomRateType'?: string;
    /**
    * Name of the guest under which the room is reserved. 
    */
    'guestName'?: string;
    /**
    * Your toll-free customer service phone number. 
    */
    'customerServicePhoneNumber'?: string;
    /**
    * Code assigned to a business. You can use this code to identify corporate rates and discounts for guests. 
    */
    'corporateClientCode'?: string;
    /**
    * Amount of an additional coupon or discount. 
    */
    'additionalDiscountAmount'?: string;
    /**
    * Location of room, such as lake view or ocean view. 
    */
    'roomLocation'?: string;
    /**
    * Code that identifies special circumstances. Possible values: - `1`: lodging (default) - `2`: no show reservation - `3`: advanced deposit 
    */
    'specialProgramCode'?: string;
    /**
    * Total tax amount. 
    */
    'totalTaxAmount'?: string;
    /**
    * Prepaid amount, such as a deposit. 
    */
    'prepaidCost'?: string;
    /**
    * Cost for all food and beverages. 
    */
    'foodAndBeverageCost'?: string;
    /**
    * Total tax for the room. 
    */
    'roomTaxAmount'?: string;
    /**
    * Adjusted amount charged in addition to the reservation amount after the stay is complete. 
    */
    'adjustmentAmount'?: string;
    /**
    * Cost of telephone services. 
    */
    'phoneCost'?: string;
    /**
    * Cost of restaurant purchases 
    */
    'restaurantCost'?: string;
    /**
    * Cost of room service. 
    */
    'roomServiceCost'?: string;
    /**
    * Cost of mini-bar purchases. 
    */
    'miniBarCost'?: string;
    /**
    * Cost of laundry services. 
    */
    'laundryCost'?: string;
    /**
    * Miscellaneous costs. 
    */
    'miscellaneousCost'?: string;
    /**
    * Cost of gift shop purchases. 
    */
    'giftShopCost'?: string;
    /**
    * Cost of movies. 
    */
    'movieCost'?: string;
    /**
    * Cost of health club services. 
    */
    'healthClubCost'?: string;
    /**
    * Cost of valet parking services. 
    */
    'valetParkingCost'?: string;
    /**
    * Cost of the cash that was disbursed plus any associated service fees 
    */
    'cashDisbursementCost'?: string;
    /**
    * Cost of non-room purchases, such as meals and gifts. 
    */
    'nonRoomCost'?: string;
    /**
    * Cost of business center services. 
    */
    'businessCenterCost'?: string;
    /**
    * Cost of lounge and bar purchases. 
    */
    'loungeBarCost'?: string;
    /**
    * Cost of transportation services. 
    */
    'transportationCost'?: string;
    /**
    * Gratuity. 
    */
    'gratuityAmount'?: string;
    /**
    * Cost of conference room services. 
    */
    'conferenceRoomCost'?: string;
    /**
    * Cost of audio visual services. 
    */
    'audioVisualCost'?: string;
    /**
    * Cost of banquet services. 
    */
    'banquestCost'?: string;
    /**
    * Tax on non-room purchases. 
    */
    'nonRoomTaxAmount'?: string;
    /**
    * Service fee for early departure. 
    */
    'earlyCheckOutCost'?: string;
    /**
    * Cost of Internet access. 
    */
    'internetAccessCost'?: string;
    /**
    * Name of the hotel for which the reservation is for. Mandatory in case the merchant’s business type is Hotel. 
    */
    'name'?: string;
    /**
    * The name of the hotel for which the reservation was made. 
    */
    'hotelName'?: string;
    /**
    * The date of the check-in in GMT+8 offset. 
    */
    'checkInDateTime'?: string;
    /**
    * The date of the check-out in GMT+8 offset. 
    */
    'checkOutDateTime'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "checkInDate",
            "baseName": "checkInDate",
            "type": "string"
        },
        {
            "name": "checkOutDate",
            "baseName": "checkOutDate",
            "type": "string"
        },
        {
            "name": "room",
            "baseName": "room",
            "type": "Array<Ptsv2paymentsTravelInformationLodgingRoom>"
        },
        {
            "name": "smokingPreference",
            "baseName": "smokingPreference",
            "type": "string"
        },
        {
            "name": "numberOfRooms",
            "baseName": "numberOfRooms",
            "type": "number"
        },
        {
            "name": "numberOfGuests",
            "baseName": "numberOfGuests",
            "type": "number"
        },
        {
            "name": "roomBedType",
            "baseName": "roomBedType",
            "type": "string"
        },
        {
            "name": "roomTaxType",
            "baseName": "roomTaxType",
            "type": "string"
        },
        {
            "name": "roomRateType",
            "baseName": "roomRateType",
            "type": "string"
        },
        {
            "name": "guestName",
            "baseName": "guestName",
            "type": "string"
        },
        {
            "name": "customerServicePhoneNumber",
            "baseName": "customerServicePhoneNumber",
            "type": "string"
        },
        {
            "name": "corporateClientCode",
            "baseName": "corporateClientCode",
            "type": "string"
        },
        {
            "name": "additionalDiscountAmount",
            "baseName": "additionalDiscountAmount",
            "type": "string"
        },
        {
            "name": "roomLocation",
            "baseName": "roomLocation",
            "type": "string"
        },
        {
            "name": "specialProgramCode",
            "baseName": "specialProgramCode",
            "type": "string"
        },
        {
            "name": "totalTaxAmount",
            "baseName": "totalTaxAmount",
            "type": "string"
        },
        {
            "name": "prepaidCost",
            "baseName": "prepaidCost",
            "type": "string"
        },
        {
            "name": "foodAndBeverageCost",
            "baseName": "foodAndBeverageCost",
            "type": "string"
        },
        {
            "name": "roomTaxAmount",
            "baseName": "roomTaxAmount",
            "type": "string"
        },
        {
            "name": "adjustmentAmount",
            "baseName": "adjustmentAmount",
            "type": "string"
        },
        {
            "name": "phoneCost",
            "baseName": "phoneCost",
            "type": "string"
        },
        {
            "name": "restaurantCost",
            "baseName": "restaurantCost",
            "type": "string"
        },
        {
            "name": "roomServiceCost",
            "baseName": "roomServiceCost",
            "type": "string"
        },
        {
            "name": "miniBarCost",
            "baseName": "miniBarCost",
            "type": "string"
        },
        {
            "name": "laundryCost",
            "baseName": "laundryCost",
            "type": "string"
        },
        {
            "name": "miscellaneousCost",
            "baseName": "miscellaneousCost",
            "type": "string"
        },
        {
            "name": "giftShopCost",
            "baseName": "giftShopCost",
            "type": "string"
        },
        {
            "name": "movieCost",
            "baseName": "movieCost",
            "type": "string"
        },
        {
            "name": "healthClubCost",
            "baseName": "healthClubCost",
            "type": "string"
        },
        {
            "name": "valetParkingCost",
            "baseName": "valetParkingCost",
            "type": "string"
        },
        {
            "name": "cashDisbursementCost",
            "baseName": "cashDisbursementCost",
            "type": "string"
        },
        {
            "name": "nonRoomCost",
            "baseName": "nonRoomCost",
            "type": "string"
        },
        {
            "name": "businessCenterCost",
            "baseName": "businessCenterCost",
            "type": "string"
        },
        {
            "name": "loungeBarCost",
            "baseName": "loungeBarCost",
            "type": "string"
        },
        {
            "name": "transportationCost",
            "baseName": "transportationCost",
            "type": "string"
        },
        {
            "name": "gratuityAmount",
            "baseName": "gratuityAmount",
            "type": "string"
        },
        {
            "name": "conferenceRoomCost",
            "baseName": "conferenceRoomCost",
            "type": "string"
        },
        {
            "name": "audioVisualCost",
            "baseName": "audioVisualCost",
            "type": "string"
        },
        {
            "name": "banquestCost",
            "baseName": "banquestCost",
            "type": "string"
        },
        {
            "name": "nonRoomTaxAmount",
            "baseName": "nonRoomTaxAmount",
            "type": "string"
        },
        {
            "name": "earlyCheckOutCost",
            "baseName": "earlyCheckOutCost",
            "type": "string"
        },
        {
            "name": "internetAccessCost",
            "baseName": "internetAccessCost",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "hotelName",
            "baseName": "hotelName",
            "type": "string"
        },
        {
            "name": "checkInDateTime",
            "baseName": "checkInDateTime",
            "type": "string"
        },
        {
            "name": "checkOutDateTime",
            "baseName": "checkOutDateTime",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsTravelInformationLodging.attributeTypeMap;
    }
}

export class Ptsv2paymentsTravelInformationLodgingRoom {
    /**
    * Daily cost of the room. 
    */
    'dailyRate'?: string;
    /**
    * Number of nights billed at the rate specified by `travelInformation.lodging.room[].dailyRate`. 
    */
    'numberOfNights'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "dailyRate",
            "baseName": "dailyRate",
            "type": "string"
        },
        {
            "name": "numberOfNights",
            "baseName": "numberOfNights",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsTravelInformationLodgingRoom.attributeTypeMap;
    }
}

export class Ptsv2paymentsTravelInformationTransit {
    'airline'?: Ptsv2paymentsTravelInformationTransitAirline;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "airline",
            "baseName": "airline",
            "type": "Ptsv2paymentsTravelInformationTransitAirline"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsTravelInformationTransit.attributeTypeMap;
    }
}

export class Ptsv2paymentsTravelInformationTransitAirline {
    /**
    * Specifies if the flight is: Domestic (01) International (02) If Y then 01 else 02 
    */
    'isDomestic'?: string;
    /**
    * Reference number for the airline booking. Required if ticket numbers are not issued. 
    */
    'bookingReferenceNumber'?: string;
    /**
    * Airline that generated the ticket. Format: English characters only. Optional request field. 
    */
    'carrierName'?: string;
    'ticketIssuer'?: Ptsv2paymentsTravelInformationTransitAirlineTicketIssuer;
    /**
    * Ticket number. Format: English characters only. Restricted string data type that indicates a sequence of letters, numbers, and spaces; special characters are not included. Optional request field. 
    */
    'ticketNumber'?: string;
    /**
    * Check digit for the ticket number. CyberSource recommends that you validate the check digit. With Discover and Diners Club, a valid ticket number has these characteristics: - The value is numeric. - The first three digits are a valid IATA2 license plate carrier code. - The last digit is a check digit or zero (0). - All remaining digits are nonzero. 
    */
    'checkDigit'?: string;
    /**
    * Flag that indicates whether or not the ticket is restricted (nonrefundable). Possible values: - 0: No restriction (refundable) - 1: Restricted (nonrefundable) Format: English characters only. Restricted string data type that indicates a sequence of letters, numbers, and spaces; special characters are not included. Optional request field. 
    */
    'restrictedTicketIndicator'?: number;
    /**
    * Type of charge. Possible values: - 01: Charge is for an airline ticket - 02: Charge is for an item that is not an airline ticket 
    */
    'transactionType'?: number;
    /**
    * The field is not currently supported. 
    */
    'extendedPaymentCode'?: string;
    /**
    * Name of the passenger to whom the ticket was issued.  This will always be a single passenger's name. If there are more than one passengers, provide only the primary passenger's name. Do not include special characters such as commas, hyphens, or apostrophes. Only ASCII characters are supported. Format: English characters only. Optional request field. 
    */
    'passengerName'?: string;
    /**
    * Reference number or code that identifies the cardholder. Format: English characters only. Restricted string data type that indicates a sequence of letters, numbers, and spaces; special characters are not included. Optional request field. 
    */
    'customerCode'?: string;
    /**
    * Airline document type code that specifies the purpose of the transaction. Format: English characters only. Optional request field.  | Code | Description | | --- | --- | | 01 | Passenger ticket | | 02 | Additional collection | | 03 | Excess baggage | | 04 | Miscellaneous charge order (MCO) or prepaid ticket authorization | | 05 | Special service ticket | | 06 | Supported refund | | 07 | Unsupported refund | | 08 | Lost ticket application | | 09 | Tour order voucher | | 10 | Ticket by mail | | 11 | Undercharge adjustment | | 12 | Group ticket | | 13 | Exchange adjustment | | 14 | SPD or air freight | | 15 | In-flight adjustment | | 16 | Agency passenger ticket | | 17 | Agency tour order or voucher | | 18 | Agency miscellaneous charge order (MCO) | | 19 | Agency exchange order | | 20 | Agency group ticket | | 21 | Debit adjustment for duplicate refund or use | | 22 | In-flight merchandise order | | 23 | Catalogue merchandise order | | 24 | In-flight phone charges | | 25 | Frequent flyer fee or purchase | | 26 | Kennel charge | | 27 | Animal transportation charge | | 28 | Firearms case | | 29 | Upgrade charge | | 30 | Credit for unused transportation | | 31 | Credit for class of service adjustment | | 32 | Credit for denied boarding | | 33 | Credit for miscellaneous refund | | 34 | Credit for lost ticket refund | | 35 | Credit for exchange refund | | 36 | Credit for overcharge adjustment | | 37 | Credit for multiple Unused tickets | | 38 | Exchange order | | 39 | Self-service ticket | | 41 | In-flight duty-free purchase | | 42 | Senior citizen discount booklets | | 43 | Club membership fee | | 44 | Coupon book | | 45 | In-flight charges | | 46 | Tour deposit | | 47 | Frequent flyer overnight delivery charge | | 48 | Frequent flyer fulfillment | | 49 | Small package delivery | | 50 | Vendor sale | | 51 | Miscellaneous taxes or fees | | 52 | Travel agency fee | | 60 | Vendor refund or credit | | 64 | Duty free sale | | 65 | Preferred seat upgrade | | 66 | Cabin upgrade | | 67 | Lounge or club access or day pass | | 68 | Agent assisted reservation or ticketing fee | | 69 | Ticket change or cancel fee | | 70 | Trip insurance | | 71 | Unaccompanied minor | | 72 | Standby fee | | 73 | Curbside baggage | | 74 | In-flight medical equipment | | 75 | Ticket or pass print fee | | 76 | Checked sporting or special equipment | | 77 | Dry ice fee | | 78 | Mail or postage fee | | 79 | Club membership fee or temporary trial | | 80 | Frequent flyer activation or reinstatement | | 81 | Gift certificate | | 82 | Onboard or in-flight prepaid voucher | | 83 | Optional services fee | | 84 | Advance purchase for excess baggage | | 85 | Advance purchase for preferred seat upgrade | | 86 | Advance purchase for cabin upgrade | | 87 | Advance purchase for optional services | | 88 | WiFi | | 89 | Packages | | 90 | In-flight entertainment or internet access | | 91 | Overweight bag fee | | 92 | Sleep sets | | 93 | Special purchase fee | 
    */
    'documentType'?: string;
    /**
    * The field is not currently supported. 
    */
    'documentNumber'?: string;
    /**
    * The field is not currently supported. 
    */
    'documentNumberOfParts'?: number;
    /**
    * Invoice number for the airline transaction. 
    */
    'invoiceNumber'?: string;
    /**
    * Invoice date. The format is YYYYMMDD. If this value is included in the request, it is used in the creation of the invoice number. See \"Invoice Number,\" 
    */
    'invoiceDate'?: number;
    /**
    * Description of the charge if the charge does not involve an airline ticket. For example: Excess baggage. 
    */
    'additionalCharges'?: string;
    /**
    * Total fee for the ticket. This value cannot exceed `99999999999999999999` (twenty 9s). Format: English characters only. Optional request field. 
    */
    'totalFeeAmount'?: string;
    /**
    * Number that identifies the clearing message when multiple clearing messages are allowed per authorized transaction. Each clearing message linked to one authorization request must include a unique clearing sequence number between 1 and the total number of clearing records. Format: English characters only. Optional request field. 
    */
    'clearingSequence'?: string;
    /**
    * Total number of clearing messages associated with the authorization request. Format: English characters only. Optional request field. 
    */
    'clearingCount'?: string;
    /**
    * Total clearing amount for all transactions in the clearing count set. This value cannot exceed `99999999999999999999` (twenty 9s). Format: English characters only. If this field is not set and if the total amount from the original authorization is not NULL, the total clearing amount is set to the total amount from the original authorization. 
    */
    'totalClearingAmount'?: string;
    /**
    * Number of passengers for whom the ticket was issued. Format: English characters only. Optional request field. 
    */
    'numberOfPassengers'?: number;
    /**
    * Code that specifies the computerized reservation system used to make the reservation and purchase the ticket. Format: English characters only. Restricted string data type that indicates a sequence of letters, numbers, and spaces; special characters are not included. Optional request field. 
    */
    'reservationSystemCode'?: string;
    /**
    * Airline process identifier. This value is the airline’s three-digit IATA1 code which is used to process extended payment airline tickets. 
    */
    'processIdentifier'?: string;
    /**
    * Date on which the transaction occurred. Format: `YYYYMMDD` Format: English characters only. Optional request field. 
    */
    'ticketIssueDate'?: string;
    /**
    * Flag that indicates whether an electronic ticket was issued. Possible values: - `true` - `false` Optional request field. 
    */
    'electronicTicketIndicator'?: boolean;
    /**
    * Original ticket number when the transaction is for a replacement ticket. 
    */
    'originalTicketNumber'?: string;
    /**
    * Type of purchase. Possible values: - `EXC`: Exchange ticket - `MSC`: Miscellaneous (not a ticket purchase and not a transaction related to an exchange ticket) - `REF`: Refund - `TKT`: Ticket Format: English characters only. Optional request field. 
    */
    'purchaseType'?: string;
    /**
    * Reason for the credit. Possible values: - `A`: Cancellation of the ancillary passenger transport purchase. - `B`: Cancellation of the airline ticket and the passenger transport ancillary purchase. - `C`: Cancellation of the airline ticket. - `O`: Other. - `P`: Partial refund of the airline ticket. Format: English characters only.  Optional request field. 
    */
    'creditReasonIndicator'?: string;
    /**
    * Type of update. Possible values: - `C`: Change to the existing ticket. - `N`: New ticket. Format: English characters only Optional request field. 
    */
    'ticketChangeIndicator'?: string;
    /**
    * Plan number based on the fare. This value is provided by the airline. Format: English characters only. Optional request field. 
    */
    'planNumber'?: string;
    /**
    * Date of arrival for the last leg of the trip. Format: `MMDDYYYY` English characters only. Optional request field. 
    */
    'arrivalDate'?: string;
    /**
    * Text that describes the ticket limitations, such as _nonrefundable_. Format: English characters only. Optional request field. 
    */
    'restrictedTicketDesciption'?: string;
    /**
    * Amount of the exchanged ticket. Format: English characters only. 
    */
    'exchangeTicketAmount'?: string;
    /**
    * Fee for exchanging the ticket. Format: English characters only. Optional request field. 
    */
    'exchangeTicketFeeAmount'?: string;
    /**
    * The field is not currently supported. 
    */
    'reservationType'?: string;
    /**
    * Boarding fee. 
    */
    'boardingFeeAmount'?: string;
    'legs'?: Array<Ptsv2paymentsTravelInformationTransitAirlineLegs>;
    'ancillaryInformation'?: Ptsv2paymentsTravelInformationTransitAirlineAncillaryInformation;
    /**
    * Specifies the type of flight. One way (0) Return (1) Transit (2) Transit & Return (3) Multi-City (4) 
    */
    'flightType'?: string;
    /**
    * The total cost of the flight insurance. Example: 10000.00 
    */
    'insuranceAmount'?: string;
    /**
    * The consumer’s frequent flyer number. Leave 0 if there is no frequent flyer number 
    */
    'frequentFlyerNumber'?: string;
    /**
    * Specifies if the travel agent joins the flight (0) or not (1) 
    */
    'thirdPartyStatus'?: string;
    /**
    * List of passenger types in a booking code: A (Adult) C (Child) Comma separated values for total number of passenger 
    */
    'passengerType'?: string;
    /**
    * Total insurance amount. We have per leg and not total 
    */
    'totalInsuranceAmount'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "isDomestic",
            "baseName": "isDomestic",
            "type": "string"
        },
        {
            "name": "bookingReferenceNumber",
            "baseName": "bookingReferenceNumber",
            "type": "string"
        },
        {
            "name": "carrierName",
            "baseName": "carrierName",
            "type": "string"
        },
        {
            "name": "ticketIssuer",
            "baseName": "ticketIssuer",
            "type": "Ptsv2paymentsTravelInformationTransitAirlineTicketIssuer"
        },
        {
            "name": "ticketNumber",
            "baseName": "ticketNumber",
            "type": "string"
        },
        {
            "name": "checkDigit",
            "baseName": "checkDigit",
            "type": "string"
        },
        {
            "name": "restrictedTicketIndicator",
            "baseName": "restrictedTicketIndicator",
            "type": "number"
        },
        {
            "name": "transactionType",
            "baseName": "transactionType",
            "type": "number"
        },
        {
            "name": "extendedPaymentCode",
            "baseName": "extendedPaymentCode",
            "type": "string"
        },
        {
            "name": "passengerName",
            "baseName": "passengerName",
            "type": "string"
        },
        {
            "name": "customerCode",
            "baseName": "customerCode",
            "type": "string"
        },
        {
            "name": "documentType",
            "baseName": "documentType",
            "type": "string"
        },
        {
            "name": "documentNumber",
            "baseName": "documentNumber",
            "type": "string"
        },
        {
            "name": "documentNumberOfParts",
            "baseName": "documentNumberOfParts",
            "type": "number"
        },
        {
            "name": "invoiceNumber",
            "baseName": "invoiceNumber",
            "type": "string"
        },
        {
            "name": "invoiceDate",
            "baseName": "invoiceDate",
            "type": "number"
        },
        {
            "name": "additionalCharges",
            "baseName": "additionalCharges",
            "type": "string"
        },
        {
            "name": "totalFeeAmount",
            "baseName": "totalFeeAmount",
            "type": "string"
        },
        {
            "name": "clearingSequence",
            "baseName": "clearingSequence",
            "type": "string"
        },
        {
            "name": "clearingCount",
            "baseName": "clearingCount",
            "type": "string"
        },
        {
            "name": "totalClearingAmount",
            "baseName": "totalClearingAmount",
            "type": "string"
        },
        {
            "name": "numberOfPassengers",
            "baseName": "numberOfPassengers",
            "type": "number"
        },
        {
            "name": "reservationSystemCode",
            "baseName": "reservationSystemCode",
            "type": "string"
        },
        {
            "name": "processIdentifier",
            "baseName": "processIdentifier",
            "type": "string"
        },
        {
            "name": "ticketIssueDate",
            "baseName": "ticketIssueDate",
            "type": "string"
        },
        {
            "name": "electronicTicketIndicator",
            "baseName": "electronicTicketIndicator",
            "type": "boolean"
        },
        {
            "name": "originalTicketNumber",
            "baseName": "originalTicketNumber",
            "type": "string"
        },
        {
            "name": "purchaseType",
            "baseName": "purchaseType",
            "type": "string"
        },
        {
            "name": "creditReasonIndicator",
            "baseName": "creditReasonIndicator",
            "type": "string"
        },
        {
            "name": "ticketChangeIndicator",
            "baseName": "ticketChangeIndicator",
            "type": "string"
        },
        {
            "name": "planNumber",
            "baseName": "planNumber",
            "type": "string"
        },
        {
            "name": "arrivalDate",
            "baseName": "arrivalDate",
            "type": "string"
        },
        {
            "name": "restrictedTicketDesciption",
            "baseName": "restrictedTicketDesciption",
            "type": "string"
        },
        {
            "name": "exchangeTicketAmount",
            "baseName": "exchangeTicketAmount",
            "type": "string"
        },
        {
            "name": "exchangeTicketFeeAmount",
            "baseName": "exchangeTicketFeeAmount",
            "type": "string"
        },
        {
            "name": "reservationType",
            "baseName": "reservationType",
            "type": "string"
        },
        {
            "name": "boardingFeeAmount",
            "baseName": "boardingFeeAmount",
            "type": "string"
        },
        {
            "name": "legs",
            "baseName": "legs",
            "type": "Array<Ptsv2paymentsTravelInformationTransitAirlineLegs>"
        },
        {
            "name": "ancillaryInformation",
            "baseName": "ancillaryInformation",
            "type": "Ptsv2paymentsTravelInformationTransitAirlineAncillaryInformation"
        },
        {
            "name": "flightType",
            "baseName": "flightType",
            "type": "string"
        },
        {
            "name": "insuranceAmount",
            "baseName": "insuranceAmount",
            "type": "string"
        },
        {
            "name": "frequentFlyerNumber",
            "baseName": "frequentFlyerNumber",
            "type": "string"
        },
        {
            "name": "thirdPartyStatus",
            "baseName": "thirdPartyStatus",
            "type": "string"
        },
        {
            "name": "passengerType",
            "baseName": "passengerType",
            "type": "string"
        },
        {
            "name": "totalInsuranceAmount",
            "baseName": "totalInsuranceAmount",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsTravelInformationTransitAirline.attributeTypeMap;
    }
}

export class Ptsv2paymentsTravelInformationTransitAirlineAncillaryInformation {
    /**
    * Ticket number, which consists of the carrier code, form, and serial number, without the check digit. **Important** This field is required in the U.S. in order for you to qualify for either the custom payment service (CPS) or the electronic interchange reimbursement fee (EIRF) program. Format: English characters only. Optional field for ancillary services. 
    */
    'ticketNumber'?: string;
    /**
    * Name of the passenger. If the passenger’s name is not available, this value is the cardholder’s name. If neither the passenger’s name nor the cardholder’s name is available, this value is a description of the ancillary purchase. **Important** This field is required in the U.S. in order for you to qualify for either the custom payment service (CPS) or the electronic interchange reimbursement fee (EIRF) program. Format: English characters only. Optional field for ancillary service. 
    */
    'passengerName'?: string;
    /**
    * Number for the airline ticket to which the ancillary purchase is connected.  If this purchase has a connection or relationship to another purchase such as a baggage fee for a passenger transport ticket, this field must contain the ticket number for the other purchase.  For a stand-alone purchase, the value for this field must be the same as the value for the `travelInformation.transit.airline.ancillaryInformation.ticketNumber` field. **Important** This field is required in the U.S. in order for you to qualify for either the custom payment service (CPS) or the electronic interchange reimbursement fee (EIRF) program. Format: English characters only. Optional request field for ancillary services. 
    */
    'connectedTicketNumber'?: string;
    /**
    * Reason for the credit. Possible values: - `A`: Cancellation of the ancillary passenger transport purchase. - `B`: Cancellation of the airline ticket and the passenger transport ancillary purchase. - `C`: Cancellation of the airline ticket. - `O`: Other. - `P`: Partial refund of the airline ticket. Format: English characters only. Optional field for ancillary services. 
    */
    'creditReasonIndicator'?: string;
    'service'?: Array<Ptsv2paymentsTravelInformationTransitAirlineAncillaryInformationService>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "ticketNumber",
            "baseName": "ticketNumber",
            "type": "string"
        },
        {
            "name": "passengerName",
            "baseName": "passengerName",
            "type": "string"
        },
        {
            "name": "connectedTicketNumber",
            "baseName": "connectedTicketNumber",
            "type": "string"
        },
        {
            "name": "creditReasonIndicator",
            "baseName": "creditReasonIndicator",
            "type": "string"
        },
        {
            "name": "service",
            "baseName": "service",
            "type": "Array<Ptsv2paymentsTravelInformationTransitAirlineAncillaryInformationService>"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsTravelInformationTransitAirlineAncillaryInformation.attributeTypeMap;
    }
}

export class Ptsv2paymentsTravelInformationTransitAirlineAncillaryInformationService {
    /**
    * Category code for the ancillary service that is provided. Obtain the codes from the International Air Transport Association (IATA). **Note** `#` is either 0, 1, 2, or 3. **Important** This field is required in the U.S. in order for you to qualify for either the custom payment service (CPS) or the electronic interchange reimbursement fee (EIRF)program. Format: English characters only. Optional request field for ancillary services. 
    */
    'categoryCode'?: string;
    /**
    * Subcategory code for the ancillary service category. Obtain the codes from the International Air Transport Association (IATA). **Note** `#` is either 0, 1, 2, or 3. Format  English characters only. Optional request field for ancillary services. 
    */
    'subCategoryCode'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "categoryCode",
            "baseName": "categoryCode",
            "type": "string"
        },
        {
            "name": "subCategoryCode",
            "baseName": "subCategoryCode",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsTravelInformationTransitAirlineAncillaryInformationService.attributeTypeMap;
    }
}

export class Ptsv2paymentsTravelInformationTransitAirlineLegs {
    /**
    * IATA code for the carrier for this leg of the trip. Format: English characters only. Restricted string data type that indicates a sequence of letters, numbers, and spaces; special characters are not included. Optional request field for travel legs. 
    */
    'carrierCode'?: string;
    /**
    * Flight number for this leg of the trip. Restrictions are limitations for the ticket based on the type of fare, such as a nonrefundable ticket or a 3-day minimum stay. Format: English characters only. Optional request field for travel legs. 
    */
    'flightNumber'?: string;
    /**
    * IATA code for the originating airport for this leg of the trip. Format: English characters only. Restricted string data type that indicates a sequence of letters, numbers, and spaces; special characters are not included. Optional request field for travel legs. 
    */
    'originatingAirportCode'?: string;
    /**
    * IATA code for the class of service for this leg of the trip. Format: English characters only. Restricted string data type that indicates a sequence of letters, numbers, and spaces; special characters are not included. Optional request field for travel legs. 
    */
    '_class'?: string;
    /**
    * Code that indicates whether a stopover is allowed on this leg of the trip. Possible values: - `O` (capital letter “O”) (default): Stopover allowed - `X` (capital letter “X”): Stopover not allowed Format: English characters only. Restricted string data type that indicates a sequence of letters, numbers, and spaces; special characters are not included. Optional request field for travel legs. 
    */
    'stopoverIndicator'?: number;
    /**
    * Departure date for the first leg of the trip. Format: `YYYYMMDD`. Format: English characters only. Optional request field for travel legs. 
    */
    'departureDate'?: number;
    /**
    * IATA code for the destination airport for this leg of the trip. Format: English characters only. Restricted string data type that indicates a sequence of letters, numbers, and spaces; special characters are not included. Optional request field for travel legs. 
    */
    'destinationAirportCode'?: string;
    /**
    * Code for the fare basis for this leg of the trip. The fare basis is assigned by the carriers and indicates a particular ticket type, such as business class or discounted/nonrefundable. Restricted string data type that indicates a sequence of letters, numbers, and spaces; special characters are not included. Format: English characters only. Optional request field for travel legs.auto_rental_regular_mileage_cost 
    */
    'fareBasis'?: string;
    /**
    * Amount of departure tax for this leg of the trip. 
    */
    'departTaxAmount'?: string;
    /**
    * Ticket that contains additional coupons for this leg of the trip on an itinerary that has more than four segments. Format: English characters only. Restricted string data type that indicates a sequence of letters, numbers, and spaces; special characters are not included. Optional request field for travel legs. 
    */
    'conjunctionTicket'?: string;
    /**
    * New ticket number that is issued when the ticket is exchanged for this leg of the trip. Restrictions are limitations for the ticket based on the type of fare, such as a nonrefundable ticket or a 3-day minimum stay. Format: English characters only. Optional request field for travel legs. 
    */
    'exchangeTicketNumber'?: string;
    /**
    * Coupon number. Each leg on the ticket requires a separate coupon, and each coupon is identified by the coupon number. Format: English characters only. Restricted string data type that indicates a sequence of letters, numbers, and spaces; special characters are not included. Optional request field for travel legs. 
    */
    'couponNumber'?: string;
    /**
    * Time of departure for this leg of the trip. The format is military time and HHMM: If not all zeros, then the hours must be `00-23` and the minutes must be `00-59`. Format: English characters only. Optional request field for travel legs. 
    */
    'departureTime'?: number;
    /**
    * AM or PM for the departure time. Possible values: - A: 12:00 midnight to 11:59 a.m. - P: 12:00 noon to 11:59 p.m Format: English characters only. Restricted string data type that indicates a sequence of letters, numbers, and spaces; special characters are not included. Optional request field for travel legs. 
    */
    'departureTimeMeridian'?: string;
    /**
    * Time of arrival for this leg of the trip. The format is military time and HHMM: If not all zeros, then the hours must be `00-23` and the minutes must be `00-59` Format: English characters only. Optional request field for travel legs. 
    */
    'arrivalTime'?: number;
    /**
    * AM or PM for the arrival time for this leg of the trip. Possible values: - `A`: 12:00 midnight to 11:59 a.m. - `P`: 12:00 noon to 11:59 p.m. Format: English characters only. Restricted string data type that indicates a sequence of letters, numbers, and spaces; special characters are not included. Optional request field for travel legs. 
    */
    'arrivalTimeMeridian'?: string;
    /**
    * Notes or notations about endorsements and restrictions for this leg of the trip. Endorsements can be notations added by the travel agency, including mandatory government-required notations such as value added tax. Restrictions are limitations for the ticket based on the type of fare, such as a nonrefundable ticket or a 3-day minimum stay. Format: English characters only. Optional request field for travel legs. 
    */
    'endorsementsRestrictions'?: string;
    /**
    * Total fare for this leg of the trip. Format: English characters only. Optional request field for travel legs. 
    */
    'totalFareAmount'?: string;
    /**
    * Fee for this leg of the trip, such as an airport fee or country fee. Format: English characters only. Optional request field for travel legs. 
    */
    'feeAmount'?: string;
    /**
    * Tax for this leg of the trip. Format: English characters only. Optional request field for travel legs. 
    */
    'taxAmount'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "carrierCode",
            "baseName": "carrierCode",
            "type": "string"
        },
        {
            "name": "flightNumber",
            "baseName": "flightNumber",
            "type": "string"
        },
        {
            "name": "originatingAirportCode",
            "baseName": "originatingAirportCode",
            "type": "string"
        },
        {
            "name": "_class",
            "baseName": "class",
            "type": "string"
        },
        {
            "name": "stopoverIndicator",
            "baseName": "stopoverIndicator",
            "type": "number"
        },
        {
            "name": "departureDate",
            "baseName": "departureDate",
            "type": "number"
        },
        {
            "name": "destinationAirportCode",
            "baseName": "destinationAirportCode",
            "type": "string"
        },
        {
            "name": "fareBasis",
            "baseName": "fareBasis",
            "type": "string"
        },
        {
            "name": "departTaxAmount",
            "baseName": "departTaxAmount",
            "type": "string"
        },
        {
            "name": "conjunctionTicket",
            "baseName": "conjunctionTicket",
            "type": "string"
        },
        {
            "name": "exchangeTicketNumber",
            "baseName": "exchangeTicketNumber",
            "type": "string"
        },
        {
            "name": "couponNumber",
            "baseName": "couponNumber",
            "type": "string"
        },
        {
            "name": "departureTime",
            "baseName": "departureTime",
            "type": "number"
        },
        {
            "name": "departureTimeMeridian",
            "baseName": "departureTimeMeridian",
            "type": "string"
        },
        {
            "name": "arrivalTime",
            "baseName": "arrivalTime",
            "type": "number"
        },
        {
            "name": "arrivalTimeMeridian",
            "baseName": "arrivalTimeMeridian",
            "type": "string"
        },
        {
            "name": "endorsementsRestrictions",
            "baseName": "endorsementsRestrictions",
            "type": "string"
        },
        {
            "name": "totalFareAmount",
            "baseName": "totalFareAmount",
            "type": "string"
        },
        {
            "name": "feeAmount",
            "baseName": "feeAmount",
            "type": "string"
        },
        {
            "name": "taxAmount",
            "baseName": "taxAmount",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsTravelInformationTransitAirlineLegs.attributeTypeMap;
    }
}

export class Ptsv2paymentsTravelInformationTransitAirlineTicketIssuer {
    /**
    * IATA2 airline code. Format: English characters only. Required for Mastercard; optional for all other card types. 
    */
    'code'?: string;
    /**
    * Name of the ticket issuer. If you do not include this field, CyberSource uses the value for your merchant name that is in the CyberSource merchant configuration database. 
    */
    'name'?: string;
    /**
    * Address of the company issuing the ticket. 
    */
    'address'?: string;
    /**
    * City in which the transaction occurred. If the name of the city exceeds 18 characters, use meaningful abbreviations. Format: English characters only. Optional request field. 
    */
    'locality'?: string;
    /**
    * State in which transaction occured. 
    */
    'administrativeArea'?: string;
    /**
    * Zip code of the city in which transaction occured. 
    */
    'postalCode'?: string;
    /**
    * Country in which transaction occured. 
    */
    'country'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "address",
            "baseName": "address",
            "type": "string"
        },
        {
            "name": "locality",
            "baseName": "locality",
            "type": "string"
        },
        {
            "name": "administrativeArea",
            "baseName": "administrativeArea",
            "type": "string"
        },
        {
            "name": "postalCode",
            "baseName": "postalCode",
            "type": "string"
        },
        {
            "name": "country",
            "baseName": "country",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsTravelInformationTransitAirlineTicketIssuer.attributeTypeMap;
    }
}

export class Ptsv2paymentsTravelInformationVehicleData {
    /**
    * This field will contain connector type values for electric vehicle transactions.  Possible Values: 001 (AC - J1772 Type 1) 002 (AC - Mennekes - Type 2) 003 (AC - GB/T) 100 (DC - CCS1) 101 (DC - CHAdeMO) 102 (DC - CCS2) 103 (DC - GB/T) 200 (NACS – Tesla) 
    */
    'connectorType'?: string;
    /**
    * This field will contain charging reason code values for electric vehicle transactions.  Possible Values: 010 (Other Error) 011 (Connector Lock Failure) 012 (EV Communication Error) 013 (Ground Failure) 014 (High Temperature) 015 (Internal Error) 016 (Over Current Failure) 017 (Over Voltage) 018 (Power Meter Failure) 019 (Power Switch Failure) 020 (Reader Failure) 021 (Reset Failure) 022 (Under Voltage) 023 (Weak Signal) 100 (No Error) 200 (Payment Related Error) 
    */
    'chargingReasonCode'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "connectorType",
            "baseName": "connectorType",
            "type": "string"
        },
        {
            "name": "chargingReasonCode",
            "baseName": "chargingReasonCode",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsTravelInformationVehicleData.attributeTypeMap;
    }
}

export class Ptsv2paymentsUnscheduledPaymentInformation {
    /**
    * Indicates the type of unscheduled payment. This field is required for unscheduled payments CIT/MIT Possible values: 1: First unscheduled transaction. 2: Subsequent unscheduled transaction. 
    */
    'type'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsUnscheduledPaymentInformation.attributeTypeMap;
    }
}

export class Ptsv2paymentsWatchlistScreeningInformation {
    /**
    * Parts of the customer’s information that must match with an entry in the DPL (denied parties list) before a match occurs. This field can contain one of the following values: - AND: (default) The customer’s name or company and the customer’s address must appear in the database. - OR: The customer’s name must appear in the database. - IGNORE: You want the service to detect a match only of the customer’s name or company but not of the address. 
    */
    'addressOperator'?: string;
    'weights'?: Ptsv2paymentsWatchlistScreeningInformationWeights;
    /**
    * Use this field to specify which list(s) you want checked with the request. The reply will include the list name as well as the response data. To check against multiple lists, enter multiple list codes separated by a caret (^). For more information, see \"Restricted and Denied Parties List,\" page 68. 
    */
    'sanctionLists'?: Array<string>;
    /**
    * Indicates whether the transaction should proceed if there is a match. Possible values: - `true`: Transaction proceeds even when match is found in the Denied Parties List. The match is noted in the response. - `false`: Normal watchlist screening behavior occurs. (Transaction stops if a match to DPL occurs. Transaction proceeds if no match.) 
    */
    'proceedOnMatch'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "addressOperator",
            "baseName": "addressOperator",
            "type": "string"
        },
        {
            "name": "weights",
            "baseName": "weights",
            "type": "Ptsv2paymentsWatchlistScreeningInformationWeights"
        },
        {
            "name": "sanctionLists",
            "baseName": "sanctionLists",
            "type": "Array<string>"
        },
        {
            "name": "proceedOnMatch",
            "baseName": "proceedOnMatch",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsWatchlistScreeningInformation.attributeTypeMap;
    }
}

export class Ptsv2paymentsWatchlistScreeningInformationWeights {
    /**
    * Degree of correlation between a customer’s address and an entry in the DPL before a match occurs. This field can contain one of the following values: - exact: The address must be identical to the entry in the DPL. - high: (default) The address cannot differ significantly from the entry in the DPL. - medium: The address can differ slightly more from the entry in the DPL. - low: The address can differ significantly from the entry in the DPL. 
    */
    'address'?: string;
    /**
    * Degree of correlation between a company address and an entry in the DPL before a match occurs. This field can contain one of the following values: - exact: The company name must be identical to the entry in the DPL. - high: (default) The company name cannot differ significantly from the entry in the DPL. - medium: The company name can differ slightly more from the entry in the DPL. - low: The company name can differ significantly from the entry in the DPL. 
    */
    'company'?: string;
    /**
    * Degree of correlation between a customer’s name and an entry in the DPL before a match occurs. This field can contain one of the following values: - exact: The name must be identical to the entry in the DPL. - high: (default) The name cannot differ significantly from the entry in the DPL. - medium: The name can differ slightly more from the entry in the DPL. - low: The name can differ significantly the entry in the DPL. 
    */
    'name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "address",
            "baseName": "address",
            "type": "string"
        },
        {
            "name": "company",
            "baseName": "company",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsWatchlistScreeningInformationWeights.attributeTypeMap;
    }
}

export class Ptsv2paymentsidClientReferenceInformation {
    /**
    * Merchant-generated order reference or tracking number. It is recommended that you send a unique value for each transaction so that you can perform meaningful searches for the transaction.  #### Used by **Authorization** Required field.  #### PIN Debit Requests for PIN debit reversals need to use the same merchant reference number that was used in the transaction that is being reversed.  Required field for all PIN Debit requests (purchase, credit, and reversal).  #### FDC Nashville Global Certain circumstances can cause the processor to truncate this value to 15 or 17 characters for Level II and Level III processing, which can cause a discrepancy between the value you submit and the value included in some processor reports. 
    */
    'code'?: string;
    'partner'?: Ptsv2paymentsidClientReferenceInformationPartner;
    /**
    * The name of the Connection Method client (such as Virtual Terminal or SOAP Toolkit API) that the merchant uses to send a transaction request to CyberSource. 
    */
    'applicationName'?: string;
    /**
    * Version of the CyberSource application or integration used for a transaction. 
    */
    'applicationVersion'?: string;
    /**
    * The entity that is responsible for running the transaction and submitting the processing request to CyberSource. This could be a person, a system, or a connection method. 
    */
    'applicationUser'?: string;
    /**
    * Identifier that you assign to the transaction. Normally generated by a client server to identify a unique API request.  **Note** Use this field only if you want to support merchant-initiated reversal and void operations.  #### Used by **Authorization, Authorization Reversal, Capture, Credit, and Void** Optional field.  #### PIN Debit For a PIN debit reversal, your request must include a request ID or a merchant transaction identifier. Optional field for PIN debit purchase or credit requests. 
    */
    'transactionId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        },
        {
            "name": "partner",
            "baseName": "partner",
            "type": "Ptsv2paymentsidClientReferenceInformationPartner"
        },
        {
            "name": "applicationName",
            "baseName": "applicationName",
            "type": "string"
        },
        {
            "name": "applicationVersion",
            "baseName": "applicationVersion",
            "type": "string"
        },
        {
            "name": "applicationUser",
            "baseName": "applicationUser",
            "type": "string"
        },
        {
            "name": "transactionId",
            "baseName": "transactionId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsidClientReferenceInformation.attributeTypeMap;
    }
}

export class Ptsv2paymentsidClientReferenceInformationPartner {
    /**
    * Value that links the previous transaction to the current follow-on request. This value is assigned by the client software that is installed on the POS terminal, which makes it available to the terminal’s software and to CyberSource. Therefore, you can use this value to reconcile transactions between CyberSource and the terminal’s software.  CyberSource does not forward this value to the processor. Instead, the value is forwarded to the CyberSource reporting functionality.  This field is supported only on these processors: - American Express Direct - Credit Mutuel-CIC - FDC Nashville Global - OmniPay Direct - SIX  Optional field. 
    */
    'originalTransactionId'?: string;
    /**
    * Identifier for the developer that helped integrate a partner solution to CyberSource.  Send this value in all requests that are sent through the partner solutions built by that developer. CyberSource assigns the ID to the developer.  **Note** When you see a developer ID of 999 in reports, the developer ID that was submitted is incorrect. 
    */
    'developerId'?: string;
    /**
    * Identifier for the partner that is integrated to CyberSource.  Send this value in all requests that are sent through the partner solution. CyberSource assigns the ID to the partner.  **Note** When you see a solutionId of 999 in reports, the solutionId that was submitted is incorrect. 
    */
    'solutionId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "originalTransactionId",
            "baseName": "originalTransactionId",
            "type": "string"
        },
        {
            "name": "developerId",
            "baseName": "developerId",
            "type": "string"
        },
        {
            "name": "solutionId",
            "baseName": "solutionId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsidClientReferenceInformationPartner.attributeTypeMap;
    }
}

export class Ptsv2paymentsidMerchantInformation {
    /**
    * Date and time at your physical location.  Format: `YYYYMMDDhhmmss`, where:  - `YYYY` = year  - `MM` = month  - `DD` = day  - `hh` = hour  - `mm` = minutes  - `ss` = seconds  #### Used by **Authorization** Required for these processors: - American Express Direct                                                                                                                                                                                                                                                                                                                         - American Express Direct - Credit Mutuel-CIC - FDC Nashville Global - SIX  Optional for all other processors. 
    */
    'transactionLocalDateTime'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "transactionLocalDateTime",
            "baseName": "transactionLocalDateTime",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsidMerchantInformation.attributeTypeMap;
    }
}

export class Ptsv2paymentsidOrderInformation {
    'amountDetails'?: Ptsv2paymentsidOrderInformationAmountDetails;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "amountDetails",
            "baseName": "amountDetails",
            "type": "Ptsv2paymentsidOrderInformationAmountDetails"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsidOrderInformation.attributeTypeMap;
    }
}

export class Ptsv2paymentsidOrderInformationAmountDetails {
    /**
    * Additional charges that have to be authorized against a lodging or auto-rental order. This value cannot be negative. You can include a decimal point (.), but no other special characters. 
    */
    'additionalAmount'?: string;
    /**
    * Currency used for the order. Use the three-character [ISO Standard Currency Codes.](http://apps.cybersource.com/library/documentation/sbc/quickref/currencies.pdf)  #### Used by **Authorization** Required field.  **Authorization Reversal** For an authorization reversal (`reversalInformation`) or a capture (`processingOptions.capture` is set to `true`), you must use the same currency that you used in your payment authorization request.  #### PIN Debit Currency for the amount you requested for the PIN debit purchase. This value is returned for partial authorizations. The issuing bank can approve a partial amount if the balance on the debit card is less than the requested transaction amount. For the possible values, see the [ISO Standard Currency Codes](https://developer.cybersource.com/library/documentation/sbc/quickref/currencies.pdf). Returned by PIN debit purchase.  For PIN debit reversal requests, you must use the same currency that was used for the PIN debit purchase or PIN debit credit that you are reversing. For the possible values, see the [ISO Standard Currency Codes](https://developer.cybersource.com/library/documentation/sbc/quickref/currencies.pdf).  Required field for PIN Debit purchase and PIN Debit credit requests. Optional field for PIN Debit reversal requests.  #### GPX This field is optional for reversing an authorization or credit.  #### DCC for First Data Your local currency.  #### Tax Calculation Required for international tax and value added tax only. Optional for U.S. and Canadian taxes. Your local currency. 
    */
    'currency'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "additionalAmount",
            "baseName": "additionalAmount",
            "type": "string"
        },
        {
            "name": "currency",
            "baseName": "currency",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsidOrderInformationAmountDetails.attributeTypeMap;
    }
}

export class Ptsv2paymentsidProcessingInformation {
    'authorizationOptions'?: Ptsv2paymentsidProcessingInformationAuthorizationOptions;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "authorizationOptions",
            "baseName": "authorizationOptions",
            "type": "Ptsv2paymentsidProcessingInformationAuthorizationOptions"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsidProcessingInformation.attributeTypeMap;
    }
}

export class Ptsv2paymentsidProcessingInformationAuthorizationOptions {
    'initiator'?: Ptsv2paymentsidProcessingInformationAuthorizationOptionsInitiator;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "initiator",
            "baseName": "initiator",
            "type": "Ptsv2paymentsidProcessingInformationAuthorizationOptionsInitiator"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsidProcessingInformationAuthorizationOptions.attributeTypeMap;
    }
}

export class Ptsv2paymentsidProcessingInformationAuthorizationOptionsInitiator {
    /**
    * Indicates to an issuing bank whether a merchant-initiated transaction came from a card that was already stored on file.  Possible values: - **true** means the merchant-initiated transaction came from a card that was already stored on file. - **false**  means the merchant-initiated transaction came from a card that was not stored on file. 
    */
    'storedCredentialUsed'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "storedCredentialUsed",
            "baseName": "storedCredentialUsed",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsidProcessingInformationAuthorizationOptionsInitiator.attributeTypeMap;
    }
}

export class Ptsv2paymentsidTravelInformation {
    /**
    * Duration for which the vehicle was rented or lodge/hotel was booked. 
    */
    'duration'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "duration",
            "baseName": "duration",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsidTravelInformation.attributeTypeMap;
    }
}

export class Ptsv2paymentsidcapturesAggregatorInformation {
    /**
    * Value that identifies you as a payment aggregator. Get this value from the processor.  #### CyberSource through VisaNet The value for this field corresponds to the following data in the TC 33 capture file5: - Record: CP01 TCR6 - Position: 95-105 - Field: Payment Facilitator ID  This field is supported for Visa, Mastercard and Discover Transactions.  **FDC Compass**\\ This value must consist of uppercase characters. 
    */
    'aggregatorId'?: string;
    /**
    * Your payment aggregator business name.  **American Express Direct**\\ The maximum length of the aggregator name depends on the length of the sub-merchant name. The combined length for both values must not exceed 36 characters.\\  #### CyberSource through VisaNet With American Express, the maximum length of the aggregator name depends on the length of the sub-merchant name. The combined length for both values must not exceed 36 characters. The value for this field does not map to the TC 33 capture file5.  **FDC Compass**\\ This value must consist of uppercase characters. 
    */
    'name'?: string;
    'subMerchant'?: Ptsv2paymentsidcapturesAggregatorInformationSubMerchant;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "aggregatorId",
            "baseName": "aggregatorId",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "subMerchant",
            "baseName": "subMerchant",
            "type": "Ptsv2paymentsidcapturesAggregatorInformationSubMerchant"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsidcapturesAggregatorInformation.attributeTypeMap;
    }
}

export class Ptsv2paymentsidcapturesAggregatorInformationSubMerchant {
    /**
    * Sub-merchant’s business name.  #### American Express Direct The maximum length of the sub-merchant name depends on the length of the aggregator name. The combined length for both values must not exceed 36 characters.  #### CyberSource through VisaNet With American Express, the maximum length of the sub-merchant name depends on the length of the aggregator name. The combined length for both values must not exceed 36 characters. The value for this field does not map to the TC 33 capture file5.  #### FDC Compass This value must consist of uppercase characters.  #### FDC Nashville Global With Mastercard, the maximum length of the sub-merchant name depends on the length of the aggregator name: - If aggregator name length is 1 through 3, maximum sub-merchant name length is 21. - If aggregator name length is 4 through 7, maximum sub-merchant name length is 17. - If aggregator name length is 8 through 12, maximum sub-merchant name length is 12. 
    */
    'name'?: string;
    /**
    * First line of the sub-merchant’s street address.  #### CyberSource through VisaNet The value for this field does not map to the TC 33 capture file5.  #### FDC Compass This value must consist of uppercase characters. 
    */
    'address1'?: string;
    /**
    * Sub-merchant’s city.  #### CyberSource through VisaNet The value for this field does not map to the TC 33 capture file5.  #### FDC Compass This value must consist of uppercase characters. 
    */
    'locality'?: string;
    /**
    * Sub-merchant’s state or province.  #### CyberSource through VisaNet The value for this field does not map to the TC 33 capture file5.  #### FDC Compass This value must consist of uppercase characters. 
    */
    'administrativeArea'?: string;
    /**
    * Partial postal code for the sub-merchant’s address.  #### CyberSource through VisaNet The value for this field does not map to the TC 33 capture file5.  #### FDC Compass This value must consist of uppercase characters. 
    */
    'postalCode'?: string;
    /**
    * Sub-merchant’s country. Use the [ISO Standard Country Codes](https://developer.cybersource.com/library/documentation/sbc/quickref/countries_alpha_list.pdf).  #### CyberSource through VisaNet The value for this field does not map to the TC 33 capture file.  #### FDC Compass This value must consist of uppercase characters. 
    */
    'country'?: string;
    /**
    * Sub-merchant’s email address.  **Maximum length for processors**   - American Express Direct: 40  - CyberSource through VisaNet: 40  - FDC Compass: 40  - FDC Nashville Global: 19  #### CyberSource through VisaNet With American Express, the value for this field corresponds to the following data in the TC 33 capture file: - Record: CP01 TCRB - Position: 25-64 - Field: American Express Seller E-mail Address  **Note** The TC 33 Capture file contains information about the purchases and refunds that a merchant submits to CyberSource. CyberSource through VisaNet creates the TC 33 Capture file at the end of the day and sends it to the merchant’s acquirer, who uses this information to facilitate end-of-day clearing processing with payment card companies. 
    */
    'email'?: string;
    /**
    * Sub-merchant’s telephone number.  **Maximum length for procesors**   - American Express Direct: 20  - CyberSource through VisaNet: 20  - FDC Compass: 13  - FDC Nashville Global: 10  #### CyberSource through VisaNet With American Express, the value for this field corresponds to the following data in the TC 33 capture file5: - Record: CP01 TCRB - Position: 5-24 - Field: American Express Seller Telephone Number  **FDC Compass**\\ This value must consist of uppercase characters. Use one of these recommended formats:\\ `NNN-NNN-NNNN`\\ `NNN-AAAAAAA` 
    */
    'phoneNumber'?: string;
    /**
    * The ID you assigned to your sub-merchant. CyberSource through VisaNet: For American Express transaction, the value for this field corresponds to the following data in the TC 33 capture file: - Record: CP01 TCRB - Position: 65-84 - Field: American Express Seller ID For  Mastercard transactions, the value for this field corresponds to the following data in the TC 33 capture file: - Record: CP01 TCR6 - Position: 117-131 - Field: Sub-Merchant ID FDC Compass: This value must consist of uppercase characters.  American Express Direct: String (20) CyberSource through VisaNet with American Express: String (20) CyberSource through VisaNet with Visa,Mastercard and Discover: String (15) FDC Compass: String (20) FDC Nashville Global: String (14) 
    */
    'id'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "address1",
            "baseName": "address1",
            "type": "string"
        },
        {
            "name": "locality",
            "baseName": "locality",
            "type": "string"
        },
        {
            "name": "administrativeArea",
            "baseName": "administrativeArea",
            "type": "string"
        },
        {
            "name": "postalCode",
            "baseName": "postalCode",
            "type": "string"
        },
        {
            "name": "country",
            "baseName": "country",
            "type": "string"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "phoneNumber",
            "baseName": "phoneNumber",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsidcapturesAggregatorInformationSubMerchant.attributeTypeMap;
    }
}

export class Ptsv2paymentsidcapturesBuyerInformation {
    /**
    * Your identifier for the customer.  When a subscription or customer profile is being created, the maximum length for this field for most processors is 30. Otherwise, the maximum length is 100.  #### Comercio Latino For recurring payments in Mexico, the value is the customer’s contract number. Note Before you request the authorization, you must inform the issuer of the customer contract numbers that will be used for recurring transactions.  #### Worldpay VAP For a follow-on credit with Worldpay VAP, CyberSource checks the following locations, in the order given, for a customer account ID value and uses the first value it finds: 1. `customer_account_id` value in the follow-on credit request 2. Customer account ID value that was used for the capture that is being credited 3. Customer account ID value that was used for the original authorization If a customer account ID value cannot be found in any of these locations, then no value is used. 
    */
    'merchantCustomerId'?: string;
    /**
    * Customer’s government-assigned tax identification number.  #### Tax Calculation Optional for international and value added taxes only. Not applicable to U.S. and Canadian taxes. 
    */
    'vatRegistrationNumber'?: string;
    /**
    * Recipient’s date of birth. **Format**: `YYYYMMDD`.  This field is a `pass-through`, which means that CyberSource ensures that the value is eight numeric characters but otherwise does not verify the value or modify it in any way before sending it to the processor. If the field is not required for the transaction, CyberSource does not forward it to the processor. 
    */
    'dateOfBirth'?: string;
    /**
    * Customer's gender. Possible values are F (female), M (male),O (other).
    */
    'gender'?: string;
    /**
    * language setting of the user.  Supports 2-character language codes (e.g., en, fr) and 5-character locale values (e.g., en-US, fr-CA). 
    */
    'language'?: string;
    'personalIdentification'?: Array<Ptsv2paymentsidcapturesBuyerInformationPersonalIdentification>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "merchantCustomerId",
            "baseName": "merchantCustomerId",
            "type": "string"
        },
        {
            "name": "vatRegistrationNumber",
            "baseName": "vatRegistrationNumber",
            "type": "string"
        },
        {
            "name": "dateOfBirth",
            "baseName": "dateOfBirth",
            "type": "string"
        },
        {
            "name": "gender",
            "baseName": "gender",
            "type": "string"
        },
        {
            "name": "language",
            "baseName": "language",
            "type": "string"
        },
        {
            "name": "personalIdentification",
            "baseName": "personalIdentification",
            "type": "Array<Ptsv2paymentsidcapturesBuyerInformationPersonalIdentification>"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsidcapturesBuyerInformation.attributeTypeMap;
    }
}

export class Ptsv2paymentsidcapturesBuyerInformationPersonalIdentification {
    /**
    * The value of the identification type. This field is supported only on the following processors.  #### ComercioLatino Set this field to the Cadastro de Pessoas Fisicas (CPF).  #### CyberSource Latin American Processing Supported for Redecard in Brazil. Set this field to the Cadastro de Pessoas Fisicas (CPF), which is required for AVS for Redecard in Brazil. **Note** CyberSource Latin American Processing is the name of a specific processing connection that CyberSource supports. In the CyberSource API documentation, CyberSource Latin American Processing does not refer to the general topic of processing in Latin America. The information in this field description is for the specific processing connection called CyberSource Latin American Processing. It is not for any other Latin American processors that CyberSource supports.               If `type = PASSPORT`, this is the cardholder's passport number. Recommended for Discover ProtectBuy. 
    */
    'id'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsidcapturesBuyerInformationPersonalIdentification.attributeTypeMap;
    }
}

export class Ptsv2paymentsidcapturesDeviceInformation {
    /**
    * DNS resolved hostname from `ipAddress`.
    */
    'hostName'?: string;
    /**
    * IP address of the customer.  #### Used by **Authorization, Capture, and Credit** Optional field. 
    */
    'ipAddress'?: string;
    /**
    * Customer’s browser as identified from the HTTP header data. For example, `Mozilla` is the value that identifies the Netscape browser. 
    */
    'userAgent'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "hostName",
            "baseName": "hostName",
            "type": "string"
        },
        {
            "name": "ipAddress",
            "baseName": "ipAddress",
            "type": "string"
        },
        {
            "name": "userAgent",
            "baseName": "userAgent",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsidcapturesDeviceInformation.attributeTypeMap;
    }
}

export class Ptsv2paymentsidcapturesInstallmentInformation {
    /**
    * Amount for the current installment payment.  This field is supported only for CyberSource through VisaNet. 
    */
    'amount'?: string;
    /**
    * Frequency of the installment payments. When you do not include this field in a request for a Crediario installment payment, CyberSource sends a space character to the processor.  This field is supported only for CyberSource through VisaNet. Possible values: - `B`: Biweekly - `M`: Monthly - `W`: Weekly  For Crediario installment payments, the value for this field corresponds to the following data in the TC 33 capture file5: - Record: CP01 TCR9 - Position: 41 - Field: Installment Frequency 
    */
    'frequency'?: string;
    /**
    * #### American Express Direct, Cielo, and CyberSource Latin American Processing Flag that indicates the type of funding for the installment plan associated with the payment.  Possible values: - `1`: Merchant-funded installment plan - `2`: Issuer-funded installment plan If you do not include this field in the request, CyberSource uses the value in your CyberSource account.  To change the value in your CyberSource account, contact CyberSource Customer Service.  #### CyberSource through VisaNet and American Express Defined code that indicates the type of installment plan for this transaction.  Contact American Express for: - Information about the kinds of installment plans that American Express provides - Values for this field  For installment payments with American Express in Brazil, the value for this field corresponds to the following data in the TC 33 capture file*: - Record: CP07 TCR3 - Position: 5-6 - Field: Plan Type  * The TC 33 Capture file contains information about the purchases and refunds that a merchant submits to CyberSource. CyberSource through VisaNet creates the TC 33 Capture file at the end of the day and sends it to the merchant’s acquirer, who uses this information to facilitate end-of-day clearing processing with payment card companies.  #### CyberSource through VisaNet with Visa or Mastercard Flag indicating the type of funding for the installment plan associated with the payment. Possible values: - 1 or 01: Merchant-funded installment plan - 2 or 02: Issuer-funded installment plan - 43: Crediario installment plan—only with Visa in Brazil  For installment payments with Visa in Brazil, the value for this field corresponds to the following data in the TC 33 capture file5: - Record: CP07 TCR1 - Position: 5-6 - Field: Installment Type  For all other kinds of installment payments, the value for this field corresponds to the following data in the TC 33 capture file5: - Record: CP01 TCR5 - Position: 39-40 - Field: Installment Plan Type (Issuer or Merchant) 
    */
    'planType'?: string;
    /**
    * Installment number when making payments in installments. Used along with `totalCount` to track which payment is being processed.  For example, the second of 5 payments would be passed to CyberSource as `sequence` = 2 and `totalCount` = 5.  #### Chase Paymentech Solutions and FDC Compass This field is optional because this value is required in the merchant descriptors.  #### CyberSource through VisaNet When you do not include this field in a request for a Crediario installment payment, CyberSource sends a value of 0 to the processor.  For Crediario installment payments, the value for this field corresponds to the following data in the TC 33 capture file*: - Record: CP01 TCR9 - Position: 38-40 - Field: Installment Payment Number  * The TC 33 Capture file contains information about the purchases and refunds that a merchant submits to CyberSource. CyberSource through VisaNet creates the TC 33 Capture file at the end of the day and sends it to the merchant’s acquirer, who uses this information to facilitate end-of-day clearing processing with payment card companies. 
    */
    'sequence'?: number;
    /**
    * Total amount of the loan that is being paid in installments. This field is supported only for CyberSource through VisaNet. 
    */
    'totalAmount'?: string;
    /**
    * Total number of installments when making payments in installments.  #### Chase Paymentech Solutions and FDC Compass This field is optional because this value is required in the merchant descriptors.  #### American Express Direct, Cielo, and Comercio Latino This value is the total number of installments you approved.  #### CyberSource Latin American Processing in Brazil This value is the total number of installments that you approved. The default is 1.  #### All Other Processors This value is used along with _sequence_ to track which payment is being processed.  For example, the second of 5 payments would be passed to CyberSource as _sequence_ = 2 and _totalCount_ = 5.  #### CyberSource through VisaNet For Crediario installment payments, the value for this field corresponds to the following data in the TC 33 capture file*: - Record: CP01 TCR9 - Position: 23-25 - Field: Number of Installments  For installment payments with American Express in Brazil, the value for this field corresponds to the following data in the TC 33 capture file*: - Record: CP07 TCR3 - Position: 7-8 - Field: Number of Installments  For installment payments with Visa in Brazil, the value for this field corresponds to the following data in the TC 33 capture file*: - Record: CP07 TCR1 - Position: 7-8 - Field: Number of Installments  For all other kinds of installment payments, the value for this field corresponds to the following data in the TC 33 capture file*: - Record: CP01 TCR5 - Position: 20-22 - Field: Installment Total Count  **Note** The TC 33 Capture file contains information about the purchases and refunds that a merchant submits to CyberSource. CyberSource through VisaNet creates the TC 33 Capture file at the end of the day and sends it to the merchant’s acquirer, who uses this information to facilitate end-of-day clearing processing with payment card companies. 
    */
    'totalCount'?: number;
    /**
    * Date of the first installment payment. Format: YYMMDD. When you do not include this field, CyberSource sends a string of six zeros (000000) to the processor.  This field is supported only for Crediario installment payments in Brazil on CyberSource through VisaNet.  The value for this field corresponds to the following data in the TC 33 capture file: - Record: CP01 TCR9 - Position: 42-47 - Field: Date of First Installment 
    */
    'firstInstallmentDate'?: string;
    /**
    * Amount of the first installment payment. The issuer provides this value when the first installment payment is successful. This field is supported for Mastercard installment payments on CyberSource through VisaNet in all countries except Brazil,Croatia, Georgia, and Greece. The value for this field corresponds to the following data in the TC 33 capture file: - Record: CP01 TCR5 - Position: 23-34 - Field: Amount of Each Installment 
    */
    'firstInstallmentAmount'?: string;
    /**
    * Invoice information that you want to provide to the issuer. This value is similar to a tracking number and is the same for all installment payments for one purchase.  This field is supported only for installment payments with Mastercard on CyberSource through VisaNet in Brazil.  The value for this field corresponds to the following data in the TC 33 capture file5: - Record: CP07 TCR4 - Position: 51-70 - Field: Purchase Identification 
    */
    'invoiceData'?: string;
    /**
    * Payment plan for the installments. This field is supported only for installment payments on Visa Platform Connect, RuPay and SPG-KSA seamless flow.  Possible values for a standing-instruction (SI) merchant-initiated transaction (MIT) with Diners Club or Mastercard in India or with an India-issued card: - 1: SI with a fixed amount. - 2: SI with a maximum amount. - 3: Other kind of SI.  Possible values for a type of Installment transaction for on-soil transaction in Kingdom of Saudi Arabia - 1: Registration or first transaction. - 2: Subsequent transaction.  Possible values for other kinds of installment payments: - 0 (default): Regular installment. This value is not allowed for airline transactions. - 1: Installment payment with down payment. - 2: Installment payment without down payment. This value is supported only for airline transactions. - 3: Installment payment; down payment and boarding fee will follow. This value is supported only for airline transactions. - 4: Down payment only; regular installment payment will follow. - 5: Boarding fee only. This value is supported only for airline transactions. - 6: SI de-registration on RuPay for the payer authentication seamless flow. 
    */
    'paymentType'?: string;
    /**
    * Additional costs charged by the issuer to fund the installment payments.  This field is included in the authorization reply for the Crediario eligibility request when the issuer approves the cardholder's request for Crediario installment payments in Brazil.  This field is supported only for Crediario installment payments in Brazil on **CyberSource through VisaNet**.  The value for this field corresponds to the following data in the TC 33 capture file1: - Record: CP01 TCR9 - Position: 128-139 - Field: Total Other Costs 
    */
    'additionalCosts'?: string;
    /**
    * Additional costs divided by the amount funded.  For example: - A value of 1.0 specifies 1%. - A value of 4.0 specifies 4%.  This field is included in the authorization reply for the Crediario eligibility request when the issuer approves the cardholder's request for Crediario installment payments in Brazil.  This field is supported only for Crediario installment payments in Brazil on **CyberSource through VisaNet**.  The value for this field corresponds to the following data in the TC 33 capture file1: - Record: CP01 TCR9 - Position: 140-143 - Field: Percent of Total Other Costs 
    */
    'additionalCostsPercentage'?: string;
    /**
    * Amount funded.  This field is included in the authorization reply for the Crediario eligibility request when the issuer approves the cardholder's request for Crediario installment payments in Brazil.  This field is supported only for Crediario installment payments in Brazil on **CyberSource through VisaNet**.  The value for this field corresponds to the following data in the TC 33 capture file1: - Record: CP01 TCR9 - Position: 48-59 - Field: Total Amount Funded 
    */
    'amountFunded'?: string;
    /**
    * Amount requested divided by the amount funded.  For example: - A value of 90.0 specifies 90%. - A value of 93.7 specifies 93.7%.  This field is included in the authorization reply for the Crediario eligibility request when the issuer approves the cardholder's request for Crediario installment payments in Brazil.  This field is supported only for Crediario installment payments in Brazil on **CyberSource through VisaNet**.  The value for this field corresponds to the following data in the TC 33 capture file1: - Record: CP01 TCR9 - Position: 60-63 - Field: Percent of Amount Requested 
    */
    'amountRequestedPercentage'?: string;
    /**
    * Annual cost of financing the installment payments.  This field is included in the authorization reply for the Crediario eligibility request when the issuer approves the cardholder's request for Crediario installment payments in Brazil.  This field is supported only for Crediario installment payments in Brazil on **CyberSource through VisaNet**.  The value for this field corresponds to the following data in the TC 33 capture file1: - Record: CP01 TCR9 - Position: 158-164 - Field: Annual Total Cost of Financing 
    */
    'annualFinancingCost'?: string;
    /**
    * Annual interest rate.  This field is returned only for two kinds of installment payments on Visa Platform Connect: - Crediario with Visa in Brazil: this field is included in the authorization response for the Crediario eligibility request when the issuer approves the customer's request for Crediario installment payments. - Mastercard in all countries except Brazil, Croatia, Georgia, and Greece.   Example: A value of 1.0 specifies 1%.  Example: A value of 4.0 specifies 4%.  #### Brazil The value for this field corresponds to the following data in the TC 33 capture file: - Record: CP01 TCR9 - Position: 151-157 - Field: Annual Interest Rate   #### Other Countries The value for this field corresponds to the following data in the TC 33 capture file: - Record: CP01 TCR5 - Position: 58-62 SCMP API Fields| 216 - Field: Mastercard Annual Percentage Rate 
    */
    'annualInterestRate'?: string;
    /**
    * Expenses charged by the issuer to fund the installment payments.  This field is included in the authorization reply for the Crediario eligibility request when the issuer approves the cardholder's request for Crediario installment payments in Brazil.  This field is supported only for Crediario installment payments in Brazil on **CyberSource through VisaNet**.  The value for this field corresponds to the following data in the TC 33 capture file1: - Record: CP01 TCR9 - Position: 64-75 - Field: Total Expenses 
    */
    'expenses'?: string;
    /**
    * Expenses divided by the amount funded.  For example: - A value of 1.0 specifies 1%. - A value of 4.0 specifies 4%.  This field is included in the authorization reply for the Crediario eligibility request when the issuer approves the cardholder's request for Crediario installment payments in Brazil.  This field is supported only for Crediario installment payments in Brazil on **CyberSource through VisaNet**.  The value for this field corresponds to the following data in the TC 33 capture file1: - Record: CP01 TCR9 - Position: 76-79 - Field: Percent of Total Expenses 
    */
    'expensesPercentage'?: string;
    /**
    * Fees charged by the issuer to fund the installment payments.  This field is included in the authorization reply for the Crediario eligibility request when the issuer approves the cardholder's request for Crediario installment payments in Brazil.  This field is supported only for Crediario installment payments in Brazil on **CyberSource through VisaNet**.  The value for this field corresponds to the following data in the TC 33 capture file1: - Record: CP01 TCR9 - Position: 80-91 - Field: Total Fees 
    */
    'fees'?: string;
    /**
    * Fees divided by the amount funded.  For example: - A value of 1.0 specifies 1%. - A value of 4.0 specifies 4%.  This field is included in the authorization reply for the Crediario eligibility request when the issuer approves the cardholder's request for Crediario installment payments in Brazil.  This field is supported only for Crediario installment payments in Brazil on CyberSource through VisaNet.  The value for this field corresponds to the following data in the TC 33 capture file1: - Record: CP01 TCR9 - Position: 92-95 - Field: Percent of Total Fees 
    */
    'feesPercentage'?: string;
    /**
    * Insurance charged by the issuer to fund the installment payments.  This field is included in the authorization reply for the Crediario eligibility request when the issuer approves the cardholder's request for Crediario installment payments in Brazil.  This field is supported only for Crediario installment payments in Brazil on **CyberSource through VisaNet**.  The value for this field corresponds to the following data in the TC 33 capture file1: - Record: CP01 TCR9 - Position: 112-123 - Field: Total Insurance 
    */
    'insurance'?: string;
    /**
    * Insurance costs divided by the amount funded.  For example: - A value of 1.0 specifies 1%. - A value of 4.0 specifies 4%.  This field is included in the authorization reply for the Crediario eligibility request when the issuer approves the cardholder's request for Crediario installment payments in Brazil.  This field is supported only for Crediario installment payments in Brazil on **CyberSource through VisaNet**.  The value for this field corresponds to the following data in the TC 33 capture file1: - Record: CP01 TCR9 - Position: 124-127 - Field: Percent Of Total Insurance 
    */
    'insurancePercentage'?: string;
    /**
    * Monthly interest rate.  For example: - A value of 1.0 specifies 1%. - A value of 4.0 specifies 4%.  This field is included in the authorization reply for the Crediario eligibility request when the issuer approves the cardholder's request for Crediario installment payments in Brazil.  This field is supported only for Crediario installment payments in Brazil on **CyberSource through VisaNet**.  The value for this field corresponds to the following data in the TC 33 capture file1: - Record: CP01 TCR9 - Position: 144-150 - Field: Monthly Interest Rate 
    */
    'monthlyInterestRate'?: string;
    /**
    * Taxes collected by the issuer to fund the installment payments.  This field is included in the authorization reply for the Crediario eligibility request when the issuer approves the cardholder's request for Crediario installment payments in Brazil.  This field is supported only for Crediario installment payments in Brazil on **CyberSource through VisaNet**.  The value for this field corresponds to the following data in the TC 33 capture file1: - Record: CP01 TCR9 - Position: 96-107 - Field: Total Taxes 
    */
    'taxes'?: string;
    /**
    * Taxes divided by the amount funded.  For example: - A value of 1.0 specifies 1%. - A value of 4.0 specifies 4%.  This field is included in the authorization reply for the Crediario eligibility request when the issuer approves the cardholder's request for Crediario installment payments in Brazil.  This field is supported only for Crediario installment payments in Brazil on **CyberSource through VisaNet**.  The value for this field corresponds to the following data in the TC 33 capture file1: - Record: CP01 TCR9 - Position: 108-111 - Field: Percent of Total Taxes 
    */
    'taxesPercentage'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "amount",
            "baseName": "amount",
            "type": "string"
        },
        {
            "name": "frequency",
            "baseName": "frequency",
            "type": "string"
        },
        {
            "name": "planType",
            "baseName": "planType",
            "type": "string"
        },
        {
            "name": "sequence",
            "baseName": "sequence",
            "type": "number"
        },
        {
            "name": "totalAmount",
            "baseName": "totalAmount",
            "type": "string"
        },
        {
            "name": "totalCount",
            "baseName": "totalCount",
            "type": "number"
        },
        {
            "name": "firstInstallmentDate",
            "baseName": "firstInstallmentDate",
            "type": "string"
        },
        {
            "name": "firstInstallmentAmount",
            "baseName": "firstInstallmentAmount",
            "type": "string"
        },
        {
            "name": "invoiceData",
            "baseName": "invoiceData",
            "type": "string"
        },
        {
            "name": "paymentType",
            "baseName": "paymentType",
            "type": "string"
        },
        {
            "name": "additionalCosts",
            "baseName": "additionalCosts",
            "type": "string"
        },
        {
            "name": "additionalCostsPercentage",
            "baseName": "additionalCostsPercentage",
            "type": "string"
        },
        {
            "name": "amountFunded",
            "baseName": "amountFunded",
            "type": "string"
        },
        {
            "name": "amountRequestedPercentage",
            "baseName": "amountRequestedPercentage",
            "type": "string"
        },
        {
            "name": "annualFinancingCost",
            "baseName": "annualFinancingCost",
            "type": "string"
        },
        {
            "name": "annualInterestRate",
            "baseName": "annualInterestRate",
            "type": "string"
        },
        {
            "name": "expenses",
            "baseName": "expenses",
            "type": "string"
        },
        {
            "name": "expensesPercentage",
            "baseName": "expensesPercentage",
            "type": "string"
        },
        {
            "name": "fees",
            "baseName": "fees",
            "type": "string"
        },
        {
            "name": "feesPercentage",
            "baseName": "feesPercentage",
            "type": "string"
        },
        {
            "name": "insurance",
            "baseName": "insurance",
            "type": "string"
        },
        {
            "name": "insurancePercentage",
            "baseName": "insurancePercentage",
            "type": "string"
        },
        {
            "name": "monthlyInterestRate",
            "baseName": "monthlyInterestRate",
            "type": "string"
        },
        {
            "name": "taxes",
            "baseName": "taxes",
            "type": "string"
        },
        {
            "name": "taxesPercentage",
            "baseName": "taxesPercentage",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsidcapturesInstallmentInformation.attributeTypeMap;
    }
}

export class Ptsv2paymentsidcapturesMerchantInformation {
    'merchantDescriptor'?: Ptsv2paymentsMerchantInformationMerchantDescriptor;
    /**
    * Reference number that facilitates card acceptor/corporation communication and record keeping. 
    */
    'cardAcceptorReferenceNumber'?: string;
    /**
    * The value for this field is a four-digit number that the payment card industry uses to classify merchants into market segments. A payment card company assigned one or more of these values to your business when you started accepting the payment card company’s cards. When you do not include this field in your request, CyberSource uses the value in your CyberSource account.  #### CyberSource through VisaNet The value for this field corresponds to the following data in the TC 33 capture file5: - Record: CP01 TCR4 - Position: 150-153 - Field: Merchant Category Code 
    */
    'categoryCode'?: number;
    /**
    * Your government-assigned tax identification number.  #### Tax Calculation Required field for value added tax only. Not applicable to U.S. and Canadian taxes.  #### CyberSource through VisaNet For CtV processors, the maximum length is 20. 
    */
    'vatRegistrationNumber'?: string;
    'serviceFeeDescriptor'?: Ptsv2paymentsMerchantInformationServiceFeeDescriptor;
    /**
    * Your Cadastro Nacional da Pessoa Jurídica (CNPJ) number.  This field is supported only for BNDES transactions on CyberSource through VisaNet.  The value for this field corresponds to the following data in the TC 33 capture file5: - Record: CP07 TCR6 - Position: 40-59 - Field: BNDES Reference Field 1 
    */
    'taxId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "merchantDescriptor",
            "baseName": "merchantDescriptor",
            "type": "Ptsv2paymentsMerchantInformationMerchantDescriptor"
        },
        {
            "name": "cardAcceptorReferenceNumber",
            "baseName": "cardAcceptorReferenceNumber",
            "type": "string"
        },
        {
            "name": "categoryCode",
            "baseName": "categoryCode",
            "type": "number"
        },
        {
            "name": "vatRegistrationNumber",
            "baseName": "vatRegistrationNumber",
            "type": "string"
        },
        {
            "name": "serviceFeeDescriptor",
            "baseName": "serviceFeeDescriptor",
            "type": "Ptsv2paymentsMerchantInformationServiceFeeDescriptor"
        },
        {
            "name": "taxId",
            "baseName": "taxId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsidcapturesMerchantInformation.attributeTypeMap;
    }
}

export class Ptsv2paymentsidcapturesOrderInformation {
    'amountDetails'?: Ptsv2paymentsidcapturesOrderInformationAmountDetails;
    'billTo'?: Ptsv2paymentsidcapturesOrderInformationBillTo;
    'shipTo'?: Ptsv2paymentsidcapturesOrderInformationShipTo;
    'lineItems'?: Array<Ptsv2paymentsOrderInformationLineItems>;
    'invoiceDetails'?: Ptsv2paymentsidcapturesOrderInformationInvoiceDetails;
    'shippingDetails'?: Ptsv2paymentsidcapturesOrderInformationShippingDetails;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "amountDetails",
            "baseName": "amountDetails",
            "type": "Ptsv2paymentsidcapturesOrderInformationAmountDetails"
        },
        {
            "name": "billTo",
            "baseName": "billTo",
            "type": "Ptsv2paymentsidcapturesOrderInformationBillTo"
        },
        {
            "name": "shipTo",
            "baseName": "shipTo",
            "type": "Ptsv2paymentsidcapturesOrderInformationShipTo"
        },
        {
            "name": "lineItems",
            "baseName": "lineItems",
            "type": "Array<Ptsv2paymentsOrderInformationLineItems>"
        },
        {
            "name": "invoiceDetails",
            "baseName": "invoiceDetails",
            "type": "Ptsv2paymentsidcapturesOrderInformationInvoiceDetails"
        },
        {
            "name": "shippingDetails",
            "baseName": "shippingDetails",
            "type": "Ptsv2paymentsidcapturesOrderInformationShippingDetails"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsidcapturesOrderInformation.attributeTypeMap;
    }
}

export class Ptsv2paymentsidcapturesOrderInformationAmountDetails {
    /**
    * Grand total for the order. This value cannot be negative. You can include a decimal point (.), but no other special characters. CyberSource truncates the amount to the correct number of decimal places.  **Note** For CTV, FDCCompass, Paymentech processors, the maximum length for this field is 12.  **Important** Some processors have specific requirements and limitations, such as maximum amounts and maximum field lengths.  If your processor supports zero amount authorizations, you can set this field to 0 for the authorization to check if the card is lost or stolen.   #### Card Present Required to include either this field or `orderInformation.lineItems[].unitPrice` for the order.  #### Invoicing / Pay By Link Required for creating a new invoice or payment link.  #### PIN Debit Amount you requested for the PIN debit purchase. This value is returned for partial authorizations. The issuing bank can approve a partial amount if the balance on the debit card is less than the requested transaction amount.  Required field for PIN Debit purchase and PIN Debit credit requests. Optional field for PIN Debit reversal requests.  #### GPX This field is optional for reversing an authorization or credit; however, for all other processors, these fields are required.  #### DCC with a Third-Party Provider Set this field to the converted amount that was returned by the DCC provider. You must include either this field or the 1st line item in the order and the specific line-order amount in your request.   #### DCC for First Data Not used. 
    */
    'totalAmount'?: string;
    /**
    * Currency used for the order. Use the three-character [ISO Standard Currency Codes.](http://apps.cybersource.com/library/documentation/sbc/quickref/currencies.pdf)  #### Used by **Authorization** Required field.  **Authorization Reversal** For an authorization reversal (`reversalInformation`) or a capture (`processingOptions.capture` is set to `true`), you must use the same currency that you used in your payment authorization request.  #### PIN Debit Currency for the amount you requested for the PIN debit purchase. This value is returned for partial authorizations. The issuing bank can approve a partial amount if the balance on the debit card is less than the requested transaction amount. For the possible values, see the [ISO Standard Currency Codes](https://developer.cybersource.com/library/documentation/sbc/quickref/currencies.pdf). Returned by PIN debit purchase.  For PIN debit reversal requests, you must use the same currency that was used for the PIN debit purchase or PIN debit credit that you are reversing. For the possible values, see the [ISO Standard Currency Codes](https://developer.cybersource.com/library/documentation/sbc/quickref/currencies.pdf).  Required field for PIN Debit purchase and PIN Debit credit requests. Optional field for PIN Debit reversal requests.  #### GPX This field is optional for reversing an authorization or credit.  #### DCC for First Data Your local currency.  #### Tax Calculation Required for international tax and value added tax only. Optional for U.S. and Canadian taxes. Your local currency. 
    */
    'currency'?: string;
    /**
    * Total discount amount applied to the order. 
    */
    'discountAmount'?: string;
    /**
    * Total charges for any import or export duties included in the order. 
    */
    'dutyAmount'?: string;
    /**
    * Gratuity or tip amount for restaurants. Allowed only when industryDatatype=restaurant. When your customer uses a debit card or prepaid card, and you receive a partial authorization, the payment networks recommend that you do not submit a capture amount that is higher than the authorized amount. When the capture amount exceeds the partial amount that was approved, the issuer has chargeback rights for the excess amount.  Used by **Capture** Optional field.  #### CyberSource through VisaNet Restaurant data is supported only on CyberSource through VisaNet when card is present. 
    */
    'gratuityAmount'?: string;
    /**
    * Total tax amount for all the items in the order. 
    */
    'taxAmount'?: string;
    /**
    * Flag that indicates whether a national tax is included in the order total.  Possible values:   - **0**: national tax not included  - **1**: national tax included 
    */
    'nationalTaxIncluded'?: string;
    /**
    * Flag that indicates how the merchant manages discounts.  Possible values:   - **0**: no invoice level discount included  - **1**: tax calculated on the postdiscount invoice total  - **2**: tax calculated on the prediscount invoice total 
    */
    'taxAppliedAfterDiscount'?: string;
    /**
    * Flag that indicates how you calculate tax.  Possible values:   - **0**: net prices with tax calculated at line item level  - **1**: net prices with tax calculated at invoice level  - **2**: gross prices with tax provided at line item level  - **3**: gross prices with tax provided at invoice level  - **4**: no tax applies on the invoice for the transaction 
    */
    'taxAppliedLevel'?: string;
    /**
    * For tax amounts that can be categorized as one tax type.  This field contains the tax type code that corresponds to the entry in the _lineItems.taxAmount_ field.  Possible values:   - **056**: sales tax (U.S only)  - **TX~**: all taxes (Canada only)   Note ~ = space. 
    */
    'taxTypeCode'?: string;
    /**
    * Total freight or shipping and handling charges for the order. When you include this field in your request, you must also include the **totalAmount** field. 
    */
    'freightAmount'?: string;
    /**
    * Set this field to the converted amount that was returned by the DCC provider. 
    */
    'foreignAmount'?: string;
    /**
    * Set this field to the converted amount that was returned by the DCC provider. 
    */
    'foreignCurrency'?: string;
    /**
    * Exchange rate returned by the DCC service. Includes a decimal point and a maximum of 4 decimal places. 
    */
    'exchangeRate'?: string;
    /**
    * Time stamp for the exchange rate. This value is returned by the DCC service.  Format: `YYYYMMDD~HH:MM`  where ~ denotes a space. 
    */
    'exchangeRateTimeStamp'?: string;
    'amexAdditionalAmounts'?: Array<Ptsv2paymentsOrderInformationAmountDetailsAmexAdditionalAmounts>;
    'taxDetails'?: Array<Ptsv2paymentsOrderInformationAmountDetailsTaxDetails>;
    /**
    * Service fee. Required for service fee transactions. 
    */
    'serviceFeeAmount'?: string;
    /**
    * Your local pricing currency code.  For the possible values, see the [ISO Standard Currency Codes.](http://apps.cybersource.com/library/documentation/sbc/quickref/currencies.pdf) 
    */
    'originalCurrency'?: string;
    /**
    * Cashback amount in the acquirer’s currency. If a cashback amount is included in the request, it must be included in the `orderInformation.amountDetails.totalAmount` value.  This field is supported only on CyberSource through VisaNet.  #### Used by **Authorization** Optional. **Authorization Reversal** Optional.  #### PIN debit Optional field for PIN debit purchase, PIN debit credit or PIN debit reversal. 
    */
    'cashbackAmount'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "totalAmount",
            "baseName": "totalAmount",
            "type": "string"
        },
        {
            "name": "currency",
            "baseName": "currency",
            "type": "string"
        },
        {
            "name": "discountAmount",
            "baseName": "discountAmount",
            "type": "string"
        },
        {
            "name": "dutyAmount",
            "baseName": "dutyAmount",
            "type": "string"
        },
        {
            "name": "gratuityAmount",
            "baseName": "gratuityAmount",
            "type": "string"
        },
        {
            "name": "taxAmount",
            "baseName": "taxAmount",
            "type": "string"
        },
        {
            "name": "nationalTaxIncluded",
            "baseName": "nationalTaxIncluded",
            "type": "string"
        },
        {
            "name": "taxAppliedAfterDiscount",
            "baseName": "taxAppliedAfterDiscount",
            "type": "string"
        },
        {
            "name": "taxAppliedLevel",
            "baseName": "taxAppliedLevel",
            "type": "string"
        },
        {
            "name": "taxTypeCode",
            "baseName": "taxTypeCode",
            "type": "string"
        },
        {
            "name": "freightAmount",
            "baseName": "freightAmount",
            "type": "string"
        },
        {
            "name": "foreignAmount",
            "baseName": "foreignAmount",
            "type": "string"
        },
        {
            "name": "foreignCurrency",
            "baseName": "foreignCurrency",
            "type": "string"
        },
        {
            "name": "exchangeRate",
            "baseName": "exchangeRate",
            "type": "string"
        },
        {
            "name": "exchangeRateTimeStamp",
            "baseName": "exchangeRateTimeStamp",
            "type": "string"
        },
        {
            "name": "amexAdditionalAmounts",
            "baseName": "amexAdditionalAmounts",
            "type": "Array<Ptsv2paymentsOrderInformationAmountDetailsAmexAdditionalAmounts>"
        },
        {
            "name": "taxDetails",
            "baseName": "taxDetails",
            "type": "Array<Ptsv2paymentsOrderInformationAmountDetailsTaxDetails>"
        },
        {
            "name": "serviceFeeAmount",
            "baseName": "serviceFeeAmount",
            "type": "string"
        },
        {
            "name": "originalCurrency",
            "baseName": "originalCurrency",
            "type": "string"
        },
        {
            "name": "cashbackAmount",
            "baseName": "cashbackAmount",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsidcapturesOrderInformationAmountDetails.attributeTypeMap;
    }
}

export class Ptsv2paymentsidcapturesOrderInformationBillTo {
    /**
    * Title. 
    */
    'title'?: string;
    /**
    * Customer’s first name. This name must be the same as the name on the card.  **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.  #### SEPA Required for Create Mandate and Import Mandate #### BACS Required for Import Mandate  #### CyberSource Latin American Processing **Important** For an authorization request, CyberSource Latin American Processing concatenates `orderInformation.billTo.firstName` and `orderInformation.billTo.lastName`. If the concatenated value exceeds 30 characters, CyberSource Latin American Processing declines the authorization request.\\ **Note** CyberSource Latin American Processing is the name of a specific processing connection that CyberSource supports. In the CyberSource API documentation, CyberSource Latin American Processing does not refer to the general topic of processing in Latin America. The information in this field description is for the specific processing connection called _CyberSource Latin American Processing_. It is not for any other Latin American processors that CyberSource supports.  #### CyberSource through VisaNet Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.  #### For Payouts: This field may be sent only for FDC Compass.  #### Chase Paymentech Solutions Optional field.  ####  Credit Mutuel-CIC Optional field.  #### OmniPay Direct Optional field.  #### SIX Optional field.  #### TSYS Acquiring Solutions Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.  #### Worldpay VAP Optional field.  #### All other processors Not used. 
    */
    'firstName'?: string;
    /**
    * Customer’s middle name. 
    */
    'middleName'?: string;
    /**
    * Customer’s last name. This name must be the same as the name on the card.  **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.  #### SEPA Required for Create Mandate and Import Mandate #### BACS Required for Import Mandate #### Chase Paymentech Solutions Optional field.  ####  Credit Mutuel-CIC Optional field.  #### CyberSource Latin American Processing **Important** For an authorization request, CyberSource Latin American Processing concatenates `orderInformation.billTo.firstName` and `orderInformation.billTo.lastName`. If the concatenated value exceeds 30 characters, CyberSource Latin American Processing declines the authorization request.\\ **Note** CyberSource Latin American Processing is the name of a specific processing connection that CyberSource supports. In the CyberSource API documentation, CyberSource Latin American Processing does not refer to the general topic of processing in Latin America. The information in this field description is for the specific processing connection called CyberSource Latin American Processing. It is not for any other Latin American processors that CyberSource supports.  #### CyberSource through VisaNet Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.  #### For Payouts: This field may be sent only for FDC Compass.  #### OmniPay Direct Optional field.  #### RBS WorldPay Atlanta Optional field.  #### SIX Optional field.  #### TSYS Acquiring Solutions Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.  #### Worldpay VAP Optional field.  #### All other processors Not used. 
    */
    'lastName'?: string;
    'company'?: Ptsv2paymentsOrderInformationBillToCompany;
    /**
    * Payment card billing street address as it appears on the credit card issuer’s records.  #### SEPA Required for Create Mandate and Import Mandate  #### Atos This field must not contain colons (:).  #### CyberSource through VisaNet **Important** When you populate orderInformation.billTo.address1 and orderInformation.billTo.address2, CyberSource through VisaNet concatenates the two values. If the concatenated value exceeds 40 characters, CyberSource through VisaNet truncates the value at 40 characters before sending it to Visa and the issuing bank. Truncating this value affects AVS results and therefore might also affect risk decisions and chargebacks. Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.  #### FDMS Nashville When the street name is numeric, it must be sent in numeric format. For example, if the address is _One First Street_, it must be sent as _1 1st Street_.  Required if keyed; not used if swiped.  String (20)  #### TSYS Acquiring Solutions Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.  #### All other processors: Optional. String (60)  #### For Payouts This field may be sent only for FDC Compass.  **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting. 
    */
    'address1'?: string;
    /**
    * Used for additional address information. For example: _Attention: Accounts Payable_ Optional field.  For Payouts: This field may be sent only for FDC Compass.  #### Atos This field must not contain colons (:).  #### CyberSource through VisaNet **Important** When you populate `orderInformation.billTo.address1` and `orderInformation.billTo.address2`, CyberSource through VisaNet concatenates the two values. If the concatenated value exceeds 40 characters, CyberSource through VisaNet truncates the value at 40 characters before sending it to Visa and the issuing bank. Truncating this value affects AVS results and therefore might also affect risk decisions and chargebacks. Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.  #### Chase Paymentech Solutions, FDC Compass, and TSYS Acquiring Solutions This value is used for AVS.  #### FDMS Nashville `orderInformation.billTo.address1` and `orderInformation.billTo.address2` together cannot exceed 20 characters. String (20)  #### All Other Processors String (60) 
    */
    'address2'?: string;
    /**
    * Payment card billing city.  #### SEPA Required for Create Mandate and Import Mandate  #### Atos This field must not contain colons (:).  #### CyberSource through VisaNet Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.  #### For Payouts: This field may be sent only for FDC Compass.  #### Chase Paymentech Solutions Optional field.  ####  Credit Mutuel-CIC Optional field.  #### OmniPay Direct Optional field.  #### SIX Optional field.  #### TSYS Acquiring Solutions Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.  #### Worldpay VAP Optional field.  #### All other processors Not used. 
    */
    'locality'?: string;
    /**
    * Customer’s neighborhood, community, or region (a barrio in Brazil) within the city or municipality. This field is available only on **Cielo**. 
    */
    'district'?: string;
    /**
    * State or province of the billing address. Use the [State, Province, and Territory Codes for the United States and Canada](https://developer.cybersource.com/library/documentation/sbc/quickref/states_and_provinces.pdf).  For Payouts: This field may be sent only for FDC Compass.  ##### CyberSource through VisaNet Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.  **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.  #### Chase Paymentech Solutions Optional field.  ####  Credit Mutuel-CIC Optional field.  #### OmniPay Direct Optional field.  #### SIX Optional field.  #### TSYS Acquiring Solutions Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.  #### Worldpay VAP Optional field.  #### All other processors Not used. 
    */
    'administrativeArea'?: string;
    /**
    * Postal code for the billing address. The postal code must consist of 5 to 9 digits.  When the billing country is the U.S., the 9-digit postal code must follow this format: [5 digits][dash][4 digits]  **Example** `12345-6789`  When the billing country is Canada, the 6-digit postal code must follow this format: [alpha][numeric][alpha][space][numeric][alpha][numeric]  **Example** `A1B 2C3`  **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.  #### SEPA Required for Create Mandate and Import Mandate  #### For Payouts:  This field may be sent only for FDC Compass.  #### American Express Direct Before sending the postal code to the processor, CyberSource removes all nonalphanumeric characters and, if the remaining value is longer than nine characters, truncates the value starting from the right side.  #### Atos This field must not contain colons (:).  #### CyberSource through VisaNet Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.  #### FDMS Nashville Required if `pointOfSaleInformation.entryMode=keyed` and the address is in the U.S. or Canada. Optional if `pointOfSaleInformation.entryMode=keyed` and the address is **not** in the U.S. or Canada. Not used if swiped.  #### RBS WorldPay Atlanta: For best card-present keyed rates, send the postal code if `pointOfSaleInformation.entryMode=keyed`.  #### TSYS Acquiring Solutions Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.  #### All other processors: Optional field. 
    */
    'postalCode'?: string;
    /**
    * U.S. county if available.
    */
    'county'?: string;
    /**
    * Payment card billing country. Use the two-character [ISO Standard Country Codes](http://apps.cybersource.com/library/documentation/sbc/quickref/countries_alpha_list.pdf).  #### SEPA/BACS Required for Create Mandate and Import Mandate  #### CyberSource through VisaNet Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.  **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.  #### Chase Paymentech Solutions Optional field.  ####  Credit Mutuel-CIC Optional field.  #### OmniPay Direct Optional field.  #### SIX Optional field.  #### TSYS Acquiring Solutions Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.  #### Worldpay VAP Optional field.  #### All other processors Not used. 
    */
    'country'?: string;
    /**
    * Customer's email address, including the full domain name.  #### CyberSource through VisaNet Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.  **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.  #### Invoicing Email address for the customer for sending the invoice. If the invoice is in SENT status and email is updated, the old email customer payment link won't work and you must resend the invoice with the new payment link.  #### Chase Paymentech Solutions Optional field.  ####  Credit Mutuel-CIC Optional field.  #### OmniPay Direct Optional field.  #### SIX Optional field.  #### TSYS Acquiring Solutions Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.  #### Worldpay VAP Optional field.  #### All other processors Not used. 
    */
    'email'?: string;
    /**
    * Customer’s phone number.  It is recommended that you include the country code when the order is from outside the U.S.  #### Chase Paymentech Solutions Optional field.  ####  Credit Mutuel-CIC Optional field.  #### CyberSource through VisaNet Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.  #### For Payouts: This field may be sent only for FDC Compass.  #### OmniPay Direct Optional field.  #### SIX Optional field.  #### TSYS Acquiring Solutions Optional field.  #### Worldpay VAP Optional field.  #### All other processors Not used. 
    */
    'phoneNumber'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "firstName",
            "baseName": "firstName",
            "type": "string"
        },
        {
            "name": "middleName",
            "baseName": "middleName",
            "type": "string"
        },
        {
            "name": "lastName",
            "baseName": "lastName",
            "type": "string"
        },
        {
            "name": "company",
            "baseName": "company",
            "type": "Ptsv2paymentsOrderInformationBillToCompany"
        },
        {
            "name": "address1",
            "baseName": "address1",
            "type": "string"
        },
        {
            "name": "address2",
            "baseName": "address2",
            "type": "string"
        },
        {
            "name": "locality",
            "baseName": "locality",
            "type": "string"
        },
        {
            "name": "district",
            "baseName": "district",
            "type": "string"
        },
        {
            "name": "administrativeArea",
            "baseName": "administrativeArea",
            "type": "string"
        },
        {
            "name": "postalCode",
            "baseName": "postalCode",
            "type": "string"
        },
        {
            "name": "county",
            "baseName": "county",
            "type": "string"
        },
        {
            "name": "country",
            "baseName": "country",
            "type": "string"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "phoneNumber",
            "baseName": "phoneNumber",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsidcapturesOrderInformationBillTo.attributeTypeMap;
    }
}

export class Ptsv2paymentsidcapturesOrderInformationInvoiceDetails {
    /**
    * Value used by your customer to identify the order. This value is typically a purchase order number. CyberSource recommends that you do not populate the field with all zeros or nines. 
    */
    'purchaseOrderNumber'?: string;
    /**
    * Date the order was processed. `Format: YYYY-MM-DD`. 
    */
    'purchaseOrderDate'?: string;
    /**
    * The name of the individual or the company contacted for company authorized purchases. 
    */
    'purchaseContactName'?: string;
    /**
    * Flag that indicates whether an order is taxable. This value must be true if the sum of all _lineItems[].taxAmount_ values > 0.  If you do not include any `lineItems[].taxAmount` values in your request, CyberSource does not include `invoiceDetails.taxable` in the data it sends to the processor.  Possible values:  - **true**  - **false** 
    */
    'taxable'?: boolean;
    /**
    * VAT invoice number associated with the transaction. 
    */
    'vatInvoiceReferenceNumber'?: string;
    /**
    * International description code of the overall order’s goods or services or the Categorizes purchases for VAT reporting. Contact your acquirer for a list of codes. 
    */
    'commodityCode'?: string;
    'transactionAdviceAddendum'?: Array<Ptsv2paymentsOrderInformationInvoiceDetailsTransactionAdviceAddendum>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "purchaseOrderNumber",
            "baseName": "purchaseOrderNumber",
            "type": "string"
        },
        {
            "name": "purchaseOrderDate",
            "baseName": "purchaseOrderDate",
            "type": "string"
        },
        {
            "name": "purchaseContactName",
            "baseName": "purchaseContactName",
            "type": "string"
        },
        {
            "name": "taxable",
            "baseName": "taxable",
            "type": "boolean"
        },
        {
            "name": "vatInvoiceReferenceNumber",
            "baseName": "vatInvoiceReferenceNumber",
            "type": "string"
        },
        {
            "name": "commodityCode",
            "baseName": "commodityCode",
            "type": "string"
        },
        {
            "name": "transactionAdviceAddendum",
            "baseName": "transactionAdviceAddendum",
            "type": "Array<Ptsv2paymentsOrderInformationInvoiceDetailsTransactionAdviceAddendum>"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsidcapturesOrderInformationInvoiceDetails.attributeTypeMap;
    }
}

export class Ptsv2paymentsidcapturesOrderInformationShipTo {
    /**
    * State or province of the shipping address. Use the [State, Province, and Territory Codes for the United States and Canada](https://developer.cybersource.com/library/documentation/sbc/quickref/states_and_provinces.pdf) (maximum length: 2)   Required field for authorization if any shipping address information is included in the request and shipping to the U.S. or Canada; otherwise, optional.  #### Tax Calculation Optional field for U.S. and Canadian taxes. Not applicable to international and value added taxes. Billing address objects will be used to determine the cardholder’s location when shipTo objects are not present. 
    */
    'administrativeArea'?: string;
    /**
    * Country of the shipping address. Use the two-character [ISO Standard Country Codes.](http://apps.cybersource.com/library/documentation/sbc/quickref/countries_alpha_list.pdf)  Required field for authorization if any shipping address information is included in the request; otherwise, optional.  #### Tax Calculation Optional field for U.S., Canadian, international tax, and value added taxes. Billing address objects will be used to determine the cardholder’s location when shipTo objects are not present. 
    */
    'country'?: string;
    /**
    * Postal code for the shipping address. The postal code must consist of 5 to 9 digits.  Required field for authorization if any shipping address information is included in the request and shipping to the U.S. or Canada; otherwise, optional.  When the billing country is the U.S., the 9-digit postal code must follow this format: [5 digits][dash][4 digits]  Example 12345-6789  When the billing country is Canada, the 6-digit postal code must follow this format: [alpha][numeric][alpha][space][numeric][alpha][numeric]  Example A1B 2C3  #### American Express Direct Before sending the postal code to the processor, all nonalphanumeric characters are removed and, if the remaining value is longer than nine characters, the value is truncated starting from the right side. #### Tax Calculation Optional field for U.S. and Canadian taxes. Not applicable to international and value added taxes. Billing address objects will be used to determine the cardholder’s location when shipTo objects are not present. 
    */
    'postalCode'?: string;
    /**
    * Email of the recipient.
    */
    'email'?: string;
    /**
    * U.S. county if available.
    */
    'county'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "administrativeArea",
            "baseName": "administrativeArea",
            "type": "string"
        },
        {
            "name": "country",
            "baseName": "country",
            "type": "string"
        },
        {
            "name": "postalCode",
            "baseName": "postalCode",
            "type": "string"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "county",
            "baseName": "county",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsidcapturesOrderInformationShipTo.attributeTypeMap;
    }
}

export class Ptsv2paymentsidcapturesOrderInformationShippingDetails {
    /**
    * Postal code for the address from which the goods are shipped, which is used to establish nexus. The default is the postal code associated with your CyberSource account.  The postal code must consist of 5 to 9 digits. When the billing country is the U.S., the 9-digit postal code must follow this format:  `[5 digits][dash][4 digits]`  Example 12345-6789  When the billing country is Canada, the 6-digit postal code must follow this format:  `[alpha][numeric][alpha][space] [numeric][alpha][numeric]`  Example A1B 2C3  This field is frequently used for Level II and Level III transactions. 
    */
    'shipFromPostalCode'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "shipFromPostalCode",
            "baseName": "shipFromPostalCode",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsidcapturesOrderInformationShippingDetails.attributeTypeMap;
    }
}

export class Ptsv2paymentsidcapturesPaymentInformation {
    'customer'?: Ptsv2paymentsPaymentInformationCustomer;
    'card'?: Ptsv2paymentsidcapturesPaymentInformationCard;
    'paymentType'?: Ptsv2paymentsidcapturesPaymentInformationPaymentType;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "customer",
            "baseName": "customer",
            "type": "Ptsv2paymentsPaymentInformationCustomer"
        },
        {
            "name": "card",
            "baseName": "card",
            "type": "Ptsv2paymentsidcapturesPaymentInformationCard"
        },
        {
            "name": "paymentType",
            "baseName": "paymentType",
            "type": "Ptsv2paymentsidcapturesPaymentInformationPaymentType"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsidcapturesPaymentInformation.attributeTypeMap;
    }
}

export class Ptsv2paymentsidcapturesPaymentInformationCard {
    /**
    * Flag that specifies the type of account associated with the card.  The cardholder provides this information during the payment process.  This field is required in the following cases:   - Debit transactions on Cielo and Comercio Latino.   - Transactions with Brazilian-issued cards on CyberSource through VisaNet.   - Applicable only for CyberSource through VisaNet (CtV).  **Note** Combo cards in Brazil contain credit and debit functionality in a single card. Visa systems use a credit bank identification number (BIN) for this type of card. Using the BIN to determine whether a card is debit or credit can cause transactions with these cards to be processed incorrectly. CyberSource strongly recommends that you include this field for combo card transactions.  Possible values include the following.   - `CH`: Checking account  - `CR`: Credit card account  - `SA`: Saving account  - `LI`: Line of credit or credit portion of combo card  - `PP`: Prepaid card account or prepaid portion of combo card  - `UA`: Universal account  If useAs is set to credit/debit and there is a value in SourceAccountType, the value in the SourceAccountType field will take precedence. If useAs is set to CR/DB and there is a value in SourceAccountType, the value in the useAs field will take precedence. 
    */
    'sourceAccountType'?: string;
    /**
    * Type of account that is being used when the value for the override_payment_method field is line of credit (LI) or prepaid card (PP). Possible values for line of credit: - `AGRC`: Visa Agro Custeio - `AGRE`: Visa Agro Electron - `AGRI`: Visa Agro Investimento - `AGRO`: Visa Agro Possible values for prepaid card: - `VVA`: Visa Vale Alimentacao - `VVF`: Visa Vale Flex - `VVR`: Visa Vale Refeicao This field is supported only for combo card transactions in Brazil on CyberSource through VisaNet. 
    */
    'sourceAccountTypeDetails'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "sourceAccountType",
            "baseName": "sourceAccountType",
            "type": "string"
        },
        {
            "name": "sourceAccountTypeDetails",
            "baseName": "sourceAccountTypeDetails",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsidcapturesPaymentInformationCard.attributeTypeMap;
    }
}

export class Ptsv2paymentsidcapturesPaymentInformationPaymentType {
    'method'?: Ptsv2paymentsidcapturesPaymentInformationPaymentTypeMethod;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "method",
            "baseName": "method",
            "type": "Ptsv2paymentsidcapturesPaymentInformationPaymentTypeMethod"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsidcapturesPaymentInformationPaymentType.attributeTypeMap;
    }
}

export class Ptsv2paymentsidcapturesPaymentInformationPaymentTypeMethod {
    /**
    * A Payment Type is enabled through a Method. Examples: Visa, Master Card, ApplePay, iDeal, 7Eleven, alfamart, bofaPayByBank, payToPayByBank, etc  For Japan Payment Processing Valid Values: - 1 Banking Data - 2 Authorization Data  #### Via KCP - `KCP` : Local Card, Bank Transfer and Carrier Billing. - `PAYCO` - `KAKAOPAY` - `NAVERPAY` 
    */
    'name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsidcapturesPaymentInformationPaymentTypeMethod.attributeTypeMap;
    }
}

export class Ptsv2paymentsidcapturesPointOfSaleInformation {
    'emv'?: Ptsv2paymentsidcapturesPointOfSaleInformationEmv;
    /**
    * Point-of-sale details for the transaction. This value is returned only for **American Express Direct**. CyberSource generates this value, which consists of a series of codes that identify terminal capability, security data, and specific conditions present at the time the transaction occurred. To comply with the CAPN requirements, this value must be included in all subsequent follow-on requests, such as captures and follow-on credits.  When you perform authorizations, captures, and credits through CyberSource, CyberSource passes this value from the authorization service to the subsequent services for you. However, when you perform authorizations through CyberSource and perform subsequent services through other financial institutions, you must ensure that your requests for captures and credits include this value. 
    */
    'amexCapnData'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "emv",
            "baseName": "emv",
            "type": "Ptsv2paymentsidcapturesPointOfSaleInformationEmv"
        },
        {
            "name": "amexCapnData",
            "baseName": "amexCapnData",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsidcapturesPointOfSaleInformation.attributeTypeMap;
    }
}

export class Ptsv2paymentsidcapturesPointOfSaleInformationEmv {
    /**
    * EMV data that is transmitted from the chip card to the issuer, and from the issuer to the chip card. The EMV data is in the tag-length-value format and includes chip card tags, terminal tags, and transaction detail tags.  For information about the individual tags, see the “Application Specification” section in the EMV 4.3 Specifications: http://emvco.com  **Note** Card present information about EMV applies only to credit card processing and PIN debit processing. All other card present information applies only to credit card processing. PIN debit processing is available only on FDC Nashville Global.  **Important** The following tags contain sensitive information and **must not** be included in this field:   - `56`: Track 1 equivalent data  - `57`: Track 2 equivalent data  - `5A`: Application PAN  - `5F20`: Cardholder name  - `5F24`: Application expiration date (This sensitivity has been relaxed for Credit Mutuel-CIC, American Express Direct, FDC Nashville Global, First Data Merchant Solutions, and SIX)  - `99`: Transaction PIN  - `9F0B`: Cardholder name (extended)  - `9F1F`: Track 1 discretionary data  - `9F20`: Track 2 discretionary data  For captures, this field is required for contact EMV transactions. Otherwise, it is optional.  For credits, this field is required for contact EMV stand-alone credits and contactless EMV stand-alone credits. Otherwise, it is optional.  **Important** For contact EMV captures, contact EMV stand-alone credits, and contactless EMV stand-alone credits, you must include the following tags in this field. For all other types of EMV transactions, the following tags are optional.   - `95`: Terminal verification results  - `9F10`: Issuer application data  - `9F26`: Application cryptogram   #### CyberSource through VisaNet - In Japan: 199 bytes - In other countries: String (252)  For Mastercard Transactions, Optionally Tag 9F60 (Authenticated Application Data) and  Tag 96 (Kernel Identifier - Terminal) can be included in the Field.  #### GPX This field only supports transactions from the following card types: - Visa - Mastercard - AMEX - Discover - Diners - JCB - Union Pay International  #### JCN Gateway The following tags must be included: - `4F`: Application identifier - `84`: Dedicated file name  Data length: 199 bytes  #### All other processors: String (999)  #### Used by Authorization: Optional Authorization Reversal: Optional Credit: Optional PIN Debit processing (purchase, credit and reversal): Optional 
    */
    'tags'?: string;
    /**
    * Indicates whether a fallback method was used to enter credit card information into the POS terminal. When a technical problem prevents a successful exchange of information between a chip card and a chip-capable terminal:   1. Swipe the card or key the credit card information into the POS terminal.  2. Use the pointOfSaleInformation.entryMode field to indicate whether the information was swiped or keyed.   Possible values: - `true`: Fallback method was used. - `false` (default): Fallback method was not used.  This field is supported only on American Express Direct, Chase Paymentech Solutions, CyberSource through VisaNet, FDC Nashville Global, GPN, JCN Gateway, OmniPay Direct, and SIX. 
    */
    'fallback'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "tags",
            "baseName": "tags",
            "type": "string"
        },
        {
            "name": "fallback",
            "baseName": "fallback",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsidcapturesPointOfSaleInformationEmv.attributeTypeMap;
    }
}

export class Ptsv2paymentsidcapturesProcessingInformation {
    /**
    * Type of digital payment solution for the transaction. Possible Values:   - `visacheckout`: Visa Checkout. This value is required for Visa Checkout transactions. For details, see `payment_solution` field description in [Visa Checkout Using the REST API.](https://developer.cybersource.com/content/dam/docs/cybs/en-us/apifields/reference/all/rest/api-fields.pdf)  - `001`: Apple Pay.  - `004`: Cybersource In-App Solution.  - `005`: Masterpass. This value is required for Masterpass transactions on OmniPay Direct.   - `006`: Android Pay.  - `007`: Chase Pay.  - `008`: Samsung Pay.  - `012`: Google Pay.  - `013`: Cybersource P2PE Decryption  - `014`: Mastercard credential on file (COF) payment network token. Returned in authorizations that use a payment network token associated with a TMS token.  - `015`: Visa credential on file (COF) payment network token. Returned in authorizations that use a payment network token associated with a TMS token.  - `027`: Click to Pay. 
    */
    'paymentSolution'?: string;
    /**
    * Please check with Cybersource customer support to see if your merchant account is configured correctly so you can include this field in your request. * For Payouts: max length for FDCCompass is String (22). 
    */
    'reconciliationId'?: string;
    /**
    * Value that links the current authorization request to the original authorization request. Set this value to the ID that was returned in the reply message from the original authorization request.  This value is used for:  - Partial authorizations - Split shipments 
    */
    'linkId'?: string;
    /**
    * Attribute that lets you define custom grouping for your processor reports. This field is supported only for **Worldpay VAP**. 
    */
    'reportGroup'?: string;
    /**
    * Identifier for the **Visa Checkout** order. Visa Checkout provides a unique order ID for every transaction in the Visa Checkout **callID** field. 
    */
    'visaCheckoutId'?: string;
    /**
    * Set this field to 3 to indicate that the request includes Level III data.
    */
    'purchaseLevel'?: string;
    /**
    * Indicates that the transaction includes industry-specific data.  Possible Values: - `airline` - `restaurant` - `lodging` - `auto_rental` - `transit` - `healthcare_medical` - `healthcare_transit` - `transit`  #### Card Present, Airlines and Auto Rental You must set this field to `airline` in order for airline data to be sent to the processor. For example, if this field is not set to `airline` or is not included in the request, no airline data is sent to the processor.  You must set this field to `restaurant` in order for restaurant data to be sent to the processor. When this field is not set to `restaurant` or is not included in the request, no restaurant data is sent to the processor.  You must set this field to `auto_rental` in order for auto rental data to be sent to the processor. For example, if this field is not set to `auto_rental` or is not included in the request, no auto rental data is sent to the processor.  Restaurant data is supported only on CyberSource through VisaNet. 
    */
    'industryDataType'?: string;
    'issuer'?: Ptsv2paymentsIssuerInformation;
    'authorizationOptions'?: Ptsv2paymentsidcapturesProcessingInformationAuthorizationOptions;
    'captureOptions'?: Ptsv2paymentsidcapturesProcessingInformationCaptureOptions;
    'loanOptions'?: Ptsv2paymentsProcessingInformationLoanOptions;
    /**
    * Flag that indicates if the transaction is pay by points transaction true: Transaction uses loyalty points false: Transaction does not use loyalty points Default: false 
    */
    'payByPointsIndicator'?: boolean;
    /**
    * Array of actions (one or more) to be included in the capture to invoke bundled services along with capture.  Possible values :   - `AP_CAPTURE`: Use this when Alternative Payment Capture service is requested. 
    */
    'actionList'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "paymentSolution",
            "baseName": "paymentSolution",
            "type": "string"
        },
        {
            "name": "reconciliationId",
            "baseName": "reconciliationId",
            "type": "string"
        },
        {
            "name": "linkId",
            "baseName": "linkId",
            "type": "string"
        },
        {
            "name": "reportGroup",
            "baseName": "reportGroup",
            "type": "string"
        },
        {
            "name": "visaCheckoutId",
            "baseName": "visaCheckoutId",
            "type": "string"
        },
        {
            "name": "purchaseLevel",
            "baseName": "purchaseLevel",
            "type": "string"
        },
        {
            "name": "industryDataType",
            "baseName": "industryDataType",
            "type": "string"
        },
        {
            "name": "issuer",
            "baseName": "issuer",
            "type": "Ptsv2paymentsIssuerInformation"
        },
        {
            "name": "authorizationOptions",
            "baseName": "authorizationOptions",
            "type": "Ptsv2paymentsidcapturesProcessingInformationAuthorizationOptions"
        },
        {
            "name": "captureOptions",
            "baseName": "captureOptions",
            "type": "Ptsv2paymentsidcapturesProcessingInformationCaptureOptions"
        },
        {
            "name": "loanOptions",
            "baseName": "loanOptions",
            "type": "Ptsv2paymentsProcessingInformationLoanOptions"
        },
        {
            "name": "payByPointsIndicator",
            "baseName": "payByPointsIndicator",
            "type": "boolean"
        },
        {
            "name": "actionList",
            "baseName": "actionList",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsidcapturesProcessingInformation.attributeTypeMap;
    }
}

export class Ptsv2paymentsidcapturesProcessingInformationAuthorizationOptions {
    /**
    * Authorization type. Possible values:   - `AUTOCAPTURE`: automatic capture.  - `STANDARDCAPTURE`: standard capture.  - `VERBAL`: forced capture. Include it in the payment request for a forced capture. Include it in the capture request for a verbal payment.  #### Asia, Middle East, and Africa Gateway; Cielo; Comercio Latino; and CyberSource Latin American Processing Set this field to `AUTOCAPTURE` and include it in a bundled request to indicate that you are requesting an automatic capture. If your account is configured to enable automatic captures, set this field to `STANDARDCAPTURE` and include it in a standard authorization or bundled request to indicate that you are overriding an automatic capture.  #### Forced Capture Set this field to `VERBAL` and include it in the authorization request to indicate that you are performing a forced capture; therefore, you receive the authorization code outside the CyberSource system.  #### Verbal Authorization Set this field to `VERBAL` and include it in the capture request to indicate that the request is for a verbal authorization.  #### for PayPal ptsV2CreateOrderPost400Response Set this field to 'AUTHORIZE' or 'CAPTURE' depending on whether you want to invoke delayed capture or sale respectively. 
    */
    'authType'?: string;
    /**
    * Authorization code.  #### Forced Capture Use this field to send the authorization code you received from a payment that you authorized outside the CyberSource system.  #### PIN debit Authorization code that is returned by the processor.  Returned by PIN debit purchase.  #### Verbal Authorization Use this field in CAPTURE API to send the verbally received authorization code. 
    */
    'verbalAuthCode'?: string;
    /**
    * Transaction ID (TID).  #### FDMS South This field is required for verbal authorizations and forced captures with the American Express card type to comply with the CAPN requirements: - Forced capture: Obtain the value for this field from the authorization response. - Verbal authorization: You cannot obtain a value for this field so CyberSource uses the default value of `000000000000000` (15 zeros). 
    */
    'verbalAuthTransactionId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "authType",
            "baseName": "authType",
            "type": "string"
        },
        {
            "name": "verbalAuthCode",
            "baseName": "verbalAuthCode",
            "type": "string"
        },
        {
            "name": "verbalAuthTransactionId",
            "baseName": "verbalAuthTransactionId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsidcapturesProcessingInformationAuthorizationOptions.attributeTypeMap;
    }
}

export class Ptsv2paymentsidcapturesProcessingInformationCaptureOptions {
    /**
    * Capture number when requesting multiple partial captures for one authorization. Used along with `totalCaptureCount` to track which capture is being processed.  For example, the second of five captures would be passed to CyberSource as:   - `captureSequenceNumber_ = 2`, and   - `totalCaptureCount = 5` 
    */
    'captureSequenceNumber'?: number;
    /**
    * Total number of captures when requesting multiple partial captures for one payment. Used along with `captureSequenceNumber` field to track which capture is being processed.  For example, the second of five captures would be passed to CyberSource as:   - `captureSequenceNumber = 2`, and   - `totalCaptureCount = 5` 
    */
    'totalCaptureCount'?: number;
    /**
    * Indicates whether to release the authorization hold on the remaining funds.   Possible Values: - `true` - `false` 
    */
    'isFinal'?: string;
    /**
    * An informational note about this settlement. Appears in both the payer's transaction history and the emails that the payer receives. 
    */
    'notes'?: string;
    /**
    * Used by Nike merchant to send 12 digit order number
    */
    'reconciliationIdAlternate'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "captureSequenceNumber",
            "baseName": "captureSequenceNumber",
            "type": "number"
        },
        {
            "name": "totalCaptureCount",
            "baseName": "totalCaptureCount",
            "type": "number"
        },
        {
            "name": "isFinal",
            "baseName": "isFinal",
            "type": "string"
        },
        {
            "name": "notes",
            "baseName": "notes",
            "type": "string"
        },
        {
            "name": "reconciliationIdAlternate",
            "baseName": "reconciliationIdAlternate",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsidcapturesProcessingInformationCaptureOptions.attributeTypeMap;
    }
}

export class Ptsv2paymentsidrefundsClientReferenceInformation {
    /**
    * Merchant-generated order reference or tracking number. It is recommended that you send a unique value for each transaction so that you can perform meaningful searches for the transaction.  #### Used by **Authorization** Required field.  #### PIN Debit Requests for PIN debit reversals need to use the same merchant reference number that was used in the transaction that is being reversed.  Required field for all PIN Debit requests (purchase, credit, and reversal).  #### FDC Nashville Global Certain circumstances can cause the processor to truncate this value to 15 or 17 characters for Level II and Level III processing, which can cause a discrepancy between the value you submit and the value included in some processor reports. 
    */
    'code'?: string;
    /**
    * Reference number for the transaction. Depending on how your Cybersource account is configured, this value could either be provided in the API request or generated by CyberSource. The actual value used in the request to the processor is provided back to you by Cybersource in the response. 
    */
    'reconciliationId'?: string;
    /**
    * A new ID which is created for refund
    */
    'returnReconciliationId'?: string;
    /**
    * Used to resume a transaction that was paused for an order modification rule to allow for payer authentication to complete. To resume and continue with the authorization/decision service flow, call the services and include the request id from the prior decision call. 
    */
    'pausedRequestId'?: string;
    /**
    * Identifier that you assign to the transaction. Normally generated by a client server to identify a unique API request.  **Note** Use this field only if you want to support merchant-initiated reversal and void operations.  #### Used by **Authorization, Authorization Reversal, Capture, Credit, and Void** Optional field.  #### PIN Debit For a PIN debit reversal, your request must include a request ID or a merchant transaction identifier. Optional field for PIN debit purchase or credit requests. 
    */
    'transactionId'?: string;
    /**
    * Brief description of the order or any comment you wish to add to the order.
    */
    'comments'?: string;
    'partner'?: Ptsv2paymentsClientReferenceInformationPartner;
    /**
    * The name of the Connection Method client (such as Virtual Terminal or SOAP Toolkit API) that the merchant uses to send a transaction request to CyberSource. 
    */
    'applicationName'?: string;
    /**
    * Version of the CyberSource application or integration used for a transaction. 
    */
    'applicationVersion'?: string;
    /**
    * The entity that is responsible for running the transaction and submitting the processing request to CyberSource. This could be a person, a system, or a connection method. 
    */
    'applicationUser'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        },
        {
            "name": "reconciliationId",
            "baseName": "reconciliationId",
            "type": "string"
        },
        {
            "name": "returnReconciliationId",
            "baseName": "returnReconciliationId",
            "type": "string"
        },
        {
            "name": "pausedRequestId",
            "baseName": "pausedRequestId",
            "type": "string"
        },
        {
            "name": "transactionId",
            "baseName": "transactionId",
            "type": "string"
        },
        {
            "name": "comments",
            "baseName": "comments",
            "type": "string"
        },
        {
            "name": "partner",
            "baseName": "partner",
            "type": "Ptsv2paymentsClientReferenceInformationPartner"
        },
        {
            "name": "applicationName",
            "baseName": "applicationName",
            "type": "string"
        },
        {
            "name": "applicationVersion",
            "baseName": "applicationVersion",
            "type": "string"
        },
        {
            "name": "applicationUser",
            "baseName": "applicationUser",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsidrefundsClientReferenceInformation.attributeTypeMap;
    }
}

export class Ptsv2paymentsidrefundsMerchantInformation {
    'merchantDescriptor'?: Ptsv2paymentsMerchantInformationMerchantDescriptor;
    /**
    * The value for this field is a four-digit number that the payment card industry uses to classify merchants into market segments. A payment card company assigned one or more of these values to your business when you started accepting the payment card company’s cards. When you do not include this field in your request, CyberSource uses the value in your CyberSource account.  #### CyberSource through VisaNet The value for this field corresponds to the following data in the TC 33 capture file5: - Record: CP01 TCR4 - Position: 150-153 - Field: Merchant Category Code 
    */
    'categoryCode'?: number;
    /**
    * Your government-assigned tax identification number.  #### Tax Calculation Required field for value added tax only. Not applicable to U.S. and Canadian taxes.  #### CyberSource through VisaNet For CtV processors, the maximum length is 20. 
    */
    'vatRegistrationNumber'?: string;
    /**
    * Reference number that facilitates card acceptor/corporation communication and record keeping. 
    */
    'cardAcceptorReferenceNumber'?: string;
    /**
    * Your Cadastro Nacional da Pessoa Jurídica (CNPJ) number.  This field is supported only for BNDES transactions on CyberSource through VisaNet.  The value for this field corresponds to the following data in the TC 33 capture file5: - Record: CP07 TCR6 - Position: 40-59 - Field: BNDES Reference Field 1 
    */
    'taxId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "merchantDescriptor",
            "baseName": "merchantDescriptor",
            "type": "Ptsv2paymentsMerchantInformationMerchantDescriptor"
        },
        {
            "name": "categoryCode",
            "baseName": "categoryCode",
            "type": "number"
        },
        {
            "name": "vatRegistrationNumber",
            "baseName": "vatRegistrationNumber",
            "type": "string"
        },
        {
            "name": "cardAcceptorReferenceNumber",
            "baseName": "cardAcceptorReferenceNumber",
            "type": "string"
        },
        {
            "name": "taxId",
            "baseName": "taxId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsidrefundsMerchantInformation.attributeTypeMap;
    }
}

export class Ptsv2paymentsidrefundsOrderInformation {
    'amountDetails'?: Ptsv2paymentsidcapturesOrderInformationAmountDetails;
    'billTo'?: Ptsv2paymentsidcapturesOrderInformationBillTo;
    'shipTo'?: Ptsv2paymentsidcapturesOrderInformationShipTo;
    'lineItems'?: Array<Ptsv2paymentsidrefundsOrderInformationLineItems>;
    'invoiceDetails'?: Ptsv2paymentsidcapturesOrderInformationInvoiceDetails;
    'shippingDetails'?: Ptsv2paymentsidcapturesOrderInformationShippingDetails;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "amountDetails",
            "baseName": "amountDetails",
            "type": "Ptsv2paymentsidcapturesOrderInformationAmountDetails"
        },
        {
            "name": "billTo",
            "baseName": "billTo",
            "type": "Ptsv2paymentsidcapturesOrderInformationBillTo"
        },
        {
            "name": "shipTo",
            "baseName": "shipTo",
            "type": "Ptsv2paymentsidcapturesOrderInformationShipTo"
        },
        {
            "name": "lineItems",
            "baseName": "lineItems",
            "type": "Array<Ptsv2paymentsidrefundsOrderInformationLineItems>"
        },
        {
            "name": "invoiceDetails",
            "baseName": "invoiceDetails",
            "type": "Ptsv2paymentsidcapturesOrderInformationInvoiceDetails"
        },
        {
            "name": "shippingDetails",
            "baseName": "shippingDetails",
            "type": "Ptsv2paymentsidcapturesOrderInformationShippingDetails"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsidrefundsOrderInformation.attributeTypeMap;
    }
}

export class Ptsv2paymentsidrefundsOrderInformationLineItems {
    /**
    * Type of product. The value for this field is used to identify the product category (electronic, handling, physical, service, or shipping). The default value is `default`.  If you are performing an authorization transaction (`processingOptions.capture` is set to `false`), and you set this field to a value other than `default` or one of the values related to shipping and/or handling, then `orderInformation.lineItems[].quantity`, `orderInformation.lineItems[].productName`, and `orderInformation.lineItems[].productSku` fields are required.  Optional field.  #### Tax Calculation Optional field for U.S., Canadian, international tax, and value added taxes.  The Product Codes for the tax service are located in the Cybersource Tax Codes guide. Contact Customer Support to request the guide. If you don’t send a tax service Product Code in your tax request, product-based rules or exemptions will not be applied and the transaction will default to fully taxable in the locations where you’ve indicated you need to collect tax [by way of nexus, no nexus, or seller registration number fields]. 
    */
    'productCode'?: string;
    /**
    * For an authorization or capture transaction (`processingOptions.capture` is `true` or `false`), this field is required when `orderInformation.lineItems[].productCode` is not `default` or one of the other values that are related to shipping and/or handling.  #### Tax Calculation Optional field for U.S., Canadian, international tax, and value added taxes. 
    */
    'productName'?: string;
    /**
    * Product identifier code. Also known as the Stock Keeping Unit (SKU) code for the product.  For an authorization or capture transaction (`processingOptions.capture` is set to `true` or `false`), this field is required when `orderInformation.lineItems[].productCode` is not set to **default** or one of the other values that are related to shipping and/or handling.  #### Tax Calculation Optional field for U.S. and Canadian taxes. Not applicable to international and value added taxes. For an authorization or capture transaction (`processingOptions.capture` is set to `true` or `false`), this field is required when `orderInformation.lineItems[].productCode` is not `default` or one of the values related to shipping and/or handling. 
    */
    'productSku'?: string;
    /**
    * Number of units for this order. Must be a non-negative integer.  The default is `1`. For an authorization or capture transaction (`processingOptions.capture` is set to `true` or `false`), this field is required when `orderInformation.lineItems[].productCode` is not `default` or one of the other values related to shipping and/or handling.  #### Tax Calculation Optional field for U.S., Canadian, international tax, and value added taxes. 
    */
    'quantity'?: number;
    /**
    * Per-item price of the product. This value for this field cannot be negative.  You must include either this field or the request-level field `orderInformation.amountDetails.totalAmount` in your request.  You can include a decimal point (.), but you cannot include any other special characters. The value is truncated to the correct number of decimal places.  #### DCC with a Third-Party Provider Set this field to the converted amount that was returned by the DCC provider. You must include either the 1st line item in the order and this field, or the request-level field `orderInformation.amountDetails.totalAmount` in your request.  #### Tax Calculation Required field for U.S., Canadian, international and value added taxes.  #### Zero Amount Authorizations If your processor supports zero amount authorizations, you can set this field to 0 for the authorization to check if the card is lost or stolen.  #### Maximum Field Lengths For GPN and JCN Gateway: Decimal (10) All other processors: Decimal (15) 
    */
    'unitPrice'?: string;
    /**
    * Unit of measure, or unit of measure code, for the item. 
    */
    'unitOfMeasure'?: string;
    /**
    * Total amount for the item. Normally calculated as the unit price times quantity.  When `orderInformation.lineItems[].productCode` is \"gift_card\", this is the purchase amount total for prepaid gift cards in major units.  Example: 123.45 USD = 123 
    */
    'totalAmount'?: string;
    /**
    * Total tax to apply to the product. This value cannot be negative. The tax amount and the offer amount must be in the same currency. The tax amount field is additive.  The following example uses a two-exponent currency such as USD:   1. You include each line item in your request.  ..- 1st line item has amount=10.00, quantity=1, and taxAmount=0.80  ..- 2nd line item has amount=20.00, quantity=1, and taxAmount=1.60  2. The total amount authorized will be 32.40, not 30.00 with 2.40 of tax included.  Optional field.  #### Airlines processing Tax portion of the order amount. This value cannot exceed 99999999999999 (fourteen 9s). Format: English characters only. Optional request field for a line item.  #### Tax Calculation Optional field for U.S., Canadian, international tax, and value added taxes.  Note if you send this field in your tax request, the value in the field will override the tax engine 
    */
    'taxAmount'?: string;
    /**
    * Tax rate applied to the item.  **Visa**: Valid range is 0.01 to 0.99 (1% to 99%, with only whole percentage values accepted; values with additional decimal places will be truncated).  **Mastercard**: Valid range is 0.00001 to 0.99999 (0.001% to 99.999%). 
    */
    'taxRate'?: string;
    /**
    * Flag to indicate how you handle discount at the line item level.   - 0: no line level discount provided  - 1: tax was calculated on the post-discount line item total  - 2: tax was calculated on the pre-discount line item total  `Note` Visa will inset 0 (zero) if an invalid value is included in this field.  This field relates to the value in the _lineItems[].discountAmount_ field. 
    */
    'taxAppliedAfterDiscount'?: string;
    /**
    * Flag to indicate whether tax is exempted or not included.   - 0: tax not included  - 1: tax included  - 2: transaction is not subject to tax 
    */
    'taxStatusIndicator'?: string;
    /**
    * Type of tax being applied to the item.  #### FDC Nashville Global - `alternate_tax_type_applied` - `alternate_tax_type_identifier`  #### Worldpay VAP - `alternate_tax_type_identifier`  #### RBS WorldPay Atlanta - `tax_type_applied`  #### TSYS Acquiring Solutions - `tax_type_applied` - `local_tax_indicator`  #### Chase Paymentech Solutions - `tax_type_applied`  #### Elavon Americas - `local_tax_indicator`  #### FDC Compass - `tax_type_applied`  #### OmniPay Direct - `local_tax_indicator` 
    */
    'taxTypeCode'?: string;
    /**
    * Flag that indicates whether the tax amount is included in the Line Item Total.  Possible values:  - **true**  - **false** 
    */
    'amountIncludesTax'?: boolean;
    /**
    * Flag to indicate whether the purchase is categorized as goods or services. Possible values:   - 00: goods  - 01: services 
    */
    'typeOfSupply'?: string;
    /**
    * Commodity code or International description code used to classify the item. Contact your acquirer for a list of codes. 
    */
    'commodityCode'?: string;
    /**
    * Discount applied to the item.
    */
    'discountAmount'?: string;
    /**
    * Flag that indicates whether the amount is discounted.  If you do not provide a value but you set Discount Amount to a value greater than zero, then CyberSource sets this field to **true**.  Possible values:  - **true**  - **false** 
    */
    'discountApplied'?: boolean;
    /**
    * Rate the item is discounted. Maximum of 2 decimal places.  Example 5.25 (=5.25%) 
    */
    'discountRate'?: string;
    /**
    * Field to support an invoice number for a transaction. You must specify the number of line items that will include an invoice number. By default, the first line item will include an invoice number field. The invoice number field can be included for up to 10 line items. 
    */
    'invoiceNumber'?: string;
    'taxDetails'?: Array<Ptsv2paymentsOrderInformationAmountDetailsTaxDetails>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "productCode",
            "baseName": "productCode",
            "type": "string"
        },
        {
            "name": "productName",
            "baseName": "productName",
            "type": "string"
        },
        {
            "name": "productSku",
            "baseName": "productSku",
            "type": "string"
        },
        {
            "name": "quantity",
            "baseName": "quantity",
            "type": "number"
        },
        {
            "name": "unitPrice",
            "baseName": "unitPrice",
            "type": "string"
        },
        {
            "name": "unitOfMeasure",
            "baseName": "unitOfMeasure",
            "type": "string"
        },
        {
            "name": "totalAmount",
            "baseName": "totalAmount",
            "type": "string"
        },
        {
            "name": "taxAmount",
            "baseName": "taxAmount",
            "type": "string"
        },
        {
            "name": "taxRate",
            "baseName": "taxRate",
            "type": "string"
        },
        {
            "name": "taxAppliedAfterDiscount",
            "baseName": "taxAppliedAfterDiscount",
            "type": "string"
        },
        {
            "name": "taxStatusIndicator",
            "baseName": "taxStatusIndicator",
            "type": "string"
        },
        {
            "name": "taxTypeCode",
            "baseName": "taxTypeCode",
            "type": "string"
        },
        {
            "name": "amountIncludesTax",
            "baseName": "amountIncludesTax",
            "type": "boolean"
        },
        {
            "name": "typeOfSupply",
            "baseName": "typeOfSupply",
            "type": "string"
        },
        {
            "name": "commodityCode",
            "baseName": "commodityCode",
            "type": "string"
        },
        {
            "name": "discountAmount",
            "baseName": "discountAmount",
            "type": "string"
        },
        {
            "name": "discountApplied",
            "baseName": "discountApplied",
            "type": "boolean"
        },
        {
            "name": "discountRate",
            "baseName": "discountRate",
            "type": "string"
        },
        {
            "name": "invoiceNumber",
            "baseName": "invoiceNumber",
            "type": "string"
        },
        {
            "name": "taxDetails",
            "baseName": "taxDetails",
            "type": "Array<Ptsv2paymentsOrderInformationAmountDetailsTaxDetails>"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsidrefundsOrderInformationLineItems.attributeTypeMap;
    }
}

export class Ptsv2paymentsidrefundsPaymentInformation {
    'card'?: Ptsv2paymentsidrefundsPaymentInformationCard;
    'bank'?: Ptsv2paymentsidrefundsPaymentInformationBank;
    'tokenizedCard'?: Ptsv2paymentsPaymentInformationTokenizedCard;
    'fluidData'?: Ptsv2paymentsPaymentInformationFluidData;
    'customer'?: Ptsv2paymentsPaymentInformationCustomer;
    'paymentInstrument'?: Ptsv2paymentsPaymentInformationPaymentInstrument;
    'instrumentIdentifier'?: Ptsv2paymentsPaymentInformationInstrumentIdentifier;
    'shippingAddress'?: Ptsv2paymentsPaymentInformationShippingAddress;
    'legacyToken'?: Ptsv2paymentsPaymentInformationLegacyToken;
    'paymentType'?: Ptsv2paymentsidrefundsPaymentInformationPaymentType;
    'eWallet'?: Ptsv2paymentsidrefundsPaymentInformationEWallet;
    'paymentAccountReference'?: Ptsv2paymentsPaymentInformationPaymentAccountReference;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "card",
            "baseName": "card",
            "type": "Ptsv2paymentsidrefundsPaymentInformationCard"
        },
        {
            "name": "bank",
            "baseName": "bank",
            "type": "Ptsv2paymentsidrefundsPaymentInformationBank"
        },
        {
            "name": "tokenizedCard",
            "baseName": "tokenizedCard",
            "type": "Ptsv2paymentsPaymentInformationTokenizedCard"
        },
        {
            "name": "fluidData",
            "baseName": "fluidData",
            "type": "Ptsv2paymentsPaymentInformationFluidData"
        },
        {
            "name": "customer",
            "baseName": "customer",
            "type": "Ptsv2paymentsPaymentInformationCustomer"
        },
        {
            "name": "paymentInstrument",
            "baseName": "paymentInstrument",
            "type": "Ptsv2paymentsPaymentInformationPaymentInstrument"
        },
        {
            "name": "instrumentIdentifier",
            "baseName": "instrumentIdentifier",
            "type": "Ptsv2paymentsPaymentInformationInstrumentIdentifier"
        },
        {
            "name": "shippingAddress",
            "baseName": "shippingAddress",
            "type": "Ptsv2paymentsPaymentInformationShippingAddress"
        },
        {
            "name": "legacyToken",
            "baseName": "legacyToken",
            "type": "Ptsv2paymentsPaymentInformationLegacyToken"
        },
        {
            "name": "paymentType",
            "baseName": "paymentType",
            "type": "Ptsv2paymentsidrefundsPaymentInformationPaymentType"
        },
        {
            "name": "eWallet",
            "baseName": "eWallet",
            "type": "Ptsv2paymentsidrefundsPaymentInformationEWallet"
        },
        {
            "name": "paymentAccountReference",
            "baseName": "paymentAccountReference",
            "type": "Ptsv2paymentsPaymentInformationPaymentAccountReference"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsidrefundsPaymentInformation.attributeTypeMap;
    }
}

export class Ptsv2paymentsidrefundsPaymentInformationBank {
    'account'?: Ptsv2paymentsidrefundsPaymentInformationBankAccount;
    /**
    * Bank routing number. This is also called the _transit number_. 
    */
    'routingNumber'?: string;
    /**
    * International Bank Account Number (IBAN) for the bank account. For some countries you can provide this number instead of the traditional bank account information. You can use this field only when scoring a direct debit transaction. 
    */
    'iban'?: string;
    /**
    * Bank’s SWIFT code. You can use this field only when scoring a direct debit transaction. Required only for crossborder transactions. 
    */
    'swiftCode'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "account",
            "baseName": "account",
            "type": "Ptsv2paymentsidrefundsPaymentInformationBankAccount"
        },
        {
            "name": "routingNumber",
            "baseName": "routingNumber",
            "type": "string"
        },
        {
            "name": "iban",
            "baseName": "iban",
            "type": "string"
        },
        {
            "name": "swiftCode",
            "baseName": "swiftCode",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsidrefundsPaymentInformationBank.attributeTypeMap;
    }
}

export class Ptsv2paymentsidrefundsPaymentInformationBankAccount {
    /**
    * Account type.  Possible values:  - **C**: Checking.  - **G**: General ledger. This value is supported only on Wells Fargo ACH.  - **S**: Savings (U.S. dollars only).  - **X**: Corporate checking (U.S. dollars only). 
    */
    'type'?: string;
    /**
    * Account number.  When processing encoded account numbers, use this field for the encoded account number. 
    */
    'number'?: string;
    /**
    * Identifier for the bank that provided the customer’s encoded account number.  To obtain the bank identifier, contact your processor. 
    */
    'encoderId'?: string;
    /**
    * Check number.  Chase Paymentech Solutions - Optional. CyberSource ACH Service - Not used. RBS WorldPay Atlanta - Optional on debits. Required on credits. TeleCheck - Strongly recommended on debit requests. Optional on credits. 
    */
    'checkNumber'?: string;
    /**
    * Image reference number associated with the check. You cannot include any special characters. 
    */
    'checkImageReferenceNumber'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "number",
            "baseName": "number",
            "type": "string"
        },
        {
            "name": "encoderId",
            "baseName": "encoderId",
            "type": "string"
        },
        {
            "name": "checkNumber",
            "baseName": "checkNumber",
            "type": "string"
        },
        {
            "name": "checkImageReferenceNumber",
            "baseName": "checkImageReferenceNumber",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsidrefundsPaymentInformationBankAccount.attributeTypeMap;
    }
}

export class Ptsv2paymentsidrefundsPaymentInformationCard {
    /**
    * The customer’s payment card number, also known as the Primary Account Number (PAN). You can also use this field for encoded account numbers.  #### FDMS Nashville Required. String (19)  #### GPX Required if `pointOfSaleInformation.entryMode=keyed`. However, this field is optional if your account is configured for relaxed requirements for address data and expiration date. **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.  #### All other processors Required if `pointOfSaleInformation.entryMode=keyed`. However, this field is optional if your account is configured for relaxed requirements for address data and expiration date. **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting. 
    */
    'number'?: string;
    /**
    * Two-digit month in which the payment card expires.  Format: `MM`.  Valid values: `01` through `12`. Leading 0 is required.  #### Barclays and Streamline For Maestro (UK Domestic) and Maestro (International) cards on Barclays and Streamline, this must be a valid value (`01` through `12`) but is not required to be a valid expiration date. In other words, an expiration date that is in the past does not cause CyberSource to reject your request. However, an invalid expiration date might cause the issuer to reject your request.  #### Encoded Account Numbers For encoded account numbers (_type_=039), if there is no expiration date on the card, use `12`.  #### FDMS Nashville Required field.  #### All other processors Required if `pointOfSaleInformation.entryMode=keyed`. However, this field is optional if your account is configured for relaxed requirements for address data and expiration date. **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.  #### Google Pay transactions For PAN-based Google Pay transactions, this field is returned in the API response. 
    */
    'expirationMonth'?: string;
    /**
    * Four-digit year in which the payment card expires.  Format: `YYYY`.  #### Barclays and Streamline For Maestro (UK Domestic) and Maestro (International) cards on Barclays and Streamline, this must be a valid value (`1900` through `3000`) but is not required to be a valid expiration date. In other words, an expiration date that is in the past does not cause CyberSource to reject your request. However, an invalid expiration date might cause the issuer to reject your request.  #### Encoded Account Numbers For encoded account numbers (**_type_**`=039`), if there is no expiration date on the card, use `2021`.  #### FDMS Nashville Required field.  #### FDC Nashville Global and FDMS South You can send in 2 digits or 4 digits. If you send in 2 digits, they must be the last 2 digits of the year.  #### All other processors Required if `pointOfSaleInformation.entryMode=keyed`. However, this field is optional if your account is configured for relaxed requirements for address data and expiration date. **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.  #### Google Pay transactions For PAN-based Google Pay transactions, this field is returned in the API response. 
    */
    'expirationYear'?: string;
    /**
    * Three-digit value that indicates the card type.  **IMPORTANT** It is strongly recommended that you include the card type field in request messages even if it is optional for your processor and card type. Omitting the card type can cause the transaction to be processed with the wrong card type.  Possible values: - `001`: Visa. Use card type value `001` for Visa Electron. - `002`: Mastercard, Eurocard[^1], which is a European regional brand of Mastercard. - `003`: American Express - `004`: Discover - `005`: Diners Club - `006`: Carte Blanche[^1] - `007`: JCB[^1] - `008`: Optima - `009`: GE Private Label - `010`: Beneficial Private Label - `011`: Twinpay Credit Card - `012`: Twinpay Debit Card - `013`: WalMart - `014`: Enroute[^1] - `015`: Lowe's Consumer - `016`: Home Depot Consumer - `017`: MBNA - `018`: Dick's Sportswear - `019`: Casual Corner - `020`: Sears - `021`: JAL[^1] - `023`: Disney Card - `024`: Maestro (UK Domestic)[^1] - `025`: Sam's Club Consumer - `026`: Sam's Club Business - `027`: Nico's - `028`: Paymentech Bill Me Later - `029`: Bebe - `030`: Restoration Hardware - `031`: Delta Online - `032`: Solo - `033`: Visa Electron[^1]. Do not use this value. Use `001` for all Visa card types. - `034`: Dankort[^1] - `035`: Laser - `036`: Cartes Bancaires[^1,4] - `037`: Carta Si[^1] - `038`: Pinless Debit - `039`: Encoded account number[^1] - `040`: UATP[^1] - `041`: HOUSEHOLD - `042`: Maestro (International)[^1] - `043`: GE MONEY - `044`: Korean Cards - `045`: Style Cards - `046`: JCrew - `047`: Payeasecn eWallet - `048`: Payeasecn Bank Transfer - `049`: Meijer - `050`: Hipercard[^2,3] - `051`: Aura - `052`: Redecard - `053`: Orico card - `054`: Elo[^3] - `055`: Capitol One Private Label - `056`: Carnet - `057`: Costco Private Label - `058`: Carnet - `059`: ValueLink - `060`: MADA - `061`: RuPay - `062`: China UnionPay - `063`: Falabella Private Label - `064`: Prompt Card - `065`: Korean Domestic - `066`: Banricompras - `067`: MEEZA - `068`: PayPak - `070`: EFTPOS - `071`: Codensa - `072`: Olimpica - `073`: Colsubsidio - `074`: Tuya - `075`: Sodexo - `076`: Naranja - `077`: Cabal - `078`: DINELCO - `079`: PANAL - `080`: EPM - `081`: Jaywan  [^1]: For this card type, you must include the `paymentInformation.card.type` or `paymentInformation.tokenizedCard.type` field in your request for an authorization or a stand-alone credit. [^2]: For this card type on Cielo 3.0, you must include the `paymentInformation.card.type` or `paymentInformation.tokenizedCard.type` field in a request for an authorization or a stand-alone credit. This card type is not supported on Cielo 1.5. [^3]: For this card type on Getnet and Rede, you must include the `paymentInformation.card.type` or `paymentInformation.tokenizedCard.type` field in a request for an authorization or a stand-alone credit. [^4]: For this card type, you must include the `paymentInformation.card.type` in your request for any payer authentication services.  #### Used by **Authorization** Required for Carte Blanche and JCB. Optional for all other card types.  #### Card Present reply This field is included in the reply message when the client software that is installed on the POS terminal uses the token management service (TMS) to retrieve tokenized payment details. You must contact customer support to have your account enabled to receive these fields in the credit reply message.  Returned by the Credit service.  This reply field is only supported by the following processors: - American Express Direct - Credit Mutuel-CIC - FDC Nashville Global - OmniPay Direct - SIX  #### Google Pay transactions For PAN-based Google Pay transactions, this field is returned in the API response.  #### GPX This field only supports transactions from the following card types: - Visa - Mastercard - AMEX - Discover - Diners - JCB - Union Pay International 
    */
    'type'?: string;
    /**
    * Identifier for the issuing bank that provided the customer’s encoded account number. Contact your processor for the bank’s ID. 
    */
    'accountEncoderId'?: string;
    /**
    * Number of times a Maestro (UK Domestic) card has been issued to the account holder. The card might or might not have an issue number. The number can consist of one or two digits, and the first digit might be a zero. When you include this value in your request, include exactly what is printed on the card. A value of 2 is different than a value of 02. Do not include the field, even with a blank value, if the card is not a Maestro (UK Domestic) card.  **Note** The issue number is not required for Maestro (UK Domestic) transactions. 
    */
    'issueNumber'?: string;
    /**
    * Month of the start of the Maestro (UK Domestic) card validity period. Do not include the field, even with a blank value, if the card is not a Maestro (UK Domestic) card. `Format: MM`. Possible values: 01 through 12.  **Note** The start date is not required for Maestro (UK Domestic) transactions. 
    */
    'startMonth'?: string;
    /**
    * Year of the start of the Maestro (UK Domestic) card validity period. Do not include the field, even with a blank value, if the card is not a Maestro (UK Domestic) card. `Format: YYYY`.  **Note** The start date is not required for Maestro (UK Domestic) transactions. 
    */
    'startYear'?: string;
    /**
    * Flag that specifies the type of account associated with the card.  The cardholder provides this information during the payment process.  This field is required in the following cases:   - Debit transactions on Cielo and Comercio Latino.   - Transactions with Brazilian-issued cards on CyberSource through VisaNet.   - Applicable only for CyberSource through VisaNet (CtV).  **Note** Combo cards in Brazil contain credit and debit functionality in a single card. Visa systems use a credit bank identification number (BIN) for this type of card. Using the BIN to determine whether a card is debit or credit can cause transactions with these cards to be processed incorrectly. CyberSource strongly recommends that you include this field for combo card transactions.  Possible values include the following.   - `CH`: Checking account  - `CR`: Credit card account  - `SA`: Saving account  - `LI`: Line of credit or credit portion of combo card  - `PP`: Prepaid card account or prepaid portion of combo card  - `UA`: Universal account  If useAs is set to credit/debit and there is a value in SourceAccountType, the value in the SourceAccountType field will take precedence. If useAs is set to CR/DB and there is a value in SourceAccountType, the value in the useAs field will take precedence. 
    */
    'sourceAccountType'?: string;
    /**
    * Type of account that is being used when the value for the override_payment_method field is line of credit (LI) or prepaid card (PP). Possible values for line of credit: - `AGRC`: Visa Agro Custeio - `AGRE`: Visa Agro Electron - `AGRI`: Visa Agro Investimento - `AGRO`: Visa Agro Possible values for prepaid card: - `VVA`: Visa Vale Alimentacao - `VVF`: Visa Vale Flex - `VVR`: Visa Vale Refeicao This field is supported only for combo card transactions in Brazil on CyberSource through VisaNet. 
    */
    'sourceAccountTypeDetails'?: string;
    /**
    * Card Verification Number.  #### FDMS Nashville Required for American Express or if swiped; otherwise, optional.  #### Ingenico ePayments Do not include this field when `commerceIndicator=recurring`. **Note** Ingenico ePayments was previously called _Global Collect_.  #### TSYS Acquiring Solutions Optional if pointOfSaleInformation.entryMode=keyed; otherwise, not used.  #### GPX Optional.  #### All other processors: Optional. 
    */
    'securityCode'?: string;
    /**
    * Flag that specifies the type of account associated with the card.  This field is available only for China UnionPay, Cielo, Comercio Latino and Visa Platform Connect. The cardholder provides this information during the payment process.  This field is required for:  - Debit transactions on Cielo and Comercio Latino.  - Transactions with Brazilian-issued cards on CyberSource through VisaNet.  **China UnionPayCard Transactions on China UnionPay:** Possible values:  - C: Domestic credit card  - D: Domestic debit card  - F: International credit card  - I: International debit card  When the value is D, the e-commerce indicator and CAVV fields must be included in the authorization request. When the value is C, F or I the card verification number, expiration month and expiration year fields must in included in the authorization request.  **Cielo and Comercio Latino Credit Card Transactions:** On these processors, this field is supported only for authorizations.  Possible values:  - CR: Credit card  - DB: Debit card       **Visa Platform Connect Credit Card Transactions:** This field is supported for all card types on Visa Platform Connect. For combo **card present** transactions with Mastercard on Brazilian-issued cards, possible values:  - CR: Credit card  - DB: Debit Card  For combo **card not present** transactions with Mastercard on Brazilian-issued cards, possible values:  - C: Credit card  - D: Debit card  A value of CR or DB in the useAs field takes precedence over any value in the Source Account Type field. 
    */
    'useAs'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "number",
            "baseName": "number",
            "type": "string"
        },
        {
            "name": "expirationMonth",
            "baseName": "expirationMonth",
            "type": "string"
        },
        {
            "name": "expirationYear",
            "baseName": "expirationYear",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "accountEncoderId",
            "baseName": "accountEncoderId",
            "type": "string"
        },
        {
            "name": "issueNumber",
            "baseName": "issueNumber",
            "type": "string"
        },
        {
            "name": "startMonth",
            "baseName": "startMonth",
            "type": "string"
        },
        {
            "name": "startYear",
            "baseName": "startYear",
            "type": "string"
        },
        {
            "name": "sourceAccountType",
            "baseName": "sourceAccountType",
            "type": "string"
        },
        {
            "name": "sourceAccountTypeDetails",
            "baseName": "sourceAccountTypeDetails",
            "type": "string"
        },
        {
            "name": "securityCode",
            "baseName": "securityCode",
            "type": "string"
        },
        {
            "name": "useAs",
            "baseName": "useAs",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsidrefundsPaymentInformationCard.attributeTypeMap;
    }
}

export class Ptsv2paymentsidrefundsPaymentInformationEWallet {
    /**
    * Payment mode for the authorization or order transaction.  INSTANT_TRANSFER  MANUAL_BANK_TRANSFER  DELAYED_TRANSFER  ECHECK  UNRESTRICTED (default)—this value is available only when configured by PayPal for the merchant. INSTANT
    */
    'fundingSource'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "fundingSource",
            "baseName": "fundingSource",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsidrefundsPaymentInformationEWallet.attributeTypeMap;
    }
}

export class Ptsv2paymentsidrefundsPaymentInformationPaymentType {
    /**
    * A Payment Type is an agreed means for a payee to receive legal tender from a payer. The way one pays for a commercial financial transaction. Examples: Card, Bank Transfer, Digital, Direct Debit. Possible values: - `CARD` (use this for a PIN debit transaction) - `CHECK` (use this for all eCheck payment transactions - ECP Debit, ECP Follow-on Credit, ECP StandAlone Credit) - `bankTransfer` (use for Online Bank Transafer for methods such as P24, iDeal, Estonia Bank, KCP) - `localCard` (KCP Local card via Altpay) - `carrierBilling` (KCP Carrier Billing via Altpay) 
    */
    'name'?: string;
    /**
    * In case the APM supports multiple modes of initiation (e.g. Alipay via QR Code or Barcode) 
    */
    'subTypeName'?: string;
    'method'?: Ptsv2paymentsidcapturesPaymentInformationPaymentTypeMethod;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "subTypeName",
            "baseName": "subTypeName",
            "type": "string"
        },
        {
            "name": "method",
            "baseName": "method",
            "type": "Ptsv2paymentsidcapturesPaymentInformationPaymentTypeMethod"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsidrefundsPaymentInformationPaymentType.attributeTypeMap;
    }
}

export class Ptsv2paymentsidrefundsPointOfSaleInformation {
    'emv'?: Ptsv2paymentsidcapturesPointOfSaleInformationEmv;
    /**
    * Indicates the type of terminal.   Possible values: - `AFD`: Automated Fuel Dispenser 
    */
    'terminalCategory'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "emv",
            "baseName": "emv",
            "type": "Ptsv2paymentsidcapturesPointOfSaleInformationEmv"
        },
        {
            "name": "terminalCategory",
            "baseName": "terminalCategory",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsidrefundsPointOfSaleInformation.attributeTypeMap;
    }
}

export class Ptsv2paymentsidrefundsProcessingInformation {
    /**
    * Array of actions (one or more) to be included in the payment to invoke bundled services along with payment status.  Possible values are one or more of follows:   - `AP_REFUND`: Use this when Alternative Payment Refund service is requested. 
    */
    'actionList'?: Array<string>;
    /**
    * Type of digital payment solution for the transaction. Possible Values:   - `visacheckout`: Visa Checkout. This value is required for Visa Checkout transactions. For details, see `payment_solution` field description in [Visa Checkout Using the REST API.](https://developer.cybersource.com/content/dam/docs/cybs/en-us/apifields/reference/all/rest/api-fields.pdf)  - `001`: Apple Pay.  - `004`: Cybersource In-App Solution.  - `005`: Masterpass. This value is required for Masterpass transactions on OmniPay Direct.   - `006`: Android Pay.  - `007`: Chase Pay.  - `008`: Samsung Pay.  - `012`: Google Pay.  - `013`: Cybersource P2PE Decryption  - `014`: Mastercard credential on file (COF) payment network token. Returned in authorizations that use a payment network token associated with a TMS token.  - `015`: Visa credential on file (COF) payment network token. Returned in authorizations that use a payment network token associated with a TMS token.  - `027`: Click to Pay. 
    */
    'paymentSolution'?: string;
    /**
    * Please check with Cybersource customer support to see if your merchant account is configured correctly so you can include this field in your request. * For Payouts: max length for FDCCompass is String (22). 
    */
    'reconciliationId'?: string;
    /**
    * Value that links the current authorization request to the original authorization request. Set this value to the ID that was returned in the reply message from the original authorization request.  This value is used for:  - Partial authorizations - Split shipments 
    */
    'linkId'?: string;
    /**
    * Attribute that lets you define custom grouping for your processor reports. This field is supported only for **Worldpay VAP**. 
    */
    'reportGroup'?: string;
    /**
    * Identifier for the **Visa Checkout** order. Visa Checkout provides a unique order ID for every transaction in the Visa Checkout **callID** field. 
    */
    'visaCheckoutId'?: string;
    /**
    * Set this field to 3 to indicate that the request includes Level III data.
    */
    'purchaseLevel'?: string;
    'recurringOptions'?: Ptsv2paymentsidrefundsProcessingInformationRecurringOptions;
    /**
    * Indicates that the transaction includes industry-specific data.  Possible Values: - `airline` - `restaurant` - `lodging` - `auto_rental` - `transit` - `healthcare_medical` - `healthcare_transit` - `transit`  #### Card Present, Airlines and Auto Rental You must set this field to `airline` in order for airline data to be sent to the processor. For example, if this field is not set to `airline` or is not included in the request, no airline data is sent to the processor.  You must set this field to `restaurant` in order for restaurant data to be sent to the processor. When this field is not set to `restaurant` or is not included in the request, no restaurant data is sent to the processor.  You must set this field to `auto_rental` in order for auto rental data to be sent to the processor. For example, if this field is not set to `auto_rental` or is not included in the request, no auto rental data is sent to the processor.  Restaurant data is supported only on CyberSource through VisaNet. 
    */
    'industryDataType'?: string;
    /**
    * Identifier for the payment type
    */
    'paymentType'?: string;
    'refundOptions'?: Ptsv2paymentsidrefundsProcessingInformationRefundOptions;
    /**
    * This field is used identify the type of payment transaction taking place. This field is applicable for MasterCard transactions only. Possible values: - 201- Mastercard Rebate - 202- rePower Load Value - 203- Gaming Re-pay - 204- General Person-to-Person - 205- General Transfer to Own Account - 206- Agent Cash Out - 207- Payment of Own Credit Card Bill - 208- Business Disbursement - 209- Government/Non-Profit Disbursement - 210- Rapid Merchant Settlement - 211- Cash in at ATM (Usage limited to specific countries) - 212- Cash in at Point of Sale (Usage limited to specific countries) - 213- General Business to Business Transfer - 214- Mastercard Merchant Presented QR - 215- Mastercard Merchant Presented QR Refund Payment - 216- Utility Payments (for Brazil domestic use only) - 217- Government Services (for Brazil domestic use only) - 218- Mobile phone top-ups (for Brazil domestic use only) - 219- Coupon booklet payments (for Brazil domestic use only) - 220- General Person-to-Person Transfer - 221- Person-to-Person Transfer to Card Account - 222- General Transfer to Own Account - 223- Agent Cash Out - 224- Payment of Own Credit Card Bill - 225- Business Disbursement - 226- Transfer to Own Staged Digital Wallet Account - 227- Transfer to Own Debit or Prepaid Account - 228- General Business-to-Business Transfer - 229- Installment-based repayment - 230- Mastercard ATM Cash Pick-Up Transaction - 231- Cryptocurrency - 232- High-risk Securities 
    */
    'transactionTypeIndicator'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "actionList",
            "baseName": "actionList",
            "type": "Array<string>"
        },
        {
            "name": "paymentSolution",
            "baseName": "paymentSolution",
            "type": "string"
        },
        {
            "name": "reconciliationId",
            "baseName": "reconciliationId",
            "type": "string"
        },
        {
            "name": "linkId",
            "baseName": "linkId",
            "type": "string"
        },
        {
            "name": "reportGroup",
            "baseName": "reportGroup",
            "type": "string"
        },
        {
            "name": "visaCheckoutId",
            "baseName": "visaCheckoutId",
            "type": "string"
        },
        {
            "name": "purchaseLevel",
            "baseName": "purchaseLevel",
            "type": "string"
        },
        {
            "name": "recurringOptions",
            "baseName": "recurringOptions",
            "type": "Ptsv2paymentsidrefundsProcessingInformationRecurringOptions"
        },
        {
            "name": "industryDataType",
            "baseName": "industryDataType",
            "type": "string"
        },
        {
            "name": "paymentType",
            "baseName": "paymentType",
            "type": "string"
        },
        {
            "name": "refundOptions",
            "baseName": "refundOptions",
            "type": "Ptsv2paymentsidrefundsProcessingInformationRefundOptions"
        },
        {
            "name": "transactionTypeIndicator",
            "baseName": "transactionTypeIndicator",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsidrefundsProcessingInformation.attributeTypeMap;
    }
}

export class Ptsv2paymentsidrefundsProcessingInformationRecurringOptions {
    /**
    * Flag that indicates whether this is a payment towards an existing contractual loan.  Possible values: - `true`: Loan payment - `false`: (default) Not a loan payment 
    */
    'loanPayment'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "loanPayment",
            "baseName": "loanPayment",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsidrefundsProcessingInformationRecurringOptions.attributeTypeMap;
    }
}

export class Ptsv2paymentsidrefundsProcessingInformationRefundOptions {
    /**
    * The reason for the refund.
    */
    'reason'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "reason",
            "baseName": "reason",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsidrefundsProcessingInformationRefundOptions.attributeTypeMap;
    }
}

export class Ptsv2paymentsidreversalsClientReferenceInformation {
    /**
    * Merchant-generated order reference or tracking number. It is recommended that you send a unique value for each transaction so that you can perform meaningful searches for the transaction.  #### Used by **Authorization** Required field.  #### PIN Debit Requests for PIN debit reversals need to use the same merchant reference number that was used in the transaction that is being reversed.  Required field for all PIN Debit requests (purchase, credit, and reversal).  #### FDC Nashville Global Certain circumstances can cause the processor to truncate this value to 15 or 17 characters for Level II and Level III processing, which can cause a discrepancy between the value you submit and the value included in some processor reports. 
    */
    'code'?: string;
    /**
    * Used to resume a transaction that was paused for an order modification rule to allow for payer authentication to complete. To resume and continue with the authorization/decision service flow, call the services and include the request id from the prior decision call. 
    */
    'pausedRequestId'?: string;
    /**
    * Brief description of the order or any comment you wish to add to the order.
    */
    'comments'?: string;
    'partner'?: Ptsv2paymentsidreversalsClientReferenceInformationPartner;
    /**
    * The name of the Connection Method client (such as Virtual Terminal or SOAP Toolkit API) that the merchant uses to send a transaction request to CyberSource. 
    */
    'applicationName'?: string;
    /**
    * Version of the CyberSource application or integration used for a transaction. 
    */
    'applicationVersion'?: string;
    /**
    * The entity that is responsible for running the transaction and submitting the processing request to CyberSource. This could be a person, a system, or a connection method. 
    */
    'applicationUser'?: string;
    /**
    * Reference number for the transaction. Depending on how your Cybersource account is configured, this value could either be provided in the API request or generated by CyberSource. The actual value used in the request to the processor is provided back to you by Cybersource in the response. 
    */
    'reconciliationId'?: string;
    /**
    * Identifier that you assign to the transaction. Normally generated by a client server to identify a unique API request.  **Note** Use this field only if you want to support merchant-initiated reversal and void operations.  #### Used by **Authorization, Authorization Reversal, Capture, Credit, and Void** Optional field.  #### PIN Debit For a PIN debit reversal, your request must include a request ID or a merchant transaction identifier. Optional field for PIN debit purchase or credit requests. 
    */
    'transactionId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        },
        {
            "name": "pausedRequestId",
            "baseName": "pausedRequestId",
            "type": "string"
        },
        {
            "name": "comments",
            "baseName": "comments",
            "type": "string"
        },
        {
            "name": "partner",
            "baseName": "partner",
            "type": "Ptsv2paymentsidreversalsClientReferenceInformationPartner"
        },
        {
            "name": "applicationName",
            "baseName": "applicationName",
            "type": "string"
        },
        {
            "name": "applicationVersion",
            "baseName": "applicationVersion",
            "type": "string"
        },
        {
            "name": "applicationUser",
            "baseName": "applicationUser",
            "type": "string"
        },
        {
            "name": "reconciliationId",
            "baseName": "reconciliationId",
            "type": "string"
        },
        {
            "name": "transactionId",
            "baseName": "transactionId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsidreversalsClientReferenceInformation.attributeTypeMap;
    }
}

export class Ptsv2paymentsidreversalsClientReferenceInformationPartner {
    /**
    * Identifier for the developer that helped integrate a partner solution to CyberSource.  Send this value in all requests that are sent through the partner solutions built by that developer. CyberSource assigns the ID to the developer.  **Note** When you see a developer ID of 999 in reports, the developer ID that was submitted is incorrect. 
    */
    'developerId'?: string;
    /**
    * Identifier for the partner that is integrated to CyberSource.  Send this value in all requests that are sent through the partner solution. CyberSource assigns the ID to the partner.  **Note** When you see a solutionId of 999 in reports, the solutionId that was submitted is incorrect. 
    */
    'solutionId'?: string;
    /**
    * Value that identifies the application vendor and application version for a third party gateway. CyberSource provides you with this value during testing and validation. This field is supported only on CyberSource through VisaNet.  #### Used by **Authorization, Authorization Reversal, Capture, Credit, Incremental Authorization, and Void** Optional field.  #### PIN debit Required field for PIN debit credit, PIN debit purchase, or PIN debit reversal request. 
    */
    'thirdPartyCertificationNumber'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "developerId",
            "baseName": "developerId",
            "type": "string"
        },
        {
            "name": "solutionId",
            "baseName": "solutionId",
            "type": "string"
        },
        {
            "name": "thirdPartyCertificationNumber",
            "baseName": "thirdPartyCertificationNumber",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsidreversalsClientReferenceInformationPartner.attributeTypeMap;
    }
}

export class Ptsv2paymentsidreversalsOrderInformation {
    'amountDetails'?: Ptsv2paymentsidreversalsOrderInformationAmountDetails;
    'lineItems'?: Array<Ptsv2paymentsidreversalsOrderInformationLineItems>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "amountDetails",
            "baseName": "amountDetails",
            "type": "Ptsv2paymentsidreversalsOrderInformationAmountDetails"
        },
        {
            "name": "lineItems",
            "baseName": "lineItems",
            "type": "Array<Ptsv2paymentsidreversalsOrderInformationLineItems>"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsidreversalsOrderInformation.attributeTypeMap;
    }
}

export class Ptsv2paymentsidreversalsOrderInformationAmountDetails {
    /**
    * Service fee. Required for service fee transactions. 
    */
    'serviceFeeAmount'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "serviceFeeAmount",
            "baseName": "serviceFeeAmount",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsidreversalsOrderInformationAmountDetails.attributeTypeMap;
    }
}

export class Ptsv2paymentsidreversalsOrderInformationLineItems {
    /**
    * Number of units for this order. Must be a non-negative integer.  The default is `1`. For an authorization or capture transaction (`processingOptions.capture` is set to `true` or `false`), this field is required when `orderInformation.lineItems[].productCode` is not `default` or one of the other values related to shipping and/or handling.  #### Tax Calculation Optional field for U.S., Canadian, international tax, and value added taxes. 
    */
    'quantity'?: number;
    /**
    * Per-item price of the product. This value for this field cannot be negative.  You must include either this field or the request-level field `orderInformation.amountDetails.totalAmount` in your request.  You can include a decimal point (.), but you cannot include any other special characters. The value is truncated to the correct number of decimal places.  #### DCC with a Third-Party Provider Set this field to the converted amount that was returned by the DCC provider. You must include either the 1st line item in the order and this field, or the request-level field `orderInformation.amountDetails.totalAmount` in your request.  #### Tax Calculation Required field for U.S., Canadian, international and value added taxes.  #### Zero Amount Authorizations If your processor supports zero amount authorizations, you can set this field to 0 for the authorization to check if the card is lost or stolen.  #### Maximum Field Lengths For GPN and JCN Gateway: Decimal (10) All other processors: Decimal (15) 
    */
    'unitPrice'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "quantity",
            "baseName": "quantity",
            "type": "number"
        },
        {
            "name": "unitPrice",
            "baseName": "unitPrice",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsidreversalsOrderInformationLineItems.attributeTypeMap;
    }
}

export class Ptsv2paymentsidreversalsPaymentInformation {
    'paymentType'?: Ptsv2paymentsidreversalsPaymentInformationPaymentType;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "paymentType",
            "baseName": "paymentType",
            "type": "Ptsv2paymentsidreversalsPaymentInformationPaymentType"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsidreversalsPaymentInformation.attributeTypeMap;
    }
}

export class Ptsv2paymentsidreversalsPaymentInformationPaymentType {
    'method'?: Ptsv2paymentsidreversalsPaymentInformationPaymentTypeMethod;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "method",
            "baseName": "method",
            "type": "Ptsv2paymentsidreversalsPaymentInformationPaymentTypeMethod"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsidreversalsPaymentInformationPaymentType.attributeTypeMap;
    }
}

export class Ptsv2paymentsidreversalsPaymentInformationPaymentTypeMethod {
    /**
    * Identifier for the payment type 
    */
    'name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsidreversalsPaymentInformationPaymentTypeMethod.attributeTypeMap;
    }
}

export class Ptsv2paymentsidreversalsPointOfSaleInformation {
    'emv'?: Ptsv2paymentsidreversalsPointOfSaleInformationEmv;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "emv",
            "baseName": "emv",
            "type": "Ptsv2paymentsidreversalsPointOfSaleInformationEmv"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsidreversalsPointOfSaleInformation.attributeTypeMap;
    }
}

export class Ptsv2paymentsidreversalsPointOfSaleInformationEmv {
    /**
    * EMV data that is transmitted from the chip card to the issuer, and from the issuer to the chip card. The EMV data is in the tag-length-value format and includes chip card tags, terminal tags, and transaction detail tags.  For information about the individual tags, see the “Application Specification” section in the EMV 4.3 Specifications: http://emvco.com  **Note** Card present information about EMV applies only to credit card processing and PIN debit processing. All other card present information applies only to credit card processing. PIN debit processing is available only on FDC Nashville Global.  **Important** The following tags contain sensitive information and **must not** be included in this field:   - `56`: Track 1 equivalent data  - `57`: Track 2 equivalent data  - `5A`: Application PAN  - `5F20`: Cardholder name  - `5F24`: Application expiration date (This sensitivity has been relaxed for Credit Mutuel-CIC, American Express Direct, FDC Nashville Global, First Data Merchant Solutions, and SIX)  - `99`: Transaction PIN  - `9F0B`: Cardholder name (extended)  - `9F1F`: Track 1 discretionary data  - `9F20`: Track 2 discretionary data  For captures, this field is required for contact EMV transactions. Otherwise, it is optional.  For credits, this field is required for contact EMV stand-alone credits and contactless EMV stand-alone credits. Otherwise, it is optional.  **Important** For contact EMV captures, contact EMV stand-alone credits, and contactless EMV stand-alone credits, you must include the following tags in this field. For all other types of EMV transactions, the following tags are optional.   - `95`: Terminal verification results  - `9F10`: Issuer application data  - `9F26`: Application cryptogram   #### CyberSource through VisaNet - In Japan: 199 bytes - In other countries: String (252)  For Mastercard Transactions, Optionally Tag 9F60 (Authenticated Application Data) and  Tag 96 (Kernel Identifier - Terminal) can be included in the Field.  #### GPX This field only supports transactions from the following card types: - Visa - Mastercard - AMEX - Discover - Diners - JCB - Union Pay International  #### JCN Gateway The following tags must be included: - `4F`: Application identifier - `84`: Dedicated file name  Data length: 199 bytes  #### All other processors: String (999)  #### Used by Authorization: Optional Authorization Reversal: Optional Credit: Optional PIN Debit processing (purchase, credit and reversal): Optional 
    */
    'tags'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "tags",
            "baseName": "tags",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsidreversalsPointOfSaleInformationEmv.attributeTypeMap;
    }
}

export class Ptsv2paymentsidreversalsProcessingInformation {
    /**
    * Type of digital payment solution for the transaction. Possible Values:   - `visacheckout`: Visa Checkout. This value is required for Visa Checkout transactions. For details, see `payment_solution` field description in [Visa Checkout Using the REST API.](https://developer.cybersource.com/content/dam/docs/cybs/en-us/apifields/reference/all/rest/api-fields.pdf)  - `001`: Apple Pay.  - `004`: Cybersource In-App Solution.  - `005`: Masterpass. This value is required for Masterpass transactions on OmniPay Direct.   - `006`: Android Pay.  - `007`: Chase Pay.  - `008`: Samsung Pay.  - `012`: Google Pay.  - `013`: Cybersource P2PE Decryption  - `014`: Mastercard credential on file (COF) payment network token. Returned in authorizations that use a payment network token associated with a TMS token.  - `015`: Visa credential on file (COF) payment network token. Returned in authorizations that use a payment network token associated with a TMS token.  - `027`: Click to Pay. 
    */
    'paymentSolution'?: string;
    /**
    * Please check with Cybersource customer support to see if your merchant account is configured correctly so you can include this field in your request. * For Payouts: max length for FDCCompass is String (22). 
    */
    'reconciliationId'?: string;
    /**
    * Value that links the current authorization request to the original authorization request. Set this value to the ID that was returned in the reply message from the original authorization request.  This value is used for:  - Partial authorizations - Split shipments 
    */
    'linkId'?: string;
    /**
    * Attribute that lets you define custom grouping for your processor reports. This field is supported only for **Worldpay VAP**. 
    */
    'reportGroup'?: string;
    /**
    * Identifier for the **Visa Checkout** order. Visa Checkout provides a unique order ID for every transaction in the Visa Checkout **callID** field. 
    */
    'visaCheckoutId'?: string;
    'issuer'?: Ptsv2paymentsIssuerInformation;
    /**
    * Array of actions (one or more) to be included in the reversal Possible value: - `AP_AUTH_REVERSAL`: Use this when you want to reverse an Alternative Payment Authorization. 
    */
    'actionList'?: Array<string>;
    /**
    * This field is used identify the type of payment transaction taking place. This field is applicable for MasterCard transactions only. Possible values: - 201- Mastercard Rebate - 202- rePower Load Value - 203- Gaming Re-pay - 204- General Person-to-Person - 205- General Transfer to Own Account - 206- Agent Cash Out - 207- Payment of Own Credit Card Bill - 208- Business Disbursement - 209- Government/Non-Profit Disbursement - 210- Rapid Merchant Settlement - 211- Cash in at ATM (Usage limited to specific countries) - 212- Cash in at Point of Sale (Usage limited to specific countries) - 213- General Business to Business Transfer - 214- Mastercard Merchant Presented QR - 215- Mastercard Merchant Presented QR Refund Payment - 216- Utility Payments (for Brazil domestic use only) - 217- Government Services (for Brazil domestic use only) - 218- Mobile phone top-ups (for Brazil domestic use only) - 219- Coupon booklet payments (for Brazil domestic use only) - 220- General Person-to-Person Transfer - 221- Person-to-Person Transfer to Card Account - 222- General Transfer to Own Account - 223- Agent Cash Out - 224- Payment of Own Credit Card Bill - 225- Business Disbursement - 226- Transfer to Own Staged Digital Wallet Account - 227- Transfer to Own Debit or Prepaid Account - 228- General Business-to-Business Transfer - 229- Installment-based repayment - 230- Mastercard ATM Cash Pick-Up Transaction - 231- Cryptocurrency - 232- High-risk Securities 
    */
    'transactionTypeIndicator'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "paymentSolution",
            "baseName": "paymentSolution",
            "type": "string"
        },
        {
            "name": "reconciliationId",
            "baseName": "reconciliationId",
            "type": "string"
        },
        {
            "name": "linkId",
            "baseName": "linkId",
            "type": "string"
        },
        {
            "name": "reportGroup",
            "baseName": "reportGroup",
            "type": "string"
        },
        {
            "name": "visaCheckoutId",
            "baseName": "visaCheckoutId",
            "type": "string"
        },
        {
            "name": "issuer",
            "baseName": "issuer",
            "type": "Ptsv2paymentsIssuerInformation"
        },
        {
            "name": "actionList",
            "baseName": "actionList",
            "type": "Array<string>"
        },
        {
            "name": "transactionTypeIndicator",
            "baseName": "transactionTypeIndicator",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsidreversalsProcessingInformation.attributeTypeMap;
    }
}

export class Ptsv2paymentsidreversalsReversalInformation {
    'amountDetails'?: Ptsv2paymentsidreversalsReversalInformationAmountDetails;
    /**
    * Reason for the authorization reversal. Possible value:   - `34`: Suspected fraud  This field is ignored for processors that do not support this value.  Returned by authorization reversal. 
    */
    'reason'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "amountDetails",
            "baseName": "amountDetails",
            "type": "Ptsv2paymentsidreversalsReversalInformationAmountDetails"
        },
        {
            "name": "reason",
            "baseName": "reason",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsidreversalsReversalInformation.attributeTypeMap;
    }
}

export class Ptsv2paymentsidreversalsReversalInformationAmountDetails {
    /**
    * Grand total for the order. This value cannot be negative. You can include a decimal point (.), but no other special characters. CyberSource truncates the amount to the correct number of decimal places.  **Note** For CTV, FDCCompass, Paymentech processors, the maximum length for this field is 12.  **Important** Some processors have specific requirements and limitations, such as maximum amounts and maximum field lengths.  If your processor supports zero amount authorizations, you can set this field to 0 for the authorization to check if the card is lost or stolen.   #### Card Present Required to include either this field or `orderInformation.lineItems[].unitPrice` for the order.  #### Invoicing / Pay By Link Required for creating a new invoice or payment link.  #### PIN Debit Amount you requested for the PIN debit purchase. This value is returned for partial authorizations. The issuing bank can approve a partial amount if the balance on the debit card is less than the requested transaction amount.  Required field for PIN Debit purchase and PIN Debit credit requests. Optional field for PIN Debit reversal requests.  #### GPX This field is optional for reversing an authorization or credit; however, for all other processors, these fields are required.  #### DCC with a Third-Party Provider Set this field to the converted amount that was returned by the DCC provider. You must include either this field or the 1st line item in the order and the specific line-order amount in your request.   #### DCC for First Data Not used. 
    */
    'totalAmount'?: string;
    /**
    * Currency used for the order. Use the three-character [ISO Standard Currency Codes.](http://apps.cybersource.com/library/documentation/sbc/quickref/currencies.pdf)  #### Used by **Authorization** Required field.  **Authorization Reversal** For an authorization reversal (`reversalInformation`) or a capture (`processingOptions.capture` is set to `true`), you must use the same currency that you used in your payment authorization request.  #### PIN Debit Currency for the amount you requested for the PIN debit purchase. This value is returned for partial authorizations. The issuing bank can approve a partial amount if the balance on the debit card is less than the requested transaction amount. For the possible values, see the [ISO Standard Currency Codes](https://developer.cybersource.com/library/documentation/sbc/quickref/currencies.pdf). Returned by PIN debit purchase.  For PIN debit reversal requests, you must use the same currency that was used for the PIN debit purchase or PIN debit credit that you are reversing. For the possible values, see the [ISO Standard Currency Codes](https://developer.cybersource.com/library/documentation/sbc/quickref/currencies.pdf).  Required field for PIN Debit purchase and PIN Debit credit requests. Optional field for PIN Debit reversal requests.  #### GPX This field is optional for reversing an authorization or credit.  #### DCC for First Data Your local currency.  #### Tax Calculation Required for international tax and value added tax only. Optional for U.S. and Canadian taxes. Your local currency. 
    */
    'currency'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "totalAmount",
            "baseName": "totalAmount",
            "type": "string"
        },
        {
            "name": "currency",
            "baseName": "currency",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsidreversalsReversalInformationAmountDetails.attributeTypeMap;
    }
}

export class Ptsv2paymentsidvoidsAgreementInformation {
    /**
    * Value of the returned in the billing agreement service response. 
    */
    'agreementId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "agreementId",
            "baseName": "agreementId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsidvoidsAgreementInformation.attributeTypeMap;
    }
}

export class Ptsv2paymentsidvoidsMerchantInformation {
    /**
    * Local Time of the transaction Set the timestamp for the exchange rate by ISO 8601 UTC format. Format: “YYYYMMdd’T’HHmmss’Z’”  (20151103T123456Z) 
    */
    'transactionLocalDateTime'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "transactionLocalDateTime",
            "baseName": "transactionLocalDateTime",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsidvoidsMerchantInformation.attributeTypeMap;
    }
}

export class Ptsv2paymentsidvoidsOrderInformation {
    'amountDetails'?: Ptsv2paymentsidreversalsReversalInformationAmountDetails;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "amountDetails",
            "baseName": "amountDetails",
            "type": "Ptsv2paymentsidreversalsReversalInformationAmountDetails"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsidvoidsOrderInformation.attributeTypeMap;
    }
}

export class Ptsv2paymentsidvoidsPaymentInformation {
    'paymentType'?: Ptsv2paymentsidrefundsPaymentInformationPaymentType;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "paymentType",
            "baseName": "paymentType",
            "type": "Ptsv2paymentsidrefundsPaymentInformationPaymentType"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsidvoidsPaymentInformation.attributeTypeMap;
    }
}

export class Ptsv2paymentsidvoidsProcessingInformation {
    /**
    * Array of actions (one or more) to be included in the void to invoke bundled services along with void. Possible values: - `AP_CANCEL`: Use this when Alternative Payment Void service is requested. 
    */
    'actionList'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "actionList",
            "baseName": "actionList",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymentsidvoidsProcessingInformation.attributeTypeMap;
    }
}

export class Ptsv2paymenttokensPaymentInformation {
    'paymentType'?: Ptsv2refreshpaymentstatusidPaymentInformationPaymentType;
    'tokenizedPaymentMethod'?: Ptsv2paymentsPaymentInformationTokenizedPaymentMethod;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "paymentType",
            "baseName": "paymentType",
            "type": "Ptsv2refreshpaymentstatusidPaymentInformationPaymentType"
        },
        {
            "name": "tokenizedPaymentMethod",
            "baseName": "tokenizedPaymentMethod",
            "type": "Ptsv2paymentsPaymentInformationTokenizedPaymentMethod"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymenttokensPaymentInformation.attributeTypeMap;
    }
}

export class Ptsv2paymenttokensProcessingInformation {
    /**
    * Array of actions (one or more) to be included in the payment to invoke bundled services. Possible values are one or more of follows:   - `TOKEN_RETRIEVE`: Use this when Alternative Payment token retrieval is requested.  - `TOKEN_DELETE`: Use this when Alternative Payment token deletion is requested. 
    */
    'actionList'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "actionList",
            "baseName": "actionList",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2paymenttokensProcessingInformation.attributeTypeMap;
    }
}

export class Ptsv2payoutsAggregatorInformation {
    /**
    * Value that identifies you as a payment aggregator. Get this value from the processor. 
    */
    'aggregatorId'?: string;
    /**
    * Your payment aggregator business name. This field is conditionally required when aggregator id is present. 
    */
    'name'?: string;
    /**
    * Independent sales organization ID. This field is only used for Mastercard transactions submitted through PPGS. 
    */
    'independentSalesOrganizationID'?: string;
    'subMerchant'?: Ptsv2payoutsAggregatorInformationSubMerchant;
    /**
    * Acquirer street name.
    */
    'streetAddress'?: string;
    /**
    * Acquirer city.
    */
    'city'?: string;
    /**
    * Acquirer state.
    */
    'state'?: string;
    /**
    * Acquirer postal code.
    */
    'postalCode'?: string;
    /**
    * Acquirer country.
    */
    'country'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "aggregatorId",
            "baseName": "aggregatorId",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "independentSalesOrganizationID",
            "baseName": "independentSalesOrganizationID",
            "type": "string"
        },
        {
            "name": "subMerchant",
            "baseName": "subMerchant",
            "type": "Ptsv2payoutsAggregatorInformationSubMerchant"
        },
        {
            "name": "streetAddress",
            "baseName": "streetAddress",
            "type": "string"
        },
        {
            "name": "city",
            "baseName": "city",
            "type": "string"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "string"
        },
        {
            "name": "postalCode",
            "baseName": "postalCode",
            "type": "string"
        },
        {
            "name": "country",
            "baseName": "country",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2payoutsAggregatorInformation.attributeTypeMap;
    }
}

export class Ptsv2payoutsAggregatorInformationSubMerchant {
    /**
    * The ID you assigned to your sub-merchant. 
    */
    'id'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2payoutsAggregatorInformationSubMerchant.attributeTypeMap;
    }
}

export class Ptsv2payoutsClientReferenceInformation {
    /**
    * Merchant-generated order reference or tracking number. It is recommended that you send a unique value for each transaction so that you can perform meaningful searches for the transaction.  #### Used by **Authorization** Required field.  #### PIN Debit Requests for PIN debit reversals need to use the same merchant reference number that was used in the transaction that is being reversed.  Required field for all PIN Debit requests (purchase, credit, and reversal).  #### FDC Nashville Global Certain circumstances can cause the processor to truncate this value to 15 or 17 characters for Level II and Level III processing, which can cause a discrepancy between the value you submit and the value included in some processor reports. 
    */
    'code'?: string;
    /**
    * The name of the Connection Method client (such as Virtual Terminal or SOAP Toolkit API) that the merchant uses to send a transaction request to CyberSource. 
    */
    'applicationName'?: string;
    /**
    * Version of the CyberSource application or integration used for a transaction. 
    */
    'applicationVersion'?: string;
    /**
    * The entity that is responsible for running the transaction and submitting the processing request to CyberSource. This could be a person, a system, or a connection method. 
    */
    'applicationUser'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        },
        {
            "name": "applicationName",
            "baseName": "applicationName",
            "type": "string"
        },
        {
            "name": "applicationVersion",
            "baseName": "applicationVersion",
            "type": "string"
        },
        {
            "name": "applicationUser",
            "baseName": "applicationUser",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2payoutsClientReferenceInformation.attributeTypeMap;
    }
}

export class Ptsv2payoutsMerchantInformation {
    /**
    * The value for this field is a four-digit number that the payment card industry uses to classify merchants into market segments. A payment card company assigned one or more of these values to your business when you started accepting the payment card company’s cards. When you do not include this field in your request, CyberSource uses the value in your CyberSource account.  #### CyberSource through VisaNet The value for this field corresponds to the following data in the TC 33 capture file5: - Record: CP01 TCR4 - Position: 150-153 - Field: Merchant Category Code 
    */
    'categoryCode'?: number;
    /**
    * Time that the transaction was submitted in local time. The time is in hhmmss format. 
    */
    'submitLocalDateTime'?: string;
    /**
    * Your government-assigned tax identification number.  #### Tax Calculation Required field for value added tax only. Not applicable to U.S. and Canadian taxes.  #### CyberSource through VisaNet For CtV processors, the maximum length is 20. 
    */
    'vatRegistrationNumber'?: string;
    'merchantDescriptor'?: Ptsv2payoutsMerchantInformationMerchantDescriptor;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "categoryCode",
            "baseName": "categoryCode",
            "type": "number"
        },
        {
            "name": "submitLocalDateTime",
            "baseName": "submitLocalDateTime",
            "type": "string"
        },
        {
            "name": "vatRegistrationNumber",
            "baseName": "vatRegistrationNumber",
            "type": "string"
        },
        {
            "name": "merchantDescriptor",
            "baseName": "merchantDescriptor",
            "type": "Ptsv2payoutsMerchantInformationMerchantDescriptor"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2payoutsMerchantInformation.attributeTypeMap;
    }
}

export class Ptsv2payoutsMerchantInformationMerchantDescriptor {
    /**
    * Your merchant name.  **Note** For Paymentech processor using Cybersource Payouts, the maximum data length is 22.  #### PIN debit Your business name. This name is displayed on the cardholder’s statement. When you include more than one consecutive space, extra spaces are removed.  When you do not include this value in your PIN debit request, the merchant name from your account is used. **Important** This value must consist of English characters.  Optional field for PIN debit credit or PIN debit purchase requests.  #### Airline processing Your merchant name. This name is displayed on the cardholder’s statement. When you include more than one consecutive space, extra spaces are removed.  **Note** Some airline fee programs may require the original ticket number (ticket identifier) or the ancillary service description in positions 13 through 23 of this field.  **Important** This value must consist of English characters.  Required for captures and credits. 
    */
    'name'?: string;
    /**
    * Merchant's City.  #### PIN debit City for your business location. This value might be displayed on the cardholder’s statement.  When you do not include this value in your PIN debit request, the merchant name from your account is used. **Important** This value must consist of English characters.  Optional field for PIN debit credit or PIN debit purchase requests. 
    */
    'locality'?: string;
    /**
    * Merchant's country.  #### PIN debit Country code for your business location. Use the [ISO Standard Country Codes](https://developer.cybersource.com/library/documentation/sbc/quickref/countries_alpha_list.pdf) This value might be displayed on the cardholder’s statement.  When you do not include this value in your PIN debit request, the merchant name from your account is used. **Important** This value must consist of English characters. **Note** If your business is located in the U.S. or Canada and you include this field in a request, you must also include `merchantInformation.merchantDescriptor.administrativeArea`.  Optional field for PIN debit credit or PIN debit purchase. 
    */
    'country'?: string;
    /**
    * The state where the merchant is located.  #### PIN debit State code or region code for your business. Use the Use the [State, Province, and Territory Codes for the United States and Canada](https://developer.cybersource.com/library/documentation/sbc/quickref/states_and_provinces.pdf) This value might be displayed on the cardholder’s statement.  When you do not include this value in your PIN debit request, the merchant name from your account is used. **Important** This value must consist of English characters.  **Note** This field is supported only for businesses located in the U.S. or Canada.  Optional field for PIN debit credit or PIN debit purchase. 
    */
    'administrativeArea'?: string;
    /**
    * Merchant's postal code.  #### PIN debit Postal code for your business location. This value might be displayed on the cardholder’s statement.  If your business is domiciled in the U.S., you can use a 5-digit or 9-digit postal code. A 9-digit postal code must follow this format: [5 digits][dash][4 digits] Example: `12345-6789`  If your business is domiciled in Canada, you can use a 6-digit or 9-digit postal code. A 6-digit postal code must follow this format: [alpha][numeric][alpha][space] [numeric][alpha][numeric] Example: `A1B 2C3`  When you do not include this value in your PIN debit request, the merchant name from your account is used. **Important** This value must consist of English characters.  **Note** This field is supported only for businesses located in the U.S. or Canada. **Important** Mastercard requires a postal code for any country that uses postal codes. You can provide the postal code in your account or you can include this field in your request.  Optional field for PIN debit credit or PIN debit purchase. 
    */
    'postalCode'?: string;
    /**
    * Contact information for the merchant.  **Note** These are the maximum data lengths for the following payment processors: - FDCCompass (13) - Paymentech (13) 
    */
    'contact'?: string;
    /**
    * First line of merchant's address. 
    */
    'address1'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "locality",
            "baseName": "locality",
            "type": "string"
        },
        {
            "name": "country",
            "baseName": "country",
            "type": "string"
        },
        {
            "name": "administrativeArea",
            "baseName": "administrativeArea",
            "type": "string"
        },
        {
            "name": "postalCode",
            "baseName": "postalCode",
            "type": "string"
        },
        {
            "name": "contact",
            "baseName": "contact",
            "type": "string"
        },
        {
            "name": "address1",
            "baseName": "address1",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2payoutsMerchantInformationMerchantDescriptor.attributeTypeMap;
    }
}

export class Ptsv2payoutsOrderInformation {
    'amountDetails'?: Ptsv2payoutsOrderInformationAmountDetails;
    'billTo'?: Ptsv2payoutsOrderInformationBillTo;
    /**
    * #### Visa Platform Connect : This API will contain the Flag that specifies whether the payment is for the purchase of cryptocurrency. Additional values to add : This API will contain the Flag that specifies whether the payment is for the purchase of cryptocurrency. valid values are - Y/y, true - N/n, false 
    */
    'isCryptocurrencyPurchase'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "amountDetails",
            "baseName": "amountDetails",
            "type": "Ptsv2payoutsOrderInformationAmountDetails"
        },
        {
            "name": "billTo",
            "baseName": "billTo",
            "type": "Ptsv2payoutsOrderInformationBillTo"
        },
        {
            "name": "isCryptocurrencyPurchase",
            "baseName": "isCryptocurrencyPurchase",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2payoutsOrderInformation.attributeTypeMap;
    }
}

export class Ptsv2payoutsOrderInformationAmountDetails {
    /**
    * Grand total for the order. This value cannot be negative. You can include a decimal point (.), but no other special characters. CyberSource truncates the amount to the correct number of decimal places.  **Note** For CTV, FDCCompass, Paymentech processors, the maximum length for this field is 12.  **Important** Some processors have specific requirements and limitations, such as maximum amounts and maximum field lengths.  If your processor supports zero amount authorizations, you can set this field to 0 for the authorization to check if the card is lost or stolen.   #### Card Present Required to include either this field or `orderInformation.lineItems[].unitPrice` for the order.  #### Invoicing / Pay By Link Required for creating a new invoice or payment link.  #### PIN Debit Amount you requested for the PIN debit purchase. This value is returned for partial authorizations. The issuing bank can approve a partial amount if the balance on the debit card is less than the requested transaction amount.  Required field for PIN Debit purchase and PIN Debit credit requests. Optional field for PIN Debit reversal requests.  #### GPX This field is optional for reversing an authorization or credit; however, for all other processors, these fields are required.  #### DCC with a Third-Party Provider Set this field to the converted amount that was returned by the DCC provider. You must include either this field or the 1st line item in the order and the specific line-order amount in your request.   #### DCC for First Data Not used. 
    */
    'totalAmount'?: string;
    /**
    * Currency used for the order. Use the three-character [ISO Standard Currency Codes.](http://apps.cybersource.com/library/documentation/sbc/quickref/currencies.pdf)  #### Used by **Authorization** Required field.  **Authorization Reversal** For an authorization reversal (`reversalInformation`) or a capture (`processingOptions.capture` is set to `true`), you must use the same currency that you used in your payment authorization request.  #### PIN Debit Currency for the amount you requested for the PIN debit purchase. This value is returned for partial authorizations. The issuing bank can approve a partial amount if the balance on the debit card is less than the requested transaction amount. For the possible values, see the [ISO Standard Currency Codes](https://developer.cybersource.com/library/documentation/sbc/quickref/currencies.pdf). Returned by PIN debit purchase.  For PIN debit reversal requests, you must use the same currency that was used for the PIN debit purchase or PIN debit credit that you are reversing. For the possible values, see the [ISO Standard Currency Codes](https://developer.cybersource.com/library/documentation/sbc/quickref/currencies.pdf).  Required field for PIN Debit purchase and PIN Debit credit requests. Optional field for PIN Debit reversal requests.  #### GPX This field is optional for reversing an authorization or credit.  #### DCC for First Data Your local currency.  #### Tax Calculation Required for international tax and value added tax only. Optional for U.S. and Canadian taxes. Your local currency. 
    */
    'currency'?: string;
    'surcharge'?: Ptsv2payoutsOrderInformationAmountDetailsSurcharge;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "totalAmount",
            "baseName": "totalAmount",
            "type": "string"
        },
        {
            "name": "currency",
            "baseName": "currency",
            "type": "string"
        },
        {
            "name": "surcharge",
            "baseName": "surcharge",
            "type": "Ptsv2payoutsOrderInformationAmountDetailsSurcharge"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2payoutsOrderInformationAmountDetails.attributeTypeMap;
    }
}

export class Ptsv2payoutsOrderInformationAmountDetailsSurcharge {
    /**
    * The surcharge amount is included in the total transaction amount but is passed in a separate field to the issuer and acquirer for tracking. The issuer can provide information about the surcharge amount to the customer.  If the amount is positive, then it is a debit for the customer. If the amount is negative, then it is a credit for the customer.  **NOTE**: This field is supported only for CyberSource through VisaNet (CtV) for Payouts. For CtV, the maximum string length is 8.  #### PIN debit Surcharge amount that you are charging the customer for this transaction. If you include a surcharge amount in the request, you must also include the surcharge amount in the value for `orderInformation.amountDetails.totalAmount`.  Optional field for transactions that use PIN debit credit or PIN debit purchase. 
    */
    'amount'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "amount",
            "baseName": "amount",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2payoutsOrderInformationAmountDetailsSurcharge.attributeTypeMap;
    }
}

export class Ptsv2payoutsOrderInformationBillTo {
    /**
    * Customer’s first name. This name must be the same as the name on the card.  **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.  #### SEPA Required for Create Mandate and Import Mandate #### BACS Required for Import Mandate  #### CyberSource Latin American Processing **Important** For an authorization request, CyberSource Latin American Processing concatenates `orderInformation.billTo.firstName` and `orderInformation.billTo.lastName`. If the concatenated value exceeds 30 characters, CyberSource Latin American Processing declines the authorization request.\\ **Note** CyberSource Latin American Processing is the name of a specific processing connection that CyberSource supports. In the CyberSource API documentation, CyberSource Latin American Processing does not refer to the general topic of processing in Latin America. The information in this field description is for the specific processing connection called _CyberSource Latin American Processing_. It is not for any other Latin American processors that CyberSource supports.  #### CyberSource through VisaNet Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.  #### For Payouts: This field may be sent only for FDC Compass.  #### Chase Paymentech Solutions Optional field.  ####  Credit Mutuel-CIC Optional field.  #### OmniPay Direct Optional field.  #### SIX Optional field.  #### TSYS Acquiring Solutions Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.  #### Worldpay VAP Optional field.  #### All other processors Not used. 
    */
    'firstName'?: string;
    /**
    * Customer’s last name. This name must be the same as the name on the card.  **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.  #### SEPA Required for Create Mandate and Import Mandate #### BACS Required for Import Mandate #### Chase Paymentech Solutions Optional field.  ####  Credit Mutuel-CIC Optional field.  #### CyberSource Latin American Processing **Important** For an authorization request, CyberSource Latin American Processing concatenates `orderInformation.billTo.firstName` and `orderInformation.billTo.lastName`. If the concatenated value exceeds 30 characters, CyberSource Latin American Processing declines the authorization request.\\ **Note** CyberSource Latin American Processing is the name of a specific processing connection that CyberSource supports. In the CyberSource API documentation, CyberSource Latin American Processing does not refer to the general topic of processing in Latin America. The information in this field description is for the specific processing connection called CyberSource Latin American Processing. It is not for any other Latin American processors that CyberSource supports.  #### CyberSource through VisaNet Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.  #### For Payouts: This field may be sent only for FDC Compass.  #### OmniPay Direct Optional field.  #### RBS WorldPay Atlanta Optional field.  #### SIX Optional field.  #### TSYS Acquiring Solutions Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.  #### Worldpay VAP Optional field.  #### All other processors Not used. 
    */
    'lastName'?: string;
    /**
    * Payment card billing street address as it appears on the credit card issuer’s records.  #### SEPA Required for Create Mandate and Import Mandate  #### Atos This field must not contain colons (:).  #### CyberSource through VisaNet **Important** When you populate orderInformation.billTo.address1 and orderInformation.billTo.address2, CyberSource through VisaNet concatenates the two values. If the concatenated value exceeds 40 characters, CyberSource through VisaNet truncates the value at 40 characters before sending it to Visa and the issuing bank. Truncating this value affects AVS results and therefore might also affect risk decisions and chargebacks. Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.  #### FDMS Nashville When the street name is numeric, it must be sent in numeric format. For example, if the address is _One First Street_, it must be sent as _1 1st Street_.  Required if keyed; not used if swiped.  String (20)  #### TSYS Acquiring Solutions Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.  #### All other processors: Optional. String (60)  #### For Payouts This field may be sent only for FDC Compass.  **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting. 
    */
    'address1'?: string;
    /**
    * Used for additional address information. For example: _Attention: Accounts Payable_ Optional field.  For Payouts: This field may be sent only for FDC Compass.  #### Atos This field must not contain colons (:).  #### CyberSource through VisaNet **Important** When you populate `orderInformation.billTo.address1` and `orderInformation.billTo.address2`, CyberSource through VisaNet concatenates the two values. If the concatenated value exceeds 40 characters, CyberSource through VisaNet truncates the value at 40 characters before sending it to Visa and the issuing bank. Truncating this value affects AVS results and therefore might also affect risk decisions and chargebacks. Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.  #### Chase Paymentech Solutions, FDC Compass, and TSYS Acquiring Solutions This value is used for AVS.  #### FDMS Nashville `orderInformation.billTo.address1` and `orderInformation.billTo.address2` together cannot exceed 20 characters. String (20)  #### All Other Processors String (60) 
    */
    'address2'?: string;
    /**
    * Payment card billing country. Use the two-character [ISO Standard Country Codes](http://apps.cybersource.com/library/documentation/sbc/quickref/countries_alpha_list.pdf).  #### SEPA/BACS Required for Create Mandate and Import Mandate  #### CyberSource through VisaNet Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.  **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.  #### Chase Paymentech Solutions Optional field.  ####  Credit Mutuel-CIC Optional field.  #### OmniPay Direct Optional field.  #### SIX Optional field.  #### TSYS Acquiring Solutions Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.  #### Worldpay VAP Optional field.  #### All other processors Not used. 
    */
    'country'?: string;
    /**
    * Payment card billing city.  #### SEPA Required for Create Mandate and Import Mandate  #### Atos This field must not contain colons (:).  #### CyberSource through VisaNet Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.  #### For Payouts: This field may be sent only for FDC Compass.  #### Chase Paymentech Solutions Optional field.  ####  Credit Mutuel-CIC Optional field.  #### OmniPay Direct Optional field.  #### SIX Optional field.  #### TSYS Acquiring Solutions Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.  #### Worldpay VAP Optional field.  #### All other processors Not used. 
    */
    'locality'?: string;
    /**
    * State or province of the billing address. Use the [State, Province, and Territory Codes for the United States and Canada](https://developer.cybersource.com/library/documentation/sbc/quickref/states_and_provinces.pdf).  For Payouts: This field may be sent only for FDC Compass.  ##### CyberSource through VisaNet Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.  **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.  #### Chase Paymentech Solutions Optional field.  ####  Credit Mutuel-CIC Optional field.  #### OmniPay Direct Optional field.  #### SIX Optional field.  #### TSYS Acquiring Solutions Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.  #### Worldpay VAP Optional field.  #### All other processors Not used. 
    */
    'administrativeArea'?: string;
    /**
    * Postal code for the billing address. The postal code must consist of 5 to 9 digits.  When the billing country is the U.S., the 9-digit postal code must follow this format: [5 digits][dash][4 digits]  **Example** `12345-6789`  When the billing country is Canada, the 6-digit postal code must follow this format: [alpha][numeric][alpha][space][numeric][alpha][numeric]  **Example** `A1B 2C3`  **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.  #### SEPA Required for Create Mandate and Import Mandate  #### For Payouts:  This field may be sent only for FDC Compass.  #### American Express Direct Before sending the postal code to the processor, CyberSource removes all nonalphanumeric characters and, if the remaining value is longer than nine characters, truncates the value starting from the right side.  #### Atos This field must not contain colons (:).  #### CyberSource through VisaNet Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.  #### FDMS Nashville Required if `pointOfSaleInformation.entryMode=keyed` and the address is in the U.S. or Canada. Optional if `pointOfSaleInformation.entryMode=keyed` and the address is **not** in the U.S. or Canada. Not used if swiped.  #### RBS WorldPay Atlanta: For best card-present keyed rates, send the postal code if `pointOfSaleInformation.entryMode=keyed`.  #### TSYS Acquiring Solutions Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.  #### All other processors: Optional field. 
    */
    'postalCode'?: string;
    /**
    * Customer’s phone number.  It is recommended that you include the country code when the order is from outside the U.S.  #### Chase Paymentech Solutions Optional field.  ####  Credit Mutuel-CIC Optional field.  #### CyberSource through VisaNet Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.  #### For Payouts: This field may be sent only for FDC Compass.  #### OmniPay Direct Optional field.  #### SIX Optional field.  #### TSYS Acquiring Solutions Optional field.  #### Worldpay VAP Optional field.  #### All other processors Not used. 
    */
    'phoneNumber'?: string;
    /**
    * Customer's phone number type.  #### For Payouts: This field may be sent only for FDC Compass.  Possible Values: * day * home * night * work 
    */
    'phoneType'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "firstName",
            "baseName": "firstName",
            "type": "string"
        },
        {
            "name": "lastName",
            "baseName": "lastName",
            "type": "string"
        },
        {
            "name": "address1",
            "baseName": "address1",
            "type": "string"
        },
        {
            "name": "address2",
            "baseName": "address2",
            "type": "string"
        },
        {
            "name": "country",
            "baseName": "country",
            "type": "string"
        },
        {
            "name": "locality",
            "baseName": "locality",
            "type": "string"
        },
        {
            "name": "administrativeArea",
            "baseName": "administrativeArea",
            "type": "string"
        },
        {
            "name": "postalCode",
            "baseName": "postalCode",
            "type": "string"
        },
        {
            "name": "phoneNumber",
            "baseName": "phoneNumber",
            "type": "string"
        },
        {
            "name": "phoneType",
            "baseName": "phoneType",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2payoutsOrderInformationBillTo.attributeTypeMap;
    }
}

export class Ptsv2payoutsPaymentInformation {
    'card'?: Ptsv2payoutsPaymentInformationCard;
    'customer'?: Ptsv2paymentsPaymentInformationCustomer;
    'paymentInstrument'?: Ptsv2paymentsPaymentInformationPaymentInstrument;
    'instrumentIdentifier'?: PtsV2PaymentsPost201ResponsePaymentInformationInstrumentIdentifier;
    'tokenizedCard'?: Ptsv2paymentsPaymentInformationTokenizedCard;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "card",
            "baseName": "card",
            "type": "Ptsv2payoutsPaymentInformationCard"
        },
        {
            "name": "customer",
            "baseName": "customer",
            "type": "Ptsv2paymentsPaymentInformationCustomer"
        },
        {
            "name": "paymentInstrument",
            "baseName": "paymentInstrument",
            "type": "Ptsv2paymentsPaymentInformationPaymentInstrument"
        },
        {
            "name": "instrumentIdentifier",
            "baseName": "instrumentIdentifier",
            "type": "PtsV2PaymentsPost201ResponsePaymentInformationInstrumentIdentifier"
        },
        {
            "name": "tokenizedCard",
            "baseName": "tokenizedCard",
            "type": "Ptsv2paymentsPaymentInformationTokenizedCard"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2payoutsPaymentInformation.attributeTypeMap;
    }
}

export class Ptsv2payoutsPaymentInformationCard {
    /**
    * Three-digit value that indicates the card type.  **IMPORTANT** It is strongly recommended that you include the card type field in request messages even if it is optional for your processor and card type. Omitting the card type can cause the transaction to be processed with the wrong card type.  Possible values: - `001`: Visa. Use card type value `001` for Visa Electron. - `002`: Mastercard, Eurocard[^1], which is a European regional brand of Mastercard. - `003`: American Express - `004`: Discover - `005`: Diners Club - `006`: Carte Blanche[^1] - `007`: JCB[^1] - `008`: Optima - `009`: GE Private Label - `010`: Beneficial Private Label - `011`: Twinpay Credit Card - `012`: Twinpay Debit Card - `013`: WalMart - `014`: Enroute[^1] - `015`: Lowe's Consumer - `016`: Home Depot Consumer - `017`: MBNA - `018`: Dick's Sportswear - `019`: Casual Corner - `020`: Sears - `021`: JAL[^1] - `023`: Disney Card - `024`: Maestro (UK Domestic)[^1] - `025`: Sam's Club Consumer - `026`: Sam's Club Business - `027`: Nico's - `028`: Paymentech Bill Me Later - `029`: Bebe - `030`: Restoration Hardware - `031`: Delta Online - `032`: Solo - `033`: Visa Electron[^1]. Do not use this value. Use `001` for all Visa card types. - `034`: Dankort[^1] - `035`: Laser - `036`: Cartes Bancaires[^1,4] - `037`: Carta Si[^1] - `038`: Pinless Debit - `039`: Encoded account number[^1] - `040`: UATP[^1] - `041`: HOUSEHOLD - `042`: Maestro (International)[^1] - `043`: GE MONEY - `044`: Korean Cards - `045`: Style Cards - `046`: JCrew - `047`: Payeasecn eWallet - `048`: Payeasecn Bank Transfer - `049`: Meijer - `050`: Hipercard[^2,3] - `051`: Aura - `052`: Redecard - `053`: Orico card - `054`: Elo[^3] - `055`: Capitol One Private Label - `056`: Carnet - `057`: Costco Private Label - `058`: Carnet - `059`: ValueLink - `060`: MADA - `061`: RuPay - `062`: China UnionPay - `063`: Falabella Private Label - `064`: Prompt Card - `065`: Korean Domestic - `066`: Banricompras - `067`: MEEZA - `068`: PayPak - `070`: EFTPOS - `071`: Codensa - `072`: Olimpica - `073`: Colsubsidio - `074`: Tuya - `075`: Sodexo - `076`: Naranja - `077`: Cabal - `078`: DINELCO - `079`: PANAL - `080`: EPM - `081`: Jaywan  [^1]: For this card type, you must include the `paymentInformation.card.type` or `paymentInformation.tokenizedCard.type` field in your request for an authorization or a stand-alone credit. [^2]: For this card type on Cielo 3.0, you must include the `paymentInformation.card.type` or `paymentInformation.tokenizedCard.type` field in a request for an authorization or a stand-alone credit. This card type is not supported on Cielo 1.5. [^3]: For this card type on Getnet and Rede, you must include the `paymentInformation.card.type` or `paymentInformation.tokenizedCard.type` field in a request for an authorization or a stand-alone credit. [^4]: For this card type, you must include the `paymentInformation.card.type` in your request for any payer authentication services.  #### Used by **Authorization** Required for Carte Blanche and JCB. Optional for all other card types.  #### Card Present reply This field is included in the reply message when the client software that is installed on the POS terminal uses the token management service (TMS) to retrieve tokenized payment details. You must contact customer support to have your account enabled to receive these fields in the credit reply message.  Returned by the Credit service.  This reply field is only supported by the following processors: - American Express Direct - Credit Mutuel-CIC - FDC Nashville Global - OmniPay Direct - SIX  #### Google Pay transactions For PAN-based Google Pay transactions, this field is returned in the API response.  #### GPX This field only supports transactions from the following card types: - Visa - Mastercard - AMEX - Discover - Diners - JCB - Union Pay International 
    */
    'type'?: string;
    /**
    * The customer’s payment card number, also known as the Primary Account Number (PAN). You can also use this field for encoded account numbers.  #### FDMS Nashville Required. String (19)  #### GPX Required if `pointOfSaleInformation.entryMode=keyed`. However, this field is optional if your account is configured for relaxed requirements for address data and expiration date. **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.  #### All other processors Required if `pointOfSaleInformation.entryMode=keyed`. However, this field is optional if your account is configured for relaxed requirements for address data and expiration date. **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting. 
    */
    'number'?: string;
    /**
    * Two-digit month in which the payment card expires.  Format: `MM`.  Valid values: `01` through `12`. Leading 0 is required.  #### Barclays and Streamline For Maestro (UK Domestic) and Maestro (International) cards on Barclays and Streamline, this must be a valid value (`01` through `12`) but is not required to be a valid expiration date. In other words, an expiration date that is in the past does not cause CyberSource to reject your request. However, an invalid expiration date might cause the issuer to reject your request.  #### Encoded Account Numbers For encoded account numbers (_type_=039), if there is no expiration date on the card, use `12`.  #### FDMS Nashville Required field.  #### All other processors Required if `pointOfSaleInformation.entryMode=keyed`. However, this field is optional if your account is configured for relaxed requirements for address data and expiration date. **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.  #### Google Pay transactions For PAN-based Google Pay transactions, this field is returned in the API response. 
    */
    'expirationMonth'?: string;
    /**
    * Four-digit year in which the payment card expires.  Format: `YYYY`.  #### Barclays and Streamline For Maestro (UK Domestic) and Maestro (International) cards on Barclays and Streamline, this must be a valid value (`1900` through `3000`) but is not required to be a valid expiration date. In other words, an expiration date that is in the past does not cause CyberSource to reject your request. However, an invalid expiration date might cause the issuer to reject your request.  #### Encoded Account Numbers For encoded account numbers (**_type_**`=039`), if there is no expiration date on the card, use `2021`.  #### FDMS Nashville Required field.  #### FDC Nashville Global and FDMS South You can send in 2 digits or 4 digits. If you send in 2 digits, they must be the last 2 digits of the year.  #### All other processors Required if `pointOfSaleInformation.entryMode=keyed`. However, this field is optional if your account is configured for relaxed requirements for address data and expiration date. **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.  #### Google Pay transactions For PAN-based Google Pay transactions, this field is returned in the API response. 
    */
    'expirationYear'?: string;
    /**
    * Flag that specifies the type of account associated with the card.  The cardholder provides this information during the payment process.  This field is required in the following cases:   - Debit transactions on Cielo and Comercio Latino.   - Transactions with Brazilian-issued cards on CyberSource through VisaNet.   - Applicable only for CyberSource through VisaNet (CtV).  **Note** Combo cards in Brazil contain credit and debit functionality in a single card. Visa systems use a credit bank identification number (BIN) for this type of card. Using the BIN to determine whether a card is debit or credit can cause transactions with these cards to be processed incorrectly. CyberSource strongly recommends that you include this field for combo card transactions.  Possible values include the following.   - `CH`: Checking account  - `CR`: Credit card account  - `SA`: Saving account  - `LI`: Line of credit or credit portion of combo card  - `PP`: Prepaid card account or prepaid portion of combo card  - `UA`: Universal account  If useAs is set to credit/debit and there is a value in SourceAccountType, the value in the SourceAccountType field will take precedence. If useAs is set to CR/DB and there is a value in SourceAccountType, the value in the useAs field will take precedence. 
    */
    'sourceAccountType'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "number",
            "baseName": "number",
            "type": "string"
        },
        {
            "name": "expirationMonth",
            "baseName": "expirationMonth",
            "type": "string"
        },
        {
            "name": "expirationYear",
            "baseName": "expirationYear",
            "type": "string"
        },
        {
            "name": "sourceAccountType",
            "baseName": "sourceAccountType",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2payoutsPaymentInformationCard.attributeTypeMap;
    }
}

export class Ptsv2payoutsProcessingInformation {
    /**
    * Payouts transaction type.  Applicable Processors: FDC Compass, Paymentech, CtV  Possible values:  **Credit Card Bill Payment**   - **CP**: credit card bill payment  **Funds Disbursement**   - **FD**: funds disbursement  - **GD**: government disbursement  - **MD**: merchant disbursement  **Money Transfer**   - **AA**: account to account. Sender and receiver are same person.  - **PP**: person to person. Sender and receiver are different.  **Prepaid Load**   - **TU**: top up 
    */
    'businessApplicationId'?: string;
    /**
    * This field is optionally used by Push Payments Gateway participants (merchants and acquirers) to get the attributes for specified networks only. The networks specified in this field must be a subset of the information provided during program enrollment. Refer to Sharing Group Code/Network Routing Order. Note: Supported only in US for domestic transactions involving Push Payments Gateway Service.  VisaNet checks to determine if there are issuer routing preferences for any of the networks specified by the network routing order. If an issuer preference exists for one of the specified debit networks, VisaNet makes a routing selection based on the issuer’s preference.  If an issuer preference exists for more than one of the specified debit networks, or if no issuer preference exists, VisaNet makes a selection based on the acquirer’s routing priorities.  
    */
    'networkRoutingOrder'?: string;
    /**
    * Type of transaction.  Value for an OCT transaction: - `internet` 
    */
    'commerceIndicator'?: string;
    /**
    * Please check with Cybersource customer support to see if your merchant account is configured correctly so you can include this field in your request. * For Payouts: max length for FDCCompass is String (22). 
    */
    'reconciliationId'?: string;
    'payoutsOptions'?: Ptsv2payoutsProcessingInformationPayoutsOptions;
    /**
    * Transaction reason code. 
    */
    'transactionReason'?: string;
    /**
    * This field is applicable for AFT and OCT transactions. For list of supported values, please refer to Developer Guide. 
    */
    'purposeOfPayment'?: string;
    'fundingOptions'?: Ptsv2payoutsProcessingInformationFundingOptions;
    /**
    * Contains the ISO 639-2 defined language Code 
    */
    'languageCode'?: string;
    'purchaseOptions'?: Ptsv2payoutsProcessingInformationPurchaseOptions;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "businessApplicationId",
            "baseName": "businessApplicationId",
            "type": "string"
        },
        {
            "name": "networkRoutingOrder",
            "baseName": "networkRoutingOrder",
            "type": "string"
        },
        {
            "name": "commerceIndicator",
            "baseName": "commerceIndicator",
            "type": "string"
        },
        {
            "name": "reconciliationId",
            "baseName": "reconciliationId",
            "type": "string"
        },
        {
            "name": "payoutsOptions",
            "baseName": "payoutsOptions",
            "type": "Ptsv2payoutsProcessingInformationPayoutsOptions"
        },
        {
            "name": "transactionReason",
            "baseName": "transactionReason",
            "type": "string"
        },
        {
            "name": "purposeOfPayment",
            "baseName": "purposeOfPayment",
            "type": "string"
        },
        {
            "name": "fundingOptions",
            "baseName": "fundingOptions",
            "type": "Ptsv2payoutsProcessingInformationFundingOptions"
        },
        {
            "name": "languageCode",
            "baseName": "languageCode",
            "type": "string"
        },
        {
            "name": "purchaseOptions",
            "baseName": "purchaseOptions",
            "type": "Ptsv2payoutsProcessingInformationPurchaseOptions"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2payoutsProcessingInformation.attributeTypeMap;
    }
}

export class Ptsv2payoutsProcessingInformationFundingOptions {
    'initiator'?: Ptsv2payoutsProcessingInformationFundingOptionsInitiator;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "initiator",
            "baseName": "initiator",
            "type": "Ptsv2payoutsProcessingInformationFundingOptionsInitiator"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2payoutsProcessingInformationFundingOptions.attributeTypeMap;
    }
}

export class Ptsv2payoutsProcessingInformationFundingOptionsInitiator {
    /**
    * #### Visa Platform Connect : This API will contain a code that denotes whether the customer identification data belongs to the sender or the recipient.  The valid values are: • S (Payer (sender)) • R (Payee (recipient)) 
    */
    'type'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2payoutsProcessingInformationFundingOptionsInitiator.attributeTypeMap;
    }
}

export class Ptsv2payoutsProcessingInformationPayoutsOptions {
    /**
    * This field identifies the card acceptor for defining the point of service terminal in both local and interchange environments. An acquirer-assigned code identifying the card acceptor for the transaction.  Depending on the acquirer and merchant billing and reporting requirements, the code can represent a merchant, a specific merchant location, or a specific merchant location terminal. Acquiring Institution Identification Code uniquely identifies the merchant. The value from the original is required in any subsequent messages, including reversals, chargebacks, and representments. * Applicable only for CTV for Payouts. 
    */
    'acquirerMerchantId'?: string;
    /**
    * This code identifies the financial institution acting as the acquirer of this customer transaction. The acquirer is the member or system user that signed the merchant or ADM or dispensed cash.  This number is usually Visa-assigned. * Applicable only for CTV for Payouts. 
    */
    'acquirerBin'?: string;
    /**
    * This field contains a number that is used with other data elements as a key to identify and track all messages related to a given cardholder transaction; that is, to a given transaction set.  Format:   Positions 1-4: The `yddd` equivalent of the date, where `y` = 0-9 and `ddd` = 001 – 366.   Positions 5-12: A unique identification number generated by the merchant  * Applicable only for CTV for Payouts. 
    */
    'retrievalReferenceNumber'?: string;
    /**
    * Visa-generated transaction identifier (TID) that is unique for each original authorization and financial request. * Applicable only for CTV for Payouts. 
    */
    'accountFundingReferenceId'?: string;
    /**
    * #### Visa Platform Connect  Contains date and time value indicating scheduled deferred OCT.  Format is : 'yyyyMMddHHmm', where  'YYYY' = year 'MM' = month 'DD' = day 'hh' = hour 'mm' = minutes 
    */
    'deferredDateTime'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "acquirerMerchantId",
            "baseName": "acquirerMerchantId",
            "type": "string"
        },
        {
            "name": "acquirerBin",
            "baseName": "acquirerBin",
            "type": "string"
        },
        {
            "name": "retrievalReferenceNumber",
            "baseName": "retrievalReferenceNumber",
            "type": "string"
        },
        {
            "name": "accountFundingReferenceId",
            "baseName": "accountFundingReferenceId",
            "type": "string"
        },
        {
            "name": "deferredDateTime",
            "baseName": "deferredDateTime",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2payoutsProcessingInformationPayoutsOptions.attributeTypeMap;
    }
}

export class Ptsv2payoutsProcessingInformationPurchaseOptions {
    /**
    * Workplace benefit amount.
    */
    'benefitAmount'?: string;
    /**
    * Workplace benefit type. Possible values: - 70 = employee benefit - 4T = transportation / transit - 52 = general benefit - 53 = meal voucher - 54 = fuel - 55 = ecological / sustainability - 58 = philanthropy / patronage / consumption - 59 = gift - 5S = sport / culture - 5T = book / education 
    */
    'benefitType'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "benefitAmount",
            "baseName": "benefitAmount",
            "type": "string"
        },
        {
            "name": "benefitType",
            "baseName": "benefitType",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2payoutsProcessingInformationPurchaseOptions.attributeTypeMap;
    }
}

export class Ptsv2payoutsRecipientInformation {
    /**
    * First name of the recipient.    This field is applicable for AFT & OCT transactions.  Only alpha numeric values are supported. Special characters not in the standard ASCII character set, are not supported and will be stripped before being sent to sent to the processor. 
    */
    'firstName'?: string;
    /**
    * Middle name of the recipient.    This field is applicable for AFT & OCT transactions.  Only alpha numeric values are supported. Special characters not in the standard ASCII character set, are not supported and will be stripped before being sent to sent to the processor. 
    */
    'middleName'?: string;
    /**
    * Last name of the recipient.  This field is applicable for AFT & OCT transactions.  Only alpha numeric values are supported. Special characters not in the standard ASCII character set, are not supported and will be stripped before being sent to sent to the processor. 
    */
    'lastName'?: string;
    /**
    * The street address of the recipient This field is applicable for AFT and OCT transactions.  Only alpha numeric values are supported. Special characters not in the standard ASCII character set are not supported and will be stripped before being sent to sent to the processor. 
    */
    'address1'?: string;
    /**
    * The city of the recipient. This field is applicable for AFT and OCT transactions.  Only alpha numeric values are supported. Special characters not in the standard ASCII character set are not supported and will be stripped before being sent to sent to the processor. 
    */
    'locality'?: string;
    /**
    * The state or province of the recipient. This field is applicable for AFT and OCT transactions when the recipient country is US or CA. Else it is optional.  Must be a two character value 
    */
    'administrativeArea'?: string;
    /**
    * The country associated with the address of the recipient. This field is applicable for AFT and OCT transactions.  Must be a two character ISO country code.  For example, see [ISO Country Code](https://developer.cybersource.com/docs/cybs/en-us/country-codes/reference/all/na/country-codes/country-codes.html) 
    */
    'country'?: string;
    /**
    * Recipient postal code. Required only for FDCCompass.
    */
    'postalCode'?: string;
    /**
    * Recipient phone number. Required only for FDCCompass.
    */
    'phoneNumber'?: string;
    /**
    * Account owner alias name. 
    */
    'aliasName'?: string;
    /**
    * Account Owner Nationality
    */
    'nationality'?: string;
    /**
    * Account Owner Country of Birth
    */
    'countryOfBirth'?: string;
    /**
    * Account Owner Occupation
    */
    'occupation'?: string;
    /**
    * Account Owner email address
    */
    'email'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "firstName",
            "baseName": "firstName",
            "type": "string"
        },
        {
            "name": "middleName",
            "baseName": "middleName",
            "type": "string"
        },
        {
            "name": "lastName",
            "baseName": "lastName",
            "type": "string"
        },
        {
            "name": "address1",
            "baseName": "address1",
            "type": "string"
        },
        {
            "name": "locality",
            "baseName": "locality",
            "type": "string"
        },
        {
            "name": "administrativeArea",
            "baseName": "administrativeArea",
            "type": "string"
        },
        {
            "name": "country",
            "baseName": "country",
            "type": "string"
        },
        {
            "name": "postalCode",
            "baseName": "postalCode",
            "type": "string"
        },
        {
            "name": "phoneNumber",
            "baseName": "phoneNumber",
            "type": "string"
        },
        {
            "name": "aliasName",
            "baseName": "aliasName",
            "type": "string"
        },
        {
            "name": "nationality",
            "baseName": "nationality",
            "type": "string"
        },
        {
            "name": "countryOfBirth",
            "baseName": "countryOfBirth",
            "type": "string"
        },
        {
            "name": "occupation",
            "baseName": "occupation",
            "type": "string"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2payoutsRecipientInformation.attributeTypeMap;
    }
}

export class Ptsv2payoutsSenderInformation {
    /**
    * Reference number generated by you that uniquely identifies the sender.
    */
    'referenceNumber'?: string;
    'account'?: Ptsv2payoutsSenderInformationAccount;
    /**
    * First name of the sender. This field is applicable for AFT and OCT transactions.   Only alpha numeric values are supported.Special characters not in the standard ASCII character set, are not supported and will be stripped before being sent to the processor. 
    */
    'firstName'?: string;
    /**
    * Recipient middle initial (Optional). 
    */
    'middleInitial'?: string;
    /**
    * Middle name of the sender. This field is applicable for AFT and OCT transactions.   Only alpha numeric values are supported. Special characters not in the standard ASCII character set, are not supported and will be stripped before being sent to sent to the processor. 
    */
    'middleName'?: string;
    /**
    * Last name of the sender. This field is applicable for AFT and OCT transactions.  Only alpha numeric values are supported. Special characters not in the standard ASCII character set, are not supported and will be stripped before being sent to sent to the processor. 
    */
    'lastName'?: string;
    /**
    * Name of sender.  **Funds Disbursement**  This value is the name of the originator sending the funds disbursement. * CTV, Paymentech (30) 
    */
    'name'?: string;
    /**
    * Street address of sender.  **Funds Disbursement**  This value is the address of the originator sending the funds disbursement. 
    */
    'address1'?: string;
    /**
    * City of sender.  **Funds Disbursement**  This value is the city of the originator sending the funds disbursement. 
    */
    'locality'?: string;
    /**
    * Sender’s state. Use the [State, Province, and Territory Codes for the United States and Canada](https://developer.cybersource.com/library/documentation/sbc/quickref/states_and_provinces.pdf). 
    */
    'administrativeArea'?: string;
    /**
    * Country of sender. Use the [ISO Standard Country Codes](https://developer.cybersource.com/library/documentation/sbc/quickref/countries_alpha_list.pdf). * CTV (3) 
    */
    'countryCode'?: string;
    /**
    * Sender’s postal code. Required only for FDCCompass.
    */
    'postalCode'?: string;
    /**
    * Sender’s phone number. Required only for FDCCompass.
    */
    'phoneNumber'?: string;
    /**
    * Sender’s date of birth in YYYYMMDD format. Required only for FDCCompass.
    */
    'dateOfBirth'?: string;
    /**
    * Customer's government-assigned tax identification number. 
    */
    'vatRegistrationNumber'?: string;
    /**
    * #### Visa Platform Connect This tag will contain the type of sender identification. The valid values are: • BTHD (Date of birth) • CUID (Customer identification (unspecified)) • NTID (National identification) • PASN (Passport number) • DRLN (Driver license) • TXIN (Tax identification) • CPNY (Company registration number) • PRXY (Proxy identification) • SSNB (Social security number) • ARNB (Alien registration number) • LAWE (Law enforcement identification) • MILI (Military identification) • TRVL (Travel identification (non-passport)) • EMAL (Email) • PHON (Phone number) 
    */
    'personalIdType'?: string;
    /**
    * #### Visa Platform Connect This tag will denote whether the tax ID is a business or individual tax ID when personal ID Type contains the value of TXIN (Tax identification).  The valid values are: • B (Business) • I (Individual) 
    */
    'type'?: string;
    /**
    * #### Visa Platform Connect This tag will contain an acquirer-populated value associated with the API : senderInformation.personalIdType which will identify the personal ID type of the sender. 
    */
    'identificationNumber'?: string;
    /**
    * Sender's alias name.
    */
    'aliasName'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "referenceNumber",
            "baseName": "referenceNumber",
            "type": "string"
        },
        {
            "name": "account",
            "baseName": "account",
            "type": "Ptsv2payoutsSenderInformationAccount"
        },
        {
            "name": "firstName",
            "baseName": "firstName",
            "type": "string"
        },
        {
            "name": "middleInitial",
            "baseName": "middleInitial",
            "type": "string"
        },
        {
            "name": "middleName",
            "baseName": "middleName",
            "type": "string"
        },
        {
            "name": "lastName",
            "baseName": "lastName",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "address1",
            "baseName": "address1",
            "type": "string"
        },
        {
            "name": "locality",
            "baseName": "locality",
            "type": "string"
        },
        {
            "name": "administrativeArea",
            "baseName": "administrativeArea",
            "type": "string"
        },
        {
            "name": "countryCode",
            "baseName": "countryCode",
            "type": "string"
        },
        {
            "name": "postalCode",
            "baseName": "postalCode",
            "type": "string"
        },
        {
            "name": "phoneNumber",
            "baseName": "phoneNumber",
            "type": "string"
        },
        {
            "name": "dateOfBirth",
            "baseName": "dateOfBirth",
            "type": "string"
        },
        {
            "name": "vatRegistrationNumber",
            "baseName": "vatRegistrationNumber",
            "type": "string"
        },
        {
            "name": "personalIdType",
            "baseName": "personalIdType",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "identificationNumber",
            "baseName": "identificationNumber",
            "type": "string"
        },
        {
            "name": "aliasName",
            "baseName": "aliasName",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2payoutsSenderInformation.attributeTypeMap;
    }
}

export class Ptsv2payoutsSenderInformationAccount {
    /**
    * Source of funds. Possible values:    Paymentech, CTV, FDC Compass:  - 01: Credit card  - 02: Debit card  - 03: Prepaid card    Paymentech, CTV -  - 04: Cash  - 05: Debit or deposit account that is not linked to a Visa card. Includes checking accounts, savings        accounts, and proprietary debit or ATM cards.  - 06: Credit account that is not linked to a Visa card. Includes credit cards and proprietary lines        of credit.    FDCCompass -   - 04: Deposit Account  **Funds Disbursement**  This value is most likely 05 to identify that the originator used a deposit account to fund the disbursement.  **Credit Card Bill Payment**  This value must be 02, 03, 04, or 05. 
    */
    'fundsSource'?: string;
    /**
    * The account number of the entity funding the transaction. It is the sender’s account number. It can be a debit/credit card account number or bank account number.  **Funds disbursements and OCT transactions**  This field is optional.  **All other transactions**  This field is required when the sender funds the transaction with a financial instrument, for example debit card. Length: * FDCCompass (<= 19) * Paymentech (<= 16) 
    */
    'number'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "fundsSource",
            "baseName": "fundsSource",
            "type": "string"
        },
        {
            "name": "number",
            "baseName": "number",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2payoutsSenderInformationAccount.attributeTypeMap;
    }
}

export class Ptsv2refreshpaymentstatusidAgreementInformation {
    /**
    * The identifier for the billing agreement. 
    */
    'agreementId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "agreementId",
            "baseName": "agreementId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2refreshpaymentstatusidAgreementInformation.attributeTypeMap;
    }
}

export class Ptsv2refreshpaymentstatusidClientReferenceInformation {
    /**
    * Merchant-generated order reference or tracking number. It is recommended that you send a unique value for each transaction so that you can perform meaningful searches for the transaction.  #### Used by **Authorization** Required field.  #### PIN Debit Requests for PIN debit reversals need to use the same merchant reference number that was used in the transaction that is being reversed.  Required field for all PIN Debit requests (purchase, credit, and reversal).  #### FDC Nashville Global Certain circumstances can cause the processor to truncate this value to 15 or 17 characters for Level II and Level III processing, which can cause a discrepancy between the value you submit and the value included in some processor reports. 
    */
    'code'?: string;
    /**
    * Reference number for the transaction. Depending on how your Cybersource account is configured, this value could either be provided in the API request or generated by CyberSource. The actual value used in the request to the processor is provided back to you by Cybersource in the response. 
    */
    'reconciliationId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        },
        {
            "name": "reconciliationId",
            "baseName": "reconciliationId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2refreshpaymentstatusidClientReferenceInformation.attributeTypeMap;
    }
}

export class Ptsv2refreshpaymentstatusidPaymentInformation {
    'customer'?: Ptsv2refreshpaymentstatusidPaymentInformationCustomer;
    'paymentType'?: Ptsv2refreshpaymentstatusidPaymentInformationPaymentType;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "customer",
            "baseName": "customer",
            "type": "Ptsv2refreshpaymentstatusidPaymentInformationCustomer"
        },
        {
            "name": "paymentType",
            "baseName": "paymentType",
            "type": "Ptsv2refreshpaymentstatusidPaymentInformationPaymentType"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2refreshpaymentstatusidPaymentInformation.attributeTypeMap;
    }
}

export class Ptsv2refreshpaymentstatusidPaymentInformationCustomer {
    /**
    * Unique identifier for the customer's card and billing information.  When you use Payment Tokenization or Recurring Billing and you include this value in your request, many of the fields that are normally required for an authorization or credit become optional.  **NOTE** When you use Payment Tokenization or Recurring Billing, the value for the Customer ID is actually the Cybersource payment token for a customer. This token stores information such as the consumer’s card number so it can be applied towards bill payments, recurring payments, or one-time payments. By using this token in a payment API request, the merchant doesn't need to pass in data such as the card number or expiration date in the request itself. 
    */
    'customerId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "customerId",
            "baseName": "customerId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2refreshpaymentstatusidPaymentInformationCustomer.attributeTypeMap;
    }
}

export class Ptsv2refreshpaymentstatusidPaymentInformationPaymentType {
    /**
    * A Payment Type is an agreed means for a payee to receive legal tender from a payer. The way one pays for a commercial financial transaction. Examples: Card, Bank Transfer, Digital, Direct Debit. Possible values: - `CARD` (use this for a PIN debit transaction) - `CHECK` (use this for all eCheck payment transactions - ECP Debit, ECP Follow-on Credit, ECP StandAlone Credit) - `bankTransfer` (use for Online Bank Transafer for methods such as P24, iDeal, Estonia Bank, KCP) - `localCard` (KCP Local card via Altpay) - `carrierBilling` (KCP Carrier Billing via Altpay) 
    */
    'name'?: string;
    'method'?: Ptsv2paymentsidcapturesPaymentInformationPaymentTypeMethod;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "method",
            "baseName": "method",
            "type": "Ptsv2paymentsidcapturesPaymentInformationPaymentTypeMethod"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2refreshpaymentstatusidPaymentInformationPaymentType.attributeTypeMap;
    }
}

export class Ptsv2refreshpaymentstatusidProcessingInformation {
    /**
    * Array of actions (one or more) to be included in the payment to invoke bundled services along with payment status.  Possible values are one or more of follows:   - `AP_STATUS`: Use this when Alternative Payment check status service is requested.   - `AP_SESSION_STATUS`: Use this when Alternative Payment check status service for Paypal, Klarna is requested.   - `AP_INITIATE_STATUS`: Use this when Alternative Payment check status service for KCP is requested.   - `AP_ORDER_STATUS`: Use this when Alternative Payment check status service for order status request.   - `AP_AUTH_STATUS`: Use this when Alternative Payment check status service for auth status request.   - `AP_CAPTURE_STATUS`: Use this when Alternative Payment check status service for capture status request.   - `AP_REFUND_STATUS`: Use this when Alternative Payment check status service for refund status request. 
    */
    'actionList'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "actionList",
            "baseName": "actionList",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2refreshpaymentstatusidProcessingInformation.attributeTypeMap;
    }
}

export class Ptsv2voidsProcessingInformation {
    /**
    * This field is to accept the id of credit/capture in the body of the requests so the type of void can be identified and processed correctly.
    */
    'paymentId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "paymentId",
            "baseName": "paymentId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Ptsv2voidsProcessingInformation.attributeTypeMap;
    }
}

export class Rbsv1plansClientReferenceInformation {
    /**
    * Brief description of the order or any comment you wish to add to the order. 
    */
    'comments'?: string;
    'partner'?: Riskv1decisionsClientReferenceInformationPartner;
    /**
    * The name of the Connection Method client (such as Virtual Terminal or SOAP Toolkit API) that the merchant uses to send a transaction request to CyberSource. 
    */
    'applicationName'?: string;
    /**
    * Version of the CyberSource application or integration used for a transaction. 
    */
    'applicationVersion'?: string;
    /**
    * The entity that is responsible for running the transaction and submitting the processing request to CyberSource. This could be a person, a system, or a connection method. 
    */
    'applicationUser'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "comments",
            "baseName": "comments",
            "type": "string"
        },
        {
            "name": "partner",
            "baseName": "partner",
            "type": "Riskv1decisionsClientReferenceInformationPartner"
        },
        {
            "name": "applicationName",
            "baseName": "applicationName",
            "type": "string"
        },
        {
            "name": "applicationVersion",
            "baseName": "applicationVersion",
            "type": "string"
        },
        {
            "name": "applicationUser",
            "baseName": "applicationUser",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Rbsv1plansClientReferenceInformation.attributeTypeMap;
    }
}

export class Rbsv1plansOrderInformation {
    'amountDetails'?: Rbsv1plansOrderInformationAmountDetails;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "amountDetails",
            "baseName": "amountDetails",
            "type": "Rbsv1plansOrderInformationAmountDetails"
        }    ];

    static getAttributeTypeMap() {
        return Rbsv1plansOrderInformation.attributeTypeMap;
    }
}

export class Rbsv1plansOrderInformationAmountDetails {
    /**
    * Currency used for the order. Use the three-character [ISO Standard Currency Codes.](http://apps.cybersource.com/library/documentation/sbc/quickref/currencies.pdf)  #### Used by **Authorization** Required field.  **Authorization Reversal** For an authorization reversal (`reversalInformation`) or a capture (`processingOptions.capture` is set to `true`), you must use the same currency that you used in your payment authorization request.  #### PIN Debit Currency for the amount you requested for the PIN debit purchase. This value is returned for partial authorizations. The issuing bank can approve a partial amount if the balance on the debit card is less than the requested transaction amount. For the possible values, see the [ISO Standard Currency Codes](https://developer.cybersource.com/library/documentation/sbc/quickref/currencies.pdf). Returned by PIN debit purchase.  For PIN debit reversal requests, you must use the same currency that was used for the PIN debit purchase or PIN debit credit that you are reversing. For the possible values, see the [ISO Standard Currency Codes](https://developer.cybersource.com/library/documentation/sbc/quickref/currencies.pdf).  Required field for PIN Debit purchase and PIN Debit credit requests. Optional field for PIN Debit reversal requests.  #### GPX This field is optional for reversing an authorization or credit.  #### DCC for First Data Your local currency.  #### Tax Calculation Required for international tax and value added tax only. Optional for U.S. and Canadian taxes. Your local currency. 
    */
    'currency': string;
    /**
    * Billing amount for the billing period. 
    */
    'billingAmount': string;
    /**
    * Subscription setup fee 
    */
    'setupFee'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "currency",
            "baseName": "currency",
            "type": "string"
        },
        {
            "name": "billingAmount",
            "baseName": "billingAmount",
            "type": "string"
        },
        {
            "name": "setupFee",
            "baseName": "setupFee",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Rbsv1plansOrderInformationAmountDetails.attributeTypeMap;
    }
}

export class Rbsv1plansPlanInformation {
    /**
    * Plan code is an optional field, If not provided system generates and assign one 
    */
    'code'?: string;
    /**
    * Plan name 
    */
    'name': string;
    /**
    * Plan description 
    */
    'description'?: string;
    /**
    * Plan Status:  - `DRAFT`  - `ACTIVE` (default) 
    */
    'status'?: string;
    'billingPeriod': GetAllPlansResponsePlanInformationBillingPeriod;
    'billingCycles'?: Rbsv1plansPlanInformationBillingCycles;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "billingPeriod",
            "baseName": "billingPeriod",
            "type": "GetAllPlansResponsePlanInformationBillingPeriod"
        },
        {
            "name": "billingCycles",
            "baseName": "billingCycles",
            "type": "Rbsv1plansPlanInformationBillingCycles"
        }    ];

    static getAttributeTypeMap() {
        return Rbsv1plansPlanInformation.attributeTypeMap;
    }
}

/**
* Number of times customer is going to be billed 
*/
export class Rbsv1plansPlanInformationBillingCycles {
    /**
    * Describe total number of billing cycles 
    */
    'total'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "total",
            "baseName": "total",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Rbsv1plansPlanInformationBillingCycles.attributeTypeMap;
    }
}

export class Rbsv1plansidPlanInformation {
    /**
    * Plan code is an optional field, If not provided system generates and assign one 
    */
    'code'?: string;
    /**
    * Plan name 
    */
    'name'?: string;
    /**
    * Plan description 
    */
    'description'?: string;
    /**
    * Updating to `DRAFT` is not allowed from `ACTIVE` and `INACTIVE` status.  Plan Status:  - `DRAFT`  - `ACTIVE`  - `INACTIVE` 
    */
    'status'?: string;
    'billingPeriod'?: GetAllPlansResponsePlanInformationBillingPeriod;
    'billingCycles'?: Rbsv1plansPlanInformationBillingCycles;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "billingPeriod",
            "baseName": "billingPeriod",
            "type": "GetAllPlansResponsePlanInformationBillingPeriod"
        },
        {
            "name": "billingCycles",
            "baseName": "billingCycles",
            "type": "Rbsv1plansPlanInformationBillingCycles"
        }    ];

    static getAttributeTypeMap() {
        return Rbsv1plansidPlanInformation.attributeTypeMap;
    }
}

export class Rbsv1plansidProcessingInformation {
    'subscriptionBillingOptions'?: Rbsv1plansidProcessingInformationSubscriptionBillingOptions;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "subscriptionBillingOptions",
            "baseName": "subscriptionBillingOptions",
            "type": "Rbsv1plansidProcessingInformationSubscriptionBillingOptions"
        }    ];

    static getAttributeTypeMap() {
        return Rbsv1plansidProcessingInformation.attributeTypeMap;
    }
}

export class Rbsv1plansidProcessingInformationSubscriptionBillingOptions {
    /**
    * Valid Values: - `ALL` - Change applied to all Subscriptions (Existing + New) - `NEW` - Change applied to New Subsciptions only 
    */
    'applyTo'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "applyTo",
            "baseName": "applyTo",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Rbsv1plansidProcessingInformationSubscriptionBillingOptions.attributeTypeMap;
    }
}

export class Rbsv1subscriptionsClientReferenceInformation {
    /**
    * > Deprecated: This field is ignored.  Merchant-generated order reference or tracking number. It is recommended that you send a unique value for each transaction so that you can perform meaningful searches for the transaction.  #### Used by **Authorization** Required field.  #### PIN Debit Requests for PIN debit reversals need to use the same merchant reference number that was used in the transaction that is being reversed.  Required field for all PIN Debit requests (purchase, credit, and reversal).  #### FDC Nashville Global Certain circumstances can cause the processor to truncate this value to 15 or 17 characters for Level II and Level III processing, which can cause a discrepancy between the value you submit and the value included in some processor reports. 
    */
    'code'?: string;
    /**
    * > Deprecated: This field is ignored.  Brief description of the order or any comment you wish to add to the order. 
    */
    'comments'?: string;
    'partner'?: Rbsv1subscriptionsClientReferenceInformationPartner;
    /**
    * > Deprecated: This field is ignored.  The name of the Connection Method client (such as Virtual Terminal or SOAP Toolkit API) that the merchant uses to send a transaction request to CyberSource. 
    */
    'applicationName'?: string;
    /**
    * > Deprecated: This field is ignored.  Version of the CyberSource application or integration used for a transaction. 
    */
    'applicationVersion'?: string;
    /**
    * > Deprecated: This field is ignored.  The entity that is responsible for running the transaction and submitting the processing request to CyberSource. This could be a person, a system, or a connection method. 
    */
    'applicationUser'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        },
        {
            "name": "comments",
            "baseName": "comments",
            "type": "string"
        },
        {
            "name": "partner",
            "baseName": "partner",
            "type": "Rbsv1subscriptionsClientReferenceInformationPartner"
        },
        {
            "name": "applicationName",
            "baseName": "applicationName",
            "type": "string"
        },
        {
            "name": "applicationVersion",
            "baseName": "applicationVersion",
            "type": "string"
        },
        {
            "name": "applicationUser",
            "baseName": "applicationUser",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Rbsv1subscriptionsClientReferenceInformation.attributeTypeMap;
    }
}

export class Rbsv1subscriptionsClientReferenceInformationPartner {
    /**
    * > This field is ignored when you provide the `subscriptionInformation.originalTransactionId` or update the subscription.  Identifier for the developer that helped integrate a partner solution to CyberSource.  Send this value in all requests that are sent through the partner solutions built by that developer. CyberSource assigns the ID to the developer.  **Note** When you see a developer ID of 999 in reports, the developer ID that was submitted is incorrect. 
    */
    'developerId'?: string;
    /**
    * > This field is ignored when you provide the `subscriptionInformation.originalTransactionId` or update the subscription.  Identifier for the partner that is integrated to CyberSource.  Send this value in all requests that are sent through the partner solution. CyberSource assigns the ID to the partner.  **Note** When you see a solutionId of 999 in reports, the solutionId that was submitted is incorrect. 
    */
    'solutionId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "developerId",
            "baseName": "developerId",
            "type": "string"
        },
        {
            "name": "solutionId",
            "baseName": "solutionId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Rbsv1subscriptionsClientReferenceInformationPartner.attributeTypeMap;
    }
}

export class Rbsv1subscriptionsPaymentInformation {
    'customer'?: Rbsv1subscriptionsPaymentInformationCustomer;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "customer",
            "baseName": "customer",
            "type": "Rbsv1subscriptionsPaymentInformationCustomer"
        }    ];

    static getAttributeTypeMap() {
        return Rbsv1subscriptionsPaymentInformation.attributeTypeMap;
    }
}

export class Rbsv1subscriptionsPaymentInformationCustomer {
    /**
    * Unique identifier for the Customer token used in the transaction. When you include this value in your request, many of the fields that are normally required for an authorization or credit become optional. 
    */
    'id': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Rbsv1subscriptionsPaymentInformationCustomer.attributeTypeMap;
    }
}

export class Rbsv1subscriptionsPlanInformation {
    'billingPeriod'?: GetAllPlansResponsePlanInformationBillingPeriod;
    'billingCycles'?: Rbsv1plansPlanInformationBillingCycles;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "billingPeriod",
            "baseName": "billingPeriod",
            "type": "GetAllPlansResponsePlanInformationBillingPeriod"
        },
        {
            "name": "billingCycles",
            "baseName": "billingCycles",
            "type": "Rbsv1plansPlanInformationBillingCycles"
        }    ];

    static getAttributeTypeMap() {
        return Rbsv1subscriptionsPlanInformation.attributeTypeMap;
    }
}

export class Rbsv1subscriptionsProcessingInformation {
    /**
    * > This field is ignored when you provide the `subscriptionInformation.originalTransactionId` or update the subscription.  Commerce Indicator is a way to identify the type of transaction. Some payment card companies use this information when determining discount rates.  Valid values: - `MOTO` - `RECURRING` - `INTERNET`  Please add the ecommerce indicator based on the rules defined by your gateway/processor. Some gateways may not accept the Commerce Indicator `RECURRING` with a Zero Dollar Authorization, that is done for subscriptions starting at a future date. 
    */
    'commerceIndicator'?: string;
    'authorizationOptions'?: Rbsv1subscriptionsProcessingInformationAuthorizationOptions;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "commerceIndicator",
            "baseName": "commerceIndicator",
            "type": "string"
        },
        {
            "name": "authorizationOptions",
            "baseName": "authorizationOptions",
            "type": "Rbsv1subscriptionsProcessingInformationAuthorizationOptions"
        }    ];

    static getAttributeTypeMap() {
        return Rbsv1subscriptionsProcessingInformation.attributeTypeMap;
    }
}

export class Rbsv1subscriptionsProcessingInformationAuthorizationOptions {
    'initiator'?: Rbsv1subscriptionsProcessingInformationAuthorizationOptionsInitiator;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "initiator",
            "baseName": "initiator",
            "type": "Rbsv1subscriptionsProcessingInformationAuthorizationOptionsInitiator"
        }    ];

    static getAttributeTypeMap() {
        return Rbsv1subscriptionsProcessingInformationAuthorizationOptions.attributeTypeMap;
    }
}

export class Rbsv1subscriptionsProcessingInformationAuthorizationOptionsInitiator {
    /**
    * > This field is ignored when you provide the `subscriptionInformation.originalTransactionId` or update the subscription.  This field indicates whether the transaction is a merchant-initiated transaction or customer-initiated transaction.  Valid values: - **customer** - **merchant** 
    */
    'type'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Rbsv1subscriptionsProcessingInformationAuthorizationOptionsInitiator.attributeTypeMap;
    }
}

export class Rbsv1subscriptionsSubscriptionInformation {
    /**
    * Subscription code is an optional field, If not provided system generates and assign one 
    */
    'code'?: string;
    /**
    * Plan Id. Use Plan Id from Create Plan Service. 
    */
    'planId'?: string;
    /**
    * Subscription Name 
    */
    'name': string;
    /**
    * Start date of the Subscription  Start date must be in UTC. Format: YYYY-MM-DDThh:mm:ssZ The T separates the date and the time. The Z indicates UTC.  Note: Subscription starts on the day provided in UTC.  **Example** 2022-08-11T22:47:57Z equals August 11, 2022, at 22:47:57 (10:47:57 p.m.). Subscription will start on August 11,2022. 
    */
    'startDate': string;
    /**
    * Network transaction identifier that was returned in the payment response field _processorInformation.transactionId_ in the reply message for the original subscription-initializing payment. 
    */
    'originalTransactionId'?: string;
    /**
    * Amount of the original subscription-initializing payment.  *Required when using a Diners or Discover card*. 
    */
    'originalTransactionAuthorizedAmount'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        },
        {
            "name": "planId",
            "baseName": "planId",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "startDate",
            "baseName": "startDate",
            "type": "string"
        },
        {
            "name": "originalTransactionId",
            "baseName": "originalTransactionId",
            "type": "string"
        },
        {
            "name": "originalTransactionAuthorizedAmount",
            "baseName": "originalTransactionAuthorizedAmount",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Rbsv1subscriptionsSubscriptionInformation.attributeTypeMap;
    }
}

export class Rbsv1subscriptionsidOrderInformation {
    'amountDetails'?: Rbsv1subscriptionsidOrderInformationAmountDetails;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "amountDetails",
            "baseName": "amountDetails",
            "type": "Rbsv1subscriptionsidOrderInformationAmountDetails"
        }    ];

    static getAttributeTypeMap() {
        return Rbsv1subscriptionsidOrderInformation.attributeTypeMap;
    }
}

export class Rbsv1subscriptionsidOrderInformationAmountDetails {
    /**
    * Billing amount for the billing period. 
    */
    'billingAmount'?: string;
    /**
    * Subscription setup fee 
    */
    'setupFee'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "billingAmount",
            "baseName": "billingAmount",
            "type": "string"
        },
        {
            "name": "setupFee",
            "baseName": "setupFee",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Rbsv1subscriptionsidOrderInformationAmountDetails.attributeTypeMap;
    }
}

export class Rbsv1subscriptionsidPlanInformation {
    'billingCycles'?: Rbsv1plansPlanInformationBillingCycles;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "billingCycles",
            "baseName": "billingCycles",
            "type": "Rbsv1plansPlanInformationBillingCycles"
        }    ];

    static getAttributeTypeMap() {
        return Rbsv1subscriptionsidPlanInformation.attributeTypeMap;
    }
}

export class Rbsv1subscriptionsidSubscriptionInformation {
    /**
    * Subscription code is an optional field, If not provided system generates and assign one 
    */
    'code'?: string;
    /**
    * Plan Id. Use Plan Id from Create Plan Service. 
    */
    'planId'?: string;
    /**
    * Subscription Name 
    */
    'name'?: string;
    /**
    * Start date of the Subscription  Start date must be in UTC. Format: YYYY-MM-DDThh:mm:ssZ The T separates the date and the time. The Z indicates UTC.  Note: Subscription starts on the day provided in UTC.  **Example** 2022-08-11T22:47:57Z equals August 11, 2022, at 22:47:57 (10:47:57 p.m.). Subscription will start on August 11,2022. 
    */
    'startDate'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        },
        {
            "name": "planId",
            "baseName": "planId",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "startDate",
            "baseName": "startDate",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Rbsv1subscriptionsidSubscriptionInformation.attributeTypeMap;
    }
}

export class RefreshPaymentStatusRequest {
    'paymentInformation'?: Ptsv2refreshpaymentstatusidPaymentInformation;
    'clientReferenceInformation'?: Ptsv2refreshpaymentstatusidClientReferenceInformation;
    'agreementInformation'?: Ptsv2refreshpaymentstatusidAgreementInformation;
    'processingInformation'?: Ptsv2refreshpaymentstatusidProcessingInformation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "paymentInformation",
            "baseName": "paymentInformation",
            "type": "Ptsv2refreshpaymentstatusidPaymentInformation"
        },
        {
            "name": "clientReferenceInformation",
            "baseName": "clientReferenceInformation",
            "type": "Ptsv2refreshpaymentstatusidClientReferenceInformation"
        },
        {
            "name": "agreementInformation",
            "baseName": "agreementInformation",
            "type": "Ptsv2refreshpaymentstatusidAgreementInformation"
        },
        {
            "name": "processingInformation",
            "baseName": "processingInformation",
            "type": "Ptsv2refreshpaymentstatusidProcessingInformation"
        }    ];

    static getAttributeTypeMap() {
        return RefreshPaymentStatusRequest.attributeTypeMap;
    }
}

export class RefundCaptureRequest {
    'clientReferenceInformation'?: Ptsv2paymentsidrefundsClientReferenceInformation;
    'processingInformation'?: Ptsv2paymentsidrefundsProcessingInformation;
    'paymentInformation'?: Ptsv2paymentsidrefundsPaymentInformation;
    'orderInformation'?: Ptsv2paymentsidrefundsOrderInformation;
    'buyerInformation'?: Ptsv2paymentsidcapturesBuyerInformation;
    'deviceInformation'?: Ptsv2paymentsidcapturesDeviceInformation;
    'merchantInformation'?: Ptsv2paymentsidrefundsMerchantInformation;
    'aggregatorInformation'?: Ptsv2paymentsidcapturesAggregatorInformation;
    'pointOfSaleInformation'?: Ptsv2paymentsidrefundsPointOfSaleInformation;
    /**
    * The object containing the custom data that the merchant defines. 
    */
    'merchantDefinedInformation'?: Array<Ptsv2paymentsMerchantDefinedInformation>;
    'travelInformation'?: Ptsv2paymentsTravelInformation;
    'promotionInformation'?: Ptsv2paymentsPromotionInformation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "clientReferenceInformation",
            "baseName": "clientReferenceInformation",
            "type": "Ptsv2paymentsidrefundsClientReferenceInformation"
        },
        {
            "name": "processingInformation",
            "baseName": "processingInformation",
            "type": "Ptsv2paymentsidrefundsProcessingInformation"
        },
        {
            "name": "paymentInformation",
            "baseName": "paymentInformation",
            "type": "Ptsv2paymentsidrefundsPaymentInformation"
        },
        {
            "name": "orderInformation",
            "baseName": "orderInformation",
            "type": "Ptsv2paymentsidrefundsOrderInformation"
        },
        {
            "name": "buyerInformation",
            "baseName": "buyerInformation",
            "type": "Ptsv2paymentsidcapturesBuyerInformation"
        },
        {
            "name": "deviceInformation",
            "baseName": "deviceInformation",
            "type": "Ptsv2paymentsidcapturesDeviceInformation"
        },
        {
            "name": "merchantInformation",
            "baseName": "merchantInformation",
            "type": "Ptsv2paymentsidrefundsMerchantInformation"
        },
        {
            "name": "aggregatorInformation",
            "baseName": "aggregatorInformation",
            "type": "Ptsv2paymentsidcapturesAggregatorInformation"
        },
        {
            "name": "pointOfSaleInformation",
            "baseName": "pointOfSaleInformation",
            "type": "Ptsv2paymentsidrefundsPointOfSaleInformation"
        },
        {
            "name": "merchantDefinedInformation",
            "baseName": "merchantDefinedInformation",
            "type": "Array<Ptsv2paymentsMerchantDefinedInformation>"
        },
        {
            "name": "travelInformation",
            "baseName": "travelInformation",
            "type": "Ptsv2paymentsTravelInformation"
        },
        {
            "name": "promotionInformation",
            "baseName": "promotionInformation",
            "type": "Ptsv2paymentsPromotionInformation"
        }    ];

    static getAttributeTypeMap() {
        return RefundCaptureRequest.attributeTypeMap;
    }
}

export class RefundPaymentRequest {
    'clientReferenceInformation'?: Ptsv2paymentsidrefundsClientReferenceInformation;
    'processingInformation'?: Ptsv2paymentsidrefundsProcessingInformation;
    'paymentInformation'?: Ptsv2paymentsidrefundsPaymentInformation;
    'orderInformation'?: Ptsv2paymentsidrefundsOrderInformation;
    'buyerInformation'?: Ptsv2paymentsidcapturesBuyerInformation;
    'deviceInformation'?: Ptsv2paymentsidcapturesDeviceInformation;
    'merchantInformation'?: Ptsv2paymentsidrefundsMerchantInformation;
    'aggregatorInformation'?: Ptsv2paymentsidcapturesAggregatorInformation;
    'pointOfSaleInformation'?: Ptsv2paymentsidrefundsPointOfSaleInformation;
    /**
    * The object containing the custom data that the merchant defines. 
    */
    'merchantDefinedInformation'?: Array<Ptsv2paymentsMerchantDefinedInformation>;
    'travelInformation'?: Ptsv2paymentsTravelInformation;
    'promotionInformation'?: Ptsv2paymentsPromotionInformation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "clientReferenceInformation",
            "baseName": "clientReferenceInformation",
            "type": "Ptsv2paymentsidrefundsClientReferenceInformation"
        },
        {
            "name": "processingInformation",
            "baseName": "processingInformation",
            "type": "Ptsv2paymentsidrefundsProcessingInformation"
        },
        {
            "name": "paymentInformation",
            "baseName": "paymentInformation",
            "type": "Ptsv2paymentsidrefundsPaymentInformation"
        },
        {
            "name": "orderInformation",
            "baseName": "orderInformation",
            "type": "Ptsv2paymentsidrefundsOrderInformation"
        },
        {
            "name": "buyerInformation",
            "baseName": "buyerInformation",
            "type": "Ptsv2paymentsidcapturesBuyerInformation"
        },
        {
            "name": "deviceInformation",
            "baseName": "deviceInformation",
            "type": "Ptsv2paymentsidcapturesDeviceInformation"
        },
        {
            "name": "merchantInformation",
            "baseName": "merchantInformation",
            "type": "Ptsv2paymentsidrefundsMerchantInformation"
        },
        {
            "name": "aggregatorInformation",
            "baseName": "aggregatorInformation",
            "type": "Ptsv2paymentsidcapturesAggregatorInformation"
        },
        {
            "name": "pointOfSaleInformation",
            "baseName": "pointOfSaleInformation",
            "type": "Ptsv2paymentsidrefundsPointOfSaleInformation"
        },
        {
            "name": "merchantDefinedInformation",
            "baseName": "merchantDefinedInformation",
            "type": "Array<Ptsv2paymentsMerchantDefinedInformation>"
        },
        {
            "name": "travelInformation",
            "baseName": "travelInformation",
            "type": "Ptsv2paymentsTravelInformation"
        },
        {
            "name": "promotionInformation",
            "baseName": "promotionInformation",
            "type": "Ptsv2paymentsPromotionInformation"
        }    ];

    static getAttributeTypeMap() {
        return RefundPaymentRequest.attributeTypeMap;
    }
}

export class ReportingV3ChargebackDetailsGet200Response {
    /**
    * Organization Id
    */
    'organizationId'?: string;
    /**
    * Report Start Date (ISO 8601 Extended)
    */
    'startTime'?: Date;
    /**
    * Report Start Date (ISO 8601 Extended)
    */
    'endTime'?: Date;
    /**
    * List of Chargeback Details list.
    */
    'chargebackDetails'?: Array<ReportingV3ChargebackDetailsGet200ResponseChargebackDetails>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "organizationId",
            "baseName": "organizationId",
            "type": "string"
        },
        {
            "name": "startTime",
            "baseName": "startTime",
            "type": "Date"
        },
        {
            "name": "endTime",
            "baseName": "endTime",
            "type": "Date"
        },
        {
            "name": "chargebackDetails",
            "baseName": "chargebackDetails",
            "type": "Array<ReportingV3ChargebackDetailsGet200ResponseChargebackDetails>"
        }    ];

    static getAttributeTypeMap() {
        return ReportingV3ChargebackDetailsGet200Response.attributeTypeMap;
    }
}

export class ReportingV3ChargebackDetailsGet200ResponseChargebackDetails {
    /**
    * Processor Merchant Id
    */
    'processorMerchantId'?: string;
    /**
    * Merchant Name
    */
    'merchantName'?: string;
    /**
    * Transaction Reference Number
    */
    'transactionReferenceNumber'?: string;
    /**
    * Merchant Reference Number
    */
    'merchantReferenceNumber'?: string;
    /**
    * Nature of Dispute
    */
    'natureOfDispute'?: string;
    /**
    * Chargeback Alert Type
    */
    'alertType'?: string;
    /**
    * Chargeback Amount
    */
    'amount'?: string;
    /**
    * Chargeback Sign
    */
    'sign'?: string;
    /**
    * Chargeback Action
    */
    'action'?: string;
    /**
    * Card Type
    */
    'cardType'?: string;
    /**
    * Original Settlement Date
    */
    'originalSettlementTime'?: Date;
    /**
    * Tracking Number
    */
    'trackingNumber'?: string;
    /**
    * Valid ISO 4217 ALPHA-3 currency code
    */
    'currencyCode'?: string;
    /**
    * Request Id
    */
    'requestId'?: string;
    /**
    * Response Due Date
    */
    'responseDueTime'?: Date;
    /**
    * Chargeback Date
    */
    'time'?: Date;
    /**
    * Chargeback Action Description
    */
    'actionDescription'?: string;
    /**
    * Customer Id
    */
    'customerId'?: string;
    /**
    * Chargeback Reason Code
    */
    'reasonCode'?: string;
    /**
    * Representment CP Date
    */
    'representmentCPTime'?: Date;
    /**
    * ICS Request Applications
    */
    'applications'?: string;
    /**
    * Event Request Date
    */
    'eventRequestedTime'?: Date;
    /**
    * Pre Dispute Flag
    */
    'preDisputeFlag'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "processorMerchantId",
            "baseName": "processorMerchantId",
            "type": "string"
        },
        {
            "name": "merchantName",
            "baseName": "merchantName",
            "type": "string"
        },
        {
            "name": "transactionReferenceNumber",
            "baseName": "transactionReferenceNumber",
            "type": "string"
        },
        {
            "name": "merchantReferenceNumber",
            "baseName": "merchantReferenceNumber",
            "type": "string"
        },
        {
            "name": "natureOfDispute",
            "baseName": "natureOfDispute",
            "type": "string"
        },
        {
            "name": "alertType",
            "baseName": "alertType",
            "type": "string"
        },
        {
            "name": "amount",
            "baseName": "amount",
            "type": "string"
        },
        {
            "name": "sign",
            "baseName": "sign",
            "type": "string"
        },
        {
            "name": "action",
            "baseName": "action",
            "type": "string"
        },
        {
            "name": "cardType",
            "baseName": "cardType",
            "type": "string"
        },
        {
            "name": "originalSettlementTime",
            "baseName": "originalSettlementTime",
            "type": "Date"
        },
        {
            "name": "trackingNumber",
            "baseName": "trackingNumber",
            "type": "string"
        },
        {
            "name": "currencyCode",
            "baseName": "currencyCode",
            "type": "string"
        },
        {
            "name": "requestId",
            "baseName": "requestId",
            "type": "string"
        },
        {
            "name": "responseDueTime",
            "baseName": "responseDueTime",
            "type": "Date"
        },
        {
            "name": "time",
            "baseName": "time",
            "type": "Date"
        },
        {
            "name": "actionDescription",
            "baseName": "actionDescription",
            "type": "string"
        },
        {
            "name": "customerId",
            "baseName": "customerId",
            "type": "string"
        },
        {
            "name": "reasonCode",
            "baseName": "reasonCode",
            "type": "string"
        },
        {
            "name": "representmentCPTime",
            "baseName": "representmentCPTime",
            "type": "Date"
        },
        {
            "name": "applications",
            "baseName": "applications",
            "type": "string"
        },
        {
            "name": "eventRequestedTime",
            "baseName": "eventRequestedTime",
            "type": "Date"
        },
        {
            "name": "preDisputeFlag",
            "baseName": "preDisputeFlag",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ReportingV3ChargebackDetailsGet200ResponseChargebackDetails.attributeTypeMap;
    }
}

export class ReportingV3ChargebackSummariesGet200Response {
    /**
    * Organization Id
    */
    'organizationId'?: string;
    /**
    * Report Start Date
    */
    'startTime'?: Date;
    /**
    * Report Start Date
    */
    'endTime'?: string;
    /**
    * List of Summary values
    */
    'chargebackSummaries'?: Array<ReportingV3ChargebackSummariesGet200ResponseChargebackSummaries>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "organizationId",
            "baseName": "organizationId",
            "type": "string"
        },
        {
            "name": "startTime",
            "baseName": "startTime",
            "type": "Date"
        },
        {
            "name": "endTime",
            "baseName": "endTime",
            "type": "string"
        },
        {
            "name": "chargebackSummaries",
            "baseName": "chargebackSummaries",
            "type": "Array<ReportingV3ChargebackSummariesGet200ResponseChargebackSummaries>"
        }    ];

    static getAttributeTypeMap() {
        return ReportingV3ChargebackSummariesGet200Response.attributeTypeMap;
    }
}

export class ReportingV3ChargebackSummariesGet200ResponseChargebackSummaries {
    /**
    * Chargeback summary list count
    */
    'count'?: number;
    /**
    * Summary Date
    */
    'time'?: Date;
    /**
    * Account Id
    */
    'accountId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "count",
            "baseName": "count",
            "type": "number"
        },
        {
            "name": "time",
            "baseName": "time",
            "type": "Date"
        },
        {
            "name": "accountId",
            "baseName": "accountId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ReportingV3ChargebackSummariesGet200ResponseChargebackSummaries.attributeTypeMap;
    }
}

export class ReportingV3ConversionDetailsGet200Response {
    /**
    * Merchant Id
    */
    'organizationId'?: string;
    'startTime'?: Date;
    'endTime'?: Date;
    'conversionDetails'?: Array<ReportingV3ConversionDetailsGet200ResponseConversionDetails>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "organizationId",
            "baseName": "organizationId",
            "type": "string"
        },
        {
            "name": "startTime",
            "baseName": "startTime",
            "type": "Date"
        },
        {
            "name": "endTime",
            "baseName": "endTime",
            "type": "Date"
        },
        {
            "name": "conversionDetails",
            "baseName": "conversionDetails",
            "type": "Array<ReportingV3ConversionDetailsGet200ResponseConversionDetails>"
        }    ];

    static getAttributeTypeMap() {
        return ReportingV3ConversionDetailsGet200Response.attributeTypeMap;
    }
}

export class ReportingV3ConversionDetailsGet200ResponseConversionDetails {
    /**
    * Merchant reference number of a merchant
    */
    'merchantReferenceNumber'?: string;
    /**
    * Date of conversion
    */
    'conversionTime'?: Date;
    /**
    * Cybersource Transation request id
    */
    'requestId'?: string;
    /**
    * Original decision
    */
    'originalDecision'?: string;
    /**
    * New decision
    */
    'newDecision'?: string;
    /**
    * User name of the reviewer
    */
    'reviewer'?: string;
    /**
    * Comments of the reviewer
    */
    'reviewerComments'?: string;
    /**
    * Name of the queue
    */
    'queue'?: string;
    /**
    * Name of the profile
    */
    'profile'?: string;
    'notes'?: Array<ReportingV3ConversionDetailsGet200ResponseNotes>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "merchantReferenceNumber",
            "baseName": "merchantReferenceNumber",
            "type": "string"
        },
        {
            "name": "conversionTime",
            "baseName": "conversionTime",
            "type": "Date"
        },
        {
            "name": "requestId",
            "baseName": "requestId",
            "type": "string"
        },
        {
            "name": "originalDecision",
            "baseName": "originalDecision",
            "type": "string"
        },
        {
            "name": "newDecision",
            "baseName": "newDecision",
            "type": "string"
        },
        {
            "name": "reviewer",
            "baseName": "reviewer",
            "type": "string"
        },
        {
            "name": "reviewerComments",
            "baseName": "reviewerComments",
            "type": "string"
        },
        {
            "name": "queue",
            "baseName": "queue",
            "type": "string"
        },
        {
            "name": "profile",
            "baseName": "profile",
            "type": "string"
        },
        {
            "name": "notes",
            "baseName": "notes",
            "type": "Array<ReportingV3ConversionDetailsGet200ResponseNotes>"
        }    ];

    static getAttributeTypeMap() {
        return ReportingV3ConversionDetailsGet200ResponseConversionDetails.attributeTypeMap;
    }
}

export class ReportingV3ConversionDetailsGet200ResponseNotes {
    /**
    * Time of the note added by reviewer
    */
    'time'?: Date;
    /**
    * Note added by reviewer
    */
    'addedBy'?: string;
    /**
    * Comments given by the reviewer
    */
    'comments'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "time",
            "baseName": "time",
            "type": "Date"
        },
        {
            "name": "addedBy",
            "baseName": "addedBy",
            "type": "string"
        },
        {
            "name": "comments",
            "baseName": "comments",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ReportingV3ConversionDetailsGet200ResponseNotes.attributeTypeMap;
    }
}

export class ReportingV3InterchangeClearingLevelDetailsGet200Response {
    /**
    * Valid report Start Date in **ISO 8601 format**. Please refer the following link to know more about ISO 8601 format. - https://xml2rfc.tools.ietf.org/public/rfc/html/rfc3339.html#anchor14  **Example:** - yyyy-MM-dd'T'HH:mm:ss.SSSZZ 
    */
    'startDate'?: Date;
    /**
    * Valid report Start Date in **ISO 8601 format**. 
    */
    'endDate'?: Date;
    /**
    * List of InterchangeClearingLevelDetail
    */
    'interchangeClearingLevelDetails'?: Array<ReportingV3InterchangeClearingLevelDetailsGet200ResponseInterchangeClearingLevelDetails>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "startDate",
            "baseName": "startDate",
            "type": "Date"
        },
        {
            "name": "endDate",
            "baseName": "endDate",
            "type": "Date"
        },
        {
            "name": "interchangeClearingLevelDetails",
            "baseName": "interchangeClearingLevelDetails",
            "type": "Array<ReportingV3InterchangeClearingLevelDetailsGet200ResponseInterchangeClearingLevelDetails>"
        }    ];

    static getAttributeTypeMap() {
        return ReportingV3InterchangeClearingLevelDetailsGet200Response.attributeTypeMap;
    }
}

export class ReportingV3InterchangeClearingLevelDetailsGet200ResponseInterchangeClearingLevelDetails {
    'requestId'?: string;
    'organizationId'?: string;
    'accountId'?: string;
    'processorMerchantId'?: string;
    'transactionReferenceNumber'?: string;
    'merchantReferenceNumber'?: string;
    'accountSuffix'?: string;
    'paymentSubType'?: string;
    'paymentSubTypeDescription'?: string;
    'transactionTime'?: Date;
    'processedTime'?: Date;
    'transactionType'?: string;
    'amount'?: string;
    /**
    * Valid ISO 4217 ALPHA-3 currency code
    */
    'currencyCode'?: string;
    'priceType'?: string;
    'priceAmountOne'?: string;
    'priceAmountTwo'?: string;
    'reClass'?: string;
    'settlementTime'?: Date;
    'settlementProcessor'?: string;
    'merchantBatchNumber'?: string;
    'clearedLevel'?: string;
    'billbackReasonCode'?: string;
    'billbackReasonDescription'?: string;
    'merchantPricedLevel'?: string;
    'discountRate'?: string;
    'discountAmount'?: string;
    'clearingRateAmountOne'?: string;
    'clearingRateAmountTwo'?: string;
    'clearingRateAmountThree'?: string;
    /**
    * Valid ISO 4217 ALPHA-3 currency code
    */
    'clearingRateCurrencyCode'?: string;
    'interchangeAmount'?: string;
    'billbackAmount'?: string;
    'settlementAmount'?: string;
    /**
    * Valid ISO 4217 ALPHA-3 currency code
    */
    'settlementCurrencyCode'?: string;
    'conversionRate'?: string;
    'deltaCost'?: string;
    'surchargeAmount'?: string;
    'percentRateCharged'?: string;
    'perTransactionCharged'?: string;
    'downgradeReasonCode'?: string;
    'processTime'?: Date;
    'authCode'?: string;
    'batchTime'?: Date;
    'processorBatchNumber'?: string;
    'cardIndicator'?: string;
    'minimumUnit'?: number;
    /**
    * Valid ISO 4217 ALPHA-3 currency code
    */
    'minimumUnitCurrencyCode'?: string;
    'creditDeltaIndicator'?: string;
    'feeCategory'?: string;
    'applicationName'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "requestId",
            "baseName": "requestId",
            "type": "string"
        },
        {
            "name": "organizationId",
            "baseName": "organizationId",
            "type": "string"
        },
        {
            "name": "accountId",
            "baseName": "accountId",
            "type": "string"
        },
        {
            "name": "processorMerchantId",
            "baseName": "processorMerchantId",
            "type": "string"
        },
        {
            "name": "transactionReferenceNumber",
            "baseName": "transactionReferenceNumber",
            "type": "string"
        },
        {
            "name": "merchantReferenceNumber",
            "baseName": "merchantReferenceNumber",
            "type": "string"
        },
        {
            "name": "accountSuffix",
            "baseName": "accountSuffix",
            "type": "string"
        },
        {
            "name": "paymentSubType",
            "baseName": "paymentSubType",
            "type": "string"
        },
        {
            "name": "paymentSubTypeDescription",
            "baseName": "paymentSubTypeDescription",
            "type": "string"
        },
        {
            "name": "transactionTime",
            "baseName": "transactionTime",
            "type": "Date"
        },
        {
            "name": "processedTime",
            "baseName": "processedTime",
            "type": "Date"
        },
        {
            "name": "transactionType",
            "baseName": "transactionType",
            "type": "string"
        },
        {
            "name": "amount",
            "baseName": "amount",
            "type": "string"
        },
        {
            "name": "currencyCode",
            "baseName": "currencyCode",
            "type": "string"
        },
        {
            "name": "priceType",
            "baseName": "priceType",
            "type": "string"
        },
        {
            "name": "priceAmountOne",
            "baseName": "priceAmountOne",
            "type": "string"
        },
        {
            "name": "priceAmountTwo",
            "baseName": "priceAmountTwo",
            "type": "string"
        },
        {
            "name": "reClass",
            "baseName": "reClass",
            "type": "string"
        },
        {
            "name": "settlementTime",
            "baseName": "settlementTime",
            "type": "Date"
        },
        {
            "name": "settlementProcessor",
            "baseName": "settlementProcessor",
            "type": "string"
        },
        {
            "name": "merchantBatchNumber",
            "baseName": "merchantBatchNumber",
            "type": "string"
        },
        {
            "name": "clearedLevel",
            "baseName": "clearedLevel",
            "type": "string"
        },
        {
            "name": "billbackReasonCode",
            "baseName": "billbackReasonCode",
            "type": "string"
        },
        {
            "name": "billbackReasonDescription",
            "baseName": "billbackReasonDescription",
            "type": "string"
        },
        {
            "name": "merchantPricedLevel",
            "baseName": "merchantPricedLevel",
            "type": "string"
        },
        {
            "name": "discountRate",
            "baseName": "discountRate",
            "type": "string"
        },
        {
            "name": "discountAmount",
            "baseName": "discountAmount",
            "type": "string"
        },
        {
            "name": "clearingRateAmountOne",
            "baseName": "clearingRateAmountOne",
            "type": "string"
        },
        {
            "name": "clearingRateAmountTwo",
            "baseName": "clearingRateAmountTwo",
            "type": "string"
        },
        {
            "name": "clearingRateAmountThree",
            "baseName": "clearingRateAmountThree",
            "type": "string"
        },
        {
            "name": "clearingRateCurrencyCode",
            "baseName": "clearingRateCurrencyCode",
            "type": "string"
        },
        {
            "name": "interchangeAmount",
            "baseName": "interchangeAmount",
            "type": "string"
        },
        {
            "name": "billbackAmount",
            "baseName": "billbackAmount",
            "type": "string"
        },
        {
            "name": "settlementAmount",
            "baseName": "settlementAmount",
            "type": "string"
        },
        {
            "name": "settlementCurrencyCode",
            "baseName": "settlementCurrencyCode",
            "type": "string"
        },
        {
            "name": "conversionRate",
            "baseName": "conversionRate",
            "type": "string"
        },
        {
            "name": "deltaCost",
            "baseName": "deltaCost",
            "type": "string"
        },
        {
            "name": "surchargeAmount",
            "baseName": "surchargeAmount",
            "type": "string"
        },
        {
            "name": "percentRateCharged",
            "baseName": "percentRateCharged",
            "type": "string"
        },
        {
            "name": "perTransactionCharged",
            "baseName": "perTransactionCharged",
            "type": "string"
        },
        {
            "name": "downgradeReasonCode",
            "baseName": "downgradeReasonCode",
            "type": "string"
        },
        {
            "name": "processTime",
            "baseName": "processTime",
            "type": "Date"
        },
        {
            "name": "authCode",
            "baseName": "authCode",
            "type": "string"
        },
        {
            "name": "batchTime",
            "baseName": "batchTime",
            "type": "Date"
        },
        {
            "name": "processorBatchNumber",
            "baseName": "processorBatchNumber",
            "type": "string"
        },
        {
            "name": "cardIndicator",
            "baseName": "cardIndicator",
            "type": "string"
        },
        {
            "name": "minimumUnit",
            "baseName": "minimumUnit",
            "type": "number"
        },
        {
            "name": "minimumUnitCurrencyCode",
            "baseName": "minimumUnitCurrencyCode",
            "type": "string"
        },
        {
            "name": "creditDeltaIndicator",
            "baseName": "creditDeltaIndicator",
            "type": "string"
        },
        {
            "name": "feeCategory",
            "baseName": "feeCategory",
            "type": "string"
        },
        {
            "name": "applicationName",
            "baseName": "applicationName",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ReportingV3InterchangeClearingLevelDetailsGet200ResponseInterchangeClearingLevelDetails.attributeTypeMap;
    }
}

export class ReportingV3NetFundingsGet200Response {
    /**
    * Valid report Start Date in **ISO 8601 format**. Please refer the following link to know more about ISO 8601 format.[Rfc Date Format](https://xml2rfc.tools.ietf.org/public/rfc/html/rfc3339.html#anchor14)  **Example:** - yyyy-MM-dd'T'HH:mm:ss.SSSZZ 
    */
    'startTime'?: Date;
    /**
    * Valid report End Date in **ISO 8601 format** **Example date format:** - yyyy-MM-dd'T'HH:mm:ss.SSSZZ 
    */
    'endTime'?: Date;
    /**
    * List of Netfunding summary objects
    */
    'netFundingSummaries'?: Array<ReportingV3NetFundingsGet200ResponseNetFundingSummaries>;
    /**
    * List of total purchases currency wise
    */
    'totalPurchases'?: Array<ReportingV3NetFundingsGet200ResponseTotalPurchases>;
    /**
    * List of total refunds currency wise
    */
    'totalRefunds'?: Array<ReportingV3NetFundingsGet200ResponseTotalPurchases>;
    /**
    * List of total fees currency wise
    */
    'totalFees'?: Array<ReportingV3NetFundingsGet200ResponseTotalPurchases>;
    /**
    * List of total chargebacks currency wise
    */
    'totalChargebacks'?: Array<ReportingV3NetFundingsGet200ResponseTotalPurchases>;
    /**
    * List of new total currency wise
    */
    'netTotal'?: Array<ReportingV3NetFundingsGet200ResponseTotalPurchases>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "startTime",
            "baseName": "startTime",
            "type": "Date"
        },
        {
            "name": "endTime",
            "baseName": "endTime",
            "type": "Date"
        },
        {
            "name": "netFundingSummaries",
            "baseName": "netFundingSummaries",
            "type": "Array<ReportingV3NetFundingsGet200ResponseNetFundingSummaries>"
        },
        {
            "name": "totalPurchases",
            "baseName": "totalPurchases",
            "type": "Array<ReportingV3NetFundingsGet200ResponseTotalPurchases>"
        },
        {
            "name": "totalRefunds",
            "baseName": "totalRefunds",
            "type": "Array<ReportingV3NetFundingsGet200ResponseTotalPurchases>"
        },
        {
            "name": "totalFees",
            "baseName": "totalFees",
            "type": "Array<ReportingV3NetFundingsGet200ResponseTotalPurchases>"
        },
        {
            "name": "totalChargebacks",
            "baseName": "totalChargebacks",
            "type": "Array<ReportingV3NetFundingsGet200ResponseTotalPurchases>"
        },
        {
            "name": "netTotal",
            "baseName": "netTotal",
            "type": "Array<ReportingV3NetFundingsGet200ResponseTotalPurchases>"
        }    ];

    static getAttributeTypeMap() {
        return ReportingV3NetFundingsGet200Response.attributeTypeMap;
    }
}

export class ReportingV3NetFundingsGet200ResponseNetFundingSummaries {
    /**
    * Valid values: - PURCHASES - REFUNDS - FEES - CHARGEBACKS 
    */
    'type'?: string;
    'paymentSubType'?: string;
    'conveyedCount'?: number;
    'conveyedAmount'?: string;
    'settledCount'?: number;
    'fundedCount'?: number;
    'fundedAmount'?: string;
    /**
    * Valid ISO 4217 ALPHA-3 currency code
    */
    'currencyCode'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "paymentSubType",
            "baseName": "paymentSubType",
            "type": "string"
        },
        {
            "name": "conveyedCount",
            "baseName": "conveyedCount",
            "type": "number"
        },
        {
            "name": "conveyedAmount",
            "baseName": "conveyedAmount",
            "type": "string"
        },
        {
            "name": "settledCount",
            "baseName": "settledCount",
            "type": "number"
        },
        {
            "name": "fundedCount",
            "baseName": "fundedCount",
            "type": "number"
        },
        {
            "name": "fundedAmount",
            "baseName": "fundedAmount",
            "type": "string"
        },
        {
            "name": "currencyCode",
            "baseName": "currencyCode",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ReportingV3NetFundingsGet200ResponseNetFundingSummaries.attributeTypeMap;
    }
}

export class ReportingV3NetFundingsGet200ResponseTotalPurchases {
    /**
    * Valid ISO 4217 ALPHA-3 currency code
    */
    'currency': string;
    'value': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "currency",
            "baseName": "currency",
            "type": "string"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ReportingV3NetFundingsGet200ResponseTotalPurchases.attributeTypeMap;
    }
}

export class ReportingV3NotificationofChangesGet200Response {
    /**
    * List of Notification Of Change Info values
    */
    'notificationOfChanges'?: Array<ReportingV3NotificationofChangesGet200ResponseNotificationOfChanges>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "notificationOfChanges",
            "baseName": "notificationOfChanges",
            "type": "Array<ReportingV3NotificationofChangesGet200ResponseNotificationOfChanges>"
        }    ];

    static getAttributeTypeMap() {
        return ReportingV3NotificationofChangesGet200Response.attributeTypeMap;
    }
}

/**
* Notification Of Change
*/
export class ReportingV3NotificationofChangesGet200ResponseNotificationOfChanges {
    /**
    * Merchant Reference Number
    */
    'merchantReferenceNumber'?: string;
    /**
    * Transaction Reference Number
    */
    'transactionReferenceNumber'?: string;
    /**
    * Notification Of Change Date(ISO 8601 Extended)
    */
    'time'?: Date;
    /**
    * Merchant Reference Number
    */
    'code'?: string;
    /**
    * Account Type
    */
    'accountType'?: string;
    /**
    * Routing Number
    */
    'routingNumber'?: string;
    /**
    * Account Number
    */
    'accountNumber'?: string;
    /**
    * Consumer Name
    */
    'consumerName'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "merchantReferenceNumber",
            "baseName": "merchantReferenceNumber",
            "type": "string"
        },
        {
            "name": "transactionReferenceNumber",
            "baseName": "transactionReferenceNumber",
            "type": "string"
        },
        {
            "name": "time",
            "baseName": "time",
            "type": "Date"
        },
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        },
        {
            "name": "accountType",
            "baseName": "accountType",
            "type": "string"
        },
        {
            "name": "routingNumber",
            "baseName": "routingNumber",
            "type": "string"
        },
        {
            "name": "accountNumber",
            "baseName": "accountNumber",
            "type": "string"
        },
        {
            "name": "consumerName",
            "baseName": "consumerName",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ReportingV3NotificationofChangesGet200ResponseNotificationOfChanges.attributeTypeMap;
    }
}

export class ReportingV3PaymentBatchSummariesGet200Response {
    'startTime'?: Date;
    'endTime'?: Date;
    'paymentBatchSummaries'?: Array<ReportingV3PaymentBatchSummariesGet200ResponsePaymentBatchSummaries>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "startTime",
            "baseName": "startTime",
            "type": "Date"
        },
        {
            "name": "endTime",
            "baseName": "endTime",
            "type": "Date"
        },
        {
            "name": "paymentBatchSummaries",
            "baseName": "paymentBatchSummaries",
            "type": "Array<ReportingV3PaymentBatchSummariesGet200ResponsePaymentBatchSummaries>"
        }    ];

    static getAttributeTypeMap() {
        return ReportingV3PaymentBatchSummariesGet200Response.attributeTypeMap;
    }
}

export class ReportingV3PaymentBatchSummariesGet200ResponsePaymentBatchSummaries {
    'currencyCode'?: string;
    'paymentSubTypeDescription'?: string;
    'startTime'?: Date;
    'endTime'?: Date;
    'salesCount'?: number;
    'salesAmount'?: string;
    'creditCount'?: number;
    'creditAmount'?: string;
    'accountName'?: string;
    'accountId'?: string;
    'merchantId'?: string;
    'merchantName'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "currencyCode",
            "baseName": "currencyCode",
            "type": "string"
        },
        {
            "name": "paymentSubTypeDescription",
            "baseName": "paymentSubTypeDescription",
            "type": "string"
        },
        {
            "name": "startTime",
            "baseName": "startTime",
            "type": "Date"
        },
        {
            "name": "endTime",
            "baseName": "endTime",
            "type": "Date"
        },
        {
            "name": "salesCount",
            "baseName": "salesCount",
            "type": "number"
        },
        {
            "name": "salesAmount",
            "baseName": "salesAmount",
            "type": "string"
        },
        {
            "name": "creditCount",
            "baseName": "creditCount",
            "type": "number"
        },
        {
            "name": "creditAmount",
            "baseName": "creditAmount",
            "type": "string"
        },
        {
            "name": "accountName",
            "baseName": "accountName",
            "type": "string"
        },
        {
            "name": "accountId",
            "baseName": "accountId",
            "type": "string"
        },
        {
            "name": "merchantId",
            "baseName": "merchantId",
            "type": "string"
        },
        {
            "name": "merchantName",
            "baseName": "merchantName",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ReportingV3PaymentBatchSummariesGet200ResponsePaymentBatchSummaries.attributeTypeMap;
    }
}

/**
* PurchaseAndRefundDetails
*/
export class ReportingV3PurchaseRefundDetailsGet200Response {
    'offset'?: number;
    'limit'?: number;
    'pageResults'?: number;
    /**
    * List of Request Info values
    */
    'requestDetails'?: Array<ReportingV3PurchaseRefundDetailsGet200ResponseRequestDetails>;
    /**
    * List of Settlement Info values
    */
    'settlements'?: Array<ReportingV3PurchaseRefundDetailsGet200ResponseSettlements>;
    /**
    * List of Authorization Info values
    */
    'authorizations'?: Array<ReportingV3PurchaseRefundDetailsGet200ResponseAuthorizations>;
    /**
    * List of Fee Funding Info values
    */
    'feeAndFundingDetails'?: Array<ReportingV3PurchaseRefundDetailsGet200ResponseFeeAndFundingDetails>;
    /**
    * List of Other Info values
    */
    'others'?: Array<ReportingV3PurchaseRefundDetailsGet200ResponseOthers>;
    /**
    * List of Settlement Status Info values
    */
    'settlementStatuses'?: Array<ReportingV3PurchaseRefundDetailsGet200ResponseSettlementStatuses>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "offset",
            "baseName": "offset",
            "type": "number"
        },
        {
            "name": "limit",
            "baseName": "limit",
            "type": "number"
        },
        {
            "name": "pageResults",
            "baseName": "pageResults",
            "type": "number"
        },
        {
            "name": "requestDetails",
            "baseName": "requestDetails",
            "type": "Array<ReportingV3PurchaseRefundDetailsGet200ResponseRequestDetails>"
        },
        {
            "name": "settlements",
            "baseName": "settlements",
            "type": "Array<ReportingV3PurchaseRefundDetailsGet200ResponseSettlements>"
        },
        {
            "name": "authorizations",
            "baseName": "authorizations",
            "type": "Array<ReportingV3PurchaseRefundDetailsGet200ResponseAuthorizations>"
        },
        {
            "name": "feeAndFundingDetails",
            "baseName": "feeAndFundingDetails",
            "type": "Array<ReportingV3PurchaseRefundDetailsGet200ResponseFeeAndFundingDetails>"
        },
        {
            "name": "others",
            "baseName": "others",
            "type": "Array<ReportingV3PurchaseRefundDetailsGet200ResponseOthers>"
        },
        {
            "name": "settlementStatuses",
            "baseName": "settlementStatuses",
            "type": "Array<ReportingV3PurchaseRefundDetailsGet200ResponseSettlementStatuses>"
        }    ];

    static getAttributeTypeMap() {
        return ReportingV3PurchaseRefundDetailsGet200Response.attributeTypeMap;
    }
}

/**
* Authorization Info Values
*/
export class ReportingV3PurchaseRefundDetailsGet200ResponseAuthorizations {
    /**
    * An unique identification number assigned by CyberSource to identify the submitted request.
    */
    'requestId'?: string;
    /**
    * Authorization Transaction Reference Number
    */
    'transactionReferenceNumber'?: string;
    /**
    * Authorization Date
    */
    'time'?: Date;
    /**
    * Authorization Request Id
    */
    'authorizationRequestId'?: string;
    /**
    * Authorization Amount
    */
    'amount'?: string;
    /**
    * Valid ISO 4217 ALPHA-3 currency code
    */
    'currencyCode'?: string;
    /**
    * Authorization Code
    */
    'code'?: string;
    /**
    * Authorization RCode
    */
    'rcode'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "requestId",
            "baseName": "requestId",
            "type": "string"
        },
        {
            "name": "transactionReferenceNumber",
            "baseName": "transactionReferenceNumber",
            "type": "string"
        },
        {
            "name": "time",
            "baseName": "time",
            "type": "Date"
        },
        {
            "name": "authorizationRequestId",
            "baseName": "authorizationRequestId",
            "type": "string"
        },
        {
            "name": "amount",
            "baseName": "amount",
            "type": "string"
        },
        {
            "name": "currencyCode",
            "baseName": "currencyCode",
            "type": "string"
        },
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        },
        {
            "name": "rcode",
            "baseName": "rcode",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ReportingV3PurchaseRefundDetailsGet200ResponseAuthorizations.attributeTypeMap;
    }
}

/**
* Fee Funding Section
*/
export class ReportingV3PurchaseRefundDetailsGet200ResponseFeeAndFundingDetails {
    /**
    * An unique identification number assigned by CyberSource to identify the submitted request.
    */
    'requestId'?: string;
    /**
    * interchange Per Item Fee
    */
    'interchangePerItemFee'?: string;
    /**
    * interchange Description
    */
    'interchangeDescription'?: string;
    /**
    * interchange Percentage
    */
    'interchangePercentage'?: string;
    /**
    * interchange Percentage Amount
    */
    'interchangePercentageAmount'?: string;
    /**
    * Discount Percentage
    */
    'discountPercentage'?: string;
    /**
    * Discount Amount
    */
    'discountAmount'?: string;
    /**
    * Discount Per Item Fee
    */
    'discountPerItemFee'?: string;
    /**
    * Total Fee
    */
    'totalFee'?: string;
    /**
    * Fee Currency
    */
    'feeCurrency'?: string;
    /**
    * Dues Assessments
    */
    'duesAssessments'?: string;
    /**
    * Funding Amount
    */
    'fundingAmount'?: string;
    /**
    * Funding Currency (ISO 4217)
    */
    'fundingCurrency'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "requestId",
            "baseName": "requestId",
            "type": "string"
        },
        {
            "name": "interchangePerItemFee",
            "baseName": "interchangePerItemFee",
            "type": "string"
        },
        {
            "name": "interchangeDescription",
            "baseName": "interchangeDescription",
            "type": "string"
        },
        {
            "name": "interchangePercentage",
            "baseName": "interchangePercentage",
            "type": "string"
        },
        {
            "name": "interchangePercentageAmount",
            "baseName": "interchangePercentageAmount",
            "type": "string"
        },
        {
            "name": "discountPercentage",
            "baseName": "discountPercentage",
            "type": "string"
        },
        {
            "name": "discountAmount",
            "baseName": "discountAmount",
            "type": "string"
        },
        {
            "name": "discountPerItemFee",
            "baseName": "discountPerItemFee",
            "type": "string"
        },
        {
            "name": "totalFee",
            "baseName": "totalFee",
            "type": "string"
        },
        {
            "name": "feeCurrency",
            "baseName": "feeCurrency",
            "type": "string"
        },
        {
            "name": "duesAssessments",
            "baseName": "duesAssessments",
            "type": "string"
        },
        {
            "name": "fundingAmount",
            "baseName": "fundingAmount",
            "type": "string"
        },
        {
            "name": "fundingCurrency",
            "baseName": "fundingCurrency",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ReportingV3PurchaseRefundDetailsGet200ResponseFeeAndFundingDetails.attributeTypeMap;
    }
}

/**
* Other Merchant Details Values.
*/
export class ReportingV3PurchaseRefundDetailsGet200ResponseOthers {
    /**
    * An unique identification number assigned by CyberSource to identify the submitted request.
    */
    'requestId'?: string;
    /**
    * Merchant Defined Data
    */
    'merchantData1'?: string;
    /**
    * Merchant Defined Data
    */
    'merchantData2'?: string;
    /**
    * Merchant Defined Data
    */
    'merchantData3'?: string;
    /**
    * Merchant Defined Data
    */
    'merchantData4'?: string;
    /**
    * First Name
    */
    'firstName'?: string;
    /**
    * Last Name
    */
    'lastName'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "requestId",
            "baseName": "requestId",
            "type": "string"
        },
        {
            "name": "merchantData1",
            "baseName": "merchantData1",
            "type": "string"
        },
        {
            "name": "merchantData2",
            "baseName": "merchantData2",
            "type": "string"
        },
        {
            "name": "merchantData3",
            "baseName": "merchantData3",
            "type": "string"
        },
        {
            "name": "merchantData4",
            "baseName": "merchantData4",
            "type": "string"
        },
        {
            "name": "firstName",
            "baseName": "firstName",
            "type": "string"
        },
        {
            "name": "lastName",
            "baseName": "lastName",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ReportingV3PurchaseRefundDetailsGet200ResponseOthers.attributeTypeMap;
    }
}

/**
* Request Info Section
*/
export class ReportingV3PurchaseRefundDetailsGet200ResponseRequestDetails {
    /**
    * An unique identification number assigned by CyberSource to identify the submitted request.
    */
    'requestId'?: string;
    /**
    * Cybersource Merchant Id
    */
    'cybersourceMerchantId'?: string;
    /**
    * Cybersource Processor Merchant Id
    */
    'processorMerchantId'?: string;
    /**
    * Group Name
    */
    'groupName'?: string;
    /**
    * Transaction Reference Number
    */
    'transactionReferenceNumber'?: string;
    /**
    * Merchant Reference Number
    */
    'merchantReferenceNumber'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "requestId",
            "baseName": "requestId",
            "type": "string"
        },
        {
            "name": "cybersourceMerchantId",
            "baseName": "cybersourceMerchantId",
            "type": "string"
        },
        {
            "name": "processorMerchantId",
            "baseName": "processorMerchantId",
            "type": "string"
        },
        {
            "name": "groupName",
            "baseName": "groupName",
            "type": "string"
        },
        {
            "name": "transactionReferenceNumber",
            "baseName": "transactionReferenceNumber",
            "type": "string"
        },
        {
            "name": "merchantReferenceNumber",
            "baseName": "merchantReferenceNumber",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ReportingV3PurchaseRefundDetailsGet200ResponseRequestDetails.attributeTypeMap;
    }
}

/**
* Settlement Status Section Values.
*/
export class ReportingV3PurchaseRefundDetailsGet200ResponseSettlementStatuses {
    /**
    * An unique identification number assigned by CyberSource to identify the submitted request.
    */
    'requestId'?: string;
    /**
    * Settlement Status
    */
    'status'?: string;
    /**
    * Settlement Date
    */
    'settlementTime'?: Date;
    /**
    * ReasonCode
    */
    'reasonCode'?: string;
    /**
    * errorText
    */
    'errorText'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "requestId",
            "baseName": "requestId",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "settlementTime",
            "baseName": "settlementTime",
            "type": "Date"
        },
        {
            "name": "reasonCode",
            "baseName": "reasonCode",
            "type": "string"
        },
        {
            "name": "errorText",
            "baseName": "errorText",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ReportingV3PurchaseRefundDetailsGet200ResponseSettlementStatuses.attributeTypeMap;
    }
}

export class ReportingV3PurchaseRefundDetailsGet200ResponseSettlements {
    /**
    * An unique identification number assigned by CyberSource to identify the submitted request.
    */
    'requestId'?: string;
    /**
    * Transaction Type
    */
    'transactionType'?: string;
    /**
    * Submission Date
    */
    'submissionTime'?: Date;
    /**
    * Amount
    */
    'amount'?: string;
    /**
    * Valid ISO 4217 ALPHA-3 currency code
    */
    'currencyCode'?: string;
    /**
    * payment method
    */
    'paymentMethod'?: string;
    /**
    * Solution Type (Wallet)
    */
    'walletType'?: string;
    /**
    * Payment Type
    */
    'paymentType'?: string;
    /**
    * Account Suffix
    */
    'accountSuffix'?: string;
    /**
    * Cybersource Batch Time
    */
    'cybersourceBatchTime'?: Date;
    /**
    * Cybersource Batch Id
    */
    'cybersourceBatchId'?: string;
    /**
    * Card Type
    */
    'cardType'?: string;
    /**
    * Debit Network
    */
    'debitNetwork'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "requestId",
            "baseName": "requestId",
            "type": "string"
        },
        {
            "name": "transactionType",
            "baseName": "transactionType",
            "type": "string"
        },
        {
            "name": "submissionTime",
            "baseName": "submissionTime",
            "type": "Date"
        },
        {
            "name": "amount",
            "baseName": "amount",
            "type": "string"
        },
        {
            "name": "currencyCode",
            "baseName": "currencyCode",
            "type": "string"
        },
        {
            "name": "paymentMethod",
            "baseName": "paymentMethod",
            "type": "string"
        },
        {
            "name": "walletType",
            "baseName": "walletType",
            "type": "string"
        },
        {
            "name": "paymentType",
            "baseName": "paymentType",
            "type": "string"
        },
        {
            "name": "accountSuffix",
            "baseName": "accountSuffix",
            "type": "string"
        },
        {
            "name": "cybersourceBatchTime",
            "baseName": "cybersourceBatchTime",
            "type": "Date"
        },
        {
            "name": "cybersourceBatchId",
            "baseName": "cybersourceBatchId",
            "type": "string"
        },
        {
            "name": "cardType",
            "baseName": "cardType",
            "type": "string"
        },
        {
            "name": "debitNetwork",
            "baseName": "debitNetwork",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ReportingV3PurchaseRefundDetailsGet200ResponseSettlements.attributeTypeMap;
    }
}

export class ReportingV3ReportDefinitionsGet200Response {
    'reportDefinitions'?: Array<ReportingV3ReportDefinitionsGet200ResponseReportDefinitions>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "reportDefinitions",
            "baseName": "reportDefinitions",
            "type": "Array<ReportingV3ReportDefinitionsGet200ResponseReportDefinitions>"
        }    ];

    static getAttributeTypeMap() {
        return ReportingV3ReportDefinitionsGet200Response.attributeTypeMap;
    }
}

export class ReportingV3ReportDefinitionsGet200ResponseReportDefinitions {
    'type'?: string;
    /**
    * | Id  |         Definition Class          | | --- | --------------------------------- | | 210 | TransactionRequestClass           | | 211 | PaymentBatchDetailClass           | | 212 | ExceptionDetailClass              | | 213 | ProcessorSettlementDetailClass    | | 214 | ProcessorEventsDetailClass        | | 215 | FundingDetailClass                | | 216 | AgingDetailClass                  | | 217 | ChargebackAndRetrievalDetailClass | | 218 | DepositDetailClass                | | 219 | FeeDetailClass                    | | 220 | InvoiceSummaryClass               | | 221 | PayerAuthDetailClass              | | 222 | ConversionDetailClass             | | 225 | BillableTransactionsDetailClass   | | 270 | JPTransactionDetailClass          | | 271 | ServiceFeeDetailClass             | | 310 | GatewayTransactionRequestClass    | | 400 | DecisionManagerEventDetailClass   | | 401 | DecisionManagerDetailClass        | | 410 | FeeSummaryClass                   | | 420 | TaxCalculationClass               | | 520 | POSTerminalExceptionClass         | | 620 | SubscriptionDetailClass           | 
    */
    'reportDefinitionId'?: number;
    'reportDefintionName'?: string;
    'supportedFormats'?: Array<string>;
    'description'?: string;
    'defaultSettings'?: ReportingV3ReportDefinitionsNameGet200ResponseDefaultSettings;
    /**
    * 'The subscription type for which report definition is required. By default the type will be CUSTOM.' Valid Values: - CLASSIC - CUSTOM - STANDARD 
    */
    'subscriptionType'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "reportDefinitionId",
            "baseName": "reportDefinitionId",
            "type": "number"
        },
        {
            "name": "reportDefintionName",
            "baseName": "reportDefintionName",
            "type": "string"
        },
        {
            "name": "supportedFormats",
            "baseName": "supportedFormats",
            "type": "Array<string>"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "defaultSettings",
            "baseName": "defaultSettings",
            "type": "ReportingV3ReportDefinitionsNameGet200ResponseDefaultSettings"
        },
        {
            "name": "subscriptionType",
            "baseName": "subscriptionType",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ReportingV3ReportDefinitionsGet200ResponseReportDefinitions.attributeTypeMap;
    }
}

export class ReportingV3ReportDefinitionsNameGet200Response {
    'type'?: string;
    'reportDefinitionId'?: number;
    'reportDefintionName'?: string;
    'attributes'?: Array<ReportingV3ReportDefinitionsNameGet200ResponseAttributes>;
    'supportedFormats'?: Array<string>;
    'description'?: string;
    'defaultSettings'?: ReportingV3ReportDefinitionsNameGet200ResponseDefaultSettings;
    /**
    * 'The subscription type for which report definition is required. By default the type will be CUSTOM.' Valid Values: - 'CLASSIC' - 'CUSTOM' - 'STANDARD' 
    */
    'subscriptionType'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "reportDefinitionId",
            "baseName": "reportDefinitionId",
            "type": "number"
        },
        {
            "name": "reportDefintionName",
            "baseName": "reportDefintionName",
            "type": "string"
        },
        {
            "name": "attributes",
            "baseName": "attributes",
            "type": "Array<ReportingV3ReportDefinitionsNameGet200ResponseAttributes>"
        },
        {
            "name": "supportedFormats",
            "baseName": "supportedFormats",
            "type": "Array<string>"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "defaultSettings",
            "baseName": "defaultSettings",
            "type": "ReportingV3ReportDefinitionsNameGet200ResponseDefaultSettings"
        },
        {
            "name": "subscriptionType",
            "baseName": "subscriptionType",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ReportingV3ReportDefinitionsNameGet200Response.attributeTypeMap;
    }
}

export class ReportingV3ReportDefinitionsNameGet200ResponseAttributes {
    'id'?: string;
    'name'?: string;
    'description'?: string;
    /**
    * Attribute Filter Type.
    */
    'filterType'?: string;
    '_default'?: boolean;
    'required'?: boolean;
    /**
    * Valid values for the filter.
    */
    'supportedType'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "filterType",
            "baseName": "filterType",
            "type": "string"
        },
        {
            "name": "_default",
            "baseName": "default",
            "type": "boolean"
        },
        {
            "name": "required",
            "baseName": "required",
            "type": "boolean"
        },
        {
            "name": "supportedType",
            "baseName": "supportedType",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ReportingV3ReportDefinitionsNameGet200ResponseAttributes.attributeTypeMap;
    }
}

export class ReportingV3ReportDefinitionsNameGet200ResponseDefaultSettings {
    /**
    * Report Format Valid values:   - application/xml   - text/csv 
    */
    'reportMimeType'?: string;
    /**
    * Report Frequency Value Valid Values:   - DAILY   - WEEKLY   - MONTHLY   - ADHOC 
    */
    'reportFrequency'?: string;
    /**
    * Report Name
    */
    'reportName'?: string;
    /**
    * Time Zone
    */
    'timezone'?: string;
    /**
    * Start Time
    */
    'startTime'?: string;
    /**
    * Start Day
    */
    'startDay'?: number;
    /**
    * List of filters to apply
    */
    'reportFilters'?: { [key: string]: Array<string>; };
    'reportPreferences'?: Reportingv3reportsReportPreferences;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "reportMimeType",
            "baseName": "reportMimeType",
            "type": "string"
        },
        {
            "name": "reportFrequency",
            "baseName": "reportFrequency",
            "type": "string"
        },
        {
            "name": "reportName",
            "baseName": "reportName",
            "type": "string"
        },
        {
            "name": "timezone",
            "baseName": "timezone",
            "type": "string"
        },
        {
            "name": "startTime",
            "baseName": "startTime",
            "type": "string"
        },
        {
            "name": "startDay",
            "baseName": "startDay",
            "type": "number"
        },
        {
            "name": "reportFilters",
            "baseName": "reportFilters",
            "type": "{ [key: string]: Array<string>; }"
        },
        {
            "name": "reportPreferences",
            "baseName": "reportPreferences",
            "type": "Reportingv3reportsReportPreferences"
        }    ];

    static getAttributeTypeMap() {
        return ReportingV3ReportDefinitionsNameGet200ResponseDefaultSettings.attributeTypeMap;
    }
}

export class ReportingV3ReportSubscriptionsGet200Response {
    'subscriptions'?: Array<ReportingV3ReportSubscriptionsGet200ResponseSubscriptions>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "subscriptions",
            "baseName": "subscriptions",
            "type": "Array<ReportingV3ReportSubscriptionsGet200ResponseSubscriptions>"
        }    ];

    static getAttributeTypeMap() {
        return ReportingV3ReportSubscriptionsGet200Response.attributeTypeMap;
    }
}

/**
* Subscription Details
*/
export class ReportingV3ReportSubscriptionsGet200ResponseSubscriptions {
    /**
    * Selected Organization Id
    */
    'organizationId'?: string;
    /**
    * Report Definition Id
    */
    'reportDefinitionId'?: string;
    /**
    * Report Definition Class
    */
    'reportDefinitionName'?: string;
    /**
    * Report Format                          Valid values: - application/xml - text/csv 
    */
    'reportMimeType'?: string;
    /**
    * 'Report Frequency' **NOTE: Do not document USER_DEFINED Frequency field in developer center**  Valid values: - DAILY - WEEKLY - MONTHLY - USER_DEFINED 
    */
    'reportFrequency'?: string;
    /**
    * If the reportFrequency is User-defined, reportInterval should be in **ISO 8601 time format** Please refer the following link to know more about ISO 8601 format.[Rfc Time Format](https://en.wikipedia.org/wiki/ISO_8601#Durations)  **Example time format for 2 hours and 30 Mins:**   - PT2H30M **NOTE: Do not document reportInterval field in developer center** 
    */
    'reportInterval'?: string;
    /**
    * Report Name
    */
    'reportName'?: string;
    /**
    * Time Zone
    */
    'timezone'?: string;
    /**
    * Start Time
    */
    'startTime'?: Date;
    /**
    * Start Day
    */
    'startDay'?: number;
    /**
    * List of all fields String values
    */
    'reportFields'?: Array<string>;
    /**
    * List of filters to apply
    */
    'reportFilters'?: { [key: string]: Array<string>; };
    'reportPreferences'?: Reportingv3reportsReportPreferences;
    /**
    * Id for the selected group.
    */
    'groupId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "organizationId",
            "baseName": "organizationId",
            "type": "string"
        },
        {
            "name": "reportDefinitionId",
            "baseName": "reportDefinitionId",
            "type": "string"
        },
        {
            "name": "reportDefinitionName",
            "baseName": "reportDefinitionName",
            "type": "string"
        },
        {
            "name": "reportMimeType",
            "baseName": "reportMimeType",
            "type": "string"
        },
        {
            "name": "reportFrequency",
            "baseName": "reportFrequency",
            "type": "string"
        },
        {
            "name": "reportInterval",
            "baseName": "reportInterval",
            "type": "string"
        },
        {
            "name": "reportName",
            "baseName": "reportName",
            "type": "string"
        },
        {
            "name": "timezone",
            "baseName": "timezone",
            "type": "string"
        },
        {
            "name": "startTime",
            "baseName": "startTime",
            "type": "Date"
        },
        {
            "name": "startDay",
            "baseName": "startDay",
            "type": "number"
        },
        {
            "name": "reportFields",
            "baseName": "reportFields",
            "type": "Array<string>"
        },
        {
            "name": "reportFilters",
            "baseName": "reportFilters",
            "type": "{ [key: string]: Array<string>; }"
        },
        {
            "name": "reportPreferences",
            "baseName": "reportPreferences",
            "type": "Reportingv3reportsReportPreferences"
        },
        {
            "name": "groupId",
            "baseName": "groupId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ReportingV3ReportSubscriptionsGet200ResponseSubscriptions.attributeTypeMap;
    }
}

export class ReportingV3ReportsGet200Response {
    'reportSearchResults'?: Array<ReportingV3ReportsGet200ResponseReportSearchResults>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "reportSearchResults",
            "baseName": "reportSearchResults",
            "type": "Array<ReportingV3ReportsGet200ResponseReportSearchResults>"
        }    ];

    static getAttributeTypeMap() {
        return ReportingV3ReportsGet200Response.attributeTypeMap;
    }
}

export class ReportingV3ReportsGet200ResponseLink {
    'reportDownload'?: ReportingV3ReportsGet200ResponseLinkReportDownload;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "reportDownload",
            "baseName": "reportDownload",
            "type": "ReportingV3ReportsGet200ResponseLinkReportDownload"
        }    ];

    static getAttributeTypeMap() {
        return ReportingV3ReportsGet200ResponseLink.attributeTypeMap;
    }
}

export class ReportingV3ReportsGet200ResponseLinkReportDownload {
    'href'?: string;
    'method'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "href",
            "baseName": "href",
            "type": "string"
        },
        {
            "name": "method",
            "baseName": "method",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ReportingV3ReportsGet200ResponseLinkReportDownload.attributeTypeMap;
    }
}

/**
* Report Search Result Bean
*/
export class ReportingV3ReportsGet200ResponseReportSearchResults {
    'link'?: ReportingV3ReportsGet200ResponseLink;
    /**
    * Unique Report Identifier of each report type
    */
    'reportDefinitionId'?: string;
    /**
    * Name of the report specified by merchant while creating the report
    */
    'reportName'?: string;
    /**
    * Format of the report to get generated Valid Values: - application/xml - text/csv 
    */
    'reportMimeType'?: string;
    /**
    * Frequency of the report to get generated Valid Values: - DAILY - WEEKLY - MONTHLY - ADHOC 
    */
    'reportFrequency'?: string;
    /**
    * Status of the report Valid Values: - COMPLETED - PENDING - QUEUED - RUNNING - ERROR - NO_DATA 
    */
    'status'?: string;
    /**
    * Specifies the report start time in ISO 8601 format
    */
    'reportStartTime'?: Date;
    /**
    * Specifies the report end time in ISO 8601 format
    */
    'reportEndTime'?: Date;
    /**
    * Time Zone
    */
    'timezone'?: string;
    /**
    * Unique identifier generated for every reports
    */
    'reportId'?: string;
    /**
    * CyberSource Merchant Id
    */
    'organizationId'?: string;
    /**
    * Specifies the time of the report in queued  in ISO 8601 format
    */
    'queuedTime'?: Date;
    /**
    * Specifies the time of the report started to generate  in ISO 8601 format
    */
    'reportGeneratingTime'?: Date;
    /**
    * Specifies the time of the report completed the generation  in ISO 8601 format
    */
    'reportCompletedTime'?: Date;
    /**
    * Specifies whether the subscription created is either Custom, Standard or Classic 
    */
    'subscriptionType'?: string;
    /**
    * Id for selected group.
    */
    'groupId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "link",
            "baseName": "_link",
            "type": "ReportingV3ReportsGet200ResponseLink"
        },
        {
            "name": "reportDefinitionId",
            "baseName": "reportDefinitionId",
            "type": "string"
        },
        {
            "name": "reportName",
            "baseName": "reportName",
            "type": "string"
        },
        {
            "name": "reportMimeType",
            "baseName": "reportMimeType",
            "type": "string"
        },
        {
            "name": "reportFrequency",
            "baseName": "reportFrequency",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "reportStartTime",
            "baseName": "reportStartTime",
            "type": "Date"
        },
        {
            "name": "reportEndTime",
            "baseName": "reportEndTime",
            "type": "Date"
        },
        {
            "name": "timezone",
            "baseName": "timezone",
            "type": "string"
        },
        {
            "name": "reportId",
            "baseName": "reportId",
            "type": "string"
        },
        {
            "name": "organizationId",
            "baseName": "organizationId",
            "type": "string"
        },
        {
            "name": "queuedTime",
            "baseName": "queuedTime",
            "type": "Date"
        },
        {
            "name": "reportGeneratingTime",
            "baseName": "reportGeneratingTime",
            "type": "Date"
        },
        {
            "name": "reportCompletedTime",
            "baseName": "reportCompletedTime",
            "type": "Date"
        },
        {
            "name": "subscriptionType",
            "baseName": "subscriptionType",
            "type": "string"
        },
        {
            "name": "groupId",
            "baseName": "groupId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ReportingV3ReportsGet200ResponseReportSearchResults.attributeTypeMap;
    }
}

/**
* Report Log
*/
export class ReportingV3ReportsIdGet200Response {
    /**
    * CyberSource merchant id
    */
    'organizationId'?: string;
    /**
    * Report ID Value
    */
    'reportId'?: string;
    /**
    * Report definition Id
    */
    'reportDefinitionId'?: string;
    /**
    * Report Name
    */
    'reportName'?: string;
    /**
    * Report Format  Valid values: - application/xml - text/csv 
    */
    'reportMimeType'?: string;
    /**
    * Report Frequency Value  Valid values: - DAILY - WEEKLY - MONTHLY - ADHOC 
    */
    'reportFrequency'?: string;
    /**
    * List of Integer Values
    */
    'reportFields'?: Array<string>;
    /**
    * Report Status Value  Valid values: - COMPLETED - PENDING - QUEUED - RUNNING - ERROR - NO_DATA - RERUN 
    */
    'reportStatus'?: string;
    /**
    * Report Start Time Value
    */
    'reportStartTime'?: Date;
    /**
    * Report End Time Value
    */
    'reportEndTime'?: Date;
    /**
    * Time Zone Value
    */
    'timezone'?: string;
    /**
    * List of filters to apply
    */
    'reportFilters'?: { [key: string]: Array<string>; };
    'reportPreferences'?: Reportingv3reportsReportPreferences;
    /**
    * Id for selected group.
    */
    'groupId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "organizationId",
            "baseName": "organizationId",
            "type": "string"
        },
        {
            "name": "reportId",
            "baseName": "reportId",
            "type": "string"
        },
        {
            "name": "reportDefinitionId",
            "baseName": "reportDefinitionId",
            "type": "string"
        },
        {
            "name": "reportName",
            "baseName": "reportName",
            "type": "string"
        },
        {
            "name": "reportMimeType",
            "baseName": "reportMimeType",
            "type": "string"
        },
        {
            "name": "reportFrequency",
            "baseName": "reportFrequency",
            "type": "string"
        },
        {
            "name": "reportFields",
            "baseName": "reportFields",
            "type": "Array<string>"
        },
        {
            "name": "reportStatus",
            "baseName": "reportStatus",
            "type": "string"
        },
        {
            "name": "reportStartTime",
            "baseName": "reportStartTime",
            "type": "Date"
        },
        {
            "name": "reportEndTime",
            "baseName": "reportEndTime",
            "type": "Date"
        },
        {
            "name": "timezone",
            "baseName": "timezone",
            "type": "string"
        },
        {
            "name": "reportFilters",
            "baseName": "reportFilters",
            "type": "{ [key: string]: Array<string>; }"
        },
        {
            "name": "reportPreferences",
            "baseName": "reportPreferences",
            "type": "Reportingv3reportsReportPreferences"
        },
        {
            "name": "groupId",
            "baseName": "groupId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ReportingV3ReportsIdGet200Response.attributeTypeMap;
    }
}

export class ReportingV3RetrievalDetailsGet200Response {
    /**
    * Organization Id
    */
    'organizationId'?: string;
    /**
    * Report Start Date (ISO 8601 Extended)
    */
    'startTime'?: Date;
    /**
    * Report Start Date (ISO 8601 Extended)
    */
    'endTime'?: Date;
    /**
    * List of Retrieval Details list.
    */
    'retrievalDetails'?: Array<ReportingV3RetrievalDetailsGet200ResponseRetrievalDetails>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "organizationId",
            "baseName": "organizationId",
            "type": "string"
        },
        {
            "name": "startTime",
            "baseName": "startTime",
            "type": "Date"
        },
        {
            "name": "endTime",
            "baseName": "endTime",
            "type": "Date"
        },
        {
            "name": "retrievalDetails",
            "baseName": "retrievalDetails",
            "type": "Array<ReportingV3RetrievalDetailsGet200ResponseRetrievalDetails>"
        }    ];

    static getAttributeTypeMap() {
        return ReportingV3RetrievalDetailsGet200Response.attributeTypeMap;
    }
}

export class ReportingV3RetrievalDetailsGet200ResponseRetrievalDetails {
    /**
    * Processor Merchant Id
    */
    'processorMerchantId'?: string;
    /**
    * Merchant Name
    */
    'merchantName'?: string;
    /**
    * Transaction Reference Number
    */
    'transactionReferenceNumber'?: string;
    /**
    * Merchant Reference Number
    */
    'merchantReferenceNumber'?: string;
    /**
    * Nature of Dispute
    */
    'natureOfDispute'?: string;
    /**
    * Retrieval Alert Type
    */
    'alertType'?: string;
    /**
    * Retrieval Amount
    */
    'amount'?: string;
    /**
    * Retrieval Sign
    */
    'sign'?: string;
    /**
    * Retrieval Action
    */
    'action'?: string;
    /**
    * Card Type
    */
    'cardType'?: string;
    /**
    * Original Settlement Date
    */
    'originalSettlementTime'?: Date;
    /**
    * Tracking Number
    */
    'trackingNumber'?: string;
    /**
    * Valid ISO 4217 ALPHA-3 currency code
    */
    'currencyCode'?: string;
    /**
    * Request Id
    */
    'requestId'?: string;
    /**
    * Response Due Date
    */
    'responseDueTime'?: Date;
    /**
    * Retrieval Date
    */
    'time'?: Date;
    /**
    * Retrieval Action Description
    */
    'actionDescription'?: string;
    /**
    * Customer Id
    */
    'customerId'?: string;
    /**
    * Retrieval Reason Code
    */
    'reasonCode'?: string;
    /**
    * Representment CP Date
    */
    'representmentCPTime'?: Date;
    /**
    * ICS Request Applications
    */
    'applications'?: string;
    /**
    * Event Request Date
    */
    'eventRequestedTime'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "processorMerchantId",
            "baseName": "processorMerchantId",
            "type": "string"
        },
        {
            "name": "merchantName",
            "baseName": "merchantName",
            "type": "string"
        },
        {
            "name": "transactionReferenceNumber",
            "baseName": "transactionReferenceNumber",
            "type": "string"
        },
        {
            "name": "merchantReferenceNumber",
            "baseName": "merchantReferenceNumber",
            "type": "string"
        },
        {
            "name": "natureOfDispute",
            "baseName": "natureOfDispute",
            "type": "string"
        },
        {
            "name": "alertType",
            "baseName": "alertType",
            "type": "string"
        },
        {
            "name": "amount",
            "baseName": "amount",
            "type": "string"
        },
        {
            "name": "sign",
            "baseName": "sign",
            "type": "string"
        },
        {
            "name": "action",
            "baseName": "action",
            "type": "string"
        },
        {
            "name": "cardType",
            "baseName": "cardType",
            "type": "string"
        },
        {
            "name": "originalSettlementTime",
            "baseName": "originalSettlementTime",
            "type": "Date"
        },
        {
            "name": "trackingNumber",
            "baseName": "trackingNumber",
            "type": "string"
        },
        {
            "name": "currencyCode",
            "baseName": "currencyCode",
            "type": "string"
        },
        {
            "name": "requestId",
            "baseName": "requestId",
            "type": "string"
        },
        {
            "name": "responseDueTime",
            "baseName": "responseDueTime",
            "type": "Date"
        },
        {
            "name": "time",
            "baseName": "time",
            "type": "Date"
        },
        {
            "name": "actionDescription",
            "baseName": "actionDescription",
            "type": "string"
        },
        {
            "name": "customerId",
            "baseName": "customerId",
            "type": "string"
        },
        {
            "name": "reasonCode",
            "baseName": "reasonCode",
            "type": "string"
        },
        {
            "name": "representmentCPTime",
            "baseName": "representmentCPTime",
            "type": "Date"
        },
        {
            "name": "applications",
            "baseName": "applications",
            "type": "string"
        },
        {
            "name": "eventRequestedTime",
            "baseName": "eventRequestedTime",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return ReportingV3RetrievalDetailsGet200ResponseRetrievalDetails.attributeTypeMap;
    }
}

export class ReportingV3RetrievalSummariesGet200Response {
    /**
    * Organization Id
    */
    'organizationId'?: string;
    /**
    * Report Start Date
    */
    'startTime'?: Date;
    /**
    * Report Start Date
    */
    'endTime'?: string;
    /**
    * List of Summary values
    */
    'retrievalSummaries'?: Array<ReportingV3ChargebackSummariesGet200ResponseChargebackSummaries>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "organizationId",
            "baseName": "organizationId",
            "type": "string"
        },
        {
            "name": "startTime",
            "baseName": "startTime",
            "type": "Date"
        },
        {
            "name": "endTime",
            "baseName": "endTime",
            "type": "string"
        },
        {
            "name": "retrievalSummaries",
            "baseName": "retrievalSummaries",
            "type": "Array<ReportingV3ChargebackSummariesGet200ResponseChargebackSummaries>"
        }    ];

    static getAttributeTypeMap() {
        return ReportingV3RetrievalSummariesGet200Response.attributeTypeMap;
    }
}

/**
* HTTP status code for client application
*/
export class Reportingv3ReportDownloadsGet400Response {
    /**
    * Time of request in UTC.  
    */
    'submitTimeUtc': Date;
    /**
    * Documented reason code 
    */
    'reason': string;
    /**
    * Short descriptive message to the user. 
    */
    'message': string;
    /**
    * Error field list 
    */
    'details': Array<Reportingv3ReportDownloadsGet400ResponseDetails>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "submitTimeUtc",
            "baseName": "submitTimeUtc",
            "type": "Date"
        },
        {
            "name": "reason",
            "baseName": "reason",
            "type": "string"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        },
        {
            "name": "details",
            "baseName": "details",
            "type": "Array<Reportingv3ReportDownloadsGet400ResponseDetails>"
        }    ];

    static getAttributeTypeMap() {
        return Reportingv3ReportDownloadsGet400Response.attributeTypeMap;
    }
}

/**
* Provides failed validation input field detail 
*/
export class Reportingv3ReportDownloadsGet400ResponseDetails {
    /**
    * Field in request that caused an error 
    */
    'field'?: string;
    /**
    * Documented reason code 
    */
    'reason'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "field",
            "baseName": "field",
            "type": "string"
        },
        {
            "name": "reason",
            "baseName": "reason",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Reportingv3ReportDownloadsGet400ResponseDetails.attributeTypeMap;
    }
}

export class Reportingv3reportsReportFilters {
    'applicationName'?: Array<string>;
    'firstName'?: Array<string>;
    'lastName'?: Array<string>;
    'email'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "applicationName",
            "baseName": "Application.Name",
            "type": "Array<string>"
        },
        {
            "name": "firstName",
            "baseName": "firstName",
            "type": "Array<string>"
        },
        {
            "name": "lastName",
            "baseName": "lastName",
            "type": "Array<string>"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return Reportingv3reportsReportFilters.attributeTypeMap;
    }
}

/**
* Report Preferences
*/
export class Reportingv3reportsReportPreferences {
    /**
    * Indicator to determine whether negative sign infront of amount for all refunded transaction
    */
    'signedAmounts'?: boolean;
    /**
    * Specify the field naming convention to be followed in reports (applicable to only csv report formats)  Valid values: - SOAPI - SCMP 
    */
    'fieldNameConvention'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "signedAmounts",
            "baseName": "signedAmounts",
            "type": "boolean"
        },
        {
            "name": "fieldNameConvention",
            "baseName": "fieldNameConvention",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Reportingv3reportsReportPreferences.attributeTypeMap;
    }
}

export class Request {
    'processingInformation'?: Ptsv2paymenttokensProcessingInformation;
    'paymentInformation'?: Ptsv2paymenttokensPaymentInformation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "processingInformation",
            "baseName": "processingInformation",
            "type": "Ptsv2paymenttokensProcessingInformation"
        },
        {
            "name": "paymentInformation",
            "baseName": "paymentInformation",
            "type": "Ptsv2paymenttokensPaymentInformation"
        }    ];

    static getAttributeTypeMap() {
        return Request.attributeTypeMap;
    }
}

export class RevokeCertificateRequest {
    /**
    * Id of the merchant to revoke certificate
    */
    'merchantId': string;
    /**
    * Id of the device to revoke certificate
    */
    'deviceId': string;
    /**
    * Type of the device
    */
    'deviceType': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "merchantId",
            "baseName": "merchantId",
            "type": "string"
        },
        {
            "name": "deviceId",
            "baseName": "deviceId",
            "type": "string"
        },
        {
            "name": "deviceType",
            "baseName": "deviceType",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return RevokeCertificateRequest.attributeTypeMap;
    }
}

export class RiskProducts {
    'fraudManagementEssentials'?: RiskProductsFraudManagementEssentials;
    'decisionManager'?: RiskProductsDecisionManager;
    'portfolioRiskControls'?: RiskProductsPortfolioRiskControls;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "fraudManagementEssentials",
            "baseName": "fraudManagementEssentials",
            "type": "RiskProductsFraudManagementEssentials"
        },
        {
            "name": "decisionManager",
            "baseName": "decisionManager",
            "type": "RiskProductsDecisionManager"
        },
        {
            "name": "portfolioRiskControls",
            "baseName": "portfolioRiskControls",
            "type": "RiskProductsPortfolioRiskControls"
        }    ];

    static getAttributeTypeMap() {
        return RiskProducts.attributeTypeMap;
    }
}

export class RiskProductsDecisionManager {
    'subscriptionInformation'?: PaymentsProductsAlternativePaymentMethodsSubscriptionInformation;
    'configurationInformation'?: RiskProductsDecisionManagerConfigurationInformation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "subscriptionInformation",
            "baseName": "subscriptionInformation",
            "type": "PaymentsProductsAlternativePaymentMethodsSubscriptionInformation"
        },
        {
            "name": "configurationInformation",
            "baseName": "configurationInformation",
            "type": "RiskProductsDecisionManagerConfigurationInformation"
        }    ];

    static getAttributeTypeMap() {
        return RiskProductsDecisionManager.attributeTypeMap;
    }
}

export class RiskProductsDecisionManagerConfigurationInformation {
    'templateId'?: string;
    'configurations'?: DmConfig;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "templateId",
            "baseName": "templateId",
            "type": "string"
        },
        {
            "name": "configurations",
            "baseName": "configurations",
            "type": "DmConfig"
        }    ];

    static getAttributeTypeMap() {
        return RiskProductsDecisionManagerConfigurationInformation.attributeTypeMap;
    }
}

export class RiskProductsFraudManagementEssentials {
    'subscriptionInformation'?: PaymentsProductsAlternativePaymentMethodsSubscriptionInformation;
    'configurationInformation'?: RiskProductsFraudManagementEssentialsConfigurationInformation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "subscriptionInformation",
            "baseName": "subscriptionInformation",
            "type": "PaymentsProductsAlternativePaymentMethodsSubscriptionInformation"
        },
        {
            "name": "configurationInformation",
            "baseName": "configurationInformation",
            "type": "RiskProductsFraudManagementEssentialsConfigurationInformation"
        }    ];

    static getAttributeTypeMap() {
        return RiskProductsFraudManagementEssentials.attributeTypeMap;
    }
}

export class RiskProductsFraudManagementEssentialsConfigurationInformation {
    'templateId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "templateId",
            "baseName": "templateId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return RiskProductsFraudManagementEssentialsConfigurationInformation.attributeTypeMap;
    }
}

export class RiskProductsPortfolioRiskControls {
    'subscriptionInformation'?: PaymentsProductsAlternativePaymentMethodsSubscriptionInformation;
    'configurationInformation'?: RiskProductsPortfolioRiskControlsConfigurationInformation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "subscriptionInformation",
            "baseName": "subscriptionInformation",
            "type": "PaymentsProductsAlternativePaymentMethodsSubscriptionInformation"
        },
        {
            "name": "configurationInformation",
            "baseName": "configurationInformation",
            "type": "RiskProductsPortfolioRiskControlsConfigurationInformation"
        }    ];

    static getAttributeTypeMap() {
        return RiskProductsPortfolioRiskControls.attributeTypeMap;
    }
}

export class RiskProductsPortfolioRiskControlsConfigurationInformation {
    'configurations'?: RiskProductsPortfolioRiskControlsConfigurationInformationConfigurations;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "configurations",
            "baseName": "configurations",
            "type": "RiskProductsPortfolioRiskControlsConfigurationInformationConfigurations"
        }    ];

    static getAttributeTypeMap() {
        return RiskProductsPortfolioRiskControlsConfigurationInformation.attributeTypeMap;
    }
}

export class RiskProductsPortfolioRiskControlsConfigurationInformationConfigurations {
    'profileId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "profileId",
            "baseName": "profileId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return RiskProductsPortfolioRiskControlsConfigurationInformationConfigurations.attributeTypeMap;
    }
}

export class RiskV1AddressVerificationsPost201Response {
    'links'?: PtsV2IncrementalAuthorizationPatch201ResponseLinks;
    /**
    * An unique identification number generated by Cybersource to identify the submitted request. Returned by all services. It is also appended to the endpoint of the resource. On incremental authorizations, this value with be the same as the identification number returned in the original authorization response. 
    */
    'id'?: string;
    /**
    * Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ` **Example** `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.). The `T` separates the date and the time. The `Z` indicates UTC.  Returned by Cybersource for all services. 
    */
    'submitTimeUtc'?: string;
    /**
    * Time that the transaction was submitted in local time. Generated by Cybersource.
    */
    'submitTimeLocal'?: string;
    /**
    * The status for the call can be: - COMPLETED - INVALID_REQUEST - DECLINED 
    */
    'status'?: string;
    /**
    * The message describing the reason of the status. Value can be   - Apartment number missing or not found.   - Insufficient address information.   - House/Box number not found on street.   - Multiple address matches were found.   - P.O. Box identifier not found or out of range.   - Route service identifier not found or out of range.   - Street name not found in Postal code.   - Postal code not found in database.   - Unable to verify or correct address.   - Multiple addres matches were found (international)   - Address match not found (no reason given)   - Unsupported character set 
    */
    'message'?: string;
    'clientReferenceInformation'?: RiskV1DecisionsPost201ResponseClientReferenceInformation;
    'addressVerificationInformation'?: RiskV1AddressVerificationsPost201ResponseAddressVerificationInformation;
    'errorInformation'?: RiskV1AddressVerificationsPost201ResponseErrorInformation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "PtsV2IncrementalAuthorizationPatch201ResponseLinks"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "submitTimeUtc",
            "baseName": "submitTimeUtc",
            "type": "string"
        },
        {
            "name": "submitTimeLocal",
            "baseName": "submitTimeLocal",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        },
        {
            "name": "clientReferenceInformation",
            "baseName": "clientReferenceInformation",
            "type": "RiskV1DecisionsPost201ResponseClientReferenceInformation"
        },
        {
            "name": "addressVerificationInformation",
            "baseName": "addressVerificationInformation",
            "type": "RiskV1AddressVerificationsPost201ResponseAddressVerificationInformation"
        },
        {
            "name": "errorInformation",
            "baseName": "errorInformation",
            "type": "RiskV1AddressVerificationsPost201ResponseErrorInformation"
        }    ];

    static getAttributeTypeMap() {
        return RiskV1AddressVerificationsPost201Response.attributeTypeMap;
    }
}

export class RiskV1AddressVerificationsPost201ResponseAddressVerificationInformation {
    /**
    * Contains the record type of the postal code with which the address was matched.  #### U.S. Addresses Depending on the quantity and quality of the address information provided, this field contains one or two characters:  - One character: sufficient correct information was provided to result in accurate matching. - Two characters: standardization would provide a better address if more or better input address information were available. The second character is D (default).  Blank fields are unassigned. When an address cannot be standardized, how the input data was parsed determines the address type. In this case, standardization may indicate a street, rural route, highway contract, general delivery, or PO box.   #### All Other Countries This field contains one of the following values: - P: Post. - S: Street. - x: Unknown. 
    */
    'addressType'?: string;
    'barCode'?: RiskV1AddressVerificationsPost201ResponseAddressVerificationInformationBarCode;
    /**
    * Value can be - Canada - US - International The values of errorCode and statusCode mean different things depending on the applicable region. Refer to the guide for more info. 
    */
    'applicableRegion'?: string;
    /**
    * Four-character error code returned for Canadian, US and international addresses. For possible values, see Verification Services guide. The meaning of the errorCode depends on value of applicableRegion. 
    */
    'errorCode'?: string;
    /**
    * Four-to-ten character status code returned for Canadian, US and international addresses. For possible values, see Verification Services guide. The meaning of the errorCode depends on value of applicableRegion. 
    */
    'statusCode'?: string;
    /**
    * Care of data dropped from the standard address.
    */
    'careOf'?: string;
    /**
    * Indicates the probable correctness of the address match. Returned for U.S. and Canadian addresses. Returns a value from 0-9, where 0 is most likely to be correct and 9 is least likely to be correct, or -1 if there is no address match. 
    */
    'matchScore'?: number;
    'standardAddress'?: RiskV1AddressVerificationsPost201ResponseAddressVerificationInformationStandardAddress;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "addressType",
            "baseName": "addressType",
            "type": "string"
        },
        {
            "name": "barCode",
            "baseName": "barCode",
            "type": "RiskV1AddressVerificationsPost201ResponseAddressVerificationInformationBarCode"
        },
        {
            "name": "applicableRegion",
            "baseName": "applicableRegion",
            "type": "string"
        },
        {
            "name": "errorCode",
            "baseName": "errorCode",
            "type": "string"
        },
        {
            "name": "statusCode",
            "baseName": "statusCode",
            "type": "string"
        },
        {
            "name": "careOf",
            "baseName": "careOf",
            "type": "string"
        },
        {
            "name": "matchScore",
            "baseName": "matchScore",
            "type": "number"
        },
        {
            "name": "standardAddress",
            "baseName": "standardAddress",
            "type": "RiskV1AddressVerificationsPost201ResponseAddressVerificationInformationStandardAddress"
        }    ];

    static getAttributeTypeMap() {
        return RiskV1AddressVerificationsPost201ResponseAddressVerificationInformation.attributeTypeMap;
    }
}

export class RiskV1AddressVerificationsPost201ResponseAddressVerificationInformationBarCode {
    /**
    * Delivery point bar code determined from the input address.
    */
    'value'?: string;
    /**
    * Check digit for the 11-digit delivery point bar code.
    */
    'checkDigit'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "value",
            "baseName": "value",
            "type": "string"
        },
        {
            "name": "checkDigit",
            "baseName": "checkDigit",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return RiskV1AddressVerificationsPost201ResponseAddressVerificationInformationBarCode.attributeTypeMap;
    }
}

export class RiskV1AddressVerificationsPost201ResponseAddressVerificationInformationStandardAddress {
    'address1'?: RiskV1AddressVerificationsPost201ResponseAddressVerificationInformationStandardAddressAddress1;
    /**
    * Second line of the standardized address.
    */
    'address2'?: string;
    /**
    * Third line of the standardized address.
    */
    'address3'?: string;
    /**
    * Fourth line of the standardized address.
    */
    'address4'?: string;
    /**
    * Standardized city name.
    */
    'locality'?: string;
    /**
    * U.S. county if available.
    */
    'county'?: string;
    /**
    * Standardized country name.
    */
    'country'?: string;
    /**
    * Standardized city, state or province, and ZIP +4 code or postal code line.
    */
    'csz'?: string;
    /**
    * Standardized two-character ISO country code.
    */
    'isoCountry'?: string;
    /**
    * U.S.P.S. standardized state or province abbreviation.
    */
    'administrativeArea'?: string;
    /**
    * Standardized U.S. ZIP + 4 postal code.
    */
    'postalCode'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "address1",
            "baseName": "address1",
            "type": "RiskV1AddressVerificationsPost201ResponseAddressVerificationInformationStandardAddressAddress1"
        },
        {
            "name": "address2",
            "baseName": "address2",
            "type": "string"
        },
        {
            "name": "address3",
            "baseName": "address3",
            "type": "string"
        },
        {
            "name": "address4",
            "baseName": "address4",
            "type": "string"
        },
        {
            "name": "locality",
            "baseName": "locality",
            "type": "string"
        },
        {
            "name": "county",
            "baseName": "county",
            "type": "string"
        },
        {
            "name": "country",
            "baseName": "country",
            "type": "string"
        },
        {
            "name": "csz",
            "baseName": "csz",
            "type": "string"
        },
        {
            "name": "isoCountry",
            "baseName": "isoCountry",
            "type": "string"
        },
        {
            "name": "administrativeArea",
            "baseName": "administrativeArea",
            "type": "string"
        },
        {
            "name": "postalCode",
            "baseName": "postalCode",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return RiskV1AddressVerificationsPost201ResponseAddressVerificationInformationStandardAddress.attributeTypeMap;
    }
}

export class RiskV1AddressVerificationsPost201ResponseAddressVerificationInformationStandardAddressAddress1 {
    /**
    * First line of the standardized address, including apartment information.
    */
    'withApartment'?: string;
    /**
    * First line of the standardized address, without apartment information. Returned for U.S. and Canadian addresses. 
    */
    'withoutApartment'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "withApartment",
            "baseName": "withApartment",
            "type": "string"
        },
        {
            "name": "withoutApartment",
            "baseName": "withoutApartment",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return RiskV1AddressVerificationsPost201ResponseAddressVerificationInformationStandardAddressAddress1.attributeTypeMap;
    }
}

export class RiskV1AddressVerificationsPost201ResponseErrorInformation {
    /**
    * The reason of the status. Value can be   - `APARTMENT_NUMBER_NOT_FOUND`   - `INSUFFICIENT_ADDRESS_INFORMATION`   - `HOUSE_OR_BOX_NUMBER_NOT_FOUND`   - `MULTIPLE_ADDRESS_MATCHES`   - `BOX_NUMBER_NOT_FOUND`   - `ROUTE_SERVICE_NOT_FOUND`   - `STREET_NAME_NOT_FOUND`   - `POSTAL_CODE_NOT_FOUND`   - `UNVERIFIABLE_ADDRESS`   - `MULTIPLE_ADDRESS_MATCHES_INTERNATIONAL`   - `ADDRESS_MATCH_NOT_FOUND`   - `UNSUPPORTED_CHARACTER_SET`   - `INVALID_MERCHANT_CONFIGURATION` 
    */
    'reason'?: string;
    /**
    * The detail message related to the status and reason listed above.
    */
    'message'?: string;
    'details'?: Array<PtsV2PaymentsPost201ResponseErrorInformationDetails>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "reason",
            "baseName": "reason",
            "type": "string"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        },
        {
            "name": "details",
            "baseName": "details",
            "type": "Array<PtsV2PaymentsPost201ResponseErrorInformationDetails>"
        }    ];

    static getAttributeTypeMap() {
        return RiskV1AddressVerificationsPost201ResponseErrorInformation.attributeTypeMap;
    }
}

export class RiskV1AuthenticationResultsPost201Response {
    'links'?: PtsV2IncrementalAuthorizationPatch201ResponseLinks;
    /**
    * An unique identification number generated by Cybersource to identify the submitted request. Returned by all services. It is also appended to the endpoint of the resource. On incremental authorizations, this value with be the same as the identification number returned in the original authorization response. 
    */
    'id'?: string;
    /**
    * Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ` **Example** `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.). The `T` separates the date and the time. The `Z` indicates UTC.  Returned by Cybersource for all services. 
    */
    'submitTimeUtc'?: string;
    /**
    * The status for payerAuthentication 201 enroll and validate calls. Possible values are: - `AUTHENTICATION_SUCCESSFUL` - `PENDING_AUTHENTICATION` - `AUTHENTICATION_FAILED` 
    */
    'status'?: string;
    /**
    * The message describing the reason of the status. Value is: - The cardholder is enrolled in Payer Authentication. Please authenticate the cardholder before continuing with the transaction. 
    */
    'message'?: string;
    'clientReferenceInformation'?: RiskV1DecisionsPost201ResponseClientReferenceInformation;
    'consumerAuthenticationInformation'?: RiskV1AuthenticationResultsPost201ResponseConsumerAuthenticationInformation;
    'errorInformation'?: RiskV1AuthenticationsPost201ResponseErrorInformation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "PtsV2IncrementalAuthorizationPatch201ResponseLinks"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "submitTimeUtc",
            "baseName": "submitTimeUtc",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        },
        {
            "name": "clientReferenceInformation",
            "baseName": "clientReferenceInformation",
            "type": "RiskV1DecisionsPost201ResponseClientReferenceInformation"
        },
        {
            "name": "consumerAuthenticationInformation",
            "baseName": "consumerAuthenticationInformation",
            "type": "RiskV1AuthenticationResultsPost201ResponseConsumerAuthenticationInformation"
        },
        {
            "name": "errorInformation",
            "baseName": "errorInformation",
            "type": "RiskV1AuthenticationsPost201ResponseErrorInformation"
        }    ];

    static getAttributeTypeMap() {
        return RiskV1AuthenticationResultsPost201Response.attributeTypeMap;
    }
}

export class RiskV1AuthenticationResultsPost201ResponseConsumerAuthenticationInformation {
    /**
    * Identifies the UI Type the ACS will use to complete the challenge. **NOTE**: Only available for App transactions using the Cardinal Mobile SDK. 
    */
    'acsRenderingType'?: string;
    /**
    * Unique identifier assigned by the EMVCo Secretariat upon Testing and Approval.
    */
    'acsReferenceNumber'?: string;
    /**
    * Unique transaction identifier assigned by the ACS to identify a single transaction. 
    */
    'acsTransactionId'?: string;
    /**
    * Directory Server assigned ACS identifier.
    */
    'acsOperatorID'?: string;
    /**
    * Raw authentication data that comes from the cardissuing bank. Primary authentication field that indicates if authentication was successful and if liability shift occurred. You should examine first the result of this field. This field contains one of these values: - `-1`: Invalid PARes. - `0`: Successful validation. - `1`: Cardholder is not participating, but the attempt to authenticate was recorded. - `6`: Issuer unable to perform authentication. - `9`: Cardholder did not complete authentication. 
    */
    'authenticationResult'?: string;
    /**
    * Indicates the type of authentication that will be used to challenge the card holder.  Possible Values:  01 - Static  02 - Dynamic  03 - OOB (Out of Band)  04 - Decoupled  20 - OTP hosted at merchant end. (Rupay S2S flow) **NOTE**:  EMV 3-D Secure version 2.1.0 supports values 01-03.  Version 2.2.0 supports values 01-04.  Decoupled authentication is not supported at this time. 
    */
    'authenticationType'?: string;
    /**
    * Message that explains the authenticationResult reply field. 
    */
    'authenticationStatusMsg'?: string;
    /**
    * Payer authentication transaction identifier is used to link the check enrollment and validate authentication messages. For Rupay, this field should be passed as request only for Resend OTP use case. 
    */
    'authenticationTransactionId'?: string;
    /**
    * Payer authentication transaction identifier passed to link the validation and authorization calls. 
    */
    'authenticationTransactionContextId'?: string;
    /**
    * Web based token used to authenticate consumer with Rupay authentication provider. 
    */
    'transactionToken'?: string;
    /**
    * The Base64 encoded JSON Payload of CB specific Authorization Values returned in the challenge Flow 
    */
    'authorizationPayload'?: string;
    /**
    * Unique identifier generated by the card-issuing bank for Visa, American Express, JCB, Diners Club, and Discover transactions after the customer is authenticated. The value is in base64. When you request the card authorization service, CyberSource automatically converts the value, not the field name, to the format required by your payment processor. 
    */
    'cavv'?: string;
    /**
    * Field that is returned only when the CAVV is generated, which occurs when paresStatus contains the values Y (successful authentication) or A (attempted authentication). If you use the ATOS processor, send the value of this field in the `cavv_algorithm` request field of the authorization service. This field contains one of these values: - `2`: Visa, American Express, JCB, Diners Club, and Discover - `3`: Mastercard 
    */
    'cavvAlgorithm'?: string;
    /**
    * An indicator as to why the transaction was canceled. Possible Values:  - `01`: Cardholder selected Cancel. - `02`: Reserved for future EMVCo use (values invalid until defined by EMVCo). - `03`: Transaction Timed Out—Decoupled Authentication - `04`: Transaction timed out at ACS—other timeouts - `05`: Transaction Timed out at ACS - First CReq not received by ACS - `06`: Transaction Error - `07`: Unknown - `08`: Transaction Timed Out at SDK 
    */
    'challengeCancelCode'?: string;
    /**
    * The directory server error code indicating a problem with this transaction. Note - Max Length of this field is typically 3 characters. 
    */
    'directoryServerErrorCode'?: string;
    /**
    * Directory server text and additional detail about the error for this transaction. 
    */
    'directoryServerErrorDescription'?: string;
    /**
    * This field describes the type of 3DS transaction flow that took place.  It can be one of three possible flows; CH - Challenge FR - Frictionless FD - Frictionless with delegation, (challenge not generated by the issuer but by the scheme on behalf of the issuer). 
    */
    'effectiveAuthenticationType'?: string;
    /**
    * Indicator used to differentiate Internet transactions from other types. The authentication failed if this field is not returned. For Visa, if your payment processor is Streamline, Barclays, AIBMS, or FDC Germany, you receive the value vbv_failure instead of internet when eci is 07. The value of this field is passed automatically to the authorization service if you request the services together. This field contains one of these values: - `aesk`: American Express SafeKey authentication verified successfully. - `aesk_attempted`: Card not enrolled in American Express SafeKey, but the attempt to authenticate was recorded. - `dipb`: Discover ProtectBuy authentication verified successfully. - `dipb_attempted`: Card not enrolled in Discover ProtectBuy, but the attempt to authenticate was recorded. - `internet`: Authentication was not verified successfully. - `js`: J/Secure authentication verified successfully. - `js_attempted`: Card not enrolled in J/Secure, but the attempt to authenticate was recorded. - `moto`: Mail or telephone order. - `pb_attempted`: Card not enrolled in Diners Club ProtectBuy, but the attempt to authenticate was recorded. - `recurring`: Recurring transaction. - `spa`: Mastercard Identity Check authentication verified successfully. - `spa_failure`: Mastercard Identity Check failed authentication. - `vbv`: Visa Secure authentication verified successfully. - `vbv_attempted`: Card not enrolled in Visa Secure, but the attempt to authenticate was recorded. - `vbv_failure`: Visa Secure authentication unavailable. 
    */
    'indicator'?: string;
    /**
    * Indicates the number of authentication cycles attempted by the cardholder and is tracked by the Issuing Banks ACS.Example: if customer gets the challenge window and enter in their one time password and hit submit then that interaction counter should just be 1. When customer gets the challenge window and the bank asks if they want to have the one time password  sent to their phone or their email and they have to choose before going to the next screen to enter in their one time password then this interaction count would be 2. One for the selection of how they want the one time password delivered and another with them actually entering in the one time password and hitting the submit button. 
    */
    'interactionCounter'?: string;
    /**
    * Note This field applies only to non-U.S-issued cards.  For enroll, Numeric electronic commerce indicator (ECI) returned only for Visa, American Express, JCB, Diners Club, and Discover transactions when the card is not enrolled. For more information, see \"Interpreting the Reply,\" page 22.  If you are not using the CyberSource payment services, you must send this value to your payment processor in the subsequent request for card authorization. This field contains one of these values: - `06`: The card can be enrolled. Liability shift. - `07`: The card cannot be enrolled. No liability shift.  For validate, Numeric electronic commerce indicator (ECI) returned only for Visa, American Express, JCB, Diners Club, and Discover transactions. The field is absent when authentication fails. You must send this value to your payment processor in the subsequent request for card authorization. This field contains one of these values: - `05`: Successful authentication - `06`: Authentication attempted - `07`: Failed authentication (No response from the merchant because of a problem.) 
    */
    'eci'?: string;
    /**
    * ECI value that can be returned for Visa, Mastercard, American Express, JCB, Diners Club, and Discover. The field is absent when authentication fails. If your payment processor is Streamline, you must pass the value of this field instead of the value of `eci` or `ucafCollectionIndicator`.  This field can contain one of these values: - `01`: Authentication attempted (Mastercard) - `02`: Successful authentication (Mastercard) - `05`: Successful authentication (Visa, American Express, JCB, Diners Club, and Discover) - `06`: Authentication attempted (Visa, American Express, JCB, Diners Club, and Discover) 
    */
    'eciRaw'?: string;
    /**
    * Raw result of the authentication check. If you are configured for Asia, Middle East, and Africa Gateway Processing, you need to send the value of this field in your authorization request. This field can contain one of these values: - `A`: Proof of authentication attempt was generated. - `N`: Customer failed or canceled authentication. Transaction denied. - `U`: Authentication not completed regardless of the reason. - `Y`: Customer was successfully authenticated. 
    */
    'paresStatus'?: string;
    /**
    * SDK unique transaction identifier that is generated on each new transaction. 
    */
    'sdkTransactionId'?: string;
    /**
    * This field contains the 3D Secure version that was used to process the transaction. For example: 2.2.0 
    */
    'specificationVersion'?: string;
    /**
    * Unique transaction identifier assigned by the 3DS Server to identify a single transaction. 
    */
    'threeDSServerTransactionId'?: string;
    /**
    * AAV is a unique identifier generated by the card-issuing bank for Mastercard Identity Check transactions after the customer is authenticated. The value is in base64. Include the data in the card authorization request. 
    */
    'ucafAuthenticationData'?: string;
    /**
    * For enroll, Returned only for Mastercard transactions. Indicates that authentication is not required because the customer is not enrolled. Add the value of this field to the authorization field ucaf_collection_indicator. This field can contain these values: 0, 1.  For validate, Numeric electronic commerce indicator (ECI) returned only for Mastercard Identity Check transactions. The field is absent when authentication fails. You must send this value to your payment processor in the request for card authorization. This field contain one of these values: - `0`: Authentication data not collected, and customer authentication was not completed. - `1`: Authentication data not collected because customer authentication was not completed. - `2`: Authentication data collected because customer completed authentication. 
    */
    'ucafCollectionIndicator'?: string;
    /**
    * Enables the communication of trusted beneficiary/whitelist status between the ACS, the DS and the 3DS Requestor.  Possible Values:  Y - 3DS Requestor is whitelisted by cardholder  N - 3DS Requestor is not whitelisted by cardholder 
    */
    'whiteListStatus'?: string;
    /**
    * This data element will be populated by the system setting Whitelist Status. Possible Values: 01 - 3DS/ Server/ 02 – DS/03 - ACS 
    */
    'whiteListStatusSource'?: string;
    /**
    * Transaction identifier generated by CyberSource for successful enrollment or validation checks. Use this value, which is in base64, to match an outgoing PAReq with an incoming PARes. CyberSource forwards the XID with the card authorization service to these payment processors in these cases: - Barclays - Streamline (when the **ecommerceIndicator**`=spa`) 
    */
    'xid'?: string;
    /**
    * The Directory Server Transaction ID is generated by the Mastercard Directory Server during the authentication transaction and passed back to the merchant with the authentication results. For Cybersource Through Visanet Gateway: The value for this field corresponds to the following data in the TC 33 capture file3: Record: CP01 TCR7, Position: 114-149, Field: MC AVV Verification—Directory Server Transaction ID 
    */
    'directoryServerTransactionId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "acsRenderingType",
            "baseName": "acsRenderingType",
            "type": "string"
        },
        {
            "name": "acsReferenceNumber",
            "baseName": "acsReferenceNumber",
            "type": "string"
        },
        {
            "name": "acsTransactionId",
            "baseName": "acsTransactionId",
            "type": "string"
        },
        {
            "name": "acsOperatorID",
            "baseName": "acsOperatorID",
            "type": "string"
        },
        {
            "name": "authenticationResult",
            "baseName": "authenticationResult",
            "type": "string"
        },
        {
            "name": "authenticationType",
            "baseName": "authenticationType",
            "type": "string"
        },
        {
            "name": "authenticationStatusMsg",
            "baseName": "authenticationStatusMsg",
            "type": "string"
        },
        {
            "name": "authenticationTransactionId",
            "baseName": "authenticationTransactionId",
            "type": "string"
        },
        {
            "name": "authenticationTransactionContextId",
            "baseName": "authenticationTransactionContextId",
            "type": "string"
        },
        {
            "name": "transactionToken",
            "baseName": "transactionToken",
            "type": "string"
        },
        {
            "name": "authorizationPayload",
            "baseName": "authorizationPayload",
            "type": "string"
        },
        {
            "name": "cavv",
            "baseName": "cavv",
            "type": "string"
        },
        {
            "name": "cavvAlgorithm",
            "baseName": "cavvAlgorithm",
            "type": "string"
        },
        {
            "name": "challengeCancelCode",
            "baseName": "challengeCancelCode",
            "type": "string"
        },
        {
            "name": "directoryServerErrorCode",
            "baseName": "directoryServerErrorCode",
            "type": "string"
        },
        {
            "name": "directoryServerErrorDescription",
            "baseName": "directoryServerErrorDescription",
            "type": "string"
        },
        {
            "name": "effectiveAuthenticationType",
            "baseName": "effectiveAuthenticationType",
            "type": "string"
        },
        {
            "name": "indicator",
            "baseName": "indicator",
            "type": "string"
        },
        {
            "name": "interactionCounter",
            "baseName": "interactionCounter",
            "type": "string"
        },
        {
            "name": "eci",
            "baseName": "eci",
            "type": "string"
        },
        {
            "name": "eciRaw",
            "baseName": "eciRaw",
            "type": "string"
        },
        {
            "name": "paresStatus",
            "baseName": "paresStatus",
            "type": "string"
        },
        {
            "name": "sdkTransactionId",
            "baseName": "sdkTransactionId",
            "type": "string"
        },
        {
            "name": "specificationVersion",
            "baseName": "specificationVersion",
            "type": "string"
        },
        {
            "name": "threeDSServerTransactionId",
            "baseName": "threeDSServerTransactionId",
            "type": "string"
        },
        {
            "name": "ucafAuthenticationData",
            "baseName": "ucafAuthenticationData",
            "type": "string"
        },
        {
            "name": "ucafCollectionIndicator",
            "baseName": "ucafCollectionIndicator",
            "type": "string"
        },
        {
            "name": "whiteListStatus",
            "baseName": "whiteListStatus",
            "type": "string"
        },
        {
            "name": "whiteListStatusSource",
            "baseName": "whiteListStatusSource",
            "type": "string"
        },
        {
            "name": "xid",
            "baseName": "xid",
            "type": "string"
        },
        {
            "name": "directoryServerTransactionId",
            "baseName": "directoryServerTransactionId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return RiskV1AuthenticationResultsPost201ResponseConsumerAuthenticationInformation.attributeTypeMap;
    }
}

export class RiskV1AuthenticationSetupsPost201Response {
    'links'?: PtsV2IncrementalAuthorizationPatch201ResponseLinks;
    /**
    * An unique identification number generated by Cybersource to identify the submitted request. Returned by all services. It is also appended to the endpoint of the resource. On incremental authorizations, this value with be the same as the identification number returned in the original authorization response. 
    */
    'id'?: string;
    /**
    * Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ` **Example** `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.). The `T` separates the date and the time. The `Z` indicates UTC.  Returned by Cybersource for all services. 
    */
    'submitTimeUtc'?: string;
    /**
    * The status for payerAuthentication 201 setup calls. Possible value is: - COMPLETED - FAILED 
    */
    'status'?: string;
    'consumerAuthenticationInformation'?: RiskV1AuthenticationSetupsPost201ResponseConsumerAuthenticationInformation;
    'clientReferenceInformation'?: RiskV1DecisionsPost201ResponseClientReferenceInformation;
    'errorInformation'?: RiskV1AuthenticationSetupsPost201ResponseErrorInformation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "PtsV2IncrementalAuthorizationPatch201ResponseLinks"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "submitTimeUtc",
            "baseName": "submitTimeUtc",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "consumerAuthenticationInformation",
            "baseName": "consumerAuthenticationInformation",
            "type": "RiskV1AuthenticationSetupsPost201ResponseConsumerAuthenticationInformation"
        },
        {
            "name": "clientReferenceInformation",
            "baseName": "clientReferenceInformation",
            "type": "RiskV1DecisionsPost201ResponseClientReferenceInformation"
        },
        {
            "name": "errorInformation",
            "baseName": "errorInformation",
            "type": "RiskV1AuthenticationSetupsPost201ResponseErrorInformation"
        }    ];

    static getAttributeTypeMap() {
        return RiskV1AuthenticationSetupsPost201Response.attributeTypeMap;
    }
}

export class RiskV1AuthenticationSetupsPost201ResponseConsumerAuthenticationInformation {
    /**
    * JSON Web Token (JWT) used to authenticate the consumer with the authentication provider, such as, CardinalCommerce or Rupay. Note - Max Length of this field is 2048 characters. 
    */
    'accessToken'?: string;
    /**
    * This identifier represents cardinal has started device data collection session and this must be passed in Authentication JWT to Cardinal when invoking the deviceDataCollectionUrl. 
    */
    'referenceId'?: string;
    /**
    * The deviceDataCollectionUrl is the location to send the Authentication JWT when invoking the Device Data collection process. 
    */
    'deviceDataCollectionUrl'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "accessToken",
            "baseName": "accessToken",
            "type": "string"
        },
        {
            "name": "referenceId",
            "baseName": "referenceId",
            "type": "string"
        },
        {
            "name": "deviceDataCollectionUrl",
            "baseName": "deviceDataCollectionUrl",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return RiskV1AuthenticationSetupsPost201ResponseConsumerAuthenticationInformation.attributeTypeMap;
    }
}

export class RiskV1AuthenticationSetupsPost201ResponseErrorInformation {
    /**
    * The reason of the status.  Possible values:  - EXPIRED_CARD  - GENERAL_DECLINE 
    */
    'reason'?: string;
    /**
    * The detail message related to the status and reason listed above.
    */
    'message'?: string;
    'details'?: Array<PtsV2PaymentsPost201ResponseErrorInformationDetails>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "reason",
            "baseName": "reason",
            "type": "string"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        },
        {
            "name": "details",
            "baseName": "details",
            "type": "Array<PtsV2PaymentsPost201ResponseErrorInformationDetails>"
        }    ];

    static getAttributeTypeMap() {
        return RiskV1AuthenticationSetupsPost201ResponseErrorInformation.attributeTypeMap;
    }
}

export class RiskV1AuthenticationsPost201Response {
    'links'?: PtsV2IncrementalAuthorizationPatch201ResponseLinks;
    /**
    * An unique identification number generated by Cybersource to identify the submitted request. Returned by all services. It is also appended to the endpoint of the resource. On incremental authorizations, this value with be the same as the identification number returned in the original authorization response. 
    */
    'id'?: string;
    /**
    * Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ` **Example** `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.). The `T` separates the date and the time. The `Z` indicates UTC.  Returned by Cybersource for all services. 
    */
    'submitTimeUtc'?: string;
    /**
    * The status for payerAuthentication 201 enroll and validate calls. Possible values are: - `AUTHENTICATION_SUCCESSFUL` - `PENDING_AUTHENTICATION` - `AUTHENTICATION_FAILED` 
    */
    'status'?: string;
    /**
    * The message describing the reason of the status. Value is: - The cardholder is enrolled in Payer Authentication. Please authenticate the cardholder before continuing with the transaction. 
    */
    'message'?: string;
    'clientReferenceInformation'?: RiskV1DecisionsPost201ResponseClientReferenceInformation;
    'orderInformation'?: RiskV1DecisionsPost201ResponseOrderInformation;
    'consumerAuthenticationInformation'?: RiskV1DecisionsPost201ResponseConsumerAuthenticationInformation;
    'errorInformation'?: RiskV1AuthenticationsPost201ResponseErrorInformation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "PtsV2IncrementalAuthorizationPatch201ResponseLinks"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "submitTimeUtc",
            "baseName": "submitTimeUtc",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        },
        {
            "name": "clientReferenceInformation",
            "baseName": "clientReferenceInformation",
            "type": "RiskV1DecisionsPost201ResponseClientReferenceInformation"
        },
        {
            "name": "orderInformation",
            "baseName": "orderInformation",
            "type": "RiskV1DecisionsPost201ResponseOrderInformation"
        },
        {
            "name": "consumerAuthenticationInformation",
            "baseName": "consumerAuthenticationInformation",
            "type": "RiskV1DecisionsPost201ResponseConsumerAuthenticationInformation"
        },
        {
            "name": "errorInformation",
            "baseName": "errorInformation",
            "type": "RiskV1AuthenticationsPost201ResponseErrorInformation"
        }    ];

    static getAttributeTypeMap() {
        return RiskV1AuthenticationsPost201Response.attributeTypeMap;
    }
}

export class RiskV1AuthenticationsPost201ResponseErrorInformation {
    /**
    * The reason of the status. Possible values are: - `INVALID_MERCHANT_CONFIGURATION` - `CONSUMER_AUTHENTICATION_REQUIRED` - `CONSUMER_AUTHENTICATION_FAILED` - `AUTHENTICATION_FAILED` 
    */
    'reason'?: string;
    /**
    * The detail message related to the status and reason listed above.
    */
    'message'?: string;
    'details'?: Array<PtsV2PaymentsPost201ResponseErrorInformationDetails>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "reason",
            "baseName": "reason",
            "type": "string"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        },
        {
            "name": "details",
            "baseName": "details",
            "type": "Array<PtsV2PaymentsPost201ResponseErrorInformationDetails>"
        }    ];

    static getAttributeTypeMap() {
        return RiskV1AuthenticationsPost201ResponseErrorInformation.attributeTypeMap;
    }
}

export class RiskV1AuthenticationsPost400Response {
    /**
    * Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ` **Example** `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.). The `T` separates the date and the time. The `Z` indicates UTC.  Returned by Cybersource for all services. 
    */
    'submitTimeUtc'?: string;
    /**
    * The status for payerAuthentication 400 setup calls. Possible values are: - INVALID_REQUEST 
    */
    'status'?: string;
    /**
    * The reason of the status. 
    */
    'reason'?: string;
    /**
    * The message describing the reason of the status. Value is: - Encountered a Payer Authentication problem. Payer could not be setup. 
    */
    'message'?: string;
    'details'?: Array<PtsV2PaymentsPost201ResponseErrorInformationDetails>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "submitTimeUtc",
            "baseName": "submitTimeUtc",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "reason",
            "baseName": "reason",
            "type": "string"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        },
        {
            "name": "details",
            "baseName": "details",
            "type": "Array<PtsV2PaymentsPost201ResponseErrorInformationDetails>"
        }    ];

    static getAttributeTypeMap() {
        return RiskV1AuthenticationsPost400Response.attributeTypeMap;
    }
}

export class RiskV1AuthenticationsPost400Response1 {
    /**
    * Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ` **Example** `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.). The `T` separates the date and the time. The `Z` indicates UTC.  Returned by Cybersource for all services. 
    */
    'submitTimeUtc'?: string;
    /**
    * The status for payerAuthentication 400 enroll and validate calls. Value is: - `INVALID_REQUEST` 
    */
    'status'?: string;
    /**
    * The reason of the status.  Possible Values: - `MISSING_FIELD` - `INVALID_DATA` 
    */
    'reason'?: string;
    /**
    * The message describing the reason of the status. Value is: - Encountered a Payer Authentication problem. Payer could not be authenticated. 
    */
    'message'?: string;
    'details'?: Array<PtsV2PaymentsPost201ResponseErrorInformationDetails>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "submitTimeUtc",
            "baseName": "submitTimeUtc",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "reason",
            "baseName": "reason",
            "type": "string"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        },
        {
            "name": "details",
            "baseName": "details",
            "type": "Array<PtsV2PaymentsPost201ResponseErrorInformationDetails>"
        }    ];

    static getAttributeTypeMap() {
        return RiskV1AuthenticationsPost400Response1.attributeTypeMap;
    }
}

export class RiskV1DecisionsPost201Response {
    'links'?: PtsV2PaymentsPost201ResponseLinks;
    /**
    * An unique identification number generated by Cybersource to identify the submitted request. Returned by all services. It is also appended to the endpoint of the resource. On incremental authorizations, this value with be the same as the identification number returned in the original authorization response. 
    */
    'id'?: string;
    /**
    * Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ` **Example** `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.). The `T` separates the date and the time. The `Z` indicates UTC.  Returned by Cybersource for all services. 
    */
    'submitTimeUtc'?: string;
    /**
    * Time that the transaction was submitted in local time. Generated by Cybersource.
    */
    'submitTimeLocal'?: string;
    /**
    * The status of the submitted transaction.  Possible values:   - `ACCEPTED`   - `REJECTED`   - `PENDING_REVIEW`   - `DECLINED`   - `PENDING_AUTHENTICATION`   - `INVALID_REQUEST`   - `AUTHENTICATION_FAILED`   - `CHALLENGE` 
    */
    'status'?: string;
    'riskInformation'?: PtsV2PaymentsPost201ResponseRiskInformation;
    'paymentInformation'?: RiskV1DecisionsPost201ResponsePaymentInformation;
    'clientReferenceInformation'?: RiskV1DecisionsPost201ResponseClientReferenceInformation;
    'orderInformation'?: RiskV1DecisionsPost201ResponseOrderInformation;
    'consumerAuthenticationInformation'?: RiskV1DecisionsPost201ResponseConsumerAuthenticationInformation;
    'watchlistScreeningInformation'?: PtsV2PaymentsPost201ResponseWatchlistScreeningInformation;
    'errorInformation'?: RiskV1DecisionsPost201ResponseErrorInformation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "PtsV2PaymentsPost201ResponseLinks"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "submitTimeUtc",
            "baseName": "submitTimeUtc",
            "type": "string"
        },
        {
            "name": "submitTimeLocal",
            "baseName": "submitTimeLocal",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "riskInformation",
            "baseName": "riskInformation",
            "type": "PtsV2PaymentsPost201ResponseRiskInformation"
        },
        {
            "name": "paymentInformation",
            "baseName": "paymentInformation",
            "type": "RiskV1DecisionsPost201ResponsePaymentInformation"
        },
        {
            "name": "clientReferenceInformation",
            "baseName": "clientReferenceInformation",
            "type": "RiskV1DecisionsPost201ResponseClientReferenceInformation"
        },
        {
            "name": "orderInformation",
            "baseName": "orderInformation",
            "type": "RiskV1DecisionsPost201ResponseOrderInformation"
        },
        {
            "name": "consumerAuthenticationInformation",
            "baseName": "consumerAuthenticationInformation",
            "type": "RiskV1DecisionsPost201ResponseConsumerAuthenticationInformation"
        },
        {
            "name": "watchlistScreeningInformation",
            "baseName": "watchlistScreeningInformation",
            "type": "PtsV2PaymentsPost201ResponseWatchlistScreeningInformation"
        },
        {
            "name": "errorInformation",
            "baseName": "errorInformation",
            "type": "RiskV1DecisionsPost201ResponseErrorInformation"
        }    ];

    static getAttributeTypeMap() {
        return RiskV1DecisionsPost201Response.attributeTypeMap;
    }
}

export class RiskV1DecisionsPost201ResponseClientReferenceInformation {
    /**
    * Merchant-generated order reference or tracking number. It is recommended that you send a unique value for each transaction so that you can perform meaningful searches for the transaction.  #### Used by **Authorization** Required field.  #### PIN Debit Requests for PIN debit reversals need to use the same merchant reference number that was used in the transaction that is being reversed.  Required field for all PIN Debit requests (purchase, credit, and reversal).  #### FDC Nashville Global Certain circumstances can cause the processor to truncate this value to 15 or 17 characters for Level II and Level III processing, which can cause a discrepancy between the value you submit and the value included in some processor reports. 
    */
    'code'?: string;
    /**
    * Brief description of the order or any comment you wish to add to the order. 
    */
    'comments'?: string;
    'partner'?: Riskv1decisionsClientReferenceInformationPartner;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        },
        {
            "name": "comments",
            "baseName": "comments",
            "type": "string"
        },
        {
            "name": "partner",
            "baseName": "partner",
            "type": "Riskv1decisionsClientReferenceInformationPartner"
        }    ];

    static getAttributeTypeMap() {
        return RiskV1DecisionsPost201ResponseClientReferenceInformation.attributeTypeMap;
    }
}

export class RiskV1DecisionsPost201ResponseConsumerAuthenticationInformation {
    /**
    * JSON Web Token (JWT) used to authenticate the consumer with the authentication provider, such as, CardinalCommerce or Rupay. Note - Max Length of this field is 2048 characters. 
    */
    'accessToken'?: string;
    /**
    * Identifies the UI Type the ACS will use to complete the challenge. **NOTE**: Only available for App transactions using the Cardinal Mobile SDK. 
    */
    'acsRenderingType'?: string;
    /**
    * Unique transaction identifier assigned by the ACS to identify a single transaction. 
    */
    'acsTransactionId'?: string;
    /**
    * URL for the card-issuing bank’s authentication form that you receive when the card is enrolled. The value can be very large. 
    */
    'acsUrl'?: string;
    /**
    * Indicates what displays to the customer during the authentication process. This field can contain one of these values: - `ADS`: (Card not enrolled) customer prompted to activate the card during the checkout process. - `ATTEMPTS`: (Attempts processing) Processing briefly displays before the checkout process is completed. - `ENROLLED`: (Card enrolled) the card issuer’s authentication window displays. - `UNKNOWN`: Card enrollment status cannot be determined. - `NOREDIRECT`: (Card not enrolled, authentication unavailable, or error occurred) nothing displays to the customer.  The following values can be returned if you are using rules-based payer authentication. - `RIBA`: The card-issuing bank supports risk-based authentication, but whether the cardholder is likely to be challenged cannot be determined. - `RIBA_PASS`: The card-issuing bank supports risk-based authentication and it is likely that the cardholder will not be challenged to provide credentials, also known as _silent authentication_. 
    */
    'authenticationPath'?: string;
    /**
    * The Base64 encoded JSON Payload of CB specific Authorization Values returned in the challenge Flow 
    */
    'authorizationPayload'?: string;
    /**
    * Indicates the type of authentication that will be used to challenge the card holder.  Possible Values:  01 - Static  02 - Dynamic  03 - OOB (Out of Band)  04 - Decoupled  20 - OTP hosted at merchant end. (Rupay S2S flow) **NOTE**:  EMV 3-D Secure version 2.1.0 supports values 01-03.  Version 2.2.0 supports values 01-04.  Decoupled authentication is not supported at this time. 
    */
    'authenticationType'?: string;
    /**
    * Payer authentication transaction identifier is used to link the check enrollment and validate authentication messages. For Rupay, this field should be passed as request only for Resend OTP use case. 
    */
    'authenticationTransactionId'?: string;
    /**
    * Payer authentication transaction identifier passed to link the validation and authorization calls. 
    */
    'authenticationTransactionContextId'?: string;
    /**
    * Describes validity of OTP in minutes for incoming transaction.        . 
    */
    'validityPeriod'?: number;
    /**
    * Text provided by the ACS/Issuer to Cardholder during a Frictionless or Decoupled transaction.The Issuer can provide information to Cardholder. For example, “Additional authentication is needed for this transaction, please contact (Issuer Name) at xxx-xxx-xxxx.”. The Issuing Bank can optionally support this value. 
    */
    'cardholderMessage'?: string;
    /**
    * Unique identifier generated by the card-issuing bank for Visa, American Express, JCB, Diners Club, and Discover transactions after the customer is authenticated. The value is in base64. When you request the card authorization service, CyberSource automatically converts the value, not the field name, to the format required by your payment processor. 
    */
    'cavv'?: string;
    /**
    * Field that is returned only when the CAVV is generated, which occurs when paresStatus contains the values Y (successful authentication) or A (attempted authentication). If you use the ATOS processor, send the value of this field in the `cavv_algorithm` request field of the authorization service. This field contains one of these values: - `2`: Visa, American Express, JCB, Diners Club, and Discover - `3`: Mastercard 
    */
    'cavvAlgorithm'?: string;
    /**
    * An indicator as to why the transaction was canceled. Possible Values:  - `01`: Cardholder selected Cancel. - `02`: Reserved for future EMVCo use (values invalid until defined by EMVCo). - `03`: Transaction Timed Out—Decoupled Authentication - `04`: Transaction timed out at ACS—other timeouts - `05`: Transaction Timed out at ACS - First CReq not received by ACS - `06`: Transaction Error - `07`: Unknown - `08`: Transaction Timed Out at SDK 
    */
    'challengeCancelCode'?: string;
    /**
    * Indicates whether a challenge is required in order to complete authentication. **Note** Regional mandates might determine that a challenge is required.  Possible values: - `Y`: Challenge required - `N`: Challenge not required **Note**  Used by the Hybrid integration. 
    */
    'challengeRequired'?: string;
    /**
    * Indicates whether the 3DS Requestor requests the ACS to utilize Decoupled Authentication and agrees to utilize Decoupled Authentication if the ACS confirms its use.  Possible Values:  Y - Decoupled Authentication is supported and preferred if challenge is necessary  N - Do not use Decoupled Authentication  **Default Value**: N 
    */
    'decoupledAuthenticationIndicator'?: string;
    /**
    * The directory server error code indicating a problem with this transaction. Note - Max Length of this field is typically 3 characters. 
    */
    'directoryServerErrorCode'?: string;
    /**
    * Directory server text and additional detail about the error for this transaction. 
    */
    'directoryServerErrorDescription'?: string;
    /**
    * Commerce indicator for cards not enrolled. This field contains one of these values: - `internet`: Card not enrolled, or card type not supported by payer authentication. No liability shift. - `js_attempted`: Card not enrolled, but attempt to authenticate is recorded. Liability shift. - `js_failure`: J/Secure directory service is not available. No liability shift. - `spa`: Mastercard card not enrolled in the SecureCode program. No liability shift. - `vbv_attempted`: Card not enrolled, but attempt to authenticate is recorded. Liability shift. - `vbv_failure`: For payment processor Barclays, Streamline, AIBMS, or FDC Germany, you receive this result if Visa’s directory service is not available. No liability shift. 
    */
    'ecommerceIndicator'?: string;
    /**
    * Note This field applies only to non-U.S-issued cards.  For enroll, Numeric electronic commerce indicator (ECI) returned only for Visa, American Express, JCB, Diners Club, and Discover transactions when the card is not enrolled. For more information, see \"Interpreting the Reply,\" page 22.  If you are not using the CyberSource payment services, you must send this value to your payment processor in the subsequent request for card authorization. This field contains one of these values: - `06`: The card can be enrolled. Liability shift. - `07`: The card cannot be enrolled. No liability shift.  For validate, Numeric electronic commerce indicator (ECI) returned only for Visa, American Express, JCB, Diners Club, and Discover transactions. The field is absent when authentication fails. You must send this value to your payment processor in the subsequent request for card authorization. This field contains one of these values: - `05`: Successful authentication - `06`: Authentication attempted - `07`: Failed authentication (No response from the merchant because of a problem.) 
    */
    'eci'?: string;
    /**
    * ECI value that can be returned for Visa, Mastercard, American Express, JCB, Diners Club, and Discover. The field is absent when authentication fails. If your payment processor is Streamline, you must pass the value of this field instead of the value of `eci` or `ucafCollectionIndicator`.  This field can contain one of these values: - `01`: Authentication attempted (Mastercard) - `02`: Successful authentication (Mastercard) - `05`: Successful authentication (Visa, American Express, JCB, Diners Club, and Discover) - `06`: Authentication attempted (Visa, American Express, JCB, Diners Club, and Discover) 
    */
    'eciRaw'?: string;
    /**
    * This field describes the type of 3DS transaction flow that took place.  It can be one of three possible flows; CH - Challenge FR - Frictionless FD - Frictionless with delegation, (challenge not generated by the issuer but by the scheme on behalf of the issuer). 
    */
    'effectiveAuthenticationType'?: string;
    /**
    * Payer authentication exemption indicator for Carte Bancaire exemptions.  This is used with unbundled authentication and authorizations calls, for example: \"low fraud merchant program\". The value returned in this field should be passed in the authorization request under the field - `consumerAuthenticationInformation.strongAuthentication.issuerInformation.exemptionDataRaw`. 
    */
    'exemptionDataRaw'?: string;
    'ivr'?: PtsV2PaymentsPost201ResponseConsumerAuthenticationInformationIvr;
    /**
    * The global score calculated by the CB scoring platform and returned to merchants. 
    */
    'networkScore'?: string;
    /**
    * Payer authentication request (PAReq) message that you need to forward to the ACS. The value can be very large. The value is in base64. 
    */
    'pareq'?: string;
    /**
    * Raw result of the authentication check. If you are configured for Asia, Middle East, and Africa Gateway Processing, you need to send the value of this field in your authorization request. This field can contain one of these values: - `A`: Proof of authentication attempt was generated. - `N`: Customer failed or canceled authentication. Transaction denied. - `U`: Authentication not completed regardless of the reason. - `Y`: Customer was successfully authenticated. 
    */
    'paresStatus'?: string;
    /**
    * Date and time of the enrollment check combined with the VEReq and VERes elements. If you ever need to show proof of enrollment checking, you may need to parse the string for the information required by the payment card company. The value can be very large.  For cards issued in the U.S. or Canada, Visa may require this data for specific merchant category codes.For cards not issued in the U.S. or Canada, your bank may require this data as proof of enrollment checking for any payer authentication transaction that you re-present because of a chargeback. 
    */
    'proofXml'?: string;
    /**
    * Encrypted version of the card number used in the payer authentication request message. 
    */
    'proxyPan'?: string;
    /**
    * SDK unique transaction identifier that is generated on each new transaction. 
    */
    'sdkTransactionId'?: string;
    /**
    * Provides additional information as to why the PAResStatus has a specific value. 
    */
    'signedParesStatusReason'?: string;
    /**
    * This field contains the 3D Secure version that was used to process the transaction. For example: 2.2.0 
    */
    'specificationVersion'?: string;
    /**
    * The fully qualified URL that the merchant uses to post a form to the cardholder in order to complete the Consumer Authentication transaction for the Cardinal Cruise API integration. 
    */
    'stepUpUrl'?: string;
    /**
    * Unique transaction identifier assigned by the 3DS Server to identify a single transaction. 
    */
    'threeDSServerTransactionId'?: string;
    /**
    * AAV is a unique identifier generated by the card-issuing bank for Mastercard Identity Check transactions after the customer is authenticated. The value is in base64. Include the data in the card authorization request. 
    */
    'ucafAuthenticationData'?: string;
    /**
    * For enroll, Returned only for Mastercard transactions. Indicates that authentication is not required because the customer is not enrolled. Add the value of this field to the authorization field ucaf_collection_indicator. This field can contain these values: 0, 1.  For validate, Numeric electronic commerce indicator (ECI) returned only for Mastercard Identity Check transactions. The field is absent when authentication fails. You must send this value to your payment processor in the request for card authorization. This field contain one of these values: - `0`: Authentication data not collected, and customer authentication was not completed. - `1`: Authentication data not collected because customer authentication was not completed. - `2`: Authentication data collected because customer completed authentication. 
    */
    'ucafCollectionIndicator'?: string;
    /**
    * Result of the enrollment check. This field can contain one of these values: - `Y`: Card enrolled or can be enrolled; you must authenticate. Liability shift. - `N`: Card not enrolled; proceed with authorization. Liability shift. - `U`: Unable to authenticate regardless of the reason. No liability shift.  **Note** This field only applies to the Asia, Middle East, and Africa Gateway. If you are configured for this processor, you must send the value of this field in your authorization request.  The following value can be returned if you are using rules-based Payer Authentication: - `B`: Indicates that authentication was bypassed. 
    */
    'veresEnrolled'?: string;
    /**
    * This data element will be populated by the system setting Whitelist Status. Possible Values: 01 - 3DS/ Server/ 02 – DS/03 - ACS 
    */
    'whiteListStatusSource'?: string;
    /**
    * Transaction identifier generated by CyberSource for successful enrollment or validation checks. Use this value, which is in base64, to match an outgoing PAReq with an incoming PARes. CyberSource forwards the XID with the card authorization service to these payment processors in these cases: - Barclays - Streamline (when the **ecommerceIndicator**`=spa`) 
    */
    'xid'?: string;
    /**
    * The Directory Server Transaction ID is generated by the Mastercard Directory Server during the authentication transaction and passed back to the merchant with the authentication results. For Cybersource Through Visanet Gateway: The value for this field corresponds to the following data in the TC 33 capture file3: Record: CP01 TCR7, Position: 114-149, Field: MC AVV Verification—Directory Server Transaction ID 
    */
    'directoryServerTransactionId'?: string;
    /**
    * Directory Server assigned ACS identifier.
    */
    'acsOperatorID'?: string;
    /**
    * Unique identifier assigned by the EMVCo Secretariat upon Testing and Approval.
    */
    'acsReferenceNumber'?: string;
    /**
    * Decision on the Risk Assessment from Mastercard.
    */
    'idciDecision'?: string;
    /**
    * ReasonCode from Mastercard
    */
    'idciReasonCode1'?: string;
    /**
    * ReasonCode from Mastercard
    */
    'idciReasonCode2'?: string;
    /**
    * Risk Assessment from Mastercard
    */
    'idciScore'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "accessToken",
            "baseName": "accessToken",
            "type": "string"
        },
        {
            "name": "acsRenderingType",
            "baseName": "acsRenderingType",
            "type": "string"
        },
        {
            "name": "acsTransactionId",
            "baseName": "acsTransactionId",
            "type": "string"
        },
        {
            "name": "acsUrl",
            "baseName": "acsUrl",
            "type": "string"
        },
        {
            "name": "authenticationPath",
            "baseName": "authenticationPath",
            "type": "string"
        },
        {
            "name": "authorizationPayload",
            "baseName": "authorizationPayload",
            "type": "string"
        },
        {
            "name": "authenticationType",
            "baseName": "authenticationType",
            "type": "string"
        },
        {
            "name": "authenticationTransactionId",
            "baseName": "authenticationTransactionId",
            "type": "string"
        },
        {
            "name": "authenticationTransactionContextId",
            "baseName": "authenticationTransactionContextId",
            "type": "string"
        },
        {
            "name": "validityPeriod",
            "baseName": "validityPeriod",
            "type": "number"
        },
        {
            "name": "cardholderMessage",
            "baseName": "cardholderMessage",
            "type": "string"
        },
        {
            "name": "cavv",
            "baseName": "cavv",
            "type": "string"
        },
        {
            "name": "cavvAlgorithm",
            "baseName": "cavvAlgorithm",
            "type": "string"
        },
        {
            "name": "challengeCancelCode",
            "baseName": "challengeCancelCode",
            "type": "string"
        },
        {
            "name": "challengeRequired",
            "baseName": "challengeRequired",
            "type": "string"
        },
        {
            "name": "decoupledAuthenticationIndicator",
            "baseName": "decoupledAuthenticationIndicator",
            "type": "string"
        },
        {
            "name": "directoryServerErrorCode",
            "baseName": "directoryServerErrorCode",
            "type": "string"
        },
        {
            "name": "directoryServerErrorDescription",
            "baseName": "directoryServerErrorDescription",
            "type": "string"
        },
        {
            "name": "ecommerceIndicator",
            "baseName": "ecommerceIndicator",
            "type": "string"
        },
        {
            "name": "eci",
            "baseName": "eci",
            "type": "string"
        },
        {
            "name": "eciRaw",
            "baseName": "eciRaw",
            "type": "string"
        },
        {
            "name": "effectiveAuthenticationType",
            "baseName": "effectiveAuthenticationType",
            "type": "string"
        },
        {
            "name": "exemptionDataRaw",
            "baseName": "exemptionDataRaw",
            "type": "string"
        },
        {
            "name": "ivr",
            "baseName": "ivr",
            "type": "PtsV2PaymentsPost201ResponseConsumerAuthenticationInformationIvr"
        },
        {
            "name": "networkScore",
            "baseName": "networkScore",
            "type": "string"
        },
        {
            "name": "pareq",
            "baseName": "pareq",
            "type": "string"
        },
        {
            "name": "paresStatus",
            "baseName": "paresStatus",
            "type": "string"
        },
        {
            "name": "proofXml",
            "baseName": "proofXml",
            "type": "string"
        },
        {
            "name": "proxyPan",
            "baseName": "proxyPan",
            "type": "string"
        },
        {
            "name": "sdkTransactionId",
            "baseName": "sdkTransactionId",
            "type": "string"
        },
        {
            "name": "signedParesStatusReason",
            "baseName": "signedParesStatusReason",
            "type": "string"
        },
        {
            "name": "specificationVersion",
            "baseName": "specificationVersion",
            "type": "string"
        },
        {
            "name": "stepUpUrl",
            "baseName": "stepUpUrl",
            "type": "string"
        },
        {
            "name": "threeDSServerTransactionId",
            "baseName": "threeDSServerTransactionId",
            "type": "string"
        },
        {
            "name": "ucafAuthenticationData",
            "baseName": "ucafAuthenticationData",
            "type": "string"
        },
        {
            "name": "ucafCollectionIndicator",
            "baseName": "ucafCollectionIndicator",
            "type": "string"
        },
        {
            "name": "veresEnrolled",
            "baseName": "veresEnrolled",
            "type": "string"
        },
        {
            "name": "whiteListStatusSource",
            "baseName": "whiteListStatusSource",
            "type": "string"
        },
        {
            "name": "xid",
            "baseName": "xid",
            "type": "string"
        },
        {
            "name": "directoryServerTransactionId",
            "baseName": "directoryServerTransactionId",
            "type": "string"
        },
        {
            "name": "acsOperatorID",
            "baseName": "acsOperatorID",
            "type": "string"
        },
        {
            "name": "acsReferenceNumber",
            "baseName": "acsReferenceNumber",
            "type": "string"
        },
        {
            "name": "idciDecision",
            "baseName": "idciDecision",
            "type": "string"
        },
        {
            "name": "idciReasonCode1",
            "baseName": "idciReasonCode1",
            "type": "string"
        },
        {
            "name": "idciReasonCode2",
            "baseName": "idciReasonCode2",
            "type": "string"
        },
        {
            "name": "idciScore",
            "baseName": "idciScore",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return RiskV1DecisionsPost201ResponseConsumerAuthenticationInformation.attributeTypeMap;
    }
}

export class RiskV1DecisionsPost201ResponseErrorInformation {
    /**
    * The reason of the status.  Possible values:  - `EXPIRED_CARD`  - `SCORE_EXCEEDS_THRESHOLD`  - `DECISION_PROFILE_REVIEW`  - `DECISION_PROFILE_REJECT`  - `CONSUMER_AUTHENTICATION_REQUIRED`  - `INVALID_MERCHANT_CONFIGURATION`  - `CONSUMER_AUTHENTICATION_FAILED`  - `DECISION_PROFILE_CHALLENGE`  - `CUSTOMER_WATCHLIST_MATCH`  - `ADDRESS_COUNTRY_WATCHLIST_MATCH`  - `EMAIL_COUNTRY_WATCHLIST_MATCH`  - `IP_COUNTRY_WATCHLIST_MATCH` 
    */
    'reason'?: string;
    /**
    * The detail message related to the status and reason listed above.
    */
    'message'?: string;
    'details'?: Array<PtsV2PaymentsPost201ResponseErrorInformationDetails>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "reason",
            "baseName": "reason",
            "type": "string"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        },
        {
            "name": "details",
            "baseName": "details",
            "type": "Array<PtsV2PaymentsPost201ResponseErrorInformationDetails>"
        }    ];

    static getAttributeTypeMap() {
        return RiskV1DecisionsPost201ResponseErrorInformation.attributeTypeMap;
    }
}

export class RiskV1DecisionsPost201ResponseOrderInformation {
    'amountDetails'?: RiskV1DecisionsPost201ResponseOrderInformationAmountDetails;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "amountDetails",
            "baseName": "amountDetails",
            "type": "RiskV1DecisionsPost201ResponseOrderInformationAmountDetails"
        }    ];

    static getAttributeTypeMap() {
        return RiskV1DecisionsPost201ResponseOrderInformation.attributeTypeMap;
    }
}

export class RiskV1DecisionsPost201ResponseOrderInformationAmountDetails {
    /**
    * Currency used for the order. Use the three-character [ISO Standard Currency Codes.](http://apps.cybersource.com/library/documentation/sbc/quickref/currencies.pdf)  #### Used by **Authorization** Required field.  **Authorization Reversal** For an authorization reversal (`reversalInformation`) or a capture (`processingOptions.capture` is set to `true`), you must use the same currency that you used in your payment authorization request.  #### PIN Debit Currency for the amount you requested for the PIN debit purchase. This value is returned for partial authorizations. The issuing bank can approve a partial amount if the balance on the debit card is less than the requested transaction amount. For the possible values, see the [ISO Standard Currency Codes](https://developer.cybersource.com/library/documentation/sbc/quickref/currencies.pdf). Returned by PIN debit purchase.  For PIN debit reversal requests, you must use the same currency that was used for the PIN debit purchase or PIN debit credit that you are reversing. For the possible values, see the [ISO Standard Currency Codes](https://developer.cybersource.com/library/documentation/sbc/quickref/currencies.pdf).  Required field for PIN Debit purchase and PIN Debit credit requests. Optional field for PIN Debit reversal requests.  #### GPX This field is optional for reversing an authorization or credit.  #### DCC for First Data Your local currency.  #### Tax Calculation Required for international tax and value added tax only. Optional for U.S. and Canadian taxes. Your local currency. 
    */
    'currency'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "currency",
            "baseName": "currency",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return RiskV1DecisionsPost201ResponseOrderInformationAmountDetails.attributeTypeMap;
    }
}

/**
* Contains response information about the payment.
*/
export class RiskV1DecisionsPost201ResponsePaymentInformation {
    /**
    * Country (two-digit country code) associated with the BIN of the customer’s card used for the payment. Returned if the information is available. Use this field for additional information when reviewing orders. This information is also displayed in the details page of the CyberSource Business Center. 
    */
    'binCountry'?: string;
    /**
    * Type of payment card account. This field can refer to a credit card, debit card, or prepaid card account type. 
    */
    'accountType'?: string;
    /**
    * Name of the bank or entity that issued the card account. 
    */
    'issuer'?: string;
    /**
    * Subtype of card account. This field can contain one of the following values: - Maestro International - Maestro UK Domestic - MasterCard Credit - MasterCard Debit - Visa Credit - Visa Debit - Visa Electron  **Note** Additional values may be present. 
    */
    'scheme'?: string;
    /**
    * Credit card BIN (the first six digits of the credit card).Derived either from the `cc_bin` request field or from the first six characters of the `customer_cc_num` field. 
    */
    'bin'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "binCountry",
            "baseName": "binCountry",
            "type": "string"
        },
        {
            "name": "accountType",
            "baseName": "accountType",
            "type": "string"
        },
        {
            "name": "issuer",
            "baseName": "issuer",
            "type": "string"
        },
        {
            "name": "scheme",
            "baseName": "scheme",
            "type": "string"
        },
        {
            "name": "bin",
            "baseName": "bin",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return RiskV1DecisionsPost201ResponsePaymentInformation.attributeTypeMap;
    }
}

export class RiskV1DecisionsPost400Response {
    /**
    * Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ` **Example** `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.). The `T` separates the date and the time. The `Z` indicates UTC.  Returned by Cybersource for all services. 
    */
    'submitTimeUtc'?: string;
    /**
    * The status of the submitted transaction.  Possible values:  - `INVALID_REQUEST`  - `DECLINED` 
    */
    'status'?: string;
    /**
    * The reason of the status.  Possible values:  - `MISSING_FIELD`  - `INVALID_DATA`  - `INVALID_ACCOUNT` 
    */
    'reason'?: string;
    /**
    * The detail message related to the status and reason listed above.
    */
    'message'?: string;
    'details'?: Array<PtsV2PaymentsPost201ResponseErrorInformationDetails>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "submitTimeUtc",
            "baseName": "submitTimeUtc",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "reason",
            "baseName": "reason",
            "type": "string"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        },
        {
            "name": "details",
            "baseName": "details",
            "type": "Array<PtsV2PaymentsPost201ResponseErrorInformationDetails>"
        }    ];

    static getAttributeTypeMap() {
        return RiskV1DecisionsPost400Response.attributeTypeMap;
    }
}

export class RiskV1DecisionsPost400Response1 {
    /**
    * Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ` **Example** `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.). The `T` separates the date and the time. The `Z` indicates UTC.  Returned by Cybersource for all services. 
    */
    'submitTimeUtc'?: string;
    /**
    * The status of the submitted transaction.  Possible values:  - INVALID_REQUEST 
    */
    'status'?: string;
    /**
    * The reason of the status.  Possible Values: - `MISSING_FIELD` - `INVALID_DATA` 
    */
    'reason'?: string;
    /**
    * The detail message related to the status and reason listed above.
    */
    'message'?: string;
    'details'?: Array<PtsV2PaymentsPost201ResponseErrorInformationDetails>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "submitTimeUtc",
            "baseName": "submitTimeUtc",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "reason",
            "baseName": "reason",
            "type": "string"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        },
        {
            "name": "details",
            "baseName": "details",
            "type": "Array<PtsV2PaymentsPost201ResponseErrorInformationDetails>"
        }    ];

    static getAttributeTypeMap() {
        return RiskV1DecisionsPost400Response1.attributeTypeMap;
    }
}

export class RiskV1ExportComplianceInquiriesPost201Response {
    'links'?: PtsV2IncrementalAuthorizationPatch201ResponseLinks;
    /**
    * An unique identification number generated by Cybersource to identify the submitted request. Returned by all services. It is also appended to the endpoint of the resource. On incremental authorizations, this value with be the same as the identification number returned in the original authorization response. 
    */
    'id'?: string;
    /**
    * Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ` **Example** `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.). The `T` separates the date and the time. The `Z` indicates UTC.  Returned by Cybersource for all services. 
    */
    'submitTimeUtc'?: string;
    /**
    * Time that the transaction was submitted in local time. Generated by Cybersource.
    */
    'submitTimeLocal'?: string;
    /**
    * The status for the call can be: - COMPLETED - INVALID_REQUEST - DECLINED 
    */
    'status'?: string;
    /**
    * The message describing the reason of the status. Value can be   - The customer matched the Denied Parties List   - The Export bill_country/ship_country  match   - Export email_country match   - Export hostname_country/ip_country match 
    */
    'message'?: string;
    'clientReferenceInformation'?: RiskV1DecisionsPost201ResponseClientReferenceInformation;
    'exportComplianceInformation'?: PtsV2PaymentsPost201ResponseWatchlistScreeningInformation;
    'errorInformation'?: RiskV1ExportComplianceInquiriesPost201ResponseErrorInformation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "PtsV2IncrementalAuthorizationPatch201ResponseLinks"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "submitTimeUtc",
            "baseName": "submitTimeUtc",
            "type": "string"
        },
        {
            "name": "submitTimeLocal",
            "baseName": "submitTimeLocal",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        },
        {
            "name": "clientReferenceInformation",
            "baseName": "clientReferenceInformation",
            "type": "RiskV1DecisionsPost201ResponseClientReferenceInformation"
        },
        {
            "name": "exportComplianceInformation",
            "baseName": "exportComplianceInformation",
            "type": "PtsV2PaymentsPost201ResponseWatchlistScreeningInformation"
        },
        {
            "name": "errorInformation",
            "baseName": "errorInformation",
            "type": "RiskV1ExportComplianceInquiriesPost201ResponseErrorInformation"
        }    ];

    static getAttributeTypeMap() {
        return RiskV1ExportComplianceInquiriesPost201Response.attributeTypeMap;
    }
}

export class RiskV1ExportComplianceInquiriesPost201ResponseErrorInformation {
    /**
    * The reason of the status. Value can be   - `CUSTOMER_WATCHLIST_MATCH`   - `ADDRESS_COUNTRY_WATCHLIST_MATCH`   - `EMAIL_COUNTRY_WATCHLIST_MATCH`   - `IP_COUNTRY_WATCHLIST_MATCH`   - `INVALID_MERCHANT_CONFIGURATION` 
    */
    'reason'?: string;
    /**
    * The detail message related to the status and reason listed above.
    */
    'message'?: string;
    'details'?: Array<PtsV2PaymentsPost201ResponseErrorInformationDetails>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "reason",
            "baseName": "reason",
            "type": "string"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        },
        {
            "name": "details",
            "baseName": "details",
            "type": "Array<PtsV2PaymentsPost201ResponseErrorInformationDetails>"
        }    ];

    static getAttributeTypeMap() {
        return RiskV1ExportComplianceInquiriesPost201ResponseErrorInformation.attributeTypeMap;
    }
}

export class RiskV1UpdatePost201Response {
    'links'?: PtsV2IncrementalAuthorizationPatch201ResponseLinks;
    'clientReferenceInformaton'?: RiskV1DecisionsPost201ResponseClientReferenceInformation;
    /**
    * An unique identification number generated by Cybersource to identify the submitted request. Returned by all services. It is also appended to the endpoint of the resource. On incremental authorizations, this value with be the same as the identification number returned in the original authorization response. 
    */
    'id'?: string;
    /**
    * The status for risk update 201 calls. Possible values are: - INVALID_REQUEST - COMPLETED 
    */
    'status'?: string;
    /**
    * Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ` **Example** `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.). The `T` separates the date and the time. The `Z` indicates UTC.  Returned by Cybersource for all services. 
    */
    'submitTimeUtc'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "PtsV2IncrementalAuthorizationPatch201ResponseLinks"
        },
        {
            "name": "clientReferenceInformaton",
            "baseName": "clientReferenceInformaton",
            "type": "RiskV1DecisionsPost201ResponseClientReferenceInformation"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "submitTimeUtc",
            "baseName": "submitTimeUtc",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return RiskV1UpdatePost201Response.attributeTypeMap;
    }
}

export class Riskv1addressverificationsBuyerInformation {
    /**
    * Optional customer’s account ID, tracking number, reward number, or other unique number that you assign to the customer for the purpose that you choose 
    */
    'merchantCustomerId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "merchantCustomerId",
            "baseName": "merchantCustomerId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Riskv1addressverificationsBuyerInformation.attributeTypeMap;
    }
}

export class Riskv1addressverificationsOrderInformation {
    'billTo'?: Riskv1addressverificationsOrderInformationBillTo;
    'shipTo'?: Riskv1addressverificationsOrderInformationShipTo;
    'lineItems'?: Array<Riskv1addressverificationsOrderInformationLineItems>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "billTo",
            "baseName": "billTo",
            "type": "Riskv1addressverificationsOrderInformationBillTo"
        },
        {
            "name": "shipTo",
            "baseName": "shipTo",
            "type": "Riskv1addressverificationsOrderInformationShipTo"
        },
        {
            "name": "lineItems",
            "baseName": "lineItems",
            "type": "Array<Riskv1addressverificationsOrderInformationLineItems>"
        }    ];

    static getAttributeTypeMap() {
        return Riskv1addressverificationsOrderInformation.attributeTypeMap;
    }
}

export class Riskv1addressverificationsOrderInformationBillTo {
    /**
    * Payment card billing street address as it appears on the credit card issuer’s records.  #### SEPA Required for Create Mandate and Import Mandate  #### Atos This field must not contain colons (:).  #### CyberSource through VisaNet **Important** When you populate orderInformation.billTo.address1 and orderInformation.billTo.address2, CyberSource through VisaNet concatenates the two values. If the concatenated value exceeds 40 characters, CyberSource through VisaNet truncates the value at 40 characters before sending it to Visa and the issuing bank. Truncating this value affects AVS results and therefore might also affect risk decisions and chargebacks. Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.  #### FDMS Nashville When the street name is numeric, it must be sent in numeric format. For example, if the address is _One First Street_, it must be sent as _1 1st Street_.  Required if keyed; not used if swiped.  String (20)  #### TSYS Acquiring Solutions Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.  #### All other processors: Optional. String (60)  #### For Payouts This field may be sent only for FDC Compass.  **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting. 
    */
    'address1': string;
    /**
    * Used for additional address information. For example: _Attention: Accounts Payable_ Optional field.  For Payouts: This field may be sent only for FDC Compass.  #### Atos This field must not contain colons (:).  #### CyberSource through VisaNet **Important** When you populate `orderInformation.billTo.address1` and `orderInformation.billTo.address2`, CyberSource through VisaNet concatenates the two values. If the concatenated value exceeds 40 characters, CyberSource through VisaNet truncates the value at 40 characters before sending it to Visa and the issuing bank. Truncating this value affects AVS results and therefore might also affect risk decisions and chargebacks. Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.  #### Chase Paymentech Solutions, FDC Compass, and TSYS Acquiring Solutions This value is used for AVS.  #### FDMS Nashville `orderInformation.billTo.address1` and `orderInformation.billTo.address2` together cannot exceed 20 characters. String (20)  #### All Other Processors String (60) 
    */
    'address2'?: string;
    /**
    * Additional address information (third line of the billing address) 
    */
    'address3'?: string;
    /**
    * Additional address information (fourth line of the billing address) 
    */
    'address4'?: string;
    /**
    * State or province of the billing address. Use the [State, Province, and Territory Codes for the United States and Canada](https://developer.cybersource.com/library/documentation/sbc/quickref/states_and_provinces.pdf).  For Payouts: This field may be sent only for FDC Compass.  ##### CyberSource through VisaNet Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.  **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.  #### Chase Paymentech Solutions Optional field.  ####  Credit Mutuel-CIC Optional field.  #### OmniPay Direct Optional field.  #### SIX Optional field.  #### TSYS Acquiring Solutions Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.  #### Worldpay VAP Optional field.  #### All other processors Not used. 
    */
    'administrativeArea'?: string;
    /**
    * Payment card billing country. Use the two-character [ISO Standard Country Codes](http://apps.cybersource.com/library/documentation/sbc/quickref/countries_alpha_list.pdf).  #### SEPA/BACS Required for Create Mandate and Import Mandate  #### CyberSource through VisaNet Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.  **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.  #### Chase Paymentech Solutions Optional field.  ####  Credit Mutuel-CIC Optional field.  #### OmniPay Direct Optional field.  #### SIX Optional field.  #### TSYS Acquiring Solutions Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.  #### Worldpay VAP Optional field.  #### All other processors Not used. 
    */
    'country': string;
    /**
    * Payment card billing city.  #### SEPA Required for Create Mandate and Import Mandate  #### Atos This field must not contain colons (:).  #### CyberSource through VisaNet Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.  #### For Payouts: This field may be sent only for FDC Compass.  #### Chase Paymentech Solutions Optional field.  ####  Credit Mutuel-CIC Optional field.  #### OmniPay Direct Optional field.  #### SIX Optional field.  #### TSYS Acquiring Solutions Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.  #### Worldpay VAP Optional field.  #### All other processors Not used. 
    */
    'locality': string;
    /**
    * Postal code for the billing address. The postal code must consist of 5 to 9 digits.  When the billing country is the U.S., the 9-digit postal code must follow this format: [5 digits][dash][4 digits]  **Example** `12345-6789`  When the billing country is Canada, the 6-digit postal code must follow this format: [alpha][numeric][alpha][space][numeric][alpha][numeric]  **Example** `A1B 2C3`  **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.  #### SEPA Required for Create Mandate and Import Mandate  #### For Payouts:  This field may be sent only for FDC Compass.  #### American Express Direct Before sending the postal code to the processor, CyberSource removes all nonalphanumeric characters and, if the remaining value is longer than nine characters, truncates the value starting from the right side.  #### Atos This field must not contain colons (:).  #### CyberSource through VisaNet Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.  #### FDMS Nashville Required if `pointOfSaleInformation.entryMode=keyed` and the address is in the U.S. or Canada. Optional if `pointOfSaleInformation.entryMode=keyed` and the address is **not** in the U.S. or Canada. Not used if swiped.  #### RBS WorldPay Atlanta: For best card-present keyed rates, send the postal code if `pointOfSaleInformation.entryMode=keyed`.  #### TSYS Acquiring Solutions Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.  #### All other processors: Optional field. 
    */
    'postalCode': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "address1",
            "baseName": "address1",
            "type": "string"
        },
        {
            "name": "address2",
            "baseName": "address2",
            "type": "string"
        },
        {
            "name": "address3",
            "baseName": "address3",
            "type": "string"
        },
        {
            "name": "address4",
            "baseName": "address4",
            "type": "string"
        },
        {
            "name": "administrativeArea",
            "baseName": "administrativeArea",
            "type": "string"
        },
        {
            "name": "country",
            "baseName": "country",
            "type": "string"
        },
        {
            "name": "locality",
            "baseName": "locality",
            "type": "string"
        },
        {
            "name": "postalCode",
            "baseName": "postalCode",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Riskv1addressverificationsOrderInformationBillTo.attributeTypeMap;
    }
}

export class Riskv1addressverificationsOrderInformationLineItems {
    /**
    * Per-item price of the product. This value for this field cannot be negative.  You must include either this field or the request-level field `orderInformation.amountDetails.totalAmount` in your request.  You can include a decimal point (.), but you cannot include any other special characters. The value is truncated to the correct number of decimal places.  #### DCC with a Third-Party Provider Set this field to the converted amount that was returned by the DCC provider. You must include either the 1st line item in the order and this field, or the request-level field `orderInformation.amountDetails.totalAmount` in your request.  #### Tax Calculation Required field for U.S., Canadian, international and value added taxes.  #### Zero Amount Authorizations If your processor supports zero amount authorizations, you can set this field to 0 for the authorization to check if the card is lost or stolen.  #### Maximum Field Lengths For GPN and JCN Gateway: Decimal (10) All other processors: Decimal (15) 
    */
    'unitPrice': string;
    /**
    * Number of units for this order. Must be a non-negative integer.  The default is `1`. For an authorization or capture transaction (`processingOptions.capture` is set to `true` or `false`), this field is required when `orderInformation.lineItems[].productCode` is not `default` or one of the other values related to shipping and/or handling.  #### Tax Calculation Optional field for U.S., Canadian, international tax, and value added taxes. 
    */
    'quantity'?: number;
    /**
    * Product identifier code. Also known as the Stock Keeping Unit (SKU) code for the product.  For an authorization or capture transaction (`processingOptions.capture` is set to `true` or `false`), this field is required when `orderInformation.lineItems[].productCode` is not set to **default** or one of the other values that are related to shipping and/or handling.  #### Tax Calculation Optional field for U.S. and Canadian taxes. Not applicable to international and value added taxes. For an authorization or capture transaction (`processingOptions.capture` is set to `true` or `false`), this field is required when `orderInformation.lineItems[].productCode` is not `default` or one of the values related to shipping and/or handling. 
    */
    'productSKU'?: string;
    /**
    * Indicates the level of risk for the product. This field can contain one of the following values: - `low`: The product is associated with few chargebacks. - `normal`: The product is associated with a normal number of chargebacks. - `high`: The product is associated with many chargebacks. 
    */
    'productRisk'?: string;
    /**
    * For an authorization or capture transaction (`processingOptions.capture` is `true` or `false`), this field is required when `orderInformation.lineItems[].productCode` is not `default` or one of the other values that are related to shipping and/or handling.  #### Tax Calculation Optional field for U.S., Canadian, international tax, and value added taxes. 
    */
    'productName'?: string;
    /**
    * Type of product. The value for this field is used to identify the product category (electronic, handling, physical, service, or shipping). The default value is `default`.  If you are performing an authorization transaction (`processingOptions.capture` is set to `false`), and you set this field to a value other than `default` or one of the values related to shipping and/or handling, then `orderInformation.lineItems[].quantity`, `orderInformation.lineItems[].productName`, and `orderInformation.lineItems[].productSku` fields are required.  Optional field.  #### Tax Calculation Optional field for U.S., Canadian, international tax, and value added taxes.  The Product Codes for the tax service are located in the Cybersource Tax Codes guide. Contact Customer Support to request the guide. If you don’t send a tax service Product Code in your tax request, product-based rules or exemptions will not be applied and the transaction will default to fully taxable in the locations where you’ve indicated you need to collect tax [by way of nexus, no nexus, or seller registration number fields]. 
    */
    'productCode'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "unitPrice",
            "baseName": "unitPrice",
            "type": "string"
        },
        {
            "name": "quantity",
            "baseName": "quantity",
            "type": "number"
        },
        {
            "name": "productSKU",
            "baseName": "productSKU",
            "type": "string"
        },
        {
            "name": "productRisk",
            "baseName": "productRisk",
            "type": "string"
        },
        {
            "name": "productName",
            "baseName": "productName",
            "type": "string"
        },
        {
            "name": "productCode",
            "baseName": "productCode",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Riskv1addressverificationsOrderInformationLineItems.attributeTypeMap;
    }
}

export class Riskv1addressverificationsOrderInformationShipTo {
    /**
    * First line of the shipping address.  Required field for authorization if any shipping address information is included in the request; otherwise, optional.  #### Tax Calculation Optional field for U.S. and Canadian taxes. Not applicable to international and value added taxes. Billing address objects will be used to determine the cardholder’s location when shipTo objects are not present. 
    */
    'address1': string;
    /**
    * Second line of the shipping address.  Optional field.  #### Tax Calculation Optional field for U.S. and Canadian taxes. Not applicable to international and value added taxes. Billing address objects will be used to determine the cardholder’s location when shipTo objects are not present. 
    */
    'address2'?: string;
    /**
    * Third line of the shipping address.  #### Tax Calculation Optional field for U.S. and Canadian taxes. Not applicable to international and value added taxes. Billing address objects will be used to determine the cardholder’s location when shipTo objects are not present. 
    */
    'address3'?: string;
    /**
    * Fourth line of the shipping address.
    */
    'address4'?: string;
    /**
    * State or province of the shipping address. Use the [State, Province, and Territory Codes for the United States and Canada](https://developer.cybersource.com/library/documentation/sbc/quickref/states_and_provinces.pdf) (maximum length: 2)   Required field for authorization if any shipping address information is included in the request and shipping to the U.S. or Canada; otherwise, optional.  #### Tax Calculation Optional field for U.S. and Canadian taxes. Not applicable to international and value added taxes. Billing address objects will be used to determine the cardholder’s location when shipTo objects are not present. 
    */
    'administrativeArea'?: string;
    /**
    * Country of the shipping address. Use the two-character [ISO Standard Country Codes.](http://apps.cybersource.com/library/documentation/sbc/quickref/countries_alpha_list.pdf)  Required field for authorization if any shipping address information is included in the request; otherwise, optional.  #### Tax Calculation Optional field for U.S., Canadian, international tax, and value added taxes. Billing address objects will be used to determine the cardholder’s location when shipTo objects are not present. 
    */
    'country': string;
    /**
    * City of the shipping address.  Required field for authorization if any shipping address information is included in the request and shipping to the U.S. or Canada; otherwise, optional.  #### Tax Calculation Optional field for U.S. and Canadian taxes. Not applicable to international and value added taxes. Billing address objects will be used to determine the cardholder’s location when shipTo objects are not present. 
    */
    'locality'?: string;
    /**
    * Postal code for the shipping address. The postal code must consist of 5 to 9 digits.  Required field for authorization if any shipping address information is included in the request and shipping to the U.S. or Canada; otherwise, optional.  When the billing country is the U.S., the 9-digit postal code must follow this format: [5 digits][dash][4 digits]  Example 12345-6789  When the billing country is Canada, the 6-digit postal code must follow this format: [alpha][numeric][alpha][space][numeric][alpha][numeric]  Example A1B 2C3  #### American Express Direct Before sending the postal code to the processor, all nonalphanumeric characters are removed and, if the remaining value is longer than nine characters, the value is truncated starting from the right side. #### Tax Calculation Optional field for U.S. and Canadian taxes. Not applicable to international and value added taxes. Billing address objects will be used to determine the cardholder’s location when shipTo objects are not present. 
    */
    'postalCode'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "address1",
            "baseName": "address1",
            "type": "string"
        },
        {
            "name": "address2",
            "baseName": "address2",
            "type": "string"
        },
        {
            "name": "address3",
            "baseName": "address3",
            "type": "string"
        },
        {
            "name": "address4",
            "baseName": "address4",
            "type": "string"
        },
        {
            "name": "administrativeArea",
            "baseName": "administrativeArea",
            "type": "string"
        },
        {
            "name": "country",
            "baseName": "country",
            "type": "string"
        },
        {
            "name": "locality",
            "baseName": "locality",
            "type": "string"
        },
        {
            "name": "postalCode",
            "baseName": "postalCode",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Riskv1addressverificationsOrderInformationShipTo.attributeTypeMap;
    }
}

export class Riskv1authenticationresultsConsumerAuthenticationInformation {
    /**
    * Payer authentication transaction identifier passed to link the check enrollment and validate authentication messages.For Rupay,this is passed only in Re-Send OTP usecase. **Note**: Required for Standard integration, Rupay Seamless server to server integration for enroll service. Required for Hybrid integration for validate service. 
    */
    'authenticationTransactionId': string;
    /**
    * Authentication transaction context is used as a unique identifier to link enroll and validate call. 
    */
    'authenticationTransactionContext'?: string;
    /**
    * OTP entered by the card holder. 
    */
    'otpToken'?: string;
    /**
    * JWT returned by the 3D Secure provider when the authentication is complete. Required for Hybrid integration if you use the Cybersource-generated access token. Note: Max. length of this field is 2048 characters. 
    */
    'responseAccessToken'?: string;
    /**
    * Provides additional information as to why the PAResStatus has a specific value. 
    */
    'signedParesStatusReason'?: string;
    /**
    * Payer authentication result (PARes) message returned by the card-issuing bank. If you need to show proof of enrollment checking, you may need to decrypt and parse the string for the information required by the payment card company. For more information, see \"Storing Payer Authentication Data,\" page 160. Important The value is in base64. You must remove all carriage returns and line feeds before adding the PARes to the request. 
    */
    'signedPares'?: string;
    /**
    * Enables the communication of trusted beneficiary/whitelist status between the ACS, the DS and the 3DS Requestor.  Possible Values:  Y - 3DS Requestor is whitelisted by cardholder  N - 3DS Requestor is not whitelisted by cardholder 
    */
    'whiteListStatus'?: string;
    /**
    * A flag to indicate if the passed credential has been encrypted by the Merchant.
    */
    'credentialEncrypted'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "authenticationTransactionId",
            "baseName": "authenticationTransactionId",
            "type": "string"
        },
        {
            "name": "authenticationTransactionContext",
            "baseName": "authenticationTransactionContext",
            "type": "string"
        },
        {
            "name": "otpToken",
            "baseName": "otpToken",
            "type": "string"
        },
        {
            "name": "responseAccessToken",
            "baseName": "responseAccessToken",
            "type": "string"
        },
        {
            "name": "signedParesStatusReason",
            "baseName": "signedParesStatusReason",
            "type": "string"
        },
        {
            "name": "signedPares",
            "baseName": "signedPares",
            "type": "string"
        },
        {
            "name": "whiteListStatus",
            "baseName": "whiteListStatus",
            "type": "string"
        },
        {
            "name": "credentialEncrypted",
            "baseName": "credentialEncrypted",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Riskv1authenticationresultsConsumerAuthenticationInformation.attributeTypeMap;
    }
}

export class Riskv1authenticationresultsDeviceInformation {
    /**
    * IP address of the customer.  #### Used by **Authorization, Capture, and Credit** Optional field. 
    */
    'ipAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "ipAddress",
            "baseName": "ipAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Riskv1authenticationresultsDeviceInformation.attributeTypeMap;
    }
}

export class Riskv1authenticationresultsOrderInformation {
    'amountDetails'?: Riskv1authenticationresultsOrderInformationAmountDetails;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "amountDetails",
            "baseName": "amountDetails",
            "type": "Riskv1authenticationresultsOrderInformationAmountDetails"
        }    ];

    static getAttributeTypeMap() {
        return Riskv1authenticationresultsOrderInformation.attributeTypeMap;
    }
}

/**
* Contains `currency` and `totalAmount` for this order.
*/
export class Riskv1authenticationresultsOrderInformationAmountDetails {
    /**
    * Currency used for the order. Use the three-character [ISO Standard Currency Codes.](http://apps.cybersource.com/library/documentation/sbc/quickref/currencies.pdf)  #### Used by **Authorization** Required field.  **Authorization Reversal** For an authorization reversal (`reversalInformation`) or a capture (`processingOptions.capture` is set to `true`), you must use the same currency that you used in your payment authorization request.  #### PIN Debit Currency for the amount you requested for the PIN debit purchase. This value is returned for partial authorizations. The issuing bank can approve a partial amount if the balance on the debit card is less than the requested transaction amount. For the possible values, see the [ISO Standard Currency Codes](https://developer.cybersource.com/library/documentation/sbc/quickref/currencies.pdf). Returned by PIN debit purchase.  For PIN debit reversal requests, you must use the same currency that was used for the PIN debit purchase or PIN debit credit that you are reversing. For the possible values, see the [ISO Standard Currency Codes](https://developer.cybersource.com/library/documentation/sbc/quickref/currencies.pdf).  Required field for PIN Debit purchase and PIN Debit credit requests. Optional field for PIN Debit reversal requests.  #### GPX This field is optional for reversing an authorization or credit.  #### DCC for First Data Your local currency.  #### Tax Calculation Required for international tax and value added tax only. Optional for U.S. and Canadian taxes. Your local currency. 
    */
    'currency'?: string;
    /**
    * Grand total for the order. This value cannot be negative. You can include a decimal point (.), but no other special characters. CyberSource truncates the amount to the correct number of decimal places.  **Note** For CTV, FDCCompass, Paymentech processors, the maximum length for this field is 12.  **Important** Some processors have specific requirements and limitations, such as maximum amounts and maximum field lengths.  If your processor supports zero amount authorizations, you can set this field to 0 for the authorization to check if the card is lost or stolen.   #### Card Present Required to include either this field or `orderInformation.lineItems[].unitPrice` for the order.  #### Invoicing / Pay By Link Required for creating a new invoice or payment link.  #### PIN Debit Amount you requested for the PIN debit purchase. This value is returned for partial authorizations. The issuing bank can approve a partial amount if the balance on the debit card is less than the requested transaction amount.  Required field for PIN Debit purchase and PIN Debit credit requests. Optional field for PIN Debit reversal requests.  #### GPX This field is optional for reversing an authorization or credit; however, for all other processors, these fields are required.  #### DCC with a Third-Party Provider Set this field to the converted amount that was returned by the DCC provider. You must include either this field or the 1st line item in the order and the specific line-order amount in your request.   #### DCC for First Data Not used. 
    */
    'totalAmount'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "currency",
            "baseName": "currency",
            "type": "string"
        },
        {
            "name": "totalAmount",
            "baseName": "totalAmount",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Riskv1authenticationresultsOrderInformationAmountDetails.attributeTypeMap;
    }
}

export class Riskv1authenticationresultsPaymentInformation {
    'card'?: Riskv1authenticationresultsPaymentInformationCard;
    'tokenizedCard'?: Riskv1authenticationresultsPaymentInformationTokenizedCard;
    'fluidData'?: Riskv1authenticationresultsPaymentInformationFluidData;
    'customer'?: Riskv1authenticationsPaymentInformationCustomer;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "card",
            "baseName": "card",
            "type": "Riskv1authenticationresultsPaymentInformationCard"
        },
        {
            "name": "tokenizedCard",
            "baseName": "tokenizedCard",
            "type": "Riskv1authenticationresultsPaymentInformationTokenizedCard"
        },
        {
            "name": "fluidData",
            "baseName": "fluidData",
            "type": "Riskv1authenticationresultsPaymentInformationFluidData"
        },
        {
            "name": "customer",
            "baseName": "customer",
            "type": "Riskv1authenticationsPaymentInformationCustomer"
        }    ];

    static getAttributeTypeMap() {
        return Riskv1authenticationresultsPaymentInformation.attributeTypeMap;
    }
}

export class Riskv1authenticationresultsPaymentInformationCard {
    /**
    * Three-digit value that indicates the card type.  **IMPORTANT** It is strongly recommended that you include the card type field in request messages even if it is optional for your processor and card type. Omitting the card type can cause the transaction to be processed with the wrong card type.  Possible values: - `001`: Visa. Use card type value `001` for Visa Electron. - `002`: Mastercard, Eurocard[^1], which is a European regional brand of Mastercard. - `003`: American Express - `004`: Discover - `005`: Diners Club - `006`: Carte Blanche[^1] - `007`: JCB[^1] - `008`: Optima - `009`: GE Private Label - `010`: Beneficial Private Label - `011`: Twinpay Credit Card - `012`: Twinpay Debit Card - `013`: WalMart - `014`: Enroute[^1] - `015`: Lowe's Consumer - `016`: Home Depot Consumer - `017`: MBNA - `018`: Dick's Sportswear - `019`: Casual Corner - `020`: Sears - `021`: JAL[^1] - `023`: Disney Card - `024`: Maestro (UK Domestic)[^1] - `025`: Sam's Club Consumer - `026`: Sam's Club Business - `027`: Nico's - `028`: Paymentech Bill Me Later - `029`: Bebe - `030`: Restoration Hardware - `031`: Delta Online - `032`: Solo - `033`: Visa Electron[^1]. Do not use this value. Use `001` for all Visa card types. - `034`: Dankort[^1] - `035`: Laser - `036`: Cartes Bancaires[^1,4] - `037`: Carta Si[^1] - `038`: Pinless Debit - `039`: Encoded account number[^1] - `040`: UATP[^1] - `041`: HOUSEHOLD - `042`: Maestro (International)[^1] - `043`: GE MONEY - `044`: Korean Cards - `045`: Style Cards - `046`: JCrew - `047`: Payeasecn eWallet - `048`: Payeasecn Bank Transfer - `049`: Meijer - `050`: Hipercard[^2,3] - `051`: Aura - `052`: Redecard - `053`: Orico card - `054`: Elo[^3] - `055`: Capitol One Private Label - `056`: Carnet - `057`: Costco Private Label - `058`: Carnet - `059`: ValueLink - `060`: MADA - `061`: RuPay - `062`: China UnionPay - `063`: Falabella Private Label - `064`: Prompt Card - `065`: Korean Domestic - `066`: Banricompras - `067`: MEEZA - `068`: PayPak - `070`: EFTPOS - `071`: Codensa - `072`: Olimpica - `073`: Colsubsidio - `074`: Tuya - `075`: Sodexo - `076`: Naranja - `077`: Cabal - `078`: DINELCO - `079`: PANAL - `080`: EPM - `081`: Jaywan  [^1]: For this card type, you must include the `paymentInformation.card.type` or `paymentInformation.tokenizedCard.type` field in your request for an authorization or a stand-alone credit. [^2]: For this card type on Cielo 3.0, you must include the `paymentInformation.card.type` or `paymentInformation.tokenizedCard.type` field in a request for an authorization or a stand-alone credit. This card type is not supported on Cielo 1.5. [^3]: For this card type on Getnet and Rede, you must include the `paymentInformation.card.type` or `paymentInformation.tokenizedCard.type` field in a request for an authorization or a stand-alone credit. [^4]: For this card type, you must include the `paymentInformation.card.type` in your request for any payer authentication services.  #### Used by **Authorization** Required for Carte Blanche and JCB. Optional for all other card types.  #### Card Present reply This field is included in the reply message when the client software that is installed on the POS terminal uses the token management service (TMS) to retrieve tokenized payment details. You must contact customer support to have your account enabled to receive these fields in the credit reply message.  Returned by the Credit service.  This reply field is only supported by the following processors: - American Express Direct - Credit Mutuel-CIC - FDC Nashville Global - OmniPay Direct - SIX  #### Google Pay transactions For PAN-based Google Pay transactions, this field is returned in the API response.  #### GPX This field only supports transactions from the following card types: - Visa - Mastercard - AMEX - Discover - Diners - JCB - Union Pay International 
    */
    'type'?: string;
    /**
    * Two-digit month in which the payment card expires.  Format: `MM`.  Valid values: `01` through `12`. Leading 0 is required.  #### Barclays and Streamline For Maestro (UK Domestic) and Maestro (International) cards on Barclays and Streamline, this must be a valid value (`01` through `12`) but is not required to be a valid expiration date. In other words, an expiration date that is in the past does not cause CyberSource to reject your request. However, an invalid expiration date might cause the issuer to reject your request.  #### Encoded Account Numbers For encoded account numbers (_type_=039), if there is no expiration date on the card, use `12`.  #### FDMS Nashville Required field.  #### All other processors Required if `pointOfSaleInformation.entryMode=keyed`. However, this field is optional if your account is configured for relaxed requirements for address data and expiration date. **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.  #### Google Pay transactions For PAN-based Google Pay transactions, this field is returned in the API response. 
    */
    'expirationMonth'?: string;
    /**
    * Four-digit year in which the payment card expires.  Format: `YYYY`.  #### Barclays and Streamline For Maestro (UK Domestic) and Maestro (International) cards on Barclays and Streamline, this must be a valid value (`1900` through `3000`) but is not required to be a valid expiration date. In other words, an expiration date that is in the past does not cause CyberSource to reject your request. However, an invalid expiration date might cause the issuer to reject your request.  #### Encoded Account Numbers For encoded account numbers (**_type_**`=039`), if there is no expiration date on the card, use `2021`.  #### FDMS Nashville Required field.  #### FDC Nashville Global and FDMS South You can send in 2 digits or 4 digits. If you send in 2 digits, they must be the last 2 digits of the year.  #### All other processors Required if `pointOfSaleInformation.entryMode=keyed`. However, this field is optional if your account is configured for relaxed requirements for address data and expiration date. **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.  #### Google Pay transactions For PAN-based Google Pay transactions, this field is returned in the API response. 
    */
    'expirationYear'?: string;
    /**
    * The customer’s payment card number, also known as the Primary Account Number (PAN). You can also use this field for encoded account numbers.  #### FDMS Nashville Required. String (19)  #### GPX Required if `pointOfSaleInformation.entryMode=keyed`. However, this field is optional if your account is configured for relaxed requirements for address data and expiration date. **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.  #### All other processors Required if `pointOfSaleInformation.entryMode=keyed`. However, this field is optional if your account is configured for relaxed requirements for address data and expiration date. **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting. 
    */
    'number'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "expirationMonth",
            "baseName": "expirationMonth",
            "type": "string"
        },
        {
            "name": "expirationYear",
            "baseName": "expirationYear",
            "type": "string"
        },
        {
            "name": "number",
            "baseName": "number",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Riskv1authenticationresultsPaymentInformationCard.attributeTypeMap;
    }
}

export class Riskv1authenticationresultsPaymentInformationFluidData {
    /**
    * Represents the encrypted payment data BLOB. The entry for this field is dependent on the payment solution used by the merchant. Used by Authorization and Standalone Credits. Required for authorizations and standalone credits that use a Cybersource suppored Point-to-Point encryption method. Card Present processing This field represents the encrypted payment data generated by the payment terminal/device. 
    */
    'value'?: string;
    /**
    * The encoded or encrypted value that a payment solution returns for an authorization request. For details about the valid values for a key, see [Creating an Online Authorization](https://developer.cybersource.com/api/developer-guides/dita-payments/CreatingOnlineAuth.html) 
    */
    'keySerialNumber'?: string;
    /**
    * The identifier for a payment solution, which is sending the encrypted payment data for decryption. Valid values: Samsung Pay: RklEPUNPTU1PTi5TQU1TVU5HLklOQVBQLlBBWU1FTlQ= Note: For other payment solutions, the value may be specific to the terminal or device initiatinf the payment. For example, the descriptor for a Bluefin payment encryption would be a device-generated descriptor. Used by Authorization and Standalone Credits. Required for authorizations and standalone credits.  Card Present processing: Format of the encrypted payment data. The value for Bluefin PCI P2PE is `Ymx1ZWZpbg==`. paymentInformation.fluidData.encoding must be `Base64`. The value for Cybersource P2PE decryption depends on the encoding method used and identified in encoding field. If paymentInformation.fluidData.encoding is `Base64`, the value is: `RklEPUVNVi5QQVlNRU5ULkFQSQ==` If paymentInformation.fluidData.encoding is `HEX`, the value is: `4649443D454D562E5041594D454E542E41504` 
    */
    'descriptor'?: string;
    /**
    * Encoding method used to encrypt the payment data. Valid values: `Base64`, `HEX` If no value is provided, `Base64` is taken as the default value. And the `Base64` descriptor is used for paymentInformation.fluidData.encoding 
    */
    'encoding'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "value",
            "baseName": "value",
            "type": "string"
        },
        {
            "name": "keySerialNumber",
            "baseName": "keySerialNumber",
            "type": "string"
        },
        {
            "name": "descriptor",
            "baseName": "descriptor",
            "type": "string"
        },
        {
            "name": "encoding",
            "baseName": "encoding",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Riskv1authenticationresultsPaymentInformationFluidData.attributeTypeMap;
    }
}

export class Riskv1authenticationresultsPaymentInformationTokenizedCard {
    /**
    * Type of transaction that provided the token data. This value does not specify the token service provider; it specifies the entity that provided you with information about the token.  Possible value: - `2`: Near-field communication (NFC) transaction. The customer’s mobile device provided the token data for a contactless EMV transaction. For recurring transactions, use this value if the original transaction was a contactless EMV transaction.  #### Visa Platform Connect - `1`: For Rupay and In App tokenization. Example: InApp apple pay. - `3`: Card/Credential On File Tokenization.  **NOTE** No CyberSource through VisaNet acquirers support EMV at this time.  Required field for PIN debit credit or PIN debit purchase transactions that use payment network tokens; otherwise, not used.  #### Rupay - `3`: Card/Credential On File Tokenization. - `4`: Tokenizined Transaction. Should be used for Guest Checkout transactions with token. 
    */
    'transactionType'?: string;
    /**
    * Three-digit value that indicates the card type.  **IMPORTANT** It is strongly recommended that you include the card type field in request messages even if it is optional for your processor and card type. Omitting the card type can cause the transaction to be processed with the wrong card type.  Possible values: - `001`: Visa. Use card type value `001` for Visa Electron. - `002`: Mastercard, Eurocard[^1], which is a European regional brand of Mastercard. - `003`: American Express - `004`: Discover - `005`: Diners Club - `006`: Carte Blanche[^1] - `007`: JCB[^1] - `008`: Optima - `009`: GE Private Label - `010`: Beneficial Private Label - `011`: Twinpay Credit Card - `012`: Twinpay Debit Card - `013`: WalMart - `014`: Enroute[^1] - `015`: Lowe's Consumer - `016`: Home Depot Consumer - `017`: MBNA - `018`: Dick's Sportswear - `019`: Casual Corner - `020`: Sears - `021`: JAL[^1] - `023`: Disney Card - `024`: Maestro (UK Domestic)[^1] - `025`: Sam's Club Consumer - `026`: Sam's Club Business - `027`: Nico's - `028`: Paymentech Bill Me Later - `029`: Bebe - `030`: Restoration Hardware - `031`: Delta Online - `032`: Solo - `033`: Visa Electron[^1]. Do not use this value. Use `001` for all Visa card types. - `034`: Dankort[^1] - `035`: Laser - `036`: Cartes Bancaires[^1,4] - `037`: Carta Si[^1] - `038`: Pinless Debit - `039`: Encoded account number[^1] - `040`: UATP[^1] - `041`: HOUSEHOLD - `042`: Maestro (International)[^1] - `043`: GE MONEY - `044`: Korean Cards - `045`: Style Cards - `046`: JCrew - `047`: Payeasecn eWallet - `048`: Payeasecn Bank Transfer - `049`: Meijer - `050`: Hipercard[^2,3] - `051`: Aura - `052`: Redecard - `053`: Orico card - `054`: Elo[^3] - `055`: Capitol One Private Label - `056`: Carnet - `057`: Costco Private Label - `058`: Carnet - `059`: ValueLink - `060`: MADA - `061`: RuPay - `062`: China UnionPay - `063`: Falabella Private Label - `064`: Prompt Card - `065`: Korean Domestic - `066`: Banricompras - `067`: MEEZA - `068`: PayPak - `070`: EFTPOS - `071`: Codensa - `072`: Olimpica - `073`: Colsubsidio - `074`: Tuya - `075`: Sodexo - `076`: Naranja - `077`: Cabal - `078`: DINELCO - `079`: PANAL - `080`: EPM - `081`: Jaywan  [^1]: For this card type, you must include the `paymentInformation.card.type` or `paymentInformation.tokenizedCard.type` field in your request for an authorization or a stand-alone credit. [^2]: For this card type on Cielo 3.0, you must include the `paymentInformation.card.type` or `paymentInformation.tokenizedCard.type` field in a request for an authorization or a stand-alone credit. This card type is not supported on Cielo 1.5. [^3]: For this card type on Getnet and Rede, you must include the `paymentInformation.card.type` or `paymentInformation.tokenizedCard.type` field in a request for an authorization or a stand-alone credit. [^4]: For this card type, you must include the `paymentInformation.card.type` in your request for any payer authentication services.  #### Used by **Authorization** Required for Carte Blanche and JCB. Optional for all other card types.  #### Card Present reply This field is included in the reply message when the client software that is installed on the POS terminal uses the token management service (TMS) to retrieve tokenized payment details. You must contact customer support to have your account enabled to receive these fields in the credit reply message.  Returned by the Credit service.  This reply field is only supported by the following processors: - American Express Direct - Credit Mutuel-CIC - FDC Nashville Global - OmniPay Direct - SIX  #### Google Pay transactions For PAN-based Google Pay transactions, this field is returned in the API response.  #### GPX This field only supports transactions from the following card types: - Visa - Mastercard - AMEX - Discover - Diners - JCB - Union Pay International 
    */
    'type'?: string;
    /**
    * One of two possible meanings: - The two-digit month in which a token expires. - The two-digit month in which a card expires. Format: `MM` Possible values: `01` through `12`  **NOTE** The meaning of this field is dependent on the payment processor that is returning the value in an authorization reply. Please see the processor-specific details below.  #### Barclays and Streamline For Maestro (UK Domestic) and Maestro (International) cards on Barclays and Streamline, this must be a valid value (`01` through `12`) but is not required to be a valid expiration date. In other words, an expiration date that is in the past does not cause CyberSource to reject your request. However, an invalid expiration date might cause the issuer to reject your request.  #### Encoded Account Numbers For encoded account numbers (`card_type=039`), if there is no expiration date on the card, use `12`.\\ **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.  #### Samsung Pay and Apple Pay Month in which the token expires. CyberSource includes this field in the reply message when it decrypts the payment blob for the tokenized transaction. 
    */
    'expirationMonth'?: string;
    /**
    * One of two possible meanings: - The four-digit year in which a token expires. - The four-digit year in which a card expires. Format: `YYYY` Possible values: `1900` through `3000` Data type: Non-negative integer  **NOTE** The meaning of this field is dependent on the payment processor that is returning the value in an authorization reply. Please see the processor-specific details below.  #### Barclays and Streamline For Maestro (UK Domestic) and Maestro (International) cards on Barclays and Streamline, this must be a valid value (1900 through 3000) but is not required to be a valid expiration date. In other words, an expiration date that is in the past does not cause CyberSource to reject your request. However, an invalid expiration date might cause the issuer to reject your request.  #### Encoded Account Numbers For encoded account numbers (`card_ type=039`), if there is no expiration date on the card, use `2021`.  #### FDC Nashville Global and FDMS South You can send in 2 digits or 4 digits. When you send in 2 digits, they must be the last 2 digits of the year.  #### Samsung Pay and Apple Pay Year in which the token expires. CyberSource includes this field in the reply message when it decrypts the payment blob for the tokenized transaction.  **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting. 
    */
    'expirationYear'?: string;
    /**
    * Customer’s payment network token value. 
    */
    'number'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "transactionType",
            "baseName": "transactionType",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "expirationMonth",
            "baseName": "expirationMonth",
            "type": "string"
        },
        {
            "name": "expirationYear",
            "baseName": "expirationYear",
            "type": "string"
        },
        {
            "name": "number",
            "baseName": "number",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Riskv1authenticationresultsPaymentInformationTokenizedCard.attributeTypeMap;
    }
}

export class Riskv1authenticationsBuyerInformation {
    /**
    * Your identifier for the customer.  When a subscription or customer profile is being created, the maximum length for this field for most processors is 30. Otherwise, the maximum length is 100.  #### Comercio Latino For recurring payments in Mexico, the value is the customer’s contract number. Note Before you request the authorization, you must inform the issuer of the customer contract numbers that will be used for recurring transactions.  #### Worldpay VAP For a follow-on credit with Worldpay VAP, CyberSource checks the following locations, in the order given, for a customer account ID value and uses the first value it finds: 1. `customer_account_id` value in the follow-on credit request 2. Customer account ID value that was used for the capture that is being credited 3. Customer account ID value that was used for the original authorization If a customer account ID value cannot be found in any of these locations, then no value is used. 
    */
    'merchantCustomerId'?: string;
    /**
    * This array contains detailed information about the buyer's form of persoanl identification.
    */
    'personalIdentification'?: Array<Ptsv2paymentsBuyerInformationPersonalIdentification>;
    /**
    * Cardholder’s mobile phone number. **Important** Required for Visa Secure transactions in Brazil. Do not use this request field for any other types of transactions. 
    */
    'mobilePhone': number;
    /**
    * Cardholder's work phone number.
    */
    'workPhone'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "merchantCustomerId",
            "baseName": "merchantCustomerId",
            "type": "string"
        },
        {
            "name": "personalIdentification",
            "baseName": "personalIdentification",
            "type": "Array<Ptsv2paymentsBuyerInformationPersonalIdentification>"
        },
        {
            "name": "mobilePhone",
            "baseName": "mobilePhone",
            "type": "number"
        },
        {
            "name": "workPhone",
            "baseName": "workPhone",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Riskv1authenticationsBuyerInformation.attributeTypeMap;
    }
}

export class Riskv1authenticationsDeviceInformation {
    /**
    * IP address of the customer.  #### Used by **Authorization, Capture, and Credit** Optional field. 
    */
    'ipAddress'?: string;
    'rawData'?: Array<Ptsv2paymentsDeviceInformationRawData>;
    /**
    * Value of the Accept header sent by the customer’s web browser. **Note** If the customer’s browser provides a value, you must include it in your request. 
    */
    'httpAcceptBrowserValue'?: string;
    /**
    * The exact content of the HTTP accept header. 
    */
    'httpAcceptContent': string;
    /**
    * Value represents the browser language as defined in IETF BCP47. Example:en-US, refer  https://en.wikipedia.org/wiki/IETF_language_tag for more details. 
    */
    'httpBrowserLanguage': string;
    /**
    * A Boolean value that represents the ability of the cardholder browser to execute Java. Value is returned from the navigator.javaEnabled property. Possible Values:True/False 
    */
    'httpBrowserJavaEnabled': boolean;
    /**
    * A Boolean value that represents the ability of the cardholder browser to execute JavaScript. Possible Values:True/False. **Note**: Merchants should be able to know the values from fingerprint details of cardholder's browser. 
    */
    'httpBrowserJavaScriptEnabled'?: boolean;
    /**
    * Value represents the bit depth of the color palette for displaying images, in bits per pixel. Example : 24, refer https://en.wikipedia.org/wiki/Color_depth for more details 
    */
    'httpBrowserColorDepth': string;
    /**
    * Total height of the Cardholder's scree in pixels, example: 864. 
    */
    'httpBrowserScreenHeight': string;
    /**
    * Total width of the cardholder's screen in pixels. Example: 1536. 
    */
    'httpBrowserScreenWidth': string;
    /**
    * Time difference between UTC time and the cardholder browser local time, in minutes, Example:300 
    */
    'httpBrowserTimeDifference': string;
    /**
    * Value of the User-Agent header sent by the customer’s web browser. Note If the customer’s browser provides a value, you must include it in your request. 
    */
    'userAgentBrowserValue': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "ipAddress",
            "baseName": "ipAddress",
            "type": "string"
        },
        {
            "name": "rawData",
            "baseName": "rawData",
            "type": "Array<Ptsv2paymentsDeviceInformationRawData>"
        },
        {
            "name": "httpAcceptBrowserValue",
            "baseName": "httpAcceptBrowserValue",
            "type": "string"
        },
        {
            "name": "httpAcceptContent",
            "baseName": "httpAcceptContent",
            "type": "string"
        },
        {
            "name": "httpBrowserLanguage",
            "baseName": "httpBrowserLanguage",
            "type": "string"
        },
        {
            "name": "httpBrowserJavaEnabled",
            "baseName": "httpBrowserJavaEnabled",
            "type": "boolean"
        },
        {
            "name": "httpBrowserJavaScriptEnabled",
            "baseName": "httpBrowserJavaScriptEnabled",
            "type": "boolean"
        },
        {
            "name": "httpBrowserColorDepth",
            "baseName": "httpBrowserColorDepth",
            "type": "string"
        },
        {
            "name": "httpBrowserScreenHeight",
            "baseName": "httpBrowserScreenHeight",
            "type": "string"
        },
        {
            "name": "httpBrowserScreenWidth",
            "baseName": "httpBrowserScreenWidth",
            "type": "string"
        },
        {
            "name": "httpBrowserTimeDifference",
            "baseName": "httpBrowserTimeDifference",
            "type": "string"
        },
        {
            "name": "userAgentBrowserValue",
            "baseName": "userAgentBrowserValue",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Riskv1authenticationsDeviceInformation.attributeTypeMap;
    }
}

export class Riskv1authenticationsOrderInformation {
    'amountDetails'?: Riskv1authenticationsOrderInformationAmountDetails;
    /**
    * Indicates whether cardholder is placing an order with a future availability or release date. This field can contain one of these values: - MERCHANDISE_AVAILABLE: Merchandise available - FUTURE_AVAILABILITY: Future availability 
    */
    'preOrder'?: string;
    /**
    * Expected date that a pre-ordered purchase will be available. Format: YYYYMMDD 
    */
    'preOrderDate'?: string;
    /**
    * Indicates whether the cardholder is reordering previously purchased merchandise. This field can contain one of these values: - false: First time ordered - true: Reordered 
    */
    'reordered'?: boolean;
    'shipTo'?: Riskv1decisionsOrderInformationShipTo;
    /**
    * This array contains detailed information about individual products in the order.
    */
    'lineItems'?: Array<Riskv1authenticationsOrderInformationLineItems>;
    'billTo'?: Riskv1authenticationsOrderInformationBillTo;
    /**
    * Total number of articles/items in the order as a numeric decimal count. Possible values: 00 - 99 
    */
    'totalOffersCount'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "amountDetails",
            "baseName": "amountDetails",
            "type": "Riskv1authenticationsOrderInformationAmountDetails"
        },
        {
            "name": "preOrder",
            "baseName": "preOrder",
            "type": "string"
        },
        {
            "name": "preOrderDate",
            "baseName": "preOrderDate",
            "type": "string"
        },
        {
            "name": "reordered",
            "baseName": "reordered",
            "type": "boolean"
        },
        {
            "name": "shipTo",
            "baseName": "shipTo",
            "type": "Riskv1decisionsOrderInformationShipTo"
        },
        {
            "name": "lineItems",
            "baseName": "lineItems",
            "type": "Array<Riskv1authenticationsOrderInformationLineItems>"
        },
        {
            "name": "billTo",
            "baseName": "billTo",
            "type": "Riskv1authenticationsOrderInformationBillTo"
        },
        {
            "name": "totalOffersCount",
            "baseName": "totalOffersCount",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Riskv1authenticationsOrderInformation.attributeTypeMap;
    }
}

/**
* Contains `currency` and `totalAmount` for this order.
*/
export class Riskv1authenticationsOrderInformationAmountDetails {
    /**
    * Currency used for the order. Use the three-character [ISO Standard Currency Codes.](http://apps.cybersource.com/library/documentation/sbc/quickref/currencies.pdf)  #### Used by **Authorization** Required field.  **Authorization Reversal** For an authorization reversal (`reversalInformation`) or a capture (`processingOptions.capture` is set to `true`), you must use the same currency that you used in your payment authorization request.  #### PIN Debit Currency for the amount you requested for the PIN debit purchase. This value is returned for partial authorizations. The issuing bank can approve a partial amount if the balance on the debit card is less than the requested transaction amount. For the possible values, see the [ISO Standard Currency Codes](https://developer.cybersource.com/library/documentation/sbc/quickref/currencies.pdf). Returned by PIN debit purchase.  For PIN debit reversal requests, you must use the same currency that was used for the PIN debit purchase or PIN debit credit that you are reversing. For the possible values, see the [ISO Standard Currency Codes](https://developer.cybersource.com/library/documentation/sbc/quickref/currencies.pdf).  Required field for PIN Debit purchase and PIN Debit credit requests. Optional field for PIN Debit reversal requests.  #### GPX This field is optional for reversing an authorization or credit.  #### DCC for First Data Your local currency.  #### Tax Calculation Required for international tax and value added tax only. Optional for U.S. and Canadian taxes. Your local currency. 
    */
    'currency': string;
    /**
    * Grand total for the order. This value cannot be negative. You can include a decimal point (.), but no other special characters. CyberSource truncates the amount to the correct number of decimal places.  **Note** For CTV, FDCCompass, Paymentech processors, the maximum length for this field is 12.  **Important** Some processors have specific requirements and limitations, such as maximum amounts and maximum field lengths.  If your processor supports zero amount authorizations, you can set this field to 0 for the authorization to check if the card is lost or stolen.   #### Card Present Required to include either this field or `orderInformation.lineItems[].unitPrice` for the order.  #### Invoicing / Pay By Link Required for creating a new invoice or payment link.  #### PIN Debit Amount you requested for the PIN debit purchase. This value is returned for partial authorizations. The issuing bank can approve a partial amount if the balance on the debit card is less than the requested transaction amount.  Required field for PIN Debit purchase and PIN Debit credit requests. Optional field for PIN Debit reversal requests.  #### GPX This field is optional for reversing an authorization or credit; however, for all other processors, these fields are required.  #### DCC with a Third-Party Provider Set this field to the converted amount that was returned by the DCC provider. You must include either this field or the 1st line item in the order and the specific line-order amount in your request.   #### DCC for First Data Not used. 
    */
    'totalAmount': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "currency",
            "baseName": "currency",
            "type": "string"
        },
        {
            "name": "totalAmount",
            "baseName": "totalAmount",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Riskv1authenticationsOrderInformationAmountDetails.attributeTypeMap;
    }
}

export class Riskv1authenticationsOrderInformationBillTo {
    /**
    * Payment card billing street address as it appears on the credit card issuer’s records.  #### SEPA Required for Create Mandate and Import Mandate  #### Atos This field must not contain colons (:).  #### CyberSource through VisaNet **Important** When you populate orderInformation.billTo.address1 and orderInformation.billTo.address2, CyberSource through VisaNet concatenates the two values. If the concatenated value exceeds 40 characters, CyberSource through VisaNet truncates the value at 40 characters before sending it to Visa and the issuing bank. Truncating this value affects AVS results and therefore might also affect risk decisions and chargebacks. Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.  #### FDMS Nashville When the street name is numeric, it must be sent in numeric format. For example, if the address is _One First Street_, it must be sent as _1 1st Street_.  Required if keyed; not used if swiped.  String (20)  #### TSYS Acquiring Solutions Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.  #### All other processors: Optional. String (60)  #### For Payouts This field may be sent only for FDC Compass.  **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting. 
    */
    'address1': string;
    /**
    * Used for additional address information. For example: _Attention: Accounts Payable_ Optional field.  For Payouts: This field may be sent only for FDC Compass.  #### Atos This field must not contain colons (:).  #### CyberSource through VisaNet **Important** When you populate `orderInformation.billTo.address1` and `orderInformation.billTo.address2`, CyberSource through VisaNet concatenates the two values. If the concatenated value exceeds 40 characters, CyberSource through VisaNet truncates the value at 40 characters before sending it to Visa and the issuing bank. Truncating this value affects AVS results and therefore might also affect risk decisions and chargebacks. Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.  #### Chase Paymentech Solutions, FDC Compass, and TSYS Acquiring Solutions This value is used for AVS.  #### FDMS Nashville `orderInformation.billTo.address1` and `orderInformation.billTo.address2` together cannot exceed 20 characters. String (20)  #### All Other Processors String (60) 
    */
    'address2'?: string;
    /**
    * Additional address information (third line of the billing address) 
    */
    'address3'?: string;
    /**
    * State or province of the billing address. Use the [State, Province, and Territory Codes for the United States and Canada](https://developer.cybersource.com/library/documentation/sbc/quickref/states_and_provinces.pdf).  For Payouts: This field may be sent only for FDC Compass.  ##### CyberSource through VisaNet Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.  **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.  #### Chase Paymentech Solutions Optional field.  ####  Credit Mutuel-CIC Optional field.  #### OmniPay Direct Optional field.  #### SIX Optional field.  #### TSYS Acquiring Solutions Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.  #### Worldpay VAP Optional field.  #### All other processors Not used. 
    */
    'administrativeArea': string;
    /**
    * Payment card billing country. Use the two-character [ISO Standard Country Codes](http://apps.cybersource.com/library/documentation/sbc/quickref/countries_alpha_list.pdf).  #### SEPA/BACS Required for Create Mandate and Import Mandate  #### CyberSource through VisaNet Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.  **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.  #### Chase Paymentech Solutions Optional field.  ####  Credit Mutuel-CIC Optional field.  #### OmniPay Direct Optional field.  #### SIX Optional field.  #### TSYS Acquiring Solutions Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.  #### Worldpay VAP Optional field.  #### All other processors Not used. 
    */
    'country': string;
    /**
    * Payment card billing city.  #### SEPA Required for Create Mandate and Import Mandate  #### Atos This field must not contain colons (:).  #### CyberSource through VisaNet Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.  #### For Payouts: This field may be sent only for FDC Compass.  #### Chase Paymentech Solutions Optional field.  ####  Credit Mutuel-CIC Optional field.  #### OmniPay Direct Optional field.  #### SIX Optional field.  #### TSYS Acquiring Solutions Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.  #### Worldpay VAP Optional field.  #### All other processors Not used. 
    */
    'locality'?: string;
    /**
    * Customer’s first name. This name must be the same as the name on the card.  **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.  #### SEPA Required for Create Mandate and Import Mandate #### BACS Required for Import Mandate  #### CyberSource Latin American Processing **Important** For an authorization request, CyberSource Latin American Processing concatenates `orderInformation.billTo.firstName` and `orderInformation.billTo.lastName`. If the concatenated value exceeds 30 characters, CyberSource Latin American Processing declines the authorization request.\\ **Note** CyberSource Latin American Processing is the name of a specific processing connection that CyberSource supports. In the CyberSource API documentation, CyberSource Latin American Processing does not refer to the general topic of processing in Latin America. The information in this field description is for the specific processing connection called _CyberSource Latin American Processing_. It is not for any other Latin American processors that CyberSource supports.  #### CyberSource through VisaNet Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.  #### For Payouts: This field may be sent only for FDC Compass.  #### Chase Paymentech Solutions Optional field.  ####  Credit Mutuel-CIC Optional field.  #### OmniPay Direct Optional field.  #### SIX Optional field.  #### TSYS Acquiring Solutions Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.  #### Worldpay VAP Optional field.  #### All other processors Not used. 
    */
    'firstName': string;
    /**
    * Customer’s last name. This name must be the same as the name on the card.  **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.  #### SEPA Required for Create Mandate and Import Mandate #### BACS Required for Import Mandate #### Chase Paymentech Solutions Optional field.  ####  Credit Mutuel-CIC Optional field.  #### CyberSource Latin American Processing **Important** For an authorization request, CyberSource Latin American Processing concatenates `orderInformation.billTo.firstName` and `orderInformation.billTo.lastName`. If the concatenated value exceeds 30 characters, CyberSource Latin American Processing declines the authorization request.\\ **Note** CyberSource Latin American Processing is the name of a specific processing connection that CyberSource supports. In the CyberSource API documentation, CyberSource Latin American Processing does not refer to the general topic of processing in Latin America. The information in this field description is for the specific processing connection called CyberSource Latin American Processing. It is not for any other Latin American processors that CyberSource supports.  #### CyberSource through VisaNet Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.  #### For Payouts: This field may be sent only for FDC Compass.  #### OmniPay Direct Optional field.  #### RBS WorldPay Atlanta Optional field.  #### SIX Optional field.  #### TSYS Acquiring Solutions Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.  #### Worldpay VAP Optional field.  #### All other processors Not used. 
    */
    'lastName': string;
    /**
    * Customer’s phone number.  It is recommended that you include the country code when the order is from outside the U.S.  #### Chase Paymentech Solutions Optional field.  ####  Credit Mutuel-CIC Optional field.  #### CyberSource through VisaNet Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.  #### For Payouts: This field may be sent only for FDC Compass.  #### OmniPay Direct Optional field.  #### SIX Optional field.  #### TSYS Acquiring Solutions Optional field.  #### Worldpay VAP Optional field.  #### All other processors Not used. 
    */
    'phoneNumber'?: string;
    /**
    * Customer's email address, including the full domain name.  #### CyberSource through VisaNet Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.  **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.  #### Invoicing Email address for the customer for sending the invoice. If the invoice is in SENT status and email is updated, the old email customer payment link won't work and you must resend the invoice with the new payment link.  #### Chase Paymentech Solutions Optional field.  ####  Credit Mutuel-CIC Optional field.  #### OmniPay Direct Optional field.  #### SIX Optional field.  #### TSYS Acquiring Solutions Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.  #### Worldpay VAP Optional field.  #### All other processors Not used. 
    */
    'email': string;
    /**
    * Postal code for the billing address. The postal code must consist of 5 to 9 digits.  When the billing country is the U.S., the 9-digit postal code must follow this format: [5 digits][dash][4 digits]  **Example** `12345-6789`  When the billing country is Canada, the 6-digit postal code must follow this format: [alpha][numeric][alpha][space][numeric][alpha][numeric]  **Example** `A1B 2C3`  **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.  #### SEPA Required for Create Mandate and Import Mandate  #### For Payouts:  This field may be sent only for FDC Compass.  #### American Express Direct Before sending the postal code to the processor, CyberSource removes all nonalphanumeric characters and, if the remaining value is longer than nine characters, truncates the value starting from the right side.  #### Atos This field must not contain colons (:).  #### CyberSource through VisaNet Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.  #### FDMS Nashville Required if `pointOfSaleInformation.entryMode=keyed` and the address is in the U.S. or Canada. Optional if `pointOfSaleInformation.entryMode=keyed` and the address is **not** in the U.S. or Canada. Not used if swiped.  #### RBS WorldPay Atlanta: For best card-present keyed rates, send the postal code if `pointOfSaleInformation.entryMode=keyed`.  #### TSYS Acquiring Solutions Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.  #### All other processors: Optional field. 
    */
    'postalCode': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "address1",
            "baseName": "address1",
            "type": "string"
        },
        {
            "name": "address2",
            "baseName": "address2",
            "type": "string"
        },
        {
            "name": "address3",
            "baseName": "address3",
            "type": "string"
        },
        {
            "name": "administrativeArea",
            "baseName": "administrativeArea",
            "type": "string"
        },
        {
            "name": "country",
            "baseName": "country",
            "type": "string"
        },
        {
            "name": "locality",
            "baseName": "locality",
            "type": "string"
        },
        {
            "name": "firstName",
            "baseName": "firstName",
            "type": "string"
        },
        {
            "name": "lastName",
            "baseName": "lastName",
            "type": "string"
        },
        {
            "name": "phoneNumber",
            "baseName": "phoneNumber",
            "type": "string"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "postalCode",
            "baseName": "postalCode",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Riskv1authenticationsOrderInformationBillTo.attributeTypeMap;
    }
}

export class Riskv1authenticationsOrderInformationLineItems {
    /**
    * Total amount for the item. Normally calculated as the unit price times quantity.  When `orderInformation.lineItems[].productCode` is \"gift_card\", this is the purchase amount total for prepaid gift cards in major units.  Example: 123.45 USD = 123 
    */
    'totalAmount'?: string;
    /**
    * Per-item price of the product. This value for this field cannot be negative.  You must include either this field or the request-level field `orderInformation.amountDetails.totalAmount` in your request.  You can include a decimal point (.), but you cannot include any other special characters. The value is truncated to the correct number of decimal places.  #### DCC with a Third-Party Provider Set this field to the converted amount that was returned by the DCC provider. You must include either the 1st line item in the order and this field, or the request-level field `orderInformation.amountDetails.totalAmount` in your request.  #### Tax Calculation Required field for U.S., Canadian, international and value added taxes.  #### Zero Amount Authorizations If your processor supports zero amount authorizations, you can set this field to 0 for the authorization to check if the card is lost or stolen.  #### Maximum Field Lengths For GPN and JCN Gateway: Decimal (10) All other processors: Decimal (15) 
    */
    'unitPrice': string;
    /**
    * Number of units for this order. Must be a non-negative integer.  The default is `1`. For an authorization or capture transaction (`processingOptions.capture` is set to `true` or `false`), this field is required when `orderInformation.lineItems[].productCode` is not `default` or one of the other values related to shipping and/or handling.  #### Tax Calculation Optional field for U.S., Canadian, international tax, and value added taxes. 
    */
    'quantity'?: number;
    /**
    * When `orderInformation.lineItems[].productCode` is \"gift_card\", this is the currency used for the gift card purchase.  For the possible values, see the [ISO Standard Currency Codes.](http://apps.cybersource.com/library/documentation/sbc/quickref/currencies.pdf) 
    */
    'giftCardCurrency'?: number;
    /**
    * Product identifier code. Also known as the Stock Keeping Unit (SKU) code for the product.  For an authorization or capture transaction (`processingOptions.capture` is set to `true` or `false`), this field is required when `orderInformation.lineItems[].productCode` is not set to **default** or one of the other values that are related to shipping and/or handling.  #### Tax Calculation Optional field for U.S. and Canadian taxes. Not applicable to international and value added taxes. For an authorization or capture transaction (`processingOptions.capture` is set to `true` or `false`), this field is required when `orderInformation.lineItems[].productCode` is not `default` or one of the values related to shipping and/or handling. 
    */
    'productSKU'?: string;
    /**
    * Brief description of item.
    */
    'productDescription'?: string;
    /**
    * For an authorization or capture transaction (`processingOptions.capture` is `true` or `false`), this field is required when `orderInformation.lineItems[].productCode` is not `default` or one of the other values that are related to shipping and/or handling.  #### Tax Calculation Optional field for U.S., Canadian, international tax, and value added taxes. 
    */
    'productName'?: string;
    'passenger'?: Ptsv2paymentsOrderInformationPassenger;
    /**
    * Destination to where the item will be shipped. Example: Commercial, Residential, Store 
    */
    'shippingDestinationTypes'?: string;
    /**
    * Total tax to apply to the product. This value cannot be negative. The tax amount and the offer amount must be in the same currency. The tax amount field is additive.  The following example uses a two-exponent currency such as USD:   1. You include each line item in your request.  ..- 1st line item has amount=10.00, quantity=1, and taxAmount=0.80  ..- 2nd line item has amount=20.00, quantity=1, and taxAmount=1.60  2. The total amount authorized will be 32.40, not 30.00 with 2.40 of tax included.  Optional field.  #### Airlines processing Tax portion of the order amount. This value cannot exceed 99999999999999 (fourteen 9s). Format: English characters only. Optional request field for a line item.  #### Tax Calculation Optional field for U.S., Canadian, international tax, and value added taxes.  Note if you send this field in your tax request, the value in the field will override the tax engine 
    */
    'taxAmount'?: string;
    /**
    * Address where item will be shipped
    */
    'shippingAddress1'?: string;
    /**
    * Address where item will be shipped
    */
    'shippingAddress2'?: string;
    /**
    * City where item will be shipped
    */
    'shippingCity'?: string;
    /**
    * Country where item will be shipped
    */
    'shippingCountryCode'?: string;
    /**
    * Customer's first name
    */
    'shippingFirstName'?: string;
    /**
    * Customer's last name
    */
    'shippingLastName'?: string;
    /**
    * Customer's middle name
    */
    'shippingMiddleName'?: string;
    /**
    * Phone number where item will be shipped
    */
    'shippingPhone'?: number;
    /**
    * Postal code where item will be shipped
    */
    'shippingPostalCode'?: number;
    /**
    * State where item will be shipped
    */
    'shippingState'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "totalAmount",
            "baseName": "totalAmount",
            "type": "string"
        },
        {
            "name": "unitPrice",
            "baseName": "unitPrice",
            "type": "string"
        },
        {
            "name": "quantity",
            "baseName": "quantity",
            "type": "number"
        },
        {
            "name": "giftCardCurrency",
            "baseName": "giftCardCurrency",
            "type": "number"
        },
        {
            "name": "productSKU",
            "baseName": "productSKU",
            "type": "string"
        },
        {
            "name": "productDescription",
            "baseName": "productDescription",
            "type": "string"
        },
        {
            "name": "productName",
            "baseName": "productName",
            "type": "string"
        },
        {
            "name": "passenger",
            "baseName": "passenger",
            "type": "Ptsv2paymentsOrderInformationPassenger"
        },
        {
            "name": "shippingDestinationTypes",
            "baseName": "shippingDestinationTypes",
            "type": "string"
        },
        {
            "name": "taxAmount",
            "baseName": "taxAmount",
            "type": "string"
        },
        {
            "name": "shippingAddress1",
            "baseName": "shippingAddress1",
            "type": "string"
        },
        {
            "name": "shippingAddress2",
            "baseName": "shippingAddress2",
            "type": "string"
        },
        {
            "name": "shippingCity",
            "baseName": "shippingCity",
            "type": "string"
        },
        {
            "name": "shippingCountryCode",
            "baseName": "shippingCountryCode",
            "type": "string"
        },
        {
            "name": "shippingFirstName",
            "baseName": "shippingFirstName",
            "type": "string"
        },
        {
            "name": "shippingLastName",
            "baseName": "shippingLastName",
            "type": "string"
        },
        {
            "name": "shippingMiddleName",
            "baseName": "shippingMiddleName",
            "type": "string"
        },
        {
            "name": "shippingPhone",
            "baseName": "shippingPhone",
            "type": "number"
        },
        {
            "name": "shippingPostalCode",
            "baseName": "shippingPostalCode",
            "type": "number"
        },
        {
            "name": "shippingState",
            "baseName": "shippingState",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Riskv1authenticationsOrderInformationLineItems.attributeTypeMap;
    }
}

export class Riskv1authenticationsPaymentInformation {
    'card'?: Riskv1authenticationsetupsPaymentInformationCard;
    'tokenizedCard'?: Riskv1authenticationsPaymentInformationTokenizedCard;
    'fluidData'?: Riskv1authenticationsetupsPaymentInformationFluidData;
    'customer'?: Riskv1authenticationsPaymentInformationCustomer;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "card",
            "baseName": "card",
            "type": "Riskv1authenticationsetupsPaymentInformationCard"
        },
        {
            "name": "tokenizedCard",
            "baseName": "tokenizedCard",
            "type": "Riskv1authenticationsPaymentInformationTokenizedCard"
        },
        {
            "name": "fluidData",
            "baseName": "fluidData",
            "type": "Riskv1authenticationsetupsPaymentInformationFluidData"
        },
        {
            "name": "customer",
            "baseName": "customer",
            "type": "Riskv1authenticationsPaymentInformationCustomer"
        }    ];

    static getAttributeTypeMap() {
        return Riskv1authenticationsPaymentInformation.attributeTypeMap;
    }
}

export class Riskv1authenticationsPaymentInformationCustomer {
    /**
    * Unique identifier for the legacy Secure Storage token used in the transaction. When you include this value in your request, many of the fields that are normally required for an authorization or credit become optional. 
    */
    'customerId': string;
    /**
    * Unique identifier for the Customer token used in the transaction. When you include this value in your request, many of the fields that are normally required for an authorization or credit become optional. 
    */
    'id'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "customerId",
            "baseName": "customerId",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Riskv1authenticationsPaymentInformationCustomer.attributeTypeMap;
    }
}

export class Riskv1authenticationsPaymentInformationTokenizedCard {
    /**
    * Type of transaction that provided the token data. This value does not specify the token service provider; it specifies the entity that provided you with information about the token.  Possible value: - `2`: Near-field communication (NFC) transaction. The customer’s mobile device provided the token data for a contactless EMV transaction. For recurring transactions, use this value if the original transaction was a contactless EMV transaction.  #### Visa Platform Connect - `1`: For Rupay and In App tokenization. Example: InApp apple pay. - `3`: Card/Credential On File Tokenization.  **NOTE** No CyberSource through VisaNet acquirers support EMV at this time.  Required field for PIN debit credit or PIN debit purchase transactions that use payment network tokens; otherwise, not used.  #### Rupay - `3`: Card/Credential On File Tokenization. - `4`: Tokenizined Transaction. Should be used for Guest Checkout transactions with token. 
    */
    'transactionType': string;
    /**
    * Three-digit value that indicates the card type.  **IMPORTANT** It is strongly recommended that you include the card type field in request messages even if it is optional for your processor and card type. Omitting the card type can cause the transaction to be processed with the wrong card type.  Possible values: - `001`: Visa. Use card type value `001` for Visa Electron. - `002`: Mastercard, Eurocard[^1], which is a European regional brand of Mastercard. - `003`: American Express - `004`: Discover - `005`: Diners Club - `006`: Carte Blanche[^1] - `007`: JCB[^1] - `008`: Optima - `009`: GE Private Label - `010`: Beneficial Private Label - `011`: Twinpay Credit Card - `012`: Twinpay Debit Card - `013`: WalMart - `014`: Enroute[^1] - `015`: Lowe's Consumer - `016`: Home Depot Consumer - `017`: MBNA - `018`: Dick's Sportswear - `019`: Casual Corner - `020`: Sears - `021`: JAL[^1] - `023`: Disney Card - `024`: Maestro (UK Domestic)[^1] - `025`: Sam's Club Consumer - `026`: Sam's Club Business - `027`: Nico's - `028`: Paymentech Bill Me Later - `029`: Bebe - `030`: Restoration Hardware - `031`: Delta Online - `032`: Solo - `033`: Visa Electron[^1]. Do not use this value. Use `001` for all Visa card types. - `034`: Dankort[^1] - `035`: Laser - `036`: Cartes Bancaires[^1,4] - `037`: Carta Si[^1] - `038`: Pinless Debit - `039`: Encoded account number[^1] - `040`: UATP[^1] - `041`: HOUSEHOLD - `042`: Maestro (International)[^1] - `043`: GE MONEY - `044`: Korean Cards - `045`: Style Cards - `046`: JCrew - `047`: Payeasecn eWallet - `048`: Payeasecn Bank Transfer - `049`: Meijer - `050`: Hipercard[^2,3] - `051`: Aura - `052`: Redecard - `053`: Orico card - `054`: Elo[^3] - `055`: Capitol One Private Label - `056`: Carnet - `057`: Costco Private Label - `058`: Carnet - `059`: ValueLink - `060`: MADA - `061`: RuPay - `062`: China UnionPay - `063`: Falabella Private Label - `064`: Prompt Card - `065`: Korean Domestic - `066`: Banricompras - `067`: MEEZA - `068`: PayPak - `070`: EFTPOS - `071`: Codensa - `072`: Olimpica - `073`: Colsubsidio - `074`: Tuya - `075`: Sodexo - `076`: Naranja - `077`: Cabal - `078`: DINELCO - `079`: PANAL - `080`: EPM - `081`: Jaywan  [^1]: For this card type, you must include the `paymentInformation.card.type` or `paymentInformation.tokenizedCard.type` field in your request for an authorization or a stand-alone credit. [^2]: For this card type on Cielo 3.0, you must include the `paymentInformation.card.type` or `paymentInformation.tokenizedCard.type` field in a request for an authorization or a stand-alone credit. This card type is not supported on Cielo 1.5. [^3]: For this card type on Getnet and Rede, you must include the `paymentInformation.card.type` or `paymentInformation.tokenizedCard.type` field in a request for an authorization or a stand-alone credit. [^4]: For this card type, you must include the `paymentInformation.card.type` in your request for any payer authentication services.  #### Used by **Authorization** Required for Carte Blanche and JCB. Optional for all other card types.  #### Card Present reply This field is included in the reply message when the client software that is installed on the POS terminal uses the token management service (TMS) to retrieve tokenized payment details. You must contact customer support to have your account enabled to receive these fields in the credit reply message.  Returned by the Credit service.  This reply field is only supported by the following processors: - American Express Direct - Credit Mutuel-CIC - FDC Nashville Global - OmniPay Direct - SIX  #### Google Pay transactions For PAN-based Google Pay transactions, this field is returned in the API response.  #### GPX This field only supports transactions from the following card types: - Visa - Mastercard - AMEX - Discover - Diners - JCB - Union Pay International 
    */
    'type': string;
    /**
    * One of two possible meanings: - The two-digit month in which a token expires. - The two-digit month in which a card expires. Format: `MM` Possible values: `01` through `12`  **NOTE** The meaning of this field is dependent on the payment processor that is returning the value in an authorization reply. Please see the processor-specific details below.  #### Barclays and Streamline For Maestro (UK Domestic) and Maestro (International) cards on Barclays and Streamline, this must be a valid value (`01` through `12`) but is not required to be a valid expiration date. In other words, an expiration date that is in the past does not cause CyberSource to reject your request. However, an invalid expiration date might cause the issuer to reject your request.  #### Encoded Account Numbers For encoded account numbers (`card_type=039`), if there is no expiration date on the card, use `12`.\\ **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.  #### Samsung Pay and Apple Pay Month in which the token expires. CyberSource includes this field in the reply message when it decrypts the payment blob for the tokenized transaction. 
    */
    'expirationMonth': string;
    /**
    * One of two possible meanings: - The four-digit year in which a token expires. - The four-digit year in which a card expires. Format: `YYYY` Possible values: `1900` through `3000` Data type: Non-negative integer  **NOTE** The meaning of this field is dependent on the payment processor that is returning the value in an authorization reply. Please see the processor-specific details below.  #### Barclays and Streamline For Maestro (UK Domestic) and Maestro (International) cards on Barclays and Streamline, this must be a valid value (1900 through 3000) but is not required to be a valid expiration date. In other words, an expiration date that is in the past does not cause CyberSource to reject your request. However, an invalid expiration date might cause the issuer to reject your request.  #### Encoded Account Numbers For encoded account numbers (`card_ type=039`), if there is no expiration date on the card, use `2021`.  #### FDC Nashville Global and FDMS South You can send in 2 digits or 4 digits. When you send in 2 digits, they must be the last 2 digits of the year.  #### Samsung Pay and Apple Pay Year in which the token expires. CyberSource includes this field in the reply message when it decrypts the payment blob for the tokenized transaction.  **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting. 
    */
    'expirationYear': string;
    /**
    * This field contains token information.
    */
    'cryptogram': string;
    /**
    * Card Verification Number (CVN).  #### Ingenico ePayments Do not include this field when **commerceIndicator=recurring**. **Note** Ingenico ePayments was previously called _Global Collect_. 
    */
    'securityCode': string;
    /**
    * Customer’s payment network token value. 
    */
    'number': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "transactionType",
            "baseName": "transactionType",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "expirationMonth",
            "baseName": "expirationMonth",
            "type": "string"
        },
        {
            "name": "expirationYear",
            "baseName": "expirationYear",
            "type": "string"
        },
        {
            "name": "cryptogram",
            "baseName": "cryptogram",
            "type": "string"
        },
        {
            "name": "securityCode",
            "baseName": "securityCode",
            "type": "string"
        },
        {
            "name": "number",
            "baseName": "number",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Riskv1authenticationsPaymentInformationTokenizedCard.attributeTypeMap;
    }
}

export class Riskv1authenticationsRiskInformation {
    'buyerHistory'?: Ptsv2paymentsRiskInformationBuyerHistory;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "buyerHistory",
            "baseName": "buyerHistory",
            "type": "Ptsv2paymentsRiskInformationBuyerHistory"
        }    ];

    static getAttributeTypeMap() {
        return Riskv1authenticationsRiskInformation.attributeTypeMap;
    }
}

export class Riskv1authenticationsTravelInformation {
    'legs'?: Array<Riskv1decisionsTravelInformationLegs>;
    /**
    * Number of passengers for whom the ticket was issued. If you do not include this field in your request, CyberSource uses a default value of 1. Required for American Express SafeKey (U.S.) for travel-related requests. 
    */
    'numberOfPassengers'?: number;
    'passengers'?: Array<Riskv1decisionsTravelInformationPassengers>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "legs",
            "baseName": "legs",
            "type": "Array<Riskv1decisionsTravelInformationLegs>"
        },
        {
            "name": "numberOfPassengers",
            "baseName": "numberOfPassengers",
            "type": "number"
        },
        {
            "name": "passengers",
            "baseName": "passengers",
            "type": "Array<Riskv1decisionsTravelInformationPassengers>"
        }    ];

    static getAttributeTypeMap() {
        return Riskv1authenticationsTravelInformation.attributeTypeMap;
    }
}

export class Riskv1authenticationsetupsClientReferenceInformation {
    /**
    * Merchant-generated order reference or tracking number. It is recommended that you send a unique value for each transaction so that you can perform meaningful searches for the transaction.  #### Used by **Authorization** Required field.  #### PIN Debit Requests for PIN debit reversals need to use the same merchant reference number that was used in the transaction that is being reversed.  Required field for all PIN Debit requests (purchase, credit, and reversal).  #### FDC Nashville Global Certain circumstances can cause the processor to truncate this value to 15 or 17 characters for Level II and Level III processing, which can cause a discrepancy between the value you submit and the value included in some processor reports. 
    */
    'code'?: string;
    /**
    * Used to resume a transaction that was paused for an order modification rule to allow for payer authentication to complete. To resume and continue with the authorization/decision service flow, call the services and include the request id from the prior decision call. 
    */
    'pausedRequestId'?: string;
    /**
    * Brief description of the order or any comment you wish to add to the order. 
    */
    'comments'?: string;
    'partner'?: Riskv1decisionsClientReferenceInformationPartner;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        },
        {
            "name": "pausedRequestId",
            "baseName": "pausedRequestId",
            "type": "string"
        },
        {
            "name": "comments",
            "baseName": "comments",
            "type": "string"
        },
        {
            "name": "partner",
            "baseName": "partner",
            "type": "Riskv1decisionsClientReferenceInformationPartner"
        }    ];

    static getAttributeTypeMap() {
        return Riskv1authenticationsetupsClientReferenceInformation.attributeTypeMap;
    }
}

export class Riskv1authenticationsetupsPaymentInformation {
    'card'?: Riskv1authenticationsetupsPaymentInformationCard;
    'tokenizedCard'?: Riskv1authenticationsetupsPaymentInformationTokenizedCard;
    'fluidData'?: Riskv1authenticationsetupsPaymentInformationFluidData;
    'customer'?: Riskv1authenticationsetupsPaymentInformationCustomer;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "card",
            "baseName": "card",
            "type": "Riskv1authenticationsetupsPaymentInformationCard"
        },
        {
            "name": "tokenizedCard",
            "baseName": "tokenizedCard",
            "type": "Riskv1authenticationsetupsPaymentInformationTokenizedCard"
        },
        {
            "name": "fluidData",
            "baseName": "fluidData",
            "type": "Riskv1authenticationsetupsPaymentInformationFluidData"
        },
        {
            "name": "customer",
            "baseName": "customer",
            "type": "Riskv1authenticationsetupsPaymentInformationCustomer"
        }    ];

    static getAttributeTypeMap() {
        return Riskv1authenticationsetupsPaymentInformation.attributeTypeMap;
    }
}

export class Riskv1authenticationsetupsPaymentInformationCard {
    /**
    * Three-digit value that indicates the card type.  **IMPORTANT** It is strongly recommended that you include the card type field in request messages even if it is optional for your processor and card type. Omitting the card type can cause the transaction to be processed with the wrong card type.  Possible values: - `001`: Visa. Use card type value `001` for Visa Electron. - `002`: Mastercard, Eurocard[^1], which is a European regional brand of Mastercard. - `003`: American Express - `004`: Discover - `005`: Diners Club - `006`: Carte Blanche[^1] - `007`: JCB[^1] - `008`: Optima - `009`: GE Private Label - `010`: Beneficial Private Label - `011`: Twinpay Credit Card - `012`: Twinpay Debit Card - `013`: WalMart - `014`: Enroute[^1] - `015`: Lowe's Consumer - `016`: Home Depot Consumer - `017`: MBNA - `018`: Dick's Sportswear - `019`: Casual Corner - `020`: Sears - `021`: JAL[^1] - `023`: Disney Card - `024`: Maestro (UK Domestic)[^1] - `025`: Sam's Club Consumer - `026`: Sam's Club Business - `027`: Nico's - `028`: Paymentech Bill Me Later - `029`: Bebe - `030`: Restoration Hardware - `031`: Delta Online - `032`: Solo - `033`: Visa Electron[^1]. Do not use this value. Use `001` for all Visa card types. - `034`: Dankort[^1] - `035`: Laser - `036`: Cartes Bancaires[^1,4] - `037`: Carta Si[^1] - `038`: Pinless Debit - `039`: Encoded account number[^1] - `040`: UATP[^1] - `041`: HOUSEHOLD - `042`: Maestro (International)[^1] - `043`: GE MONEY - `044`: Korean Cards - `045`: Style Cards - `046`: JCrew - `047`: Payeasecn eWallet - `048`: Payeasecn Bank Transfer - `049`: Meijer - `050`: Hipercard[^2,3] - `051`: Aura - `052`: Redecard - `053`: Orico card - `054`: Elo[^3] - `055`: Capitol One Private Label - `056`: Carnet - `057`: Costco Private Label - `058`: Carnet - `059`: ValueLink - `060`: MADA - `061`: RuPay - `062`: China UnionPay - `063`: Falabella Private Label - `064`: Prompt Card - `065`: Korean Domestic - `066`: Banricompras - `067`: MEEZA - `068`: PayPak - `070`: EFTPOS - `071`: Codensa - `072`: Olimpica - `073`: Colsubsidio - `074`: Tuya - `075`: Sodexo - `076`: Naranja - `077`: Cabal - `078`: DINELCO - `079`: PANAL - `080`: EPM - `081`: Jaywan  [^1]: For this card type, you must include the `paymentInformation.card.type` or `paymentInformation.tokenizedCard.type` field in your request for an authorization or a stand-alone credit. [^2]: For this card type on Cielo 3.0, you must include the `paymentInformation.card.type` or `paymentInformation.tokenizedCard.type` field in a request for an authorization or a stand-alone credit. This card type is not supported on Cielo 1.5. [^3]: For this card type on Getnet and Rede, you must include the `paymentInformation.card.type` or `paymentInformation.tokenizedCard.type` field in a request for an authorization or a stand-alone credit. [^4]: For this card type, you must include the `paymentInformation.card.type` in your request for any payer authentication services.  #### Used by **Authorization** Required for Carte Blanche and JCB. Optional for all other card types.  #### Card Present reply This field is included in the reply message when the client software that is installed on the POS terminal uses the token management service (TMS) to retrieve tokenized payment details. You must contact customer support to have your account enabled to receive these fields in the credit reply message.  Returned by the Credit service.  This reply field is only supported by the following processors: - American Express Direct - Credit Mutuel-CIC - FDC Nashville Global - OmniPay Direct - SIX  #### Google Pay transactions For PAN-based Google Pay transactions, this field is returned in the API response.  #### GPX This field only supports transactions from the following card types: - Visa - Mastercard - AMEX - Discover - Diners - JCB - Union Pay International 
    */
    'type'?: string;
    /**
    * Two-digit month in which the payment card expires.  Format: `MM`.  Valid values: `01` through `12`. Leading 0 is required.  #### Barclays and Streamline For Maestro (UK Domestic) and Maestro (International) cards on Barclays and Streamline, this must be a valid value (`01` through `12`) but is not required to be a valid expiration date. In other words, an expiration date that is in the past does not cause CyberSource to reject your request. However, an invalid expiration date might cause the issuer to reject your request.  #### Encoded Account Numbers For encoded account numbers (_type_=039), if there is no expiration date on the card, use `12`.  #### FDMS Nashville Required field.  #### All other processors Required if `pointOfSaleInformation.entryMode=keyed`. However, this field is optional if your account is configured for relaxed requirements for address data and expiration date. **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.  #### Google Pay transactions For PAN-based Google Pay transactions, this field is returned in the API response. 
    */
    'expirationMonth': string;
    /**
    * Four-digit year in which the payment card expires.  Format: `YYYY`.  #### Barclays and Streamline For Maestro (UK Domestic) and Maestro (International) cards on Barclays and Streamline, this must be a valid value (`1900` through `3000`) but is not required to be a valid expiration date. In other words, an expiration date that is in the past does not cause CyberSource to reject your request. However, an invalid expiration date might cause the issuer to reject your request.  #### Encoded Account Numbers For encoded account numbers (**_type_**`=039`), if there is no expiration date on the card, use `2021`.  #### FDMS Nashville Required field.  #### FDC Nashville Global and FDMS South You can send in 2 digits or 4 digits. If you send in 2 digits, they must be the last 2 digits of the year.  #### All other processors Required if `pointOfSaleInformation.entryMode=keyed`. However, this field is optional if your account is configured for relaxed requirements for address data and expiration date. **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.  #### Google Pay transactions For PAN-based Google Pay transactions, this field is returned in the API response. 
    */
    'expirationYear': string;
    /**
    * The customer’s payment card number, also known as the Primary Account Number (PAN). You can also use this field for encoded account numbers.  #### FDMS Nashville Required. String (19)  #### GPX Required if `pointOfSaleInformation.entryMode=keyed`. However, this field is optional if your account is configured for relaxed requirements for address data and expiration date. **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.  #### All other processors Required if `pointOfSaleInformation.entryMode=keyed`. However, this field is optional if your account is configured for relaxed requirements for address data and expiration date. **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting. 
    */
    'number': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "expirationMonth",
            "baseName": "expirationMonth",
            "type": "string"
        },
        {
            "name": "expirationYear",
            "baseName": "expirationYear",
            "type": "string"
        },
        {
            "name": "number",
            "baseName": "number",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Riskv1authenticationsetupsPaymentInformationCard.attributeTypeMap;
    }
}

export class Riskv1authenticationsetupsPaymentInformationCustomer {
    /**
    * Unique identifier for the legacy Secure Storage token used in the transaction. When you include this value in your request, many of the fields that are normally required for an authorization or credit become optional. 
    */
    'customerId': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "customerId",
            "baseName": "customerId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Riskv1authenticationsetupsPaymentInformationCustomer.attributeTypeMap;
    }
}

export class Riskv1authenticationsetupsPaymentInformationFluidData {
    /**
    * Represents the encrypted payment data BLOB. The entry for this field is dependent on the payment solution used by the merchant. Used by Authorization and Standalone Credits. Required for authorizations and standalone credits that use a Cybersource suppored Point-to-Point encryption method. Card Present processing This field represents the encrypted payment data generated by the payment terminal/device. 
    */
    'value': string;
    /**
    * The encoded or encrypted value that a payment solution returns for an authorization request. For details about the valid values for a key, see [Creating an Online Authorization](https://developer.cybersource.com/api/developer-guides/dita-payments/CreatingOnlineAuth.html) 
    */
    'keySerialNumber'?: string;
    /**
    * The identifier for a payment solution, which is sending the encrypted payment data for decryption. Valid values: Samsung Pay: RklEPUNPTU1PTi5TQU1TVU5HLklOQVBQLlBBWU1FTlQ= Note: For other payment solutions, the value may be specific to the terminal or device initiatinf the payment. For example, the descriptor for a Bluefin payment encryption would be a device-generated descriptor. Used by Authorization and Standalone Credits. Required for authorizations and standalone credits.  Card Present processing: Format of the encrypted payment data. The value for Bluefin PCI P2PE is `Ymx1ZWZpbg==`. paymentInformation.fluidData.encoding must be `Base64`. The value for Cybersource P2PE decryption depends on the encoding method used and identified in encoding field. If paymentInformation.fluidData.encoding is `Base64`, the value is: `RklEPUVNVi5QQVlNRU5ULkFQSQ==` If paymentInformation.fluidData.encoding is `HEX`, the value is: `4649443D454D562E5041594D454E542E41504` 
    */
    'descriptor'?: string;
    /**
    * Encoding method used to encrypt the payment data. Valid values: `Base64`, `HEX` If no value is provided, `Base64` is taken as the default value. And the `Base64` descriptor is used for paymentInformation.fluidData.encoding 
    */
    'encoding'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "value",
            "baseName": "value",
            "type": "string"
        },
        {
            "name": "keySerialNumber",
            "baseName": "keySerialNumber",
            "type": "string"
        },
        {
            "name": "descriptor",
            "baseName": "descriptor",
            "type": "string"
        },
        {
            "name": "encoding",
            "baseName": "encoding",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Riskv1authenticationsetupsPaymentInformationFluidData.attributeTypeMap;
    }
}

export class Riskv1authenticationsetupsPaymentInformationTokenizedCard {
    /**
    * Type of transaction that provided the token data. This value does not specify the token service provider; it specifies the entity that provided you with information about the token.  Possible value: - `2`: Near-field communication (NFC) transaction. The customer’s mobile device provided the token data for a contactless EMV transaction. For recurring transactions, use this value if the original transaction was a contactless EMV transaction.  #### Visa Platform Connect - `1`: For Rupay and In App tokenization. Example: InApp apple pay. - `3`: Card/Credential On File Tokenization.  **NOTE** No CyberSource through VisaNet acquirers support EMV at this time.  Required field for PIN debit credit or PIN debit purchase transactions that use payment network tokens; otherwise, not used.  #### Rupay - `3`: Card/Credential On File Tokenization. - `4`: Tokenizined Transaction. Should be used for Guest Checkout transactions with token. 
    */
    'transactionType': string;
    /**
    * Three-digit value that indicates the card type.  **IMPORTANT** It is strongly recommended that you include the card type field in request messages even if it is optional for your processor and card type. Omitting the card type can cause the transaction to be processed with the wrong card type.  Possible values: - `001`: Visa. Use card type value `001` for Visa Electron. - `002`: Mastercard, Eurocard[^1], which is a European regional brand of Mastercard. - `003`: American Express - `004`: Discover - `005`: Diners Club - `006`: Carte Blanche[^1] - `007`: JCB[^1] - `008`: Optima - `009`: GE Private Label - `010`: Beneficial Private Label - `011`: Twinpay Credit Card - `012`: Twinpay Debit Card - `013`: WalMart - `014`: Enroute[^1] - `015`: Lowe's Consumer - `016`: Home Depot Consumer - `017`: MBNA - `018`: Dick's Sportswear - `019`: Casual Corner - `020`: Sears - `021`: JAL[^1] - `023`: Disney Card - `024`: Maestro (UK Domestic)[^1] - `025`: Sam's Club Consumer - `026`: Sam's Club Business - `027`: Nico's - `028`: Paymentech Bill Me Later - `029`: Bebe - `030`: Restoration Hardware - `031`: Delta Online - `032`: Solo - `033`: Visa Electron[^1]. Do not use this value. Use `001` for all Visa card types. - `034`: Dankort[^1] - `035`: Laser - `036`: Cartes Bancaires[^1,4] - `037`: Carta Si[^1] - `038`: Pinless Debit - `039`: Encoded account number[^1] - `040`: UATP[^1] - `041`: HOUSEHOLD - `042`: Maestro (International)[^1] - `043`: GE MONEY - `044`: Korean Cards - `045`: Style Cards - `046`: JCrew - `047`: Payeasecn eWallet - `048`: Payeasecn Bank Transfer - `049`: Meijer - `050`: Hipercard[^2,3] - `051`: Aura - `052`: Redecard - `053`: Orico card - `054`: Elo[^3] - `055`: Capitol One Private Label - `056`: Carnet - `057`: Costco Private Label - `058`: Carnet - `059`: ValueLink - `060`: MADA - `061`: RuPay - `062`: China UnionPay - `063`: Falabella Private Label - `064`: Prompt Card - `065`: Korean Domestic - `066`: Banricompras - `067`: MEEZA - `068`: PayPak - `070`: EFTPOS - `071`: Codensa - `072`: Olimpica - `073`: Colsubsidio - `074`: Tuya - `075`: Sodexo - `076`: Naranja - `077`: Cabal - `078`: DINELCO - `079`: PANAL - `080`: EPM - `081`: Jaywan  [^1]: For this card type, you must include the `paymentInformation.card.type` or `paymentInformation.tokenizedCard.type` field in your request for an authorization or a stand-alone credit. [^2]: For this card type on Cielo 3.0, you must include the `paymentInformation.card.type` or `paymentInformation.tokenizedCard.type` field in a request for an authorization or a stand-alone credit. This card type is not supported on Cielo 1.5. [^3]: For this card type on Getnet and Rede, you must include the `paymentInformation.card.type` or `paymentInformation.tokenizedCard.type` field in a request for an authorization or a stand-alone credit. [^4]: For this card type, you must include the `paymentInformation.card.type` in your request for any payer authentication services.  #### Used by **Authorization** Required for Carte Blanche and JCB. Optional for all other card types.  #### Card Present reply This field is included in the reply message when the client software that is installed on the POS terminal uses the token management service (TMS) to retrieve tokenized payment details. You must contact customer support to have your account enabled to receive these fields in the credit reply message.  Returned by the Credit service.  This reply field is only supported by the following processors: - American Express Direct - Credit Mutuel-CIC - FDC Nashville Global - OmniPay Direct - SIX  #### Google Pay transactions For PAN-based Google Pay transactions, this field is returned in the API response.  #### GPX This field only supports transactions from the following card types: - Visa - Mastercard - AMEX - Discover - Diners - JCB - Union Pay International 
    */
    'type': string;
    /**
    * One of two possible meanings: - The two-digit month in which a token expires. - The two-digit month in which a card expires. Format: `MM` Possible values: `01` through `12`  **NOTE** The meaning of this field is dependent on the payment processor that is returning the value in an authorization reply. Please see the processor-specific details below.  #### Barclays and Streamline For Maestro (UK Domestic) and Maestro (International) cards on Barclays and Streamline, this must be a valid value (`01` through `12`) but is not required to be a valid expiration date. In other words, an expiration date that is in the past does not cause CyberSource to reject your request. However, an invalid expiration date might cause the issuer to reject your request.  #### Encoded Account Numbers For encoded account numbers (`card_type=039`), if there is no expiration date on the card, use `12`.\\ **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.  #### Samsung Pay and Apple Pay Month in which the token expires. CyberSource includes this field in the reply message when it decrypts the payment blob for the tokenized transaction. 
    */
    'expirationMonth': string;
    /**
    * One of two possible meanings: - The four-digit year in which a token expires. - The four-digit year in which a card expires. Format: `YYYY` Possible values: `1900` through `3000` Data type: Non-negative integer  **NOTE** The meaning of this field is dependent on the payment processor that is returning the value in an authorization reply. Please see the processor-specific details below.  #### Barclays and Streamline For Maestro (UK Domestic) and Maestro (International) cards on Barclays and Streamline, this must be a valid value (1900 through 3000) but is not required to be a valid expiration date. In other words, an expiration date that is in the past does not cause CyberSource to reject your request. However, an invalid expiration date might cause the issuer to reject your request.  #### Encoded Account Numbers For encoded account numbers (`card_ type=039`), if there is no expiration date on the card, use `2021`.  #### FDC Nashville Global and FDMS South You can send in 2 digits or 4 digits. When you send in 2 digits, they must be the last 2 digits of the year.  #### Samsung Pay and Apple Pay Year in which the token expires. CyberSource includes this field in the reply message when it decrypts the payment blob for the tokenized transaction.  **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting. 
    */
    'expirationYear': string;
    /**
    * Customer’s payment network token value. 
    */
    'number': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "transactionType",
            "baseName": "transactionType",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "expirationMonth",
            "baseName": "expirationMonth",
            "type": "string"
        },
        {
            "name": "expirationYear",
            "baseName": "expirationYear",
            "type": "string"
        },
        {
            "name": "number",
            "baseName": "number",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Riskv1authenticationsetupsPaymentInformationTokenizedCard.attributeTypeMap;
    }
}

export class Riskv1authenticationsetupsProcessingInformation {
    /**
    * Type of digital payment solution for the transaction. Possible Values:   - `visacheckout`: Visa Checkout. This value is required for Visa Checkout transactions. For details, see `payment_solution` field description in [Visa Checkout Using the REST API.](https://developer.cybersource.com/content/dam/docs/cybs/en-us/apifields/reference/all/rest/api-fields.pdf)  - `001`: Apple Pay.  - `004`: Cybersource In-App Solution.  - `005`: Masterpass. This value is required for Masterpass transactions on OmniPay Direct.   - `006`: Android Pay.  - `007`: Chase Pay.  - `008`: Samsung Pay.  - `012`: Google Pay.  - `013`: Cybersource P2PE Decryption  - `014`: Mastercard credential on file (COF) payment network token. Returned in authorizations that use a payment network token associated with a TMS token.  - `015`: Visa credential on file (COF) payment network token. Returned in authorizations that use a payment network token associated with a TMS token.  - `027`: Click to Pay. 
    */
    'paymentSolution'?: string;
    /**
    * Identifier for the **Visa Checkout** order. Visa Checkout provides a unique order ID for every transaction in the Visa Checkout **callID** field. 
    */
    'visaCheckoutId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "paymentSolution",
            "baseName": "paymentSolution",
            "type": "string"
        },
        {
            "name": "visaCheckoutId",
            "baseName": "visaCheckoutId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Riskv1authenticationsetupsProcessingInformation.attributeTypeMap;
    }
}

export class Riskv1authenticationsetupsTokenInformation {
    /**
    * A temporary ID that represents the customer's payment data (which is securely stored in Visa Data Centers). Flex Microform generates this ID and sets it to expire within 15 minutes from when the ID is generated or until the first payment authorization is carried out (whichever occurs first).  Valid value for the ID is a 64-character, alphanumeric string.  Example: 1D08M4YB968R1F7YVL4TBBKYVNRIR02VZFH9CBYSQIJJXORPI1NK5C98D7F6EB53 
    */
    'transientToken'?: string;
    /**
    * TMS Transient Token, 64 hexadecimal id value representing captured payment credentials (including Sensitive Authentication Data, e.g. CVV). 
    */
    'jti'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "transientToken",
            "baseName": "transientToken",
            "type": "string"
        },
        {
            "name": "jti",
            "baseName": "jti",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Riskv1authenticationsetupsTokenInformation.attributeTypeMap;
    }
}

export class Riskv1decisionsAcquirerInformation {
    /**
    * Acquirer bank ID number that  corresponds to a certificate that Cybersource already has.This ID has this format. 4XXXXX for Visa and 5XXXXX for Mastercard. 
    */
    'acquirerBin'?: string;
    /**
    * Issuers need to be aware of the Acquirer's Country Code when the Acquirer country differs from the Merchant country and the Acquirer is in the EEA (European Economic Area). 
    */
    'country'?: string;
    /**
    * Registered password for the Visa directory server. 
    */
    'password'?: string;
    /**
    * Username for the visa directory server that is created when your acquirer sets up your account. This ID might be the same as your merchant ID. the username can be 15 or 23 characters. 
    */
    'merchantId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "acquirerBin",
            "baseName": "acquirerBin",
            "type": "string"
        },
        {
            "name": "country",
            "baseName": "country",
            "type": "string"
        },
        {
            "name": "password",
            "baseName": "password",
            "type": "string"
        },
        {
            "name": "merchantId",
            "baseName": "merchantId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Riskv1decisionsAcquirerInformation.attributeTypeMap;
    }
}

/**
* Contains information about the buyer.
*/
export class Riskv1decisionsBuyerInformation {
    /**
    * Your identifier for the customer.  When a subscription or customer profile is being created, the maximum length for this field for most processors is 30. Otherwise, the maximum length is 100.  #### Comercio Latino For recurring payments in Mexico, the value is the customer’s contract number. Note Before you request the authorization, you must inform the issuer of the customer contract numbers that will be used for recurring transactions.  #### Worldpay VAP For a follow-on credit with Worldpay VAP, CyberSource checks the following locations, in the order given, for a customer account ID value and uses the first value it finds: 1. `customer_account_id` value in the follow-on credit request 2. Customer account ID value that was used for the capture that is being credited 3. Customer account ID value that was used for the original authorization If a customer account ID value cannot be found in any of these locations, then no value is used. 
    */
    'merchantCustomerId'?: string;
    /**
    * Specifies the customer account user name.
    */
    'username'?: string;
    /**
    * The merchant's password that CyberSource hashes and stores as a hashed password. 
    */
    'hashedPassword'?: string;
    /**
    * Recipient’s date of birth. **Format**: `YYYYMMDD`.  This field is a `pass-through`, which means that CyberSource ensures that the value is eight numeric characters but otherwise does not verify the value or modify it in any way before sending it to the processor. If the field is not required for the transaction, CyberSource does not forward it to the processor. 
    */
    'dateOfBirth'?: string;
    'personalIdentification'?: Array<Ptsv2paymentsBuyerInformationPersonalIdentification>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "merchantCustomerId",
            "baseName": "merchantCustomerId",
            "type": "string"
        },
        {
            "name": "username",
            "baseName": "username",
            "type": "string"
        },
        {
            "name": "hashedPassword",
            "baseName": "hashedPassword",
            "type": "string"
        },
        {
            "name": "dateOfBirth",
            "baseName": "dateOfBirth",
            "type": "string"
        },
        {
            "name": "personalIdentification",
            "baseName": "personalIdentification",
            "type": "Array<Ptsv2paymentsBuyerInformationPersonalIdentification>"
        }    ];

    static getAttributeTypeMap() {
        return Riskv1decisionsBuyerInformation.attributeTypeMap;
    }
}

export class Riskv1decisionsClientReferenceInformation {
    /**
    * Merchant-generated order reference or tracking number. It is recommended that you send a unique value for each transaction so that you can perform meaningful searches for the transaction.  #### Used by **Authorization** Required field.  #### PIN Debit Requests for PIN debit reversals need to use the same merchant reference number that was used in the transaction that is being reversed.  Required field for all PIN Debit requests (purchase, credit, and reversal).  #### FDC Nashville Global Certain circumstances can cause the processor to truncate this value to 15 or 17 characters for Level II and Level III processing, which can cause a discrepancy between the value you submit and the value included in some processor reports. 
    */
    'code': string;
    /**
    * Used to resume a transaction that was paused for an order modification rule to allow for payer authentication to complete. To resume and continue with the authorization/decision service flow, call the services and include the request id from the prior decision call. 
    */
    'pausedRequestId'?: string;
    /**
    * Brief description of the order or any comment you wish to add to the order. 
    */
    'comments'?: string;
    'partner'?: Riskv1decisionsClientReferenceInformationPartner;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        },
        {
            "name": "pausedRequestId",
            "baseName": "pausedRequestId",
            "type": "string"
        },
        {
            "name": "comments",
            "baseName": "comments",
            "type": "string"
        },
        {
            "name": "partner",
            "baseName": "partner",
            "type": "Riskv1decisionsClientReferenceInformationPartner"
        }    ];

    static getAttributeTypeMap() {
        return Riskv1decisionsClientReferenceInformation.attributeTypeMap;
    }
}

export class Riskv1decisionsClientReferenceInformationPartner {
    /**
    * Identifier for the developer that helped integrate a partner solution to CyberSource.  Send this value in all requests that are sent through the partner solutions built by that developer. CyberSource assigns the ID to the developer.  **Note** When you see a developer ID of 999 in reports, the developer ID that was submitted is incorrect. 
    */
    'developerId'?: string;
    /**
    * Identifier for the partner that is integrated to CyberSource.  Send this value in all requests that are sent through the partner solution. CyberSource assigns the ID to the partner.  **Note** When you see a solutionId of 999 in reports, the solutionId that was submitted is incorrect. 
    */
    'solutionId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "developerId",
            "baseName": "developerId",
            "type": "string"
        },
        {
            "name": "solutionId",
            "baseName": "solutionId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Riskv1decisionsClientReferenceInformationPartner.attributeTypeMap;
    }
}

export class Riskv1decisionsConsumerAuthenticationInformation {
    'strongAuthentication'?: Riskv1decisionsConsumerAuthenticationInformationStrongAuthentication;
    /**
    * An override field that a merchant can pass in to set the challenge window size to display to the end cardholder.  The ACS (Active Control Server) will reply with content that is formatted appropriately to this window size to allow for the best user experience.  The sizes are width x height in pixels of the window displayed in the cardholder browser window.  01 - 250x400  02 - 390x400  03 - 500x600  04 - 600x400  05 - Full page 
    */
    'acsWindowSize'?: string;
    /**
    * Data that documents and supports a specific authentication process. 
    */
    'alternateAuthenticationData'?: string;
    /**
    * Date and time in UTC of the cardholder authentication. Format: YYYYMMDDHHMM 
    */
    'alternateAuthenticationDate'?: string;
    /**
    * Mechanism used by the cardholder to authenticate to the 3D Secure requestor. Possible values: - `01`: No authentication occurred - `02`: Login using merchant system credentials - `03`: Login using Federated ID - `04`: Login using issuer credentials - `05`: Login using third-party authenticator - `06`: Login using FIDO Authenticator 
    */
    'alternateAuthenticationMethod'?: string;
    /**
    * The date/time of the authentication at the 3DS servers. RISK update authorization service in auth request payload with value returned in `consumerAuthenticationInformation.alternateAuthenticationData` if merchant calls via CYBS or field can be provided by merchant in authorization request if calling an external 3DS provider.  This field is supported for Cartes Bancaires Fast'R transactions on Credit Mutuel-CIC. Format: YYYYMMDDHHMMSS 
    */
    'authenticationDate'?: string;
    /**
    * Payer authentication transaction identifier passed to link the check enrollment and validate authentication messages.For Rupay,this is passed only in Re-Send OTP usecase. **Note**: Required for Standard integration, Rupay Seamless server to server integration for enroll service. Required for Hybrid integration for validate service. 
    */
    'authenticationTransactionId'?: string;
    /**
    * This  field is only applicable to Rupay and is optional. Merchant will have to pass a valid value from 01 through 07 which indicates the transaction flow. Below are the possible values. 01:NW- Transaction performed at domestic merchant. 02:TW- Transaction performed at domestic merchant along with Token provisioning. 03:IT- Transaction performed at International merchant. 04:AT- Authentication Transaction Only. 05:AW- Authentication transaction for provisioning. 06:DI- Domestic InApp Transaction. 07:II- International InApp transaction. 08:GC- Guest Checkout 09:ST- SI Authentication Transaction only 10:SW- SI Authorization along with token provisioning 
    */
    'transactionFlowIndicator'?: number;
    /**
    * Possible values: - `01`: No preference - `02`: No challenge request - `03`: Challenge requested (3D Secure requestor preference) - `04`: Challenge requested (mandate) - `05`: No challenge requested (transactional risk analysis is already performed) - `06`: No challenge requested (Data share only) - `07`: No challenge requested (strong consumer authentication is already performed) - `08`: No challenge requested (utilize whitelist exemption if no challenge required) - `09`: Challenge requested (whitelist prompt requested if challenge required) **Note** This field will default to `01` on merchant configuration and can be overridden by the merchant. EMV 3D Secure version 2.1.0 supports values `01-04`. Version 2.2.0 supports values `01-09`. 
    */
    'challengeCode'?: string;
    /**
    * The `consumerAuthenticationInformation.challengeCode` indicates the authentication type/level, or challenge, that was presented to the cardholder at checkout by the merchant when calling the Carte Bancaire 3DS servers via CYBS RISK services. It conveys to the issuer the alternative authentication methods that the consumer used. 
    */
    'challengeStatus'?: string;
    /**
    * An alias that uniquely identifies the customer's account and credit card on file. Note This field is required if Tokenization is enabled in the merchant profile settings. 
    */
    'customerCardAlias'?: string;
    /**
    * Indicates whether the 3DS Requestor requests the ACS to utilize Decoupled Authentication and agrees to utilize Decoupled Authentication if the ACS confirms its use.  Possible Values:  Y - Decoupled Authentication is supported and preferred if challenge is necessary  N - Do not use Decoupled Authentication  **Default Value**: N 
    */
    'decoupledAuthenticationIndicator'?: string;
    /**
    * Indicates the maximum amount of time that the 3DS Requestor will wait for an ACS (Active control server) to provide the results of a Decoupled Authentication transaction (in minutes). Possible Values: Numeric values between 1 and 10080 accepted. 
    */
    'decoupledAuthenticationMaxTime'?: string;
    /**
    * Indicates that the card being used is the one designated as the primary payment card for purchase. Recommended for Discover ProtectBuy. 
    */
    'defaultCard'?: boolean;
    /**
    * Determines the channel that the transaction came through. Possible Values: SDK/Browser/3RI. 3RI - 3DS request initiated. 
    */
    'deviceChannel': string;
    /**
    * An integer value greater than 1 indicating the max number of permitted authorizations for installment payments. **Note** This is required if the merchant and cardholder have agreed to installment payments. 
    */
    'installmentTotalCount'?: number;
    /**
    * Calculated by merchants as per PSD2** RTS** (EEA** card fraud divided by all EEA card volumes). Possible Values: 1 = Represents fraud rate <=1  2 = Represents fraud rate >1 and <=6  3 = Represents fraud rate >6 and <=13  4 = Represents fraud rate >13 and <=25  5 = Represents fraud rate >25  EEA** = European Economic Area RTS** = Regulatory Technical Standards PSD2** = Payment Services Directive 
    */
    'merchantFraudRate'?: string;
    /**
    * Indicates whether the customer has opted in for marketing offers. Recommended for Discover ProtectBuy. 
    */
    'marketingOptIn'?: boolean;
    /**
    * Indicates origin of the marketing offer. Recommended for Discover ProtectBuy. 
    */
    'marketingSource'?: string;
    /**
    * Merchant category code. **Important** Required only for Visa Secure transactions in Brazil. Do not use this request field for any other types of transactions. 
    */
    'mcc'?: string;
    /**
    * Risk Score provided by merchants. This is specific for CB transactions. 
    */
    'merchantScore'?: number;
    /**
    * Category of the message for a specific use case. Possible values:  - `01`: PA- payment authentication - `02`: NPA- non-payment authentication - `03-79`: Reserved for EMVCo future use (values invalid until defined by EMVCo) - `80-99`: Reserved for DS use 
    */
    'messageCategory'?: string;
    /**
    * Non-Payer Authentication Indicator. Possible values: - `01`: Add card - `02`: Maintain card information - `03`: Cardholder verification for EMV token - `04-80` Reserved for EMVCo - `80-90` Reserved DS 
    */
    'npaCode'?: string;
    /**
    * Specifies the Brazilian payment account type used for the transaction. This field overrides other payment types that might be specified in the request. Use one of the following values for this field: - `NA`: Not applicable. Do not override other payment types that are specified in the request. - `CR`: Credit card. - `DB`: Debit card. - `VSAVR`: Visa Vale Refeicao - `VSAVA`: Visa Vale Alimentacao **Important** Required only for Visa Secure transactions in Brazil. Do not use this request field for any other types of transactions. 
    */
    'overridePaymentMethod'?: string;
    /**
    * Two-character [ISO Standard Country Codes](https://developer.cybersource.com/library/documentation/sbc/quickref/countries_alpha_list.pdf).. 
    */
    'overrideCountryCode'?: string;
    /**
    * This field carry data that the ACS can use to verify the authentication process. 
    */
    'priorAuthenticationData'?: string;
    /**
    * Mechanism used by the Cardholder to previously authenticate to the 3DS Requestor.  01 - Frictionless authentication occurred by ACS  02 - Cardholder challenge occurred by ACS  03 - AVS verified  04 - Other issuer methods  05-79 - Reserved for EMVCo future use (values invalid until defined by EMVCo)  80-99 - Reserved for DS use 
    */
    'priorAuthenticationMethod'?: string;
    /**
    * This data element contains a ACS Transaction ID for a prior authenticated transaction. For example, the first recurring transaction that was authenticated with the cardholder 
    */
    'priorAuthenticationReferenceId'?: string;
    /**
    * Date and time in UTC of the prior cardholder authentication. Format – YYYYMMDDHHMM 
    */
    'priorAuthenticationTime'?: string;
    /**
    * Specifies the product code, which designates the type of transaction. Specify one of the following values for this field: - AIR: Airline purchase Important Required for American Express SafeKey (U.S.). - `ACC`: Accommodation Rental - `ACF`: Account funding - `CHA`: Check acceptance - `DIG`: Digital Goods - `DSP`: Cash Dispensing - `GAS`: Fuel - `GEN`: General Retail - `LUX`: Luxury Retail - `PAL`: Prepaid activation and load - `PHY`: Goods or services purchase - `QCT`: Quasi-cash transaction - `REN`: Car Rental - `RES`: Restaurant - `SVC`: Services - `TBD`: Other - `TRA`: Travel **Important** Required for Visa Secure transactions in Brazil. Do not use this request field for any other types of transactions. 
    */
    'productCode'?: string;
    /**
    * The URL of the merchant’s return page. CyberSource adds this return URL to the step-up JWT and returns it in the response of the Payer Authentication enrollment call. The merchant's return URL page serves as a listening URL. Once the bank session completes, the merchant receives a POST to their URL. This response contains the completed bank session’s transactionId. The merchant’s return page should capture the transaction ID and send it in the Payer Authentication validation call. 
    */
    'returnUrl'?: string;
    /**
    * Cardinal's directory server assigned 3DS Requestor ID value
    */
    'requestorId'?: string;
    /**
    * Indicates the type of 3RI request.  Possible Values:  01 - Recurring transaction  02 - Installment transaction  03 - Add card  04 - Maintain card  05 - Account verification  06 - Split/delayed shipment  07 - Top-up  08 - Mail Order  09 - Telephone Order  10 - Whitelist status check  11 - Other payment 
    */
    'requestorInitiatedAuthenticationIndicator'?: string;
    /**
    * Cardinal's directory server assigned 3DS Requestor Name value
    */
    'requestorName'?: string;
    /**
    * Reference ID that corresponds to the device fingerprinting data that was collected previously. Note Required for Hybrid integration. 
    */
    'referenceId'?: string;
    /**
    * This field indicates the maximum amount of time for all 3DS 2.0 messages to be communicated between all components (in minutes).  Possible Values:  Greater than or equal to 05 (05 is the minimum timeout to set)  Cardinal Default is set to 15  NOTE: This field is a required 3DS 2.0 field and Cardinal sends in a default of 15 if nothing is passed 
    */
    'sdkMaxTimeout'?: string;
    /**
    * Indicates dedicated payment processes and procedures were used, potential secure corporate payment exemption applies. Possible Values : 0/1 
    */
    'secureCorporatePaymentIndicator'?: string;
    /**
    * Transaction mode identifier. Identifies the channel from which the transaction originates. Possible values:  - `M`: MOTO (Mail Order Telephone Order) - `R`: Retail - `S`: eCommerce - `P`: Mobile Device - `T`: Tablet 
    */
    'transactionMode'?: string;
    /**
    * Enables the communication of trusted beneficiary/whitelist status between the ACS, the DS and the 3DS Requestor.  Possible Values:  Y - 3DS Requestor is whitelisted by cardholder  N - 3DS Requestor is not whitelisted by cardholder 
    */
    'whiteListStatus'?: string;
    /**
    * Risk Assessment from Mastercard. This is to be sent by merchant if they would like to request a score
    */
    'scoreRequest'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "strongAuthentication",
            "baseName": "strongAuthentication",
            "type": "Riskv1decisionsConsumerAuthenticationInformationStrongAuthentication"
        },
        {
            "name": "acsWindowSize",
            "baseName": "acsWindowSize",
            "type": "string"
        },
        {
            "name": "alternateAuthenticationData",
            "baseName": "alternateAuthenticationData",
            "type": "string"
        },
        {
            "name": "alternateAuthenticationDate",
            "baseName": "alternateAuthenticationDate",
            "type": "string"
        },
        {
            "name": "alternateAuthenticationMethod",
            "baseName": "alternateAuthenticationMethod",
            "type": "string"
        },
        {
            "name": "authenticationDate",
            "baseName": "authenticationDate",
            "type": "string"
        },
        {
            "name": "authenticationTransactionId",
            "baseName": "authenticationTransactionId",
            "type": "string"
        },
        {
            "name": "transactionFlowIndicator",
            "baseName": "transactionFlowIndicator",
            "type": "number"
        },
        {
            "name": "challengeCode",
            "baseName": "challengeCode",
            "type": "string"
        },
        {
            "name": "challengeStatus",
            "baseName": "challengeStatus",
            "type": "string"
        },
        {
            "name": "customerCardAlias",
            "baseName": "customerCardAlias",
            "type": "string"
        },
        {
            "name": "decoupledAuthenticationIndicator",
            "baseName": "decoupledAuthenticationIndicator",
            "type": "string"
        },
        {
            "name": "decoupledAuthenticationMaxTime",
            "baseName": "decoupledAuthenticationMaxTime",
            "type": "string"
        },
        {
            "name": "defaultCard",
            "baseName": "defaultCard",
            "type": "boolean"
        },
        {
            "name": "deviceChannel",
            "baseName": "deviceChannel",
            "type": "string"
        },
        {
            "name": "installmentTotalCount",
            "baseName": "installmentTotalCount",
            "type": "number"
        },
        {
            "name": "merchantFraudRate",
            "baseName": "merchantFraudRate",
            "type": "string"
        },
        {
            "name": "marketingOptIn",
            "baseName": "marketingOptIn",
            "type": "boolean"
        },
        {
            "name": "marketingSource",
            "baseName": "marketingSource",
            "type": "string"
        },
        {
            "name": "mcc",
            "baseName": "mcc",
            "type": "string"
        },
        {
            "name": "merchantScore",
            "baseName": "merchantScore",
            "type": "number"
        },
        {
            "name": "messageCategory",
            "baseName": "messageCategory",
            "type": "string"
        },
        {
            "name": "npaCode",
            "baseName": "npaCode",
            "type": "string"
        },
        {
            "name": "overridePaymentMethod",
            "baseName": "overridePaymentMethod",
            "type": "string"
        },
        {
            "name": "overrideCountryCode",
            "baseName": "overrideCountryCode",
            "type": "string"
        },
        {
            "name": "priorAuthenticationData",
            "baseName": "priorAuthenticationData",
            "type": "string"
        },
        {
            "name": "priorAuthenticationMethod",
            "baseName": "priorAuthenticationMethod",
            "type": "string"
        },
        {
            "name": "priorAuthenticationReferenceId",
            "baseName": "priorAuthenticationReferenceId",
            "type": "string"
        },
        {
            "name": "priorAuthenticationTime",
            "baseName": "priorAuthenticationTime",
            "type": "string"
        },
        {
            "name": "productCode",
            "baseName": "productCode",
            "type": "string"
        },
        {
            "name": "returnUrl",
            "baseName": "returnUrl",
            "type": "string"
        },
        {
            "name": "requestorId",
            "baseName": "requestorId",
            "type": "string"
        },
        {
            "name": "requestorInitiatedAuthenticationIndicator",
            "baseName": "requestorInitiatedAuthenticationIndicator",
            "type": "string"
        },
        {
            "name": "requestorName",
            "baseName": "requestorName",
            "type": "string"
        },
        {
            "name": "referenceId",
            "baseName": "referenceId",
            "type": "string"
        },
        {
            "name": "sdkMaxTimeout",
            "baseName": "sdkMaxTimeout",
            "type": "string"
        },
        {
            "name": "secureCorporatePaymentIndicator",
            "baseName": "secureCorporatePaymentIndicator",
            "type": "string"
        },
        {
            "name": "transactionMode",
            "baseName": "transactionMode",
            "type": "string"
        },
        {
            "name": "whiteListStatus",
            "baseName": "whiteListStatus",
            "type": "string"
        },
        {
            "name": "scoreRequest",
            "baseName": "scoreRequest",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Riskv1decisionsConsumerAuthenticationInformation.attributeTypeMap;
    }
}

export class Riskv1decisionsConsumerAuthenticationInformationStrongAuthentication {
    /**
    * Indicates the type of Authentication request  01 - Payment transaction  02 - Recurring transaction  03 - Installment transaction  04 - Add card  05 - Maintain card  06 - Cardholder verification as part of EMV token ID and V 
    */
    'authenticationIndicator'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "authenticationIndicator",
            "baseName": "authenticationIndicator",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Riskv1decisionsConsumerAuthenticationInformationStrongAuthentication.attributeTypeMap;
    }
}

export class Riskv1decisionsDeviceInformation {
    /**
    * Whether the customer’s browser accepts cookies. This field can contain one of the following values: - `yes`: The customer’s browser accepts cookies. - `no`: The customer’s browser does not accept cookies. 
    */
    'cookiesAccepted'?: string;
    /**
    * IP address of the customer.  #### Used by **Authorization, Capture, and Credit** Optional field. 
    */
    'ipAddress'?: string;
    /**
    * DNS resolved hostname from `ipAddress`.
    */
    'hostName'?: string;
    /**
    * Field that contains the session ID that you send to Decision Manager to obtain the device fingerprint information. The string can contain uppercase and lowercase letters, digits, hyphen (-), and underscore (_). However, do not use the same uppercase and lowercase letters to indicate different session IDs.  The session ID must be unique for each merchant ID. You can use any string that you are already generating, such as an order number or web session ID.  The session ID must be unique for each page load, regardless of an individual’s web session ID. If a user navigates to a profiled page and is assigned a web session, navigates away from the profiled page, then navigates back to the profiled page, the generated session ID should be different and unique. You may use a web session ID, but it is preferable to use an application GUID (Globally Unique Identifier). This measure ensures that a unique ID is generated every time the page is loaded, even if it is the same user reloading the page. 
    */
    'fingerprintSessionId'?: string;
    /**
    * Email address set in the customer’s browser, which may differ from customer email. 
    */
    'httpBrowserEmail'?: string;
    /**
    * Customer’s browser as identified from the HTTP header data. For example, `Mozilla` is the value that identifies the Netscape browser. 
    */
    'userAgent'?: string;
    'rawData'?: Array<Ptsv2paymentsDeviceInformationRawData>;
    /**
    * Value of the Accept header sent by the customer’s web browser. **Note** If the customer’s browser provides a value, you must include it in your request. 
    */
    'httpAcceptBrowserValue'?: string;
    /**
    * The exact content of the HTTP accept header. 
    */
    'httpAcceptContent'?: string;
    /**
    * Value represents the browser language as defined in IETF BCP47. Example:en-US, refer  https://en.wikipedia.org/wiki/IETF_language_tag for more details. 
    */
    'httpBrowserLanguage'?: string;
    /**
    * A Boolean value that represents the ability of the cardholder browser to execute Java. Value is returned from the navigator.javaEnabled property. Possible Values:True/False 
    */
    'httpBrowserJavaEnabled'?: boolean;
    /**
    * A Boolean value that represents the ability of the cardholder browser to execute JavaScript. Possible Values:True/False. **Note**: Merchants should be able to know the values from fingerprint details of cardholder's browser. 
    */
    'httpBrowserJavaScriptEnabled'?: boolean;
    /**
    * Value represents the bit depth of the color palette for displaying images, in bits per pixel. Example : 24, refer https://en.wikipedia.org/wiki/Color_depth for more details 
    */
    'httpBrowserColorDepth'?: string;
    /**
    * Total height of the Cardholder's scree in pixels, example: 864. 
    */
    'httpBrowserScreenHeight'?: string;
    /**
    * Total width of the cardholder's screen in pixels. Example: 1536. 
    */
    'httpBrowserScreenWidth'?: string;
    /**
    * Time difference between UTC time and the cardholder browser local time, in minutes, Example:300 
    */
    'httpBrowserTimeDifference'?: string;
    /**
    * Value of the User-Agent header sent by the customer’s web browser. Note If the customer’s browser provides a value, you must include it in your request. 
    */
    'userAgentBrowserValue'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "cookiesAccepted",
            "baseName": "cookiesAccepted",
            "type": "string"
        },
        {
            "name": "ipAddress",
            "baseName": "ipAddress",
            "type": "string"
        },
        {
            "name": "hostName",
            "baseName": "hostName",
            "type": "string"
        },
        {
            "name": "fingerprintSessionId",
            "baseName": "fingerprintSessionId",
            "type": "string"
        },
        {
            "name": "httpBrowserEmail",
            "baseName": "httpBrowserEmail",
            "type": "string"
        },
        {
            "name": "userAgent",
            "baseName": "userAgent",
            "type": "string"
        },
        {
            "name": "rawData",
            "baseName": "rawData",
            "type": "Array<Ptsv2paymentsDeviceInformationRawData>"
        },
        {
            "name": "httpAcceptBrowserValue",
            "baseName": "httpAcceptBrowserValue",
            "type": "string"
        },
        {
            "name": "httpAcceptContent",
            "baseName": "httpAcceptContent",
            "type": "string"
        },
        {
            "name": "httpBrowserLanguage",
            "baseName": "httpBrowserLanguage",
            "type": "string"
        },
        {
            "name": "httpBrowserJavaEnabled",
            "baseName": "httpBrowserJavaEnabled",
            "type": "boolean"
        },
        {
            "name": "httpBrowserJavaScriptEnabled",
            "baseName": "httpBrowserJavaScriptEnabled",
            "type": "boolean"
        },
        {
            "name": "httpBrowserColorDepth",
            "baseName": "httpBrowserColorDepth",
            "type": "string"
        },
        {
            "name": "httpBrowserScreenHeight",
            "baseName": "httpBrowserScreenHeight",
            "type": "string"
        },
        {
            "name": "httpBrowserScreenWidth",
            "baseName": "httpBrowserScreenWidth",
            "type": "string"
        },
        {
            "name": "httpBrowserTimeDifference",
            "baseName": "httpBrowserTimeDifference",
            "type": "string"
        },
        {
            "name": "userAgentBrowserValue",
            "baseName": "userAgentBrowserValue",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Riskv1decisionsDeviceInformation.attributeTypeMap;
    }
}

/**
* Contains merchant-defined key-value pairs.
*/
export class Riskv1decisionsMerchantDefinedInformation {
    /**
    * Fields that you can use to store information. The value appears in the Case Management Details window in the Business Center. The first four fields are the same fields that are used by the Secure Data services. See request code examples. **Warning** Merchant-defined data fields are not intended to and must not be used to capture personally identifying information. Accordingly, merchants are prohibited from capturing, obtaining, and/or transmitting any personally identifying information in or via the merchant-defined data fields. Personally identifying information includes, but is not limited to, address, credit card number, social security number, driver's license number, state-issued identification number, passport number, and card verification numbers (CVV, CVC2, CVV2, CID, CVN). In the event CyberSource discovers that a merchant is capturing and/or transmitting personally identifying information via the merchant-defined data fields, whether or not intentionally, CyberSource will immediately suspend the merchant's account, which will result in a rejection of any and all transaction requests submitted by the merchant after the point of suspension. 
    */
    'key'?: string;
    /**
    * String value for the key
    */
    'value'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "key",
            "baseName": "key",
            "type": "string"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Riskv1decisionsMerchantDefinedInformation.attributeTypeMap;
    }
}

export class Riskv1decisionsMerchantInformation {
    'merchantDescriptor'?: Riskv1decisionsMerchantInformationMerchantDescriptor;
    /**
    * Your company’s name as you want it to appear to the customer in the issuing bank’s authentication form. This value overrides the value specified by your merchant bank. 
    */
    'merchantName'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "merchantDescriptor",
            "baseName": "merchantDescriptor",
            "type": "Riskv1decisionsMerchantInformationMerchantDescriptor"
        },
        {
            "name": "merchantName",
            "baseName": "merchantName",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Riskv1decisionsMerchantInformation.attributeTypeMap;
    }
}

export class Riskv1decisionsMerchantInformationMerchantDescriptor {
    /**
    * Your merchant name.  **Note** For Paymentech processor using Cybersource Payouts, the maximum data length is 22.  #### PIN debit Your business name. This name is displayed on the cardholder’s statement. When you include more than one consecutive space, extra spaces are removed.  When you do not include this value in your PIN debit request, the merchant name from your account is used. **Important** This value must consist of English characters.  Optional field for PIN debit credit or PIN debit purchase requests.  #### Airline processing Your merchant name. This name is displayed on the cardholder’s statement. When you include more than one consecutive space, extra spaces are removed.  **Note** Some airline fee programs may require the original ticket number (ticket identifier) or the ancillary service description in positions 13 through 23 of this field.  **Important** This value must consist of English characters.  Required for captures and credits. 
    */
    'name'?: string;
    /**
    * Address of company's website provided by merchant 
    */
    'url'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Riskv1decisionsMerchantInformationMerchantDescriptor.attributeTypeMap;
    }
}

/**
* Contains detailed order-level information.
*/
export class Riskv1decisionsOrderInformation {
    'amountDetails'?: Riskv1decisionsOrderInformationAmountDetails;
    /**
    * Indicates whether cardholder is placing an order with a future availability or release date. This field can contain one of these values: - MERCHANDISE_AVAILABLE: Merchandise available - FUTURE_AVAILABILITY: Future availability 
    */
    'preOrder'?: string;
    /**
    * Expected date that a pre-ordered purchase will be available. Format: YYYYMMDD 
    */
    'preOrderDate'?: string;
    /**
    * Starting date and time for an event or a journey that is independent of which transportation mechanism, in UTC. The cutoffDateTime will supersede travelInformation.departureTime if both are supplied in the request. Format: YYYY-MM-DDThh:mm:ssZ. Example 2016-08-11T22:47:57Z equals August 11, 2016, at 22:47:57 (10:47:57 p.m.). The T separates the date and the time. The Z indicates UTC. 
    */
    'cutoffDateTime'?: string;
    /**
    * Indicates whether the cardholder is reordering previously purchased merchandise. This field can contain one of these values: - false: First time ordered - true: Reordered 
    */
    'reordered'?: boolean;
    'shippingDetails'?: Riskv1decisionsOrderInformationShippingDetails;
    'shipTo'?: Riskv1decisionsOrderInformationShipTo;
    /**
    * Boolean that indicates whether returns are accepted for this order. This field can contain one of the following values: - true: Returns are accepted for this order. - false: Returns are not accepted for this order. 
    */
    'returnsAccepted'?: boolean;
    /**
    * This array contains detailed information about individual products in the order.
    */
    'lineItems'?: Array<Riskv1decisionsOrderInformationLineItems>;
    'billTo'?: Riskv1decisionsOrderInformationBillTo;
    /**
    * Total number of articles/items in the order as a numeric decimal count. Possible values: 00 - 99 
    */
    'totalOffersCount'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "amountDetails",
            "baseName": "amountDetails",
            "type": "Riskv1decisionsOrderInformationAmountDetails"
        },
        {
            "name": "preOrder",
            "baseName": "preOrder",
            "type": "string"
        },
        {
            "name": "preOrderDate",
            "baseName": "preOrderDate",
            "type": "string"
        },
        {
            "name": "cutoffDateTime",
            "baseName": "cutoffDateTime",
            "type": "string"
        },
        {
            "name": "reordered",
            "baseName": "reordered",
            "type": "boolean"
        },
        {
            "name": "shippingDetails",
            "baseName": "shippingDetails",
            "type": "Riskv1decisionsOrderInformationShippingDetails"
        },
        {
            "name": "shipTo",
            "baseName": "shipTo",
            "type": "Riskv1decisionsOrderInformationShipTo"
        },
        {
            "name": "returnsAccepted",
            "baseName": "returnsAccepted",
            "type": "boolean"
        },
        {
            "name": "lineItems",
            "baseName": "lineItems",
            "type": "Array<Riskv1decisionsOrderInformationLineItems>"
        },
        {
            "name": "billTo",
            "baseName": "billTo",
            "type": "Riskv1decisionsOrderInformationBillTo"
        },
        {
            "name": "totalOffersCount",
            "baseName": "totalOffersCount",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Riskv1decisionsOrderInformation.attributeTypeMap;
    }
}

/**
* Contains `currency` and `totalAmount` for this order.
*/
export class Riskv1decisionsOrderInformationAmountDetails {
    /**
    * Currency used for the order. Use the three-character [ISO Standard Currency Codes.](http://apps.cybersource.com/library/documentation/sbc/quickref/currencies.pdf)  #### Used by **Authorization** Required field.  **Authorization Reversal** For an authorization reversal (`reversalInformation`) or a capture (`processingOptions.capture` is set to `true`), you must use the same currency that you used in your payment authorization request.  #### PIN Debit Currency for the amount you requested for the PIN debit purchase. This value is returned for partial authorizations. The issuing bank can approve a partial amount if the balance on the debit card is less than the requested transaction amount. For the possible values, see the [ISO Standard Currency Codes](https://developer.cybersource.com/library/documentation/sbc/quickref/currencies.pdf). Returned by PIN debit purchase.  For PIN debit reversal requests, you must use the same currency that was used for the PIN debit purchase or PIN debit credit that you are reversing. For the possible values, see the [ISO Standard Currency Codes](https://developer.cybersource.com/library/documentation/sbc/quickref/currencies.pdf).  Required field for PIN Debit purchase and PIN Debit credit requests. Optional field for PIN Debit reversal requests.  #### GPX This field is optional for reversing an authorization or credit.  #### DCC for First Data Your local currency.  #### Tax Calculation Required for international tax and value added tax only. Optional for U.S. and Canadian taxes. Your local currency. 
    */
    'currency': string;
    /**
    * Grand total for the order. You can include a decimal point (.), but no other special characters. CyberSource truncates the amount to the correct number of decimal places.  **Note** For CTV, FDCCompass, Paymentech processors, the maximum length for this field is 12.  **Important** Some processors have specific requirements and limitations, such as maximum amounts and maximum field lengths.  If your processor supports zero amount authorizations, you can set this field to 0 for the authorization to check if the card is lost or stolen.   #### Card Present Required to include either this field or `orderInformation.lineItems[].unitPrice` for the order.  #### Invoicing Required for creating a new invoice.  #### PIN Debit Amount you requested for the PIN debit purchase. This value is returned for partial authorizations. The issuing bank can approve a partial amount if the balance on the debit card is less than the requested transaction amount.  Required field for PIN Debit purchase and PIN Debit credit requests. Optional field for PIN Debit reversal requests.  #### GPX This field is optional for reversing an authorization or credit; however, for all other processors, these fields are required.  #### DCC with a Third-Party Provider Set this field to the converted amount that was returned by the DCC provider. You must include either this field or the 1st line item in the order and the specific line-order amount in your request. For details, see `grand_total_amount` field description in [Dynamic Currency Conversion For First Data Using the SCMP API](http://apps.cybersource.com/library/documentation/dev_guides/DCC_FirstData_SCMP/DCC_FirstData_SCMP_API.pdf).  #### FDMS South If you accept IDR or CLP currencies, see the entry for FDMS South in \"Authorization Information for Specific Processors\" of the [REST API Fields Guide](https://developer.cybersource.com/docs/cybs/en-us/api-fields/reference/all/rest/api-fields/order-info-aa/order-info-amount-details-total-amount.html)  #### DCC for First Data Not used. For details, see [REST API Field Guide](https://developer.cybersource.com/docs/cybs/en-us/api-fields/reference/all/rest/api-fields/order-info-aa/order-info-amount-details-total-amount.html) 
    */
    'totalAmount'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "currency",
            "baseName": "currency",
            "type": "string"
        },
        {
            "name": "totalAmount",
            "baseName": "totalAmount",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Riskv1decisionsOrderInformationAmountDetails.attributeTypeMap;
    }
}

export class Riskv1decisionsOrderInformationBillTo {
    /**
    * Payment card billing street address as it appears on the credit card issuer’s records.  #### SEPA Required for Create Mandate and Import Mandate  #### Atos This field must not contain colons (:).  #### CyberSource through VisaNet **Important** When you populate orderInformation.billTo.address1 and orderInformation.billTo.address2, CyberSource through VisaNet concatenates the two values. If the concatenated value exceeds 40 characters, CyberSource through VisaNet truncates the value at 40 characters before sending it to Visa and the issuing bank. Truncating this value affects AVS results and therefore might also affect risk decisions and chargebacks. Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.  #### FDMS Nashville When the street name is numeric, it must be sent in numeric format. For example, if the address is _One First Street_, it must be sent as _1 1st Street_.  Required if keyed; not used if swiped.  String (20)  #### TSYS Acquiring Solutions Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.  #### All other processors: Optional. String (60)  #### For Payouts This field may be sent only for FDC Compass.  **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting. 
    */
    'address1'?: string;
    /**
    * Used for additional address information. For example: _Attention: Accounts Payable_ Optional field.  For Payouts: This field may be sent only for FDC Compass.  #### Atos This field must not contain colons (:).  #### CyberSource through VisaNet **Important** When you populate `orderInformation.billTo.address1` and `orderInformation.billTo.address2`, CyberSource through VisaNet concatenates the two values. If the concatenated value exceeds 40 characters, CyberSource through VisaNet truncates the value at 40 characters before sending it to Visa and the issuing bank. Truncating this value affects AVS results and therefore might also affect risk decisions and chargebacks. Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.  #### Chase Paymentech Solutions, FDC Compass, and TSYS Acquiring Solutions This value is used for AVS.  #### FDMS Nashville `orderInformation.billTo.address1` and `orderInformation.billTo.address2` together cannot exceed 20 characters. String (20)  #### All Other Processors String (60) 
    */
    'address2'?: string;
    /**
    * State or province of the billing address. Use the [State, Province, and Territory Codes for the United States and Canada](https://developer.cybersource.com/library/documentation/sbc/quickref/states_and_provinces.pdf).  For Payouts: This field may be sent only for FDC Compass.  ##### CyberSource through VisaNet Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.  **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.  #### Chase Paymentech Solutions Optional field.  ####  Credit Mutuel-CIC Optional field.  #### OmniPay Direct Optional field.  #### SIX Optional field.  #### TSYS Acquiring Solutions Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.  #### Worldpay VAP Optional field.  #### All other processors Not used. 
    */
    'administrativeArea'?: string;
    /**
    * Payment card billing country. Use the two-character [ISO Standard Country Codes](http://apps.cybersource.com/library/documentation/sbc/quickref/countries_alpha_list.pdf).  #### SEPA/BACS Required for Create Mandate and Import Mandate  #### CyberSource through VisaNet Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.  **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.  #### Chase Paymentech Solutions Optional field.  ####  Credit Mutuel-CIC Optional field.  #### OmniPay Direct Optional field.  #### SIX Optional field.  #### TSYS Acquiring Solutions Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.  #### Worldpay VAP Optional field.  #### All other processors Not used. 
    */
    'country'?: string;
    /**
    * Payment card billing city.  #### SEPA Required for Create Mandate and Import Mandate  #### Atos This field must not contain colons (:).  #### CyberSource through VisaNet Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.  #### For Payouts: This field may be sent only for FDC Compass.  #### Chase Paymentech Solutions Optional field.  ####  Credit Mutuel-CIC Optional field.  #### OmniPay Direct Optional field.  #### SIX Optional field.  #### TSYS Acquiring Solutions Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.  #### Worldpay VAP Optional field.  #### All other processors Not used. 
    */
    'locality'?: string;
    /**
    * Customer’s first name. This name must be the same as the name on the card.  **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.  #### SEPA Required for Create Mandate and Import Mandate #### BACS Required for Import Mandate  #### CyberSource Latin American Processing **Important** For an authorization request, CyberSource Latin American Processing concatenates `orderInformation.billTo.firstName` and `orderInformation.billTo.lastName`. If the concatenated value exceeds 30 characters, CyberSource Latin American Processing declines the authorization request.\\ **Note** CyberSource Latin American Processing is the name of a specific processing connection that CyberSource supports. In the CyberSource API documentation, CyberSource Latin American Processing does not refer to the general topic of processing in Latin America. The information in this field description is for the specific processing connection called _CyberSource Latin American Processing_. It is not for any other Latin American processors that CyberSource supports.  #### CyberSource through VisaNet Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.  #### For Payouts: This field may be sent only for FDC Compass.  #### Chase Paymentech Solutions Optional field.  ####  Credit Mutuel-CIC Optional field.  #### OmniPay Direct Optional field.  #### SIX Optional field.  #### TSYS Acquiring Solutions Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.  #### Worldpay VAP Optional field.  #### All other processors Not used. 
    */
    'firstName'?: string;
    /**
    * Customer’s last name. This name must be the same as the name on the card.  **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.  #### SEPA Required for Create Mandate and Import Mandate #### BACS Required for Import Mandate #### Chase Paymentech Solutions Optional field.  ####  Credit Mutuel-CIC Optional field.  #### CyberSource Latin American Processing **Important** For an authorization request, CyberSource Latin American Processing concatenates `orderInformation.billTo.firstName` and `orderInformation.billTo.lastName`. If the concatenated value exceeds 30 characters, CyberSource Latin American Processing declines the authorization request.\\ **Note** CyberSource Latin American Processing is the name of a specific processing connection that CyberSource supports. In the CyberSource API documentation, CyberSource Latin American Processing does not refer to the general topic of processing in Latin America. The information in this field description is for the specific processing connection called CyberSource Latin American Processing. It is not for any other Latin American processors that CyberSource supports.  #### CyberSource through VisaNet Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.  #### For Payouts: This field may be sent only for FDC Compass.  #### OmniPay Direct Optional field.  #### RBS WorldPay Atlanta Optional field.  #### SIX Optional field.  #### TSYS Acquiring Solutions Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.  #### Worldpay VAP Optional field.  #### All other processors Not used. 
    */
    'lastName'?: string;
    /**
    * Customer’s phone number.  It is recommended that you include the country code when the order is from outside the U.S.  #### Chase Paymentech Solutions Optional field.  ####  Credit Mutuel-CIC Optional field.  #### CyberSource through VisaNet Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.  #### For Payouts: This field may be sent only for FDC Compass.  #### OmniPay Direct Optional field.  #### SIX Optional field.  #### TSYS Acquiring Solutions Optional field.  #### Worldpay VAP Optional field.  #### All other processors Not used. 
    */
    'phoneNumber'?: string;
    /**
    * Customer's email address, including the full domain name.  #### CyberSource through VisaNet Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.  **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.  #### Invoicing Email address for the customer for sending the invoice. If the invoice is in SENT status and email is updated, the old email customer payment link won't work and you must resend the invoice with the new payment link.  #### Chase Paymentech Solutions Optional field.  ####  Credit Mutuel-CIC Optional field.  #### OmniPay Direct Optional field.  #### SIX Optional field.  #### TSYS Acquiring Solutions Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.  #### Worldpay VAP Optional field.  #### All other processors Not used. 
    */
    'email'?: string;
    /**
    * Postal code for the billing address. The postal code must consist of 5 to 9 digits.  When the billing country is the U.S., the 9-digit postal code must follow this format: [5 digits][dash][4 digits]  **Example** `12345-6789`  When the billing country is Canada, the 6-digit postal code must follow this format: [alpha][numeric][alpha][space][numeric][alpha][numeric]  **Example** `A1B 2C3`  **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.  #### SEPA Required for Create Mandate and Import Mandate  #### For Payouts:  This field may be sent only for FDC Compass.  #### American Express Direct Before sending the postal code to the processor, CyberSource removes all nonalphanumeric characters and, if the remaining value is longer than nine characters, truncates the value starting from the right side.  #### Atos This field must not contain colons (:).  #### CyberSource through VisaNet Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.  #### FDMS Nashville Required if `pointOfSaleInformation.entryMode=keyed` and the address is in the U.S. or Canada. Optional if `pointOfSaleInformation.entryMode=keyed` and the address is **not** in the U.S. or Canada. Not used if swiped.  #### RBS WorldPay Atlanta: For best card-present keyed rates, send the postal code if `pointOfSaleInformation.entryMode=keyed`.  #### TSYS Acquiring Solutions Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.  #### All other processors: Optional field. 
    */
    'postalCode'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "address1",
            "baseName": "address1",
            "type": "string"
        },
        {
            "name": "address2",
            "baseName": "address2",
            "type": "string"
        },
        {
            "name": "administrativeArea",
            "baseName": "administrativeArea",
            "type": "string"
        },
        {
            "name": "country",
            "baseName": "country",
            "type": "string"
        },
        {
            "name": "locality",
            "baseName": "locality",
            "type": "string"
        },
        {
            "name": "firstName",
            "baseName": "firstName",
            "type": "string"
        },
        {
            "name": "lastName",
            "baseName": "lastName",
            "type": "string"
        },
        {
            "name": "phoneNumber",
            "baseName": "phoneNumber",
            "type": "string"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "postalCode",
            "baseName": "postalCode",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Riskv1decisionsOrderInformationBillTo.attributeTypeMap;
    }
}

export class Riskv1decisionsOrderInformationLineItems {
    /**
    * Total amount for the item. Normally calculated as the unit price times quantity.  When `orderInformation.lineItems[].productCode` is \"gift_card\", this is the purchase amount total for prepaid gift cards in major units.  Example: 123.45 USD = 123 
    */
    'totalAmount'?: string;
    /**
    * Per-item price of the product. This value for this field cannot be negative.  You must include either this field or the request-level field `orderInformation.amountDetails.totalAmount` in your request.  You can include a decimal point (.), but you cannot include any other special characters. The value is truncated to the correct number of decimal places.  #### DCC with a Third-Party Provider Set this field to the converted amount that was returned by the DCC provider. You must include either the 1st line item in the order and this field, or the request-level field `orderInformation.amountDetails.totalAmount` in your request.  #### Tax Calculation Required field for U.S., Canadian, international and value added taxes.  #### Zero Amount Authorizations If your processor supports zero amount authorizations, you can set this field to 0 for the authorization to check if the card is lost or stolen.  #### Maximum Field Lengths For GPN and JCN Gateway: Decimal (10) All other processors: Decimal (15) 
    */
    'unitPrice'?: string;
    /**
    * Number of units for this order. Must be a non-negative integer.  The default is `1`. For an authorization or capture transaction (`processingOptions.capture` is set to `true` or `false`), this field is required when `orderInformation.lineItems[].productCode` is not `default` or one of the other values related to shipping and/or handling.  #### Tax Calculation Optional field for U.S., Canadian, international tax, and value added taxes. 
    */
    'quantity'?: number;
    /**
    * When `orderInformation.lineItems[].productCode` is \"gift_card\", this is the currency used for the gift card purchase.  For the possible values, see the [ISO Standard Currency Codes.](http://apps.cybersource.com/library/documentation/sbc/quickref/currencies.pdf) 
    */
    'giftCardCurrency'?: number;
    /**
    * Product identifier code. Also known as the Stock Keeping Unit (SKU) code for the product.  For an authorization or capture transaction (`processingOptions.capture` is set to `true` or `false`), this field is required when `orderInformation.lineItems[].productCode` is not set to **default** or one of the other values that are related to shipping and/or handling.  #### Tax Calculation Optional field for U.S. and Canadian taxes. Not applicable to international and value added taxes. For an authorization or capture transaction (`processingOptions.capture` is set to `true` or `false`), this field is required when `orderInformation.lineItems[].productCode` is not `default` or one of the values related to shipping and/or handling. 
    */
    'productSKU'?: string;
    /**
    * Indicates the level of risk for the product. This field can contain one of the following values: - `low`: The product is associated with few chargebacks. - `normal`: The product is associated with a normal number of chargebacks. - `high`: The product is associated with many chargebacks. 
    */
    'productRisk'?: string;
    /**
    * Brief description of item.
    */
    'productDescription'?: string;
    /**
    * For an authorization or capture transaction (`processingOptions.capture` is `true` or `false`), this field is required when `orderInformation.lineItems[].productCode` is not `default` or one of the other values that are related to shipping and/or handling.  #### Tax Calculation Optional field for U.S., Canadian, international tax, and value added taxes. 
    */
    'productName'?: string;
    /**
    * Type of product. The value for this field is used to identify the product category (electronic, handling, physical, service, or shipping). The default value is `default`.  If you are performing an authorization transaction (`processingOptions.capture` is set to `false`), and you set this field to a value other than `default` or one of the values related to shipping and/or handling, then `orderInformation.lineItems[].quantity`, `orderInformation.lineItems[].productName`, and `orderInformation.lineItems[].productSku` fields are required.  Optional field.  #### Tax Calculation Optional field for U.S., Canadian, international tax, and value added taxes.  The Product Codes for the tax service are located in the Cybersource Tax Codes guide. Contact Customer Support to request the guide. If you don’t send a tax service Product Code in your tax request, product-based rules or exemptions will not be applied and the transaction will default to fully taxable in the locations where you’ve indicated you need to collect tax [by way of nexus, no nexus, or seller registration number fields]. 
    */
    'productCode'?: string;
    /**
    * This field is only used in DM service.  Determines whether to assign risk to the order if the billing and shipping addresses specify different cities, states, or countries. This field can contain one of the following values: - true: Orders are assigned only slight additional risk if billing and shipping addresses are different. - false: Orders are assigned higher additional risk if billing and shipping addresses are different. 
    */
    'gift'?: boolean;
    /**
    * Product’s identifier code. This field is inserted into the outgoing message without being parsed or formatted. This field is included as Distributor product SKU (Offer) in the list of API fields with which you can create custom rules. 
    */
    'distributorProductSku'?: string;
    'passenger'?: Ptsv2paymentsOrderInformationPassenger;
    /**
    * Destination to where the item will be shipped. Example: Commercial, Residential, Store 
    */
    'shippingDestinationTypes'?: string;
    /**
    * Total tax to apply to the product. This value cannot be negative. The tax amount and the offer amount must be in the same currency. The tax amount field is additive.  The following example uses a two-exponent currency such as USD:   1. You include each line item in your request.  ..- 1st line item has amount=10.00, quantity=1, and taxAmount=0.80  ..- 2nd line item has amount=20.00, quantity=1, and taxAmount=1.60  2. The total amount authorized will be 32.40, not 30.00 with 2.40 of tax included.  Optional field.  #### Airlines processing Tax portion of the order amount. This value cannot exceed 99999999999999 (fourteen 9s). Format: English characters only. Optional request field for a line item.  #### Tax Calculation Optional field for U.S., Canadian, international tax, and value added taxes.  Note if you send this field in your tax request, the value in the field will override the tax engine 
    */
    'taxAmount'?: string;
    'allowedExportCountries'?: Array<string>;
    'restrictedExportCountries'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "totalAmount",
            "baseName": "totalAmount",
            "type": "string"
        },
        {
            "name": "unitPrice",
            "baseName": "unitPrice",
            "type": "string"
        },
        {
            "name": "quantity",
            "baseName": "quantity",
            "type": "number"
        },
        {
            "name": "giftCardCurrency",
            "baseName": "giftCardCurrency",
            "type": "number"
        },
        {
            "name": "productSKU",
            "baseName": "productSKU",
            "type": "string"
        },
        {
            "name": "productRisk",
            "baseName": "productRisk",
            "type": "string"
        },
        {
            "name": "productDescription",
            "baseName": "productDescription",
            "type": "string"
        },
        {
            "name": "productName",
            "baseName": "productName",
            "type": "string"
        },
        {
            "name": "productCode",
            "baseName": "productCode",
            "type": "string"
        },
        {
            "name": "gift",
            "baseName": "gift",
            "type": "boolean"
        },
        {
            "name": "distributorProductSku",
            "baseName": "distributorProductSku",
            "type": "string"
        },
        {
            "name": "passenger",
            "baseName": "passenger",
            "type": "Ptsv2paymentsOrderInformationPassenger"
        },
        {
            "name": "shippingDestinationTypes",
            "baseName": "shippingDestinationTypes",
            "type": "string"
        },
        {
            "name": "taxAmount",
            "baseName": "taxAmount",
            "type": "string"
        },
        {
            "name": "allowedExportCountries",
            "baseName": "allowedExportCountries",
            "type": "Array<string>"
        },
        {
            "name": "restrictedExportCountries",
            "baseName": "restrictedExportCountries",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return Riskv1decisionsOrderInformationLineItems.attributeTypeMap;
    }
}

export class Riskv1decisionsOrderInformationShipTo {
    /**
    * First line of the shipping address.  Required field for authorization if any shipping address information is included in the request; otherwise, optional.  #### Tax Calculation Optional field for U.S. and Canadian taxes. Not applicable to international and value added taxes. Billing address objects will be used to determine the cardholder’s location when shipTo objects are not present. 
    */
    'address1'?: string;
    /**
    * Second line of the shipping address.  Optional field.  #### Tax Calculation Optional field for U.S. and Canadian taxes. Not applicable to international and value added taxes. Billing address objects will be used to determine the cardholder’s location when shipTo objects are not present. 
    */
    'address2'?: string;
    /**
    * Third line of the shipping address.  #### Tax Calculation Optional field for U.S. and Canadian taxes. Not applicable to international and value added taxes. Billing address objects will be used to determine the cardholder’s location when shipTo objects are not present. 
    */
    'address3'?: string;
    /**
    * State or province of the shipping address. Use the [State, Province, and Territory Codes for the United States and Canada](https://developer.cybersource.com/library/documentation/sbc/quickref/states_and_provinces.pdf) (maximum length: 2)   Required field for authorization if any shipping address information is included in the request and shipping to the U.S. or Canada; otherwise, optional.  #### Tax Calculation Optional field for U.S. and Canadian taxes. Not applicable to international and value added taxes. Billing address objects will be used to determine the cardholder’s location when shipTo objects are not present. 
    */
    'administrativeArea'?: string;
    /**
    * Country of the shipping address. Use the two-character [ISO Standard Country Codes.](http://apps.cybersource.com/library/documentation/sbc/quickref/countries_alpha_list.pdf)  Required field for authorization if any shipping address information is included in the request; otherwise, optional.  #### Tax Calculation Optional field for U.S., Canadian, international tax, and value added taxes. Billing address objects will be used to determine the cardholder’s location when shipTo objects are not present. 
    */
    'country'?: string;
    /**
    * Shipping destination of item. Example: Commercial, Residential, Store 
    */
    'destinationTypes'?: string;
    /**
    * City of the shipping address.  Required field for authorization if any shipping address information is included in the request and shipping to the U.S. or Canada; otherwise, optional.  #### Tax Calculation Optional field for U.S. and Canadian taxes. Not applicable to international and value added taxes. Billing address objects will be used to determine the cardholder’s location when shipTo objects are not present. 
    */
    'locality'?: string;
    /**
    * First name of the recipient.  #### Litle Maximum length: 25  #### All other processors Maximum length: 60  Optional field. 
    */
    'firstName'?: string;
    /**
    * Last name of the recipient.  #### Litle Maximum length: 25  #### All other processors Maximum length: 60  Optional field. 
    */
    'lastName'?: string;
    /**
    * Middle name of the recipient.  #### Litle Maximum length: 25  #### All other processors Maximum length: 60  Optional field. 
    */
    'middleName'?: string;
    /**
    * Phone number associated with the shipping address.
    */
    'phoneNumber'?: string;
    /**
    * Postal code for the shipping address. The postal code must consist of 5 to 9 digits.  Required field for authorization if any shipping address information is included in the request and shipping to the U.S. or Canada; otherwise, optional.  When the billing country is the U.S., the 9-digit postal code must follow this format: [5 digits][dash][4 digits]  Example 12345-6789  When the billing country is Canada, the 6-digit postal code must follow this format: [alpha][numeric][alpha][space][numeric][alpha][numeric]  Example A1B 2C3  #### American Express Direct Before sending the postal code to the processor, all nonalphanumeric characters are removed and, if the remaining value is longer than nine characters, the value is truncated starting from the right side. #### Tax Calculation Optional field for U.S. and Canadian taxes. Not applicable to international and value added taxes. Billing address objects will be used to determine the cardholder’s location when shipTo objects are not present. 
    */
    'postalCode'?: string;
    /**
    * Indicates destination chosen for the transaction. Possible values: - 01- Ship to cardholder billing address - 02- Ship to another verified address on file with merchant - 03- Ship to address that is different than billing address - 04- Ship to store (store address should be populated on request) - 05- Digital goods - 06- Travel and event tickets, not shipped - 07- Other 
    */
    'destinationCode'?: number;
    /**
    * Shipping method for the product. Possible values: - lowcost: Lowest-cost service - sameday: Courier or same-day service - oneday: Next-day or overnight service - twoday: Two-day service - threeday: Three-day service - pickup: Store pick-up - other: Other shipping method - none: No shipping method because product is a service or subscription Required for American Express SafeKey (U.S.). 
    */
    'method'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "address1",
            "baseName": "address1",
            "type": "string"
        },
        {
            "name": "address2",
            "baseName": "address2",
            "type": "string"
        },
        {
            "name": "address3",
            "baseName": "address3",
            "type": "string"
        },
        {
            "name": "administrativeArea",
            "baseName": "administrativeArea",
            "type": "string"
        },
        {
            "name": "country",
            "baseName": "country",
            "type": "string"
        },
        {
            "name": "destinationTypes",
            "baseName": "destinationTypes",
            "type": "string"
        },
        {
            "name": "locality",
            "baseName": "locality",
            "type": "string"
        },
        {
            "name": "firstName",
            "baseName": "firstName",
            "type": "string"
        },
        {
            "name": "lastName",
            "baseName": "lastName",
            "type": "string"
        },
        {
            "name": "middleName",
            "baseName": "middleName",
            "type": "string"
        },
        {
            "name": "phoneNumber",
            "baseName": "phoneNumber",
            "type": "string"
        },
        {
            "name": "postalCode",
            "baseName": "postalCode",
            "type": "string"
        },
        {
            "name": "destinationCode",
            "baseName": "destinationCode",
            "type": "number"
        },
        {
            "name": "method",
            "baseName": "method",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Riskv1decisionsOrderInformationShipTo.attributeTypeMap;
    }
}

/**
* Contains shipping information not related to address.
*/
export class Riskv1decisionsOrderInformationShippingDetails {
    /**
    * Boolean that indicates whether the customer requested gift wrapping for this purchase. This field can contain one of the following values: - true: The customer requested gift wrapping. - false: The customer did not request gift wrapping. 
    */
    'giftWrap'?: boolean;
    /**
    * Shipping method for the product. Possible values:   - `lowcost`: Lowest-cost service  - `sameday`: Courier or same-day service  - `oneday`: Next-day or overnight service  - `twoday`: Two-day service  - `threeday`: Three-day service  - `pickup`: Store pick-up  - `other`: Other shipping method  - `none`: No shipping method because product is a service or subscription 
    */
    'shippingMethod'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "giftWrap",
            "baseName": "giftWrap",
            "type": "boolean"
        },
        {
            "name": "shippingMethod",
            "baseName": "shippingMethod",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Riskv1decisionsOrderInformationShippingDetails.attributeTypeMap;
    }
}

/**
* Contains the payment data for this transaction.
*/
export class Riskv1decisionsPaymentInformation {
    'card'?: Riskv1decisionsPaymentInformationCard;
    'tokenizedCard'?: Riskv1decisionsPaymentInformationTokenizedCard;
    'customer'?: Ptsv2paymentsPaymentInformationCustomer;
    'bank'?: Ptsv2paymentsPaymentInformationBank;
    /**
    * Method of payment used for the order. This field can contain one of the following values:   - `consumer` (default): Customer credit card   - `corporate`: Corporate credit card   - `debit`: Debit card, such as a Maestro (UK Domestic) card   - `cod`: Collect on delivery   - `check`: Electronic check   - `p2p`: Person-to-person payment   - `private1`: Private label credit card   - `other`: Other payment method 
    */
    'method'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "card",
            "baseName": "card",
            "type": "Riskv1decisionsPaymentInformationCard"
        },
        {
            "name": "tokenizedCard",
            "baseName": "tokenizedCard",
            "type": "Riskv1decisionsPaymentInformationTokenizedCard"
        },
        {
            "name": "customer",
            "baseName": "customer",
            "type": "Ptsv2paymentsPaymentInformationCustomer"
        },
        {
            "name": "bank",
            "baseName": "bank",
            "type": "Ptsv2paymentsPaymentInformationBank"
        },
        {
            "name": "method",
            "baseName": "method",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Riskv1decisionsPaymentInformation.attributeTypeMap;
    }
}

/**
* Use this for a non-tokenized payment card.
*/
export class Riskv1decisionsPaymentInformationCard {
    /**
    * The customer’s payment card number, also known as the Primary Account Number (PAN). You can also use this field for encoded account numbers.  #### FDMS Nashville Required. String (19)  #### GPX Required if `pointOfSaleInformation.entryMode=keyed`. However, this field is optional if your account is configured for relaxed requirements for address data and expiration date. **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.  #### All other processors Required if `pointOfSaleInformation.entryMode=keyed`. However, this field is optional if your account is configured for relaxed requirements for address data and expiration date. **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting. 
    */
    'number'?: string;
    /**
    * Three-digit value that indicates the card type.  **IMPORTANT** It is strongly recommended that you include the card type field in request messages even if it is optional for your processor and card type. Omitting the card type can cause the transaction to be processed with the wrong card type.  Possible values: - `001`: Visa. Use card type value `001` for Visa Electron. - `002`: Mastercard, Eurocard[^1], which is a European regional brand of Mastercard. - `003`: American Express - `004`: Discover - `005`: Diners Club - `006`: Carte Blanche[^1] - `007`: JCB[^1] - `008`: Optima - `009`: GE Private Label - `010`: Beneficial Private Label - `011`: Twinpay Credit Card - `012`: Twinpay Debit Card - `013`: WalMart - `014`: Enroute[^1] - `015`: Lowe's Consumer - `016`: Home Depot Consumer - `017`: MBNA - `018`: Dick's Sportswear - `019`: Casual Corner - `020`: Sears - `021`: JAL[^1] - `023`: Disney Card - `024`: Maestro (UK Domestic)[^1] - `025`: Sam's Club Consumer - `026`: Sam's Club Business - `027`: Nico's - `028`: Paymentech Bill Me Later - `029`: Bebe - `030`: Restoration Hardware - `031`: Delta Online - `032`: Solo - `033`: Visa Electron[^1]. Do not use this value. Use `001` for all Visa card types. - `034`: Dankort[^1] - `035`: Laser - `036`: Cartes Bancaires[^1,4] - `037`: Carta Si[^1] - `038`: Pinless Debit - `039`: Encoded account number[^1] - `040`: UATP[^1] - `041`: HOUSEHOLD - `042`: Maestro (International)[^1] - `043`: GE MONEY - `044`: Korean Cards - `045`: Style Cards - `046`: JCrew - `047`: Payeasecn eWallet - `048`: Payeasecn Bank Transfer - `049`: Meijer - `050`: Hipercard[^2,3] - `051`: Aura - `052`: Redecard - `053`: Orico card - `054`: Elo[^3] - `055`: Capitol One Private Label - `056`: Carnet - `057`: Costco Private Label - `058`: Carnet - `059`: ValueLink - `060`: MADA - `061`: RuPay - `062`: China UnionPay - `063`: Falabella Private Label - `064`: Prompt Card - `065`: Korean Domestic - `066`: Banricompras - `067`: MEEZA - `068`: PayPak - `070`: EFTPOS - `071`: Codensa - `072`: Olimpica - `073`: Colsubsidio - `074`: Tuya - `075`: Sodexo - `076`: Naranja - `077`: Cabal - `078`: DINELCO - `079`: PANAL - `080`: EPM - `081`: Jaywan  [^1]: For this card type, you must include the `paymentInformation.card.type` or `paymentInformation.tokenizedCard.type` field in your request for an authorization or a stand-alone credit. [^2]: For this card type on Cielo 3.0, you must include the `paymentInformation.card.type` or `paymentInformation.tokenizedCard.type` field in a request for an authorization or a stand-alone credit. This card type is not supported on Cielo 1.5. [^3]: For this card type on Getnet and Rede, you must include the `paymentInformation.card.type` or `paymentInformation.tokenizedCard.type` field in a request for an authorization or a stand-alone credit. [^4]: For this card type, you must include the `paymentInformation.card.type` in your request for any payer authentication services.  #### Used by **Authorization** Required for Carte Blanche and JCB. Optional for all other card types.  #### Card Present reply This field is included in the reply message when the client software that is installed on the POS terminal uses the token management service (TMS) to retrieve tokenized payment details. You must contact customer support to have your account enabled to receive these fields in the credit reply message.  Returned by the Credit service.  This reply field is only supported by the following processors: - American Express Direct - Credit Mutuel-CIC - FDC Nashville Global - OmniPay Direct - SIX  #### Google Pay transactions For PAN-based Google Pay transactions, this field is returned in the API response.  #### GPX This field only supports transactions from the following card types: - Visa - Mastercard - AMEX - Discover - Diners - JCB - Union Pay International 
    */
    'type'?: string;
    /**
    * description: The BIN is the first six digits of the card's Primary Account Number (PAN). 
    */
    'bin'?: string;
    /**
    * Two-digit month in which the payment card expires.  Format: `MM`.  Valid values: `01` through `12`. Leading 0 is required.  #### Barclays and Streamline For Maestro (UK Domestic) and Maestro (International) cards on Barclays and Streamline, this must be a valid value (`01` through `12`) but is not required to be a valid expiration date. In other words, an expiration date that is in the past does not cause CyberSource to reject your request. However, an invalid expiration date might cause the issuer to reject your request.  #### Encoded Account Numbers For encoded account numbers (_type_=039), if there is no expiration date on the card, use `12`.  #### FDMS Nashville Required field.  #### All other processors Required if `pointOfSaleInformation.entryMode=keyed`. However, this field is optional if your account is configured for relaxed requirements for address data and expiration date. **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.  #### Google Pay transactions For PAN-based Google Pay transactions, this field is returned in the API response. 
    */
    'expirationMonth'?: string;
    /**
    * Four-digit year in which the payment card expires.  Format: `YYYY`.  #### Barclays and Streamline For Maestro (UK Domestic) and Maestro (International) cards on Barclays and Streamline, this must be a valid value (`1900` through `3000`) but is not required to be a valid expiration date. In other words, an expiration date that is in the past does not cause CyberSource to reject your request. However, an invalid expiration date might cause the issuer to reject your request.  #### Encoded Account Numbers For encoded account numbers (**_type_**`=039`), if there is no expiration date on the card, use `2021`.  #### FDMS Nashville Required field.  #### FDC Nashville Global and FDMS South You can send in 2 digits or 4 digits. If you send in 2 digits, they must be the last 2 digits of the year.  #### All other processors Required if `pointOfSaleInformation.entryMode=keyed`. However, this field is optional if your account is configured for relaxed requirements for address data and expiration date. **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.  #### Google Pay transactions For PAN-based Google Pay transactions, this field is returned in the API response. 
    */
    'expirationYear'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "number",
            "baseName": "number",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "bin",
            "baseName": "bin",
            "type": "string"
        },
        {
            "name": "expirationMonth",
            "baseName": "expirationMonth",
            "type": "string"
        },
        {
            "name": "expirationYear",
            "baseName": "expirationYear",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Riskv1decisionsPaymentInformationCard.attributeTypeMap;
    }
}

/**
* Use this object to submit a payment network token instead of card-based values.
*/
export class Riskv1decisionsPaymentInformationTokenizedCard {
    /**
    * Type of transaction that provided the token data. This value does not specify the token service provider; it specifies the entity that provided you with information about the token.  Possible value: - `2`: Near-field communication (NFC) transaction. The customer’s mobile device provided the token data for a contactless EMV transaction. For recurring transactions, use this value if the original transaction was a contactless EMV transaction.  #### Visa Platform Connect - `1`: For Rupay and In App tokenization. Example: InApp apple pay. - `3`: Card/Credential On File Tokenization.  **NOTE** No CyberSource through VisaNet acquirers support EMV at this time.  Required field for PIN debit credit or PIN debit purchase transactions that use payment network tokens; otherwise, not used.  #### Rupay - `3`: Card/Credential On File Tokenization. - `4`: Tokenizined Transaction. Should be used for Guest Checkout transactions with token. 
    */
    'transactionType'?: string;
    /**
    * Three-digit value that indicates the card type.  **IMPORTANT** It is strongly recommended that you include the card type field in request messages even if it is optional for your processor and card type. Omitting the card type can cause the transaction to be processed with the wrong card type.  Possible values: - `001`: Visa. Use card type value `001` for Visa Electron. - `002`: Mastercard, Eurocard[^1], which is a European regional brand of Mastercard. - `003`: American Express - `004`: Discover - `005`: Diners Club - `006`: Carte Blanche[^1] - `007`: JCB[^1] - `008`: Optima - `009`: GE Private Label - `010`: Beneficial Private Label - `011`: Twinpay Credit Card - `012`: Twinpay Debit Card - `013`: WalMart - `014`: Enroute[^1] - `015`: Lowe's Consumer - `016`: Home Depot Consumer - `017`: MBNA - `018`: Dick's Sportswear - `019`: Casual Corner - `020`: Sears - `021`: JAL[^1] - `023`: Disney Card - `024`: Maestro (UK Domestic)[^1] - `025`: Sam's Club Consumer - `026`: Sam's Club Business - `027`: Nico's - `028`: Paymentech Bill Me Later - `029`: Bebe - `030`: Restoration Hardware - `031`: Delta Online - `032`: Solo - `033`: Visa Electron[^1]. Do not use this value. Use `001` for all Visa card types. - `034`: Dankort[^1] - `035`: Laser - `036`: Cartes Bancaires[^1,4] - `037`: Carta Si[^1] - `038`: Pinless Debit - `039`: Encoded account number[^1] - `040`: UATP[^1] - `041`: HOUSEHOLD - `042`: Maestro (International)[^1] - `043`: GE MONEY - `044`: Korean Cards - `045`: Style Cards - `046`: JCrew - `047`: Payeasecn eWallet - `048`: Payeasecn Bank Transfer - `049`: Meijer - `050`: Hipercard[^2,3] - `051`: Aura - `052`: Redecard - `053`: Orico card - `054`: Elo[^3] - `055`: Capitol One Private Label - `056`: Carnet - `057`: Costco Private Label - `058`: Carnet - `059`: ValueLink - `060`: MADA - `061`: RuPay - `062`: China UnionPay - `063`: Falabella Private Label - `064`: Prompt Card - `065`: Korean Domestic - `066`: Banricompras - `067`: MEEZA - `068`: PayPak - `070`: EFTPOS - `071`: Codensa - `072`: Olimpica - `073`: Colsubsidio - `074`: Tuya - `075`: Sodexo - `076`: Naranja - `077`: Cabal - `078`: DINELCO - `079`: PANAL - `080`: EPM - `081`: Jaywan  [^1]: For this card type, you must include the `paymentInformation.card.type` or `paymentInformation.tokenizedCard.type` field in your request for an authorization or a stand-alone credit. [^2]: For this card type on Cielo 3.0, you must include the `paymentInformation.card.type` or `paymentInformation.tokenizedCard.type` field in a request for an authorization or a stand-alone credit. This card type is not supported on Cielo 1.5. [^3]: For this card type on Getnet and Rede, you must include the `paymentInformation.card.type` or `paymentInformation.tokenizedCard.type` field in a request for an authorization or a stand-alone credit. [^4]: For this card type, you must include the `paymentInformation.card.type` in your request for any payer authentication services.  #### Used by **Authorization** Required for Carte Blanche and JCB. Optional for all other card types.  #### Card Present reply This field is included in the reply message when the client software that is installed on the POS terminal uses the token management service (TMS) to retrieve tokenized payment details. You must contact customer support to have your account enabled to receive these fields in the credit reply message.  Returned by the Credit service.  This reply field is only supported by the following processors: - American Express Direct - Credit Mutuel-CIC - FDC Nashville Global - OmniPay Direct - SIX  #### Google Pay transactions For PAN-based Google Pay transactions, this field is returned in the API response.  #### GPX This field only supports transactions from the following card types: - Visa - Mastercard - AMEX - Discover - Diners - JCB - Union Pay International 
    */
    'type'?: string;
    /**
    * Customer’s payment network token value. 
    */
    'number'?: string;
    /**
    * One of two possible meanings: - The two-digit month in which a token expires. - The two-digit month in which a card expires. Format: `MM` Possible values: `01` through `12`  **NOTE** The meaning of this field is dependent on the payment processor that is returning the value in an authorization reply. Please see the processor-specific details below.  #### Barclays and Streamline For Maestro (UK Domestic) and Maestro (International) cards on Barclays and Streamline, this must be a valid value (`01` through `12`) but is not required to be a valid expiration date. In other words, an expiration date that is in the past does not cause CyberSource to reject your request. However, an invalid expiration date might cause the issuer to reject your request.  #### Encoded Account Numbers For encoded account numbers (`card_type=039`), if there is no expiration date on the card, use `12`.\\ **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.  #### Samsung Pay and Apple Pay Month in which the token expires. CyberSource includes this field in the reply message when it decrypts the payment blob for the tokenized transaction. 
    */
    'expirationMonth'?: string;
    /**
    * One of two possible meanings: - The four-digit year in which a token expires. - The four-digit year in which a card expires. Format: `YYYY` Possible values: `1900` through `3000` Data type: Non-negative integer  **NOTE** The meaning of this field is dependent on the payment processor that is returning the value in an authorization reply. Please see the processor-specific details below.  #### Barclays and Streamline For Maestro (UK Domestic) and Maestro (International) cards on Barclays and Streamline, this must be a valid value (1900 through 3000) but is not required to be a valid expiration date. In other words, an expiration date that is in the past does not cause CyberSource to reject your request. However, an invalid expiration date might cause the issuer to reject your request.  #### Encoded Account Numbers For encoded account numbers (`card_ type=039`), if there is no expiration date on the card, use `2021`.  #### FDC Nashville Global and FDMS South You can send in 2 digits or 4 digits. When you send in 2 digits, they must be the last 2 digits of the year.  #### Samsung Pay and Apple Pay Year in which the token expires. CyberSource includes this field in the reply message when it decrypts the payment blob for the tokenized transaction.  **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting. 
    */
    'expirationYear'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "transactionType",
            "baseName": "transactionType",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "number",
            "baseName": "number",
            "type": "string"
        },
        {
            "name": "expirationMonth",
            "baseName": "expirationMonth",
            "type": "string"
        },
        {
            "name": "expirationYear",
            "baseName": "expirationYear",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Riskv1decisionsPaymentInformationTokenizedCard.attributeTypeMap;
    }
}

/**
* Decides whether to call Payer Authentication or Watchlist Screening service along with DM or not.
*/
export class Riskv1decisionsProcessingInformation {
    /**
    * - Use `CONSUMER_AUTHENTICATION` to use Payer Authentication along with Decision Manager. For any other value, only Decision Manager will run. - Use `WATCHLIST_SCREENING`  when you want to call Watchlist Screening service. 
    */
    'actionList'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "actionList",
            "baseName": "actionList",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return Riskv1decisionsProcessingInformation.attributeTypeMap;
    }
}

/**
* Contains information related to the payment processor.
*/
export class Riskv1decisionsProcessorInformation {
    'avs'?: Riskv1decisionsProcessorInformationAvs;
    'cardVerification'?: Riskv1decisionsProcessorInformationCardVerification;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "avs",
            "baseName": "avs",
            "type": "Riskv1decisionsProcessorInformationAvs"
        },
        {
            "name": "cardVerification",
            "baseName": "cardVerification",
            "type": "Riskv1decisionsProcessorInformationCardVerification"
        }    ];

    static getAttributeTypeMap() {
        return Riskv1decisionsProcessorInformation.attributeTypeMap;
    }
}

/**
* Address Verification Service
*/
export class Riskv1decisionsProcessorInformationAvs {
    /**
    * Value returned for address verification from the Payments Authorization response.
    */
    'code'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Riskv1decisionsProcessorInformationAvs.attributeTypeMap;
    }
}

export class Riskv1decisionsProcessorInformationCardVerification {
    /**
    * CVN result code. 
    */
    'resultCode'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "resultCode",
            "baseName": "resultCode",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Riskv1decisionsProcessorInformationCardVerification.attributeTypeMap;
    }
}

export class Riskv1decisionsRiskInformation {
    'profile'?: Ptsv2paymentsRiskInformationProfile;
    /**
    * Specifies one of the following types of events: - login - account_creation - account_update For regular payment transactions, do not send this field. 
    */
    'eventType'?: string;
    'buyerHistory'?: Ptsv2paymentsRiskInformationBuyerHistory;
    'auxiliaryData'?: Array<Ptsv2paymentsRiskInformationAuxiliaryData>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "profile",
            "baseName": "profile",
            "type": "Ptsv2paymentsRiskInformationProfile"
        },
        {
            "name": "eventType",
            "baseName": "eventType",
            "type": "string"
        },
        {
            "name": "buyerHistory",
            "baseName": "buyerHistory",
            "type": "Ptsv2paymentsRiskInformationBuyerHistory"
        },
        {
            "name": "auxiliaryData",
            "baseName": "auxiliaryData",
            "type": "Array<Ptsv2paymentsRiskInformationAuxiliaryData>"
        }    ];

    static getAttributeTypeMap() {
        return Riskv1decisionsRiskInformation.attributeTypeMap;
    }
}

export class Riskv1decisionsTokenInformation {
    /**
    * TMS Transient Token, 64 hexadecimal id value representing captured payment credentials (including Sensitive Authentication Data, e.g. CVV). 
    */
    'jti'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "jti",
            "baseName": "jti",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Riskv1decisionsTokenInformation.attributeTypeMap;
    }
}

export class Riskv1decisionsTravelInformation {
    /**
    * IATA Code for the actual final destination that the customer intends to travel to. It should be a destination on the completeRoute. 
    */
    'actualFinalDestination'?: string;
    /**
    * Concatenation of individual travel legs in the format ORIG1-DEST1[:ORIG2-DEST2...:ORIGn-DESTn], for example, SFO-JFK:JFK-LHR:LHR-CDG. For airport codes, see the IATA Airline and Airport Code Search. Note In your request, send either the complete route or the individual legs (_leg#_orig and _leg#_dest). If you send all the fields, the value of _complete_route takes precedence over that of the _leg# fields. 
    */
    'completeRoute'?: string;
    /**
    * Departure date and time of the first leg of the trip. Use one of the following formats:   - yyyy-MM-dd HH:mm z   - yyyy-MM-dd hh:mm a z   - yyyy-MM-dd hh:mma z   HH = hour in 24-hour format   hh = hour in 12-hour format   a = am or pm (case insensitive)   z = time zone of the departing flight, for example: If the   airline is based in city A, but the flight departs from city   B, z is the time zone of city B at the time of departure. Important For travel information, use GMT instead of UTC, or use the local time zone. Examples 2011-03-20 11:30 PM PDT 2011-03-20 11:30pm GMT 2011-03-20 11:30pm GMT-05:00 Eastern Standard Time: GMT-05:00 or EST Note When specifying an offset from GMT, the format must be exactly as specified in the example. Insert no spaces between the time zone and the offset. 
    */
    'departureTime'?: string;
    /**
    * Type of travel, for example one way or round trip.
    */
    'journeyType'?: string;
    'legs'?: Array<Riskv1decisionsTravelInformationLegs>;
    /**
    * Number of passengers for whom the ticket was issued. If you do not include this field in your request, CyberSource uses a default value of 1. Required for American Express SafeKey (U.S.) for travel-related requests. 
    */
    'numberOfPassengers'?: number;
    'passengers'?: Array<Riskv1decisionsTravelInformationPassengers>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "actualFinalDestination",
            "baseName": "actualFinalDestination",
            "type": "string"
        },
        {
            "name": "completeRoute",
            "baseName": "completeRoute",
            "type": "string"
        },
        {
            "name": "departureTime",
            "baseName": "departureTime",
            "type": "string"
        },
        {
            "name": "journeyType",
            "baseName": "journeyType",
            "type": "string"
        },
        {
            "name": "legs",
            "baseName": "legs",
            "type": "Array<Riskv1decisionsTravelInformationLegs>"
        },
        {
            "name": "numberOfPassengers",
            "baseName": "numberOfPassengers",
            "type": "number"
        },
        {
            "name": "passengers",
            "baseName": "passengers",
            "type": "Array<Riskv1decisionsTravelInformationPassengers>"
        }    ];

    static getAttributeTypeMap() {
        return Riskv1decisionsTravelInformation.attributeTypeMap;
    }
}

export class Riskv1decisionsTravelInformationLegs {
    /**
    * Use to specify the airport code for the origin of the leg of the trip, which is designated by the pound (#) symbol in the field name. This code is usually three digits long, for example: SFO = San Francisco. Do not use the colon (:) or the dash (-). For airport codes, see the IATA Airline and Airport Code Search. The leg number can be a positive integer from 0 to N. For example: `travelInformation.legs.0.origination=SFO` `travelInformation.legs.1.origination=SFO`  **Note** In your request, send either the complete route or the individual legs (`legs.0.origination` and `legs.n.destination`). If you send all the fields, the complete route takes precedence over the individual legs.  For details, see the `decision_manager_travel_leg#_orig` field description in _Decision Manager Using the SCMP API Developer Guide_ on the [CyberSource Business Center.](https://ebc2.cybersource.com/ebc2/) Click **Decision Manager** > **Documentation** > **Guides** > _Decision Manager Using the SCMP API Developer Guide_ (PDF link). 
    */
    'origination'?: string;
    /**
    * Use to specify the airport code for the destination of the leg of the trip, which is designated by the pound (#) symbol in the field name. This code is usually three digits long, for example: SFO = San Francisco. Do not use the colon (:) or the dash (-). For airport codes, see [IATA Airline and Airport Code Search](https://www.iata.org/publications/Pages/code-search.aspx). The leg number can be a positive integer from 0 to N. For example:  `travelInformation.legs.0.destination=SFO` `travelInformation.legs.1.destination=SFO`  **Note** In your request, send either the complete route or the individual legs (`legs.0.origination` and `legs.n.destination`). If you send all the fields, the complete route takes precedence over the individual legs.  For details, see the `decision_manager_travel_leg#_dest` field description in _Decision Manager Using the SCMP API Developer Guide_ on the [CyberSource Business Center.](https://ebc2.cybersource.com/ebc2/) Click **Decision Manager** > **Documentation** > **Guides** > _Decision Manager Using the SCMP API Developer Guide_ (PDF link). 
    */
    'destination'?: string;
    /**
    * International Air Transport Association (IATA) code for the carrier for this leg of the trip. Required for each leg. Required for American Express SafeKey (U.S.) for travel-related requests. 
    */
    'carrierCode'?: string;
    /**
    * Departure date for the first leg of the trip. Format: YYYYMMDD. Required for American Express SafeKey (U.S.) for travel-related requests. 
    */
    'departureDate'?: string;
    /**
    * Time of departure for this leg of the trip. The format is military time and HHMM: If not all zeros, then the hours must be `00-23` and the minutes must be `00-59`. Format: English characters only. Optional request field for travel legs. 
    */
    'departureTime'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "origination",
            "baseName": "origination",
            "type": "string"
        },
        {
            "name": "destination",
            "baseName": "destination",
            "type": "string"
        },
        {
            "name": "carrierCode",
            "baseName": "carrierCode",
            "type": "string"
        },
        {
            "name": "departureDate",
            "baseName": "departureDate",
            "type": "string"
        },
        {
            "name": "departureTime",
            "baseName": "departureTime",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return Riskv1decisionsTravelInformationLegs.attributeTypeMap;
    }
}

export class Riskv1decisionsTravelInformationPassengers {
    /**
    * First name of the passenger to whom the ticket was issued. If there are multiple passengers, include all listed on the ticket. Do not include special characters such as commas, hyphens, or apostrophes. Only ASCII characters are supported. Required for American Express SafeKey (U.S.) for travel-related requests. 
    */
    'firstName'?: string;
    /**
    * Last name of the passenger to whom the ticket was issued. If there are multiple passengers, include all listed on the ticket. Do not include special characters such as commas, hyphens, or apostrophes. Only ASCII characters are supported. Required for American Express SafeKey (U.S.) for travel-related requests. 
    */
    'lastName'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "firstName",
            "baseName": "firstName",
            "type": "string"
        },
        {
            "name": "lastName",
            "baseName": "lastName",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Riskv1decisionsTravelInformationPassengers.attributeTypeMap;
    }
}

export class Riskv1decisionsidactionsDecisionInformation {
    /**
    * Decision that will be applied to the given case. Possible values are: - `ACCEPT` - `REJECT` 
    */
    'decision'?: string;
    /**
    * Notes from the reviewer about the decision made to this case.
    */
    'comments'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "decision",
            "baseName": "decision",
            "type": "string"
        },
        {
            "name": "comments",
            "baseName": "comments",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Riskv1decisionsidactionsDecisionInformation.attributeTypeMap;
    }
}

export class Riskv1decisionsidactionsProcessingInformation {
    /**
    * Follow-on action to apply to the case after the decision is successfully applied. Possible values are one of the following: - `CAPTURE` - `REVERSE`  If decision is ACCEPT, then CAPTURE can be used in actionList. If decision is REJECT, then REVERSE can be used. 
    */
    'actionList'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "actionList",
            "baseName": "actionList",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return Riskv1decisionsidactionsProcessingInformation.attributeTypeMap;
    }
}

export class Riskv1decisionsidmarkingRiskInformation {
    'markingDetails'?: Riskv1decisionsidmarkingRiskInformationMarkingDetails;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "markingDetails",
            "baseName": "markingDetails",
            "type": "Riskv1decisionsidmarkingRiskInformationMarkingDetails"
        }    ];

    static getAttributeTypeMap() {
        return Riskv1decisionsidmarkingRiskInformation.attributeTypeMap;
    }
}

/**
* Details for marking the transaction.
*/
export class Riskv1decisionsidmarkingRiskInformationMarkingDetails {
    /**
    * Notes or details that explain the reasons for marking the transaction as suspect or otherwise.
    */
    'notes'?: string;
    /**
    * Reason for marking the transaction as suspect or otherwise. This field can contain one of the following values: - `fraud_chargeback:` You have received a fraud-related chargeback for the transaction. - `non_fraud_chargeback:` You have received a non-fraudulent chargeback for the transaction. - `suspected:` You believe that you will probably receive a chargeback for the transaction. - `creditback:` You issued a refund to the customer to avoid a chargeback for the transaction. 
    */
    'reason'?: string;
    /**
    * This field can contain one or more of the following values. When you specify more than one value, separate them with commas (,). - `account_key_hash` - `customer_account_id` - `customer_email` - `customer_ipaddress` - `customer_phone` - `device_fingerprint` - `ship_address` If no value is specified, `account_key_hash`, `customer_email`, and `ship_address` are used by default. Note `account_key_hash` adds the field that contains the card number (`customer_cc_number`). 
    */
    'fieldsIncluded'?: Array<string>;
    /**
    * This field can contain one of the following values: - add: Mark as Suspect. - clear: Clear Mark as Suspect. - hide: Remove from history. 
    */
    'action'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "notes",
            "baseName": "notes",
            "type": "string"
        },
        {
            "name": "reason",
            "baseName": "reason",
            "type": "string"
        },
        {
            "name": "fieldsIncluded",
            "baseName": "fieldsIncluded",
            "type": "Array<string>"
        },
        {
            "name": "action",
            "baseName": "action",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Riskv1decisionsidmarkingRiskInformationMarkingDetails.attributeTypeMap;
    }
}

export class Riskv1exportcomplianceinquiriesDeviceInformation {
    /**
    * IP address of the customer.  #### Used by **Authorization, Capture, and Credit** Optional field. 
    */
    'ipAddress'?: string;
    /**
    * DNS resolved hostname from `ipAddress`.
    */
    'hostName'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "ipAddress",
            "baseName": "ipAddress",
            "type": "string"
        },
        {
            "name": "hostName",
            "baseName": "hostName",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Riskv1exportcomplianceinquiriesDeviceInformation.attributeTypeMap;
    }
}

export class Riskv1exportcomplianceinquiriesExportComplianceInformation {
    /**
    * Parts of the customer’s information that must match with an entry in the DPL (denied parties list) before a match occurs. This field can contain one of the following values: - AND: (default) The customer’s name or company and the customer’s address must appear in the database. - OR: The customer’s name must appear in the database. - IGNORE: You want the service to detect a match only of the customer’s name or company but not of the address. 
    */
    'addressOperator'?: string;
    'weights'?: Ptsv2paymentsWatchlistScreeningInformationWeights;
    /**
    * Use this field to specify which list(s) you want checked with the request. The reply will include the list name as well as the response data. To check against multiple lists, enter multiple list codes separated by a caret (^). For more information, see \"Restricted and Denied Parties List,\" page 68. 
    */
    'sanctionLists'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "addressOperator",
            "baseName": "addressOperator",
            "type": "string"
        },
        {
            "name": "weights",
            "baseName": "weights",
            "type": "Ptsv2paymentsWatchlistScreeningInformationWeights"
        },
        {
            "name": "sanctionLists",
            "baseName": "sanctionLists",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return Riskv1exportcomplianceinquiriesExportComplianceInformation.attributeTypeMap;
    }
}

export class Riskv1exportcomplianceinquiriesOrderInformation {
    'billTo'?: Riskv1exportcomplianceinquiriesOrderInformationBillTo;
    'shipTo'?: Riskv1exportcomplianceinquiriesOrderInformationShipTo;
    'lineItems'?: Array<Riskv1exportcomplianceinquiriesOrderInformationLineItems>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "billTo",
            "baseName": "billTo",
            "type": "Riskv1exportcomplianceinquiriesOrderInformationBillTo"
        },
        {
            "name": "shipTo",
            "baseName": "shipTo",
            "type": "Riskv1exportcomplianceinquiriesOrderInformationShipTo"
        },
        {
            "name": "lineItems",
            "baseName": "lineItems",
            "type": "Array<Riskv1exportcomplianceinquiriesOrderInformationLineItems>"
        }    ];

    static getAttributeTypeMap() {
        return Riskv1exportcomplianceinquiriesOrderInformation.attributeTypeMap;
    }
}

export class Riskv1exportcomplianceinquiriesOrderInformationBillTo {
    /**
    * Payment card billing street address as it appears on the credit card issuer’s records.  #### SEPA Required for Create Mandate and Import Mandate  #### Atos This field must not contain colons (:).  #### CyberSource through VisaNet **Important** When you populate orderInformation.billTo.address1 and orderInformation.billTo.address2, CyberSource through VisaNet concatenates the two values. If the concatenated value exceeds 40 characters, CyberSource through VisaNet truncates the value at 40 characters before sending it to Visa and the issuing bank. Truncating this value affects AVS results and therefore might also affect risk decisions and chargebacks. Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.  #### FDMS Nashville When the street name is numeric, it must be sent in numeric format. For example, if the address is _One First Street_, it must be sent as _1 1st Street_.  Required if keyed; not used if swiped.  String (20)  #### TSYS Acquiring Solutions Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.  #### All other processors: Optional. String (60)  #### For Payouts This field may be sent only for FDC Compass.  **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting. 
    */
    'address1': string;
    /**
    * Used for additional address information. For example: _Attention: Accounts Payable_ Optional field.  For Payouts: This field may be sent only for FDC Compass.  #### Atos This field must not contain colons (:).  #### CyberSource through VisaNet **Important** When you populate `orderInformation.billTo.address1` and `orderInformation.billTo.address2`, CyberSource through VisaNet concatenates the two values. If the concatenated value exceeds 40 characters, CyberSource through VisaNet truncates the value at 40 characters before sending it to Visa and the issuing bank. Truncating this value affects AVS results and therefore might also affect risk decisions and chargebacks. Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.  #### Chase Paymentech Solutions, FDC Compass, and TSYS Acquiring Solutions This value is used for AVS.  #### FDMS Nashville `orderInformation.billTo.address1` and `orderInformation.billTo.address2` together cannot exceed 20 characters. String (20)  #### All Other Processors String (60) 
    */
    'address2'?: string;
    /**
    * Additional address information (third line of the billing address) 
    */
    'address3'?: string;
    /**
    * Additional address information (fourth line of the billing address) 
    */
    'address4'?: string;
    /**
    * State or province of the billing address. Use the [State, Province, and Territory Codes for the United States and Canada](https://developer.cybersource.com/library/documentation/sbc/quickref/states_and_provinces.pdf).  For Payouts: This field may be sent only for FDC Compass.  ##### CyberSource through VisaNet Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.  **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.  #### Chase Paymentech Solutions Optional field.  ####  Credit Mutuel-CIC Optional field.  #### OmniPay Direct Optional field.  #### SIX Optional field.  #### TSYS Acquiring Solutions Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.  #### Worldpay VAP Optional field.  #### All other processors Not used. 
    */
    'administrativeArea'?: string;
    /**
    * Payment card billing country. Use the two-character [ISO Standard Country Codes](http://apps.cybersource.com/library/documentation/sbc/quickref/countries_alpha_list.pdf).  #### SEPA/BACS Required for Create Mandate and Import Mandate  #### CyberSource through VisaNet Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.  **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.  #### Chase Paymentech Solutions Optional field.  ####  Credit Mutuel-CIC Optional field.  #### OmniPay Direct Optional field.  #### SIX Optional field.  #### TSYS Acquiring Solutions Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.  #### Worldpay VAP Optional field.  #### All other processors Not used. 
    */
    'country': string;
    /**
    * Payment card billing city.  #### SEPA Required for Create Mandate and Import Mandate  #### Atos This field must not contain colons (:).  #### CyberSource through VisaNet Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.  #### For Payouts: This field may be sent only for FDC Compass.  #### Chase Paymentech Solutions Optional field.  ####  Credit Mutuel-CIC Optional field.  #### OmniPay Direct Optional field.  #### SIX Optional field.  #### TSYS Acquiring Solutions Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.  #### Worldpay VAP Optional field.  #### All other processors Not used. 
    */
    'locality': string;
    /**
    * Postal code for the billing address. The postal code must consist of 5 to 9 digits.  When the billing country is the U.S., the 9-digit postal code must follow this format: [5 digits][dash][4 digits]  **Example** `12345-6789`  When the billing country is Canada, the 6-digit postal code must follow this format: [alpha][numeric][alpha][space][numeric][alpha][numeric]  **Example** `A1B 2C3`  **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.  #### SEPA Required for Create Mandate and Import Mandate  #### For Payouts:  This field may be sent only for FDC Compass.  #### American Express Direct Before sending the postal code to the processor, CyberSource removes all nonalphanumeric characters and, if the remaining value is longer than nine characters, truncates the value starting from the right side.  #### Atos This field must not contain colons (:).  #### CyberSource through VisaNet Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.  #### FDMS Nashville Required if `pointOfSaleInformation.entryMode=keyed` and the address is in the U.S. or Canada. Optional if `pointOfSaleInformation.entryMode=keyed` and the address is **not** in the U.S. or Canada. Not used if swiped.  #### RBS WorldPay Atlanta: For best card-present keyed rates, send the postal code if `pointOfSaleInformation.entryMode=keyed`.  #### TSYS Acquiring Solutions Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.  #### All other processors: Optional field. 
    */
    'postalCode': string;
    'company'?: Riskv1exportcomplianceinquiriesOrderInformationBillToCompany;
    /**
    * Customer’s first name. This name must be the same as the name on the card.  **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.  #### SEPA Required for Create Mandate and Import Mandate #### BACS Required for Import Mandate  #### CyberSource Latin American Processing **Important** For an authorization request, CyberSource Latin American Processing concatenates `orderInformation.billTo.firstName` and `orderInformation.billTo.lastName`. If the concatenated value exceeds 30 characters, CyberSource Latin American Processing declines the authorization request.\\ **Note** CyberSource Latin American Processing is the name of a specific processing connection that CyberSource supports. In the CyberSource API documentation, CyberSource Latin American Processing does not refer to the general topic of processing in Latin America. The information in this field description is for the specific processing connection called _CyberSource Latin American Processing_. It is not for any other Latin American processors that CyberSource supports.  #### CyberSource through VisaNet Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.  #### For Payouts: This field may be sent only for FDC Compass.  #### Chase Paymentech Solutions Optional field.  ####  Credit Mutuel-CIC Optional field.  #### OmniPay Direct Optional field.  #### SIX Optional field.  #### TSYS Acquiring Solutions Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.  #### Worldpay VAP Optional field.  #### All other processors Not used. 
    */
    'firstName'?: string;
    /**
    * Customer’s last name. This name must be the same as the name on the card.  **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.  #### SEPA Required for Create Mandate and Import Mandate #### BACS Required for Import Mandate #### Chase Paymentech Solutions Optional field.  ####  Credit Mutuel-CIC Optional field.  #### CyberSource Latin American Processing **Important** For an authorization request, CyberSource Latin American Processing concatenates `orderInformation.billTo.firstName` and `orderInformation.billTo.lastName`. If the concatenated value exceeds 30 characters, CyberSource Latin American Processing declines the authorization request.\\ **Note** CyberSource Latin American Processing is the name of a specific processing connection that CyberSource supports. In the CyberSource API documentation, CyberSource Latin American Processing does not refer to the general topic of processing in Latin America. The information in this field description is for the specific processing connection called CyberSource Latin American Processing. It is not for any other Latin American processors that CyberSource supports.  #### CyberSource through VisaNet Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.  #### For Payouts: This field may be sent only for FDC Compass.  #### OmniPay Direct Optional field.  #### RBS WorldPay Atlanta Optional field.  #### SIX Optional field.  #### TSYS Acquiring Solutions Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.  #### Worldpay VAP Optional field.  #### All other processors Not used. 
    */
    'lastName'?: string;
    /**
    * Customer's email address, including the full domain name.  #### CyberSource through VisaNet Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.  **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.  #### Invoicing Email address for the customer for sending the invoice. If the invoice is in SENT status and email is updated, the old email customer payment link won't work and you must resend the invoice with the new payment link.  #### Chase Paymentech Solutions Optional field.  ####  Credit Mutuel-CIC Optional field.  #### OmniPay Direct Optional field.  #### SIX Optional field.  #### TSYS Acquiring Solutions Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.  #### Worldpay VAP Optional field.  #### All other processors Not used. 
    */
    'email': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "address1",
            "baseName": "address1",
            "type": "string"
        },
        {
            "name": "address2",
            "baseName": "address2",
            "type": "string"
        },
        {
            "name": "address3",
            "baseName": "address3",
            "type": "string"
        },
        {
            "name": "address4",
            "baseName": "address4",
            "type": "string"
        },
        {
            "name": "administrativeArea",
            "baseName": "administrativeArea",
            "type": "string"
        },
        {
            "name": "country",
            "baseName": "country",
            "type": "string"
        },
        {
            "name": "locality",
            "baseName": "locality",
            "type": "string"
        },
        {
            "name": "postalCode",
            "baseName": "postalCode",
            "type": "string"
        },
        {
            "name": "company",
            "baseName": "company",
            "type": "Riskv1exportcomplianceinquiriesOrderInformationBillToCompany"
        },
        {
            "name": "firstName",
            "baseName": "firstName",
            "type": "string"
        },
        {
            "name": "lastName",
            "baseName": "lastName",
            "type": "string"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Riskv1exportcomplianceinquiriesOrderInformationBillTo.attributeTypeMap;
    }
}

export class Riskv1exportcomplianceinquiriesOrderInformationBillToCompany {
    /**
    * Company name of person buying the product. Important: This field or billTo.firstName and billTo.lastName must be present. Else, your request will fail. 
    */
    'name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Riskv1exportcomplianceinquiriesOrderInformationBillToCompany.attributeTypeMap;
    }
}

export class Riskv1exportcomplianceinquiriesOrderInformationLineItems {
    /**
    * Per-item price of the product. If line items are present in the request, the unit price is a mandatory field. 
    */
    'unitPrice'?: string;
    'allowedExportCountries'?: Array<string>;
    'restrictedExportCountries'?: Array<string>;
    /**
    * Number of units for this order. Must be a non-negative integer.  The default is `1`. For an authorization or capture transaction (`processingOptions.capture` is set to `true` or `false`), this field is required when `orderInformation.lineItems[].productCode` is not `default` or one of the other values related to shipping and/or handling.  #### Tax Calculation Optional field for U.S., Canadian, international tax, and value added taxes. 
    */
    'quantity'?: number;
    /**
    * Product identifier code. Also known as the Stock Keeping Unit (SKU) code for the product.  For an authorization or capture transaction (`processingOptions.capture` is set to `true` or `false`), this field is required when `orderInformation.lineItems[].productCode` is not set to **default** or one of the other values that are related to shipping and/or handling.  #### Tax Calculation Optional field for U.S. and Canadian taxes. Not applicable to international and value added taxes. For an authorization or capture transaction (`processingOptions.capture` is set to `true` or `false`), this field is required when `orderInformation.lineItems[].productCode` is not `default` or one of the values related to shipping and/or handling. 
    */
    'productSKU'?: string;
    /**
    * Indicates the level of risk for the product. This field can contain one of the following values: - `low`: The product is associated with few chargebacks. - `normal`: The product is associated with a normal number of chargebacks. - `high`: The product is associated with many chargebacks. 
    */
    'productRisk'?: string;
    /**
    * For an authorization or capture transaction (`processingOptions.capture` is `true` or `false`), this field is required when `orderInformation.lineItems[].productCode` is not `default` or one of the other values that are related to shipping and/or handling.  #### Tax Calculation Optional field for U.S., Canadian, international tax, and value added taxes. 
    */
    'productName'?: string;
    /**
    * Type of product. The value for this field is used to identify the product category (electronic, handling, physical, service, or shipping). The default value is `default`.  If you are performing an authorization transaction (`processingOptions.capture` is set to `false`), and you set this field to a value other than `default` or one of the values related to shipping and/or handling, then `orderInformation.lineItems[].quantity`, `orderInformation.lineItems[].productName`, and `orderInformation.lineItems[].productSku` fields are required.  Optional field.  #### Tax Calculation Optional field for U.S., Canadian, international tax, and value added taxes.  The Product Codes for the tax service are located in the Cybersource Tax Codes guide. Contact Customer Support to request the guide. If you don’t send a tax service Product Code in your tax request, product-based rules or exemptions will not be applied and the transaction will default to fully taxable in the locations where you’ve indicated you need to collect tax [by way of nexus, no nexus, or seller registration number fields]. 
    */
    'productCode'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "unitPrice",
            "baseName": "unitPrice",
            "type": "string"
        },
        {
            "name": "allowedExportCountries",
            "baseName": "allowedExportCountries",
            "type": "Array<string>"
        },
        {
            "name": "restrictedExportCountries",
            "baseName": "restrictedExportCountries",
            "type": "Array<string>"
        },
        {
            "name": "quantity",
            "baseName": "quantity",
            "type": "number"
        },
        {
            "name": "productSKU",
            "baseName": "productSKU",
            "type": "string"
        },
        {
            "name": "productRisk",
            "baseName": "productRisk",
            "type": "string"
        },
        {
            "name": "productName",
            "baseName": "productName",
            "type": "string"
        },
        {
            "name": "productCode",
            "baseName": "productCode",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Riskv1exportcomplianceinquiriesOrderInformationLineItems.attributeTypeMap;
    }
}

export class Riskv1exportcomplianceinquiriesOrderInformationShipTo {
    /**
    * Country of the shipping address. Use the two-character [ISO Standard Country Codes.](http://apps.cybersource.com/library/documentation/sbc/quickref/countries_alpha_list.pdf)  Required field for authorization if any shipping address information is included in the request; otherwise, optional.  #### Tax Calculation Optional field for U.S., Canadian, international tax, and value added taxes. Billing address objects will be used to determine the cardholder’s location when shipTo objects are not present. 
    */
    'country'?: string;
    /**
    * First name of the recipient.  #### Litle Maximum length: 25  #### All other processors Maximum length: 60  Optional field. 
    */
    'firstName'?: string;
    /**
    * Last name of the recipient.  #### Litle Maximum length: 25  #### All other processors Maximum length: 60  Optional field. 
    */
    'lastName'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "country",
            "baseName": "country",
            "type": "string"
        },
        {
            "name": "firstName",
            "baseName": "firstName",
            "type": "string"
        },
        {
            "name": "lastName",
            "baseName": "lastName",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Riskv1exportcomplianceinquiriesOrderInformationShipTo.attributeTypeMap;
    }
}

/**
* Contains information about the buyer.
*/
export class Riskv1liststypeentriesBuyerInformation {
    'personalIdentification'?: Array<Ptsv2paymentsBuyerInformationPersonalIdentification>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "personalIdentification",
            "baseName": "personalIdentification",
            "type": "Array<Ptsv2paymentsBuyerInformationPersonalIdentification>"
        }    ];

    static getAttributeTypeMap() {
        return Riskv1liststypeentriesBuyerInformation.attributeTypeMap;
    }
}

export class Riskv1liststypeentriesClientReferenceInformation {
    /**
    * Merchant-generated order reference or tracking number. It is recommended that you send a unique value for each transaction so that you can perform meaningful searches for the transaction.  #### Used by **Authorization** Required field.  #### PIN Debit Requests for PIN debit reversals need to use the same merchant reference number that was used in the transaction that is being reversed.  Required field for all PIN Debit requests (purchase, credit, and reversal).  #### FDC Nashville Global Certain circumstances can cause the processor to truncate this value to 15 or 17 characters for Level II and Level III processing, which can cause a discrepancy between the value you submit and the value included in some processor reports. 
    */
    'code': string;
    /**
    * Brief description of the order or any comment you wish to add to the order. 
    */
    'comments'?: string;
    'partner'?: Riskv1decisionsClientReferenceInformationPartner;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        },
        {
            "name": "comments",
            "baseName": "comments",
            "type": "string"
        },
        {
            "name": "partner",
            "baseName": "partner",
            "type": "Riskv1decisionsClientReferenceInformationPartner"
        }    ];

    static getAttributeTypeMap() {
        return Riskv1liststypeentriesClientReferenceInformation.attributeTypeMap;
    }
}

export class Riskv1liststypeentriesDeviceInformation {
    /**
    * IP address of the customer.  #### Used by **Authorization, Capture, and Credit** Optional field. 
    */
    'ipAddress'?: string;
    /**
    * Network IP address of the customer (for example, 10.1.27). A network IP address includes up to 256 IP addresses. 
    */
    'networkIpAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "ipAddress",
            "baseName": "ipAddress",
            "type": "string"
        },
        {
            "name": "networkIpAddress",
            "baseName": "networkIpAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Riskv1liststypeentriesDeviceInformation.attributeTypeMap;
    }
}

export class Riskv1liststypeentriesOrderInformation {
    'address'?: Riskv1liststypeentriesOrderInformationAddress;
    'billTo'?: Riskv1liststypeentriesOrderInformationBillTo;
    'shipTo'?: Riskv1liststypeentriesOrderInformationShipTo;
    /**
    * This array contains detailed information about individual products in the order.
    */
    'lineItems'?: Array<Riskv1liststypeentriesOrderInformationLineItems>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "address",
            "baseName": "address",
            "type": "Riskv1liststypeentriesOrderInformationAddress"
        },
        {
            "name": "billTo",
            "baseName": "billTo",
            "type": "Riskv1liststypeentriesOrderInformationBillTo"
        },
        {
            "name": "shipTo",
            "baseName": "shipTo",
            "type": "Riskv1liststypeentriesOrderInformationShipTo"
        },
        {
            "name": "lineItems",
            "baseName": "lineItems",
            "type": "Array<Riskv1liststypeentriesOrderInformationLineItems>"
        }    ];

    static getAttributeTypeMap() {
        return Riskv1liststypeentriesOrderInformation.attributeTypeMap;
    }
}

/**
* Contains address information related to the order
*/
export class Riskv1liststypeentriesOrderInformationAddress {
    /**
    * First line of the street address
    */
    'address1'?: string;
    /**
    * Second line of the street address
    */
    'address2'?: string;
    /**
    * City of the street address. Required when adding the address to a list. 
    */
    'locality'?: string;
    /**
    * Country of the street address. Use the two-character codes located in the Support Center. Required if address1 is present. 
    */
    'country'?: string;
    /**
    * State, province, or territory of the street address. Use the two-character codes located in the Support Center.
    */
    'administrativeArea'?: string;
    /**
    * Postal code of the street address. Required when adding the address to a list.
    */
    'postalCode'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "address1",
            "baseName": "address1",
            "type": "string"
        },
        {
            "name": "address2",
            "baseName": "address2",
            "type": "string"
        },
        {
            "name": "locality",
            "baseName": "locality",
            "type": "string"
        },
        {
            "name": "country",
            "baseName": "country",
            "type": "string"
        },
        {
            "name": "administrativeArea",
            "baseName": "administrativeArea",
            "type": "string"
        },
        {
            "name": "postalCode",
            "baseName": "postalCode",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Riskv1liststypeentriesOrderInformationAddress.attributeTypeMap;
    }
}

export class Riskv1liststypeentriesOrderInformationBillTo {
    /**
    * Payment card billing street address as it appears on the credit card issuer’s records.  #### SEPA Required for Create Mandate and Import Mandate  #### Atos This field must not contain colons (:).  #### CyberSource through VisaNet **Important** When you populate orderInformation.billTo.address1 and orderInformation.billTo.address2, CyberSource through VisaNet concatenates the two values. If the concatenated value exceeds 40 characters, CyberSource through VisaNet truncates the value at 40 characters before sending it to Visa and the issuing bank. Truncating this value affects AVS results and therefore might also affect risk decisions and chargebacks. Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.  #### FDMS Nashville When the street name is numeric, it must be sent in numeric format. For example, if the address is _One First Street_, it must be sent as _1 1st Street_.  Required if keyed; not used if swiped.  String (20)  #### TSYS Acquiring Solutions Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.  #### All other processors: Optional. String (60)  #### For Payouts This field may be sent only for FDC Compass.  **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting. 
    */
    'address1'?: string;
    /**
    * Used for additional address information. For example: _Attention: Accounts Payable_ Optional field.  For Payouts: This field may be sent only for FDC Compass.  #### Atos This field must not contain colons (:).  #### CyberSource through VisaNet **Important** When you populate `orderInformation.billTo.address1` and `orderInformation.billTo.address2`, CyberSource through VisaNet concatenates the two values. If the concatenated value exceeds 40 characters, CyberSource through VisaNet truncates the value at 40 characters before sending it to Visa and the issuing bank. Truncating this value affects AVS results and therefore might also affect risk decisions and chargebacks. Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.  #### Chase Paymentech Solutions, FDC Compass, and TSYS Acquiring Solutions This value is used for AVS.  #### FDMS Nashville `orderInformation.billTo.address1` and `orderInformation.billTo.address2` together cannot exceed 20 characters. String (20)  #### All Other Processors String (60) 
    */
    'address2'?: string;
    /**
    * State or province of the billing address. Use the [State, Province, and Territory Codes for the United States and Canada](https://developer.cybersource.com/library/documentation/sbc/quickref/states_and_provinces.pdf).  For Payouts: This field may be sent only for FDC Compass.  ##### CyberSource through VisaNet Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.  **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.  #### Chase Paymentech Solutions Optional field.  ####  Credit Mutuel-CIC Optional field.  #### OmniPay Direct Optional field.  #### SIX Optional field.  #### TSYS Acquiring Solutions Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.  #### Worldpay VAP Optional field.  #### All other processors Not used. 
    */
    'administrativeArea'?: string;
    /**
    * Payment card billing country. Use the two-character [ISO Standard Country Codes](http://apps.cybersource.com/library/documentation/sbc/quickref/countries_alpha_list.pdf).  #### SEPA/BACS Required for Create Mandate and Import Mandate  #### CyberSource through VisaNet Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.  **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.  #### Chase Paymentech Solutions Optional field.  ####  Credit Mutuel-CIC Optional field.  #### OmniPay Direct Optional field.  #### SIX Optional field.  #### TSYS Acquiring Solutions Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.  #### Worldpay VAP Optional field.  #### All other processors Not used. 
    */
    'country'?: string;
    /**
    * Payment card billing city.  #### SEPA Required for Create Mandate and Import Mandate  #### Atos This field must not contain colons (:).  #### CyberSource through VisaNet Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.  #### For Payouts: This field may be sent only for FDC Compass.  #### Chase Paymentech Solutions Optional field.  ####  Credit Mutuel-CIC Optional field.  #### OmniPay Direct Optional field.  #### SIX Optional field.  #### TSYS Acquiring Solutions Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.  #### Worldpay VAP Optional field.  #### All other processors Not used. 
    */
    'locality'?: string;
    /**
    * Postal code for the billing address. The postal code must consist of 5 to 9 digits.  When the billing country is the U.S., the 9-digit postal code must follow this format: [5 digits][dash][4 digits]  **Example** `12345-6789`  When the billing country is Canada, the 6-digit postal code must follow this format: [alpha][numeric][alpha][space][numeric][alpha][numeric]  **Example** `A1B 2C3`  **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.  #### SEPA Required for Create Mandate and Import Mandate  #### For Payouts:  This field may be sent only for FDC Compass.  #### American Express Direct Before sending the postal code to the processor, CyberSource removes all nonalphanumeric characters and, if the remaining value is longer than nine characters, truncates the value starting from the right side.  #### Atos This field must not contain colons (:).  #### CyberSource through VisaNet Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.  #### FDMS Nashville Required if `pointOfSaleInformation.entryMode=keyed` and the address is in the U.S. or Canada. Optional if `pointOfSaleInformation.entryMode=keyed` and the address is **not** in the U.S. or Canada. Not used if swiped.  #### RBS WorldPay Atlanta: For best card-present keyed rates, send the postal code if `pointOfSaleInformation.entryMode=keyed`.  #### TSYS Acquiring Solutions Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.  #### All other processors: Optional field. 
    */
    'postalCode'?: string;
    /**
    * Customer’s first name. This name must be the same as the name on the card.  **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.  #### SEPA Required for Create Mandate and Import Mandate #### BACS Required for Import Mandate  #### CyberSource Latin American Processing **Important** For an authorization request, CyberSource Latin American Processing concatenates `orderInformation.billTo.firstName` and `orderInformation.billTo.lastName`. If the concatenated value exceeds 30 characters, CyberSource Latin American Processing declines the authorization request.\\ **Note** CyberSource Latin American Processing is the name of a specific processing connection that CyberSource supports. In the CyberSource API documentation, CyberSource Latin American Processing does not refer to the general topic of processing in Latin America. The information in this field description is for the specific processing connection called _CyberSource Latin American Processing_. It is not for any other Latin American processors that CyberSource supports.  #### CyberSource through VisaNet Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.  #### For Payouts: This field may be sent only for FDC Compass.  #### Chase Paymentech Solutions Optional field.  ####  Credit Mutuel-CIC Optional field.  #### OmniPay Direct Optional field.  #### SIX Optional field.  #### TSYS Acquiring Solutions Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.  #### Worldpay VAP Optional field.  #### All other processors Not used. 
    */
    'firstName'?: string;
    /**
    * Customer’s last name. This name must be the same as the name on the card.  **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.  #### SEPA Required for Create Mandate and Import Mandate #### BACS Required for Import Mandate #### Chase Paymentech Solutions Optional field.  ####  Credit Mutuel-CIC Optional field.  #### CyberSource Latin American Processing **Important** For an authorization request, CyberSource Latin American Processing concatenates `orderInformation.billTo.firstName` and `orderInformation.billTo.lastName`. If the concatenated value exceeds 30 characters, CyberSource Latin American Processing declines the authorization request.\\ **Note** CyberSource Latin American Processing is the name of a specific processing connection that CyberSource supports. In the CyberSource API documentation, CyberSource Latin American Processing does not refer to the general topic of processing in Latin America. The information in this field description is for the specific processing connection called CyberSource Latin American Processing. It is not for any other Latin American processors that CyberSource supports.  #### CyberSource through VisaNet Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.  #### For Payouts: This field may be sent only for FDC Compass.  #### OmniPay Direct Optional field.  #### RBS WorldPay Atlanta Optional field.  #### SIX Optional field.  #### TSYS Acquiring Solutions Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.  #### Worldpay VAP Optional field.  #### All other processors Not used. 
    */
    'lastName'?: string;
    /**
    * Customer’s phone number.  It is recommended that you include the country code when the order is from outside the U.S.  #### Chase Paymentech Solutions Optional field.  ####  Credit Mutuel-CIC Optional field.  #### CyberSource through VisaNet Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.  #### For Payouts: This field may be sent only for FDC Compass.  #### OmniPay Direct Optional field.  #### SIX Optional field.  #### TSYS Acquiring Solutions Optional field.  #### Worldpay VAP Optional field.  #### All other processors Not used. 
    */
    'phoneNumber'?: string;
    /**
    * Customer's email address, including the full domain name.  #### CyberSource through VisaNet Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.  **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.  #### Invoicing Email address for the customer for sending the invoice. If the invoice is in SENT status and email is updated, the old email customer payment link won't work and you must resend the invoice with the new payment link.  #### Chase Paymentech Solutions Optional field.  ####  Credit Mutuel-CIC Optional field.  #### OmniPay Direct Optional field.  #### SIX Optional field.  #### TSYS Acquiring Solutions Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.  #### Worldpay VAP Optional field.  #### All other processors Not used. 
    */
    'email'?: string;
    /**
    * Email domain of the customer. The domain of the email address comprises all characters that follow the @ symbol, such as mail.example.com. For the Risk Update service, if the email address and the domain are sent in the request, the domain supersedes the email address. 
    */
    'emailDomain'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "address1",
            "baseName": "address1",
            "type": "string"
        },
        {
            "name": "address2",
            "baseName": "address2",
            "type": "string"
        },
        {
            "name": "administrativeArea",
            "baseName": "administrativeArea",
            "type": "string"
        },
        {
            "name": "country",
            "baseName": "country",
            "type": "string"
        },
        {
            "name": "locality",
            "baseName": "locality",
            "type": "string"
        },
        {
            "name": "postalCode",
            "baseName": "postalCode",
            "type": "string"
        },
        {
            "name": "firstName",
            "baseName": "firstName",
            "type": "string"
        },
        {
            "name": "lastName",
            "baseName": "lastName",
            "type": "string"
        },
        {
            "name": "phoneNumber",
            "baseName": "phoneNumber",
            "type": "string"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "emailDomain",
            "baseName": "emailDomain",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Riskv1liststypeentriesOrderInformationBillTo.attributeTypeMap;
    }
}

export class Riskv1liststypeentriesOrderInformationLineItems {
    /**
    * Per-item price of the product. This value for this field cannot be negative.  You must include either this field or the request-level field `orderInformation.amountDetails.totalAmount` in your request.  You can include a decimal point (.), but you cannot include any other special characters. The value is truncated to the correct number of decimal places.  #### DCC with a Third-Party Provider Set this field to the converted amount that was returned by the DCC provider. You must include either the 1st line item in the order and this field, or the request-level field `orderInformation.amountDetails.totalAmount` in your request.  #### Tax Calculation Required field for U.S., Canadian, international and value added taxes.  #### Zero Amount Authorizations If your processor supports zero amount authorizations, you can set this field to 0 for the authorization to check if the card is lost or stolen.  #### Maximum Field Lengths For GPN and JCN Gateway: Decimal (10) All other processors: Decimal (15) 
    */
    'unitPrice'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "unitPrice",
            "baseName": "unitPrice",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Riskv1liststypeentriesOrderInformationLineItems.attributeTypeMap;
    }
}

/**
* Contains recipient shipping information.
*/
export class Riskv1liststypeentriesOrderInformationShipTo {
    /**
    * First line of the shipping address.  Required field for authorization if any shipping address information is included in the request; otherwise, optional.  #### Tax Calculation Optional field for U.S. and Canadian taxes. Not applicable to international and value added taxes. Billing address objects will be used to determine the cardholder’s location when shipTo objects are not present. 
    */
    'address1'?: string;
    /**
    * Second line of the shipping address.  Optional field.  #### Tax Calculation Optional field for U.S. and Canadian taxes. Not applicable to international and value added taxes. Billing address objects will be used to determine the cardholder’s location when shipTo objects are not present. 
    */
    'address2'?: string;
    /**
    * State or province of the shipping address. Use the [State, Province, and Territory Codes for the United States and Canada](https://developer.cybersource.com/library/documentation/sbc/quickref/states_and_provinces.pdf) (maximum length: 2)   Required field for authorization if any shipping address information is included in the request and shipping to the U.S. or Canada; otherwise, optional.  #### Tax Calculation Optional field for U.S. and Canadian taxes. Not applicable to international and value added taxes. Billing address objects will be used to determine the cardholder’s location when shipTo objects are not present. 
    */
    'administrativeArea'?: string;
    /**
    * Country of the shipping address. Use the two-character [ISO Standard Country Codes.](http://apps.cybersource.com/library/documentation/sbc/quickref/countries_alpha_list.pdf)  Required field for authorization if any shipping address information is included in the request; otherwise, optional.  #### Tax Calculation Optional field for U.S., Canadian, international tax, and value added taxes. Billing address objects will be used to determine the cardholder’s location when shipTo objects are not present. 
    */
    'country'?: string;
    /**
    * City of the shipping address.  Required field for authorization if any shipping address information is included in the request and shipping to the U.S. or Canada; otherwise, optional.  #### Tax Calculation Optional field for U.S. and Canadian taxes. Not applicable to international and value added taxes. Billing address objects will be used to determine the cardholder’s location when shipTo objects are not present. 
    */
    'locality'?: string;
    /**
    * Postal code for the shipping address. The postal code must consist of 5 to 9 digits.  Required field for authorization if any shipping address information is included in the request and shipping to the U.S. or Canada; otherwise, optional.  When the billing country is the U.S., the 9-digit postal code must follow this format: [5 digits][dash][4 digits]  Example 12345-6789  When the billing country is Canada, the 6-digit postal code must follow this format: [alpha][numeric][alpha][space][numeric][alpha][numeric]  Example A1B 2C3  #### American Express Direct Before sending the postal code to the processor, all nonalphanumeric characters are removed and, if the remaining value is longer than nine characters, the value is truncated starting from the right side. #### Tax Calculation Optional field for U.S. and Canadian taxes. Not applicable to international and value added taxes. Billing address objects will be used to determine the cardholder’s location when shipTo objects are not present. 
    */
    'postalCode'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "address1",
            "baseName": "address1",
            "type": "string"
        },
        {
            "name": "address2",
            "baseName": "address2",
            "type": "string"
        },
        {
            "name": "administrativeArea",
            "baseName": "administrativeArea",
            "type": "string"
        },
        {
            "name": "country",
            "baseName": "country",
            "type": "string"
        },
        {
            "name": "locality",
            "baseName": "locality",
            "type": "string"
        },
        {
            "name": "postalCode",
            "baseName": "postalCode",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Riskv1liststypeentriesOrderInformationShipTo.attributeTypeMap;
    }
}

/**
* Contains the payment data for updating in List Management.
*/
export class Riskv1liststypeentriesPaymentInformation {
    'card'?: Riskv1liststypeentriesPaymentInformationCard;
    'bank'?: Riskv1liststypeentriesPaymentInformationBank;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "card",
            "baseName": "card",
            "type": "Riskv1liststypeentriesPaymentInformationCard"
        },
        {
            "name": "bank",
            "baseName": "bank",
            "type": "Riskv1liststypeentriesPaymentInformationBank"
        }    ];

    static getAttributeTypeMap() {
        return Riskv1liststypeentriesPaymentInformation.attributeTypeMap;
    }
}

/**
* Customer's bank account details
*/
export class Riskv1liststypeentriesPaymentInformationBank {
    /**
    * Customer's bank account number. You can use this field only when scoring a direct debit transaction. Use this field if you do not or are not allowed to provide the IBAN. Note Do not use the IBAN in this field. Use nly the traditional account number information. For the IBAN, use bank_iban. 
    */
    'accountNumber'?: string;
    /**
    * Country-specific code used to identify the customer’s bank. Required for some countries if you do not or are not allowed to provide the IBAN instead. You can use this field only when scoring a direct debit transaction. For specific requirements, see \"Required Bank Account Information by Country,\" 
    */
    'code'?: string;
    /**
    * Country where the bank is located. Use the two-character ISO codes. You can use this field only when scoring a direct debit transaction. 
    */
    'country'?: string;
    /**
    * International Bank Account Number (IBAN) for the bank account. For some countries you can provide this number instead of the traditional bank account information. You can use this field only when scoring a direct debit transaction. For specific requirements, see \"Required Bank Account Information by Country,\" 
    */
    'iban'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "accountNumber",
            "baseName": "accountNumber",
            "type": "string"
        },
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        },
        {
            "name": "country",
            "baseName": "country",
            "type": "string"
        },
        {
            "name": "iban",
            "baseName": "iban",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Riskv1liststypeentriesPaymentInformationBank.attributeTypeMap;
    }
}

export class Riskv1liststypeentriesPaymentInformationCard {
    /**
    * The customer’s payment card number, also known as the Primary Account Number (PAN). You can also use this field for encoded account numbers.  #### FDMS Nashville Required. String (19)  #### GPX Required if `pointOfSaleInformation.entryMode=keyed`. However, this field is optional if your account is configured for relaxed requirements for address data and expiration date. **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.  #### All other processors Required if `pointOfSaleInformation.entryMode=keyed`. However, this field is optional if your account is configured for relaxed requirements for address data and expiration date. **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting. 
    */
    'number'?: string;
    /**
    * Three-digit value that indicates the card type.  **IMPORTANT** It is strongly recommended that you include the card type field in request messages even if it is optional for your processor and card type. Omitting the card type can cause the transaction to be processed with the wrong card type.  Possible values: - `001`: Visa. Use card type value `001` for Visa Electron. - `002`: Mastercard, Eurocard[^1], which is a European regional brand of Mastercard. - `003`: American Express - `004`: Discover - `005`: Diners Club - `006`: Carte Blanche[^1] - `007`: JCB[^1] - `008`: Optima - `009`: GE Private Label - `010`: Beneficial Private Label - `011`: Twinpay Credit Card - `012`: Twinpay Debit Card - `013`: WalMart - `014`: Enroute[^1] - `015`: Lowe's Consumer - `016`: Home Depot Consumer - `017`: MBNA - `018`: Dick's Sportswear - `019`: Casual Corner - `020`: Sears - `021`: JAL[^1] - `023`: Disney Card - `024`: Maestro (UK Domestic)[^1] - `025`: Sam's Club Consumer - `026`: Sam's Club Business - `027`: Nico's - `028`: Paymentech Bill Me Later - `029`: Bebe - `030`: Restoration Hardware - `031`: Delta Online - `032`: Solo - `033`: Visa Electron[^1]. Do not use this value. Use `001` for all Visa card types. - `034`: Dankort[^1] - `035`: Laser - `036`: Cartes Bancaires[^1,4] - `037`: Carta Si[^1] - `038`: Pinless Debit - `039`: Encoded account number[^1] - `040`: UATP[^1] - `041`: HOUSEHOLD - `042`: Maestro (International)[^1] - `043`: GE MONEY - `044`: Korean Cards - `045`: Style Cards - `046`: JCrew - `047`: Payeasecn eWallet - `048`: Payeasecn Bank Transfer - `049`: Meijer - `050`: Hipercard[^2,3] - `051`: Aura - `052`: Redecard - `053`: Orico card - `054`: Elo[^3] - `055`: Capitol One Private Label - `056`: Carnet - `057`: Costco Private Label - `058`: Carnet - `059`: ValueLink - `060`: MADA - `061`: RuPay - `062`: China UnionPay - `063`: Falabella Private Label - `064`: Prompt Card - `065`: Korean Domestic - `066`: Banricompras - `067`: MEEZA - `068`: PayPak - `070`: EFTPOS - `071`: Codensa - `072`: Olimpica - `073`: Colsubsidio - `074`: Tuya - `075`: Sodexo - `076`: Naranja - `077`: Cabal - `078`: DINELCO - `079`: PANAL - `080`: EPM - `081`: Jaywan  [^1]: For this card type, you must include the `paymentInformation.card.type` or `paymentInformation.tokenizedCard.type` field in your request for an authorization or a stand-alone credit. [^2]: For this card type on Cielo 3.0, you must include the `paymentInformation.card.type` or `paymentInformation.tokenizedCard.type` field in a request for an authorization or a stand-alone credit. This card type is not supported on Cielo 1.5. [^3]: For this card type on Getnet and Rede, you must include the `paymentInformation.card.type` or `paymentInformation.tokenizedCard.type` field in a request for an authorization or a stand-alone credit. [^4]: For this card type, you must include the `paymentInformation.card.type` in your request for any payer authentication services.  #### Used by **Authorization** Required for Carte Blanche and JCB. Optional for all other card types.  #### Card Present reply This field is included in the reply message when the client software that is installed on the POS terminal uses the token management service (TMS) to retrieve tokenized payment details. You must contact customer support to have your account enabled to receive these fields in the credit reply message.  Returned by the Credit service.  This reply field is only supported by the following processors: - American Express Direct - Credit Mutuel-CIC - FDC Nashville Global - OmniPay Direct - SIX  #### Google Pay transactions For PAN-based Google Pay transactions, this field is returned in the API response.  #### GPX This field only supports transactions from the following card types: - Visa - Mastercard - AMEX - Discover - Diners - JCB - Union Pay International 
    */
    'type'?: string;
    /**
    * description: The BIN is the first six digits of the card's Primary Account Number (PAN). 
    */
    'bin'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "number",
            "baseName": "number",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "bin",
            "baseName": "bin",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Riskv1liststypeentriesPaymentInformationCard.attributeTypeMap;
    }
}

export class Riskv1liststypeentriesRiskInformation {
    'markingDetails'?: Riskv1liststypeentriesRiskInformationMarkingDetails;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "markingDetails",
            "baseName": "markingDetails",
            "type": "Riskv1liststypeentriesRiskInformationMarkingDetails"
        }    ];

    static getAttributeTypeMap() {
        return Riskv1liststypeentriesRiskInformation.attributeTypeMap;
    }
}

/**
* Details for marking the transaction as either positive or negative.
*/
export class Riskv1liststypeentriesRiskInformationMarkingDetails {
    /**
    * Notes or details that explain the reasons for adding the transaction to either the positive or negative list.
    */
    'notes'?: string;
    /**
    * Reason for adding the transaction to the negative list. This field can contain one of the following values: - `fraud_chargeback:` You have received a fraud-related chargeback for the transaction. - `non_fraud_chargeback:` You have received a non-fraudulent chargeback for the transaction. - `suspected:` You believe that you will probably receive a chargeback for the transaction. - `creditback:` You issued a refund to the customer to avoid a chargeback for the transaction. 
    */
    'reason'?: string;
    /**
    * Name of the customer’s record entered in the list. For the positive list, it is required if `action_ code`=`add_positive`. If absent from the request, `ics_risk_update` creates the value for this field by concatenating the customer’s first and last names. For the negative and the review lists, `record_name`, `customer_firstname`, and `customer_lastname` are optional. 
    */
    'recordName'?: string;
    /**
    * Indicates whether to add to or remove a customer’s identity from the negative or positive list. This field can contain one of the following values: - add: Add information to the list. - convert: moves the data. - delete: deletes the data from the list. 
    */
    'action'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "notes",
            "baseName": "notes",
            "type": "string"
        },
        {
            "name": "reason",
            "baseName": "reason",
            "type": "string"
        },
        {
            "name": "recordName",
            "baseName": "recordName",
            "type": "string"
        },
        {
            "name": "action",
            "baseName": "action",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Riskv1liststypeentriesRiskInformationMarkingDetails.attributeTypeMap;
    }
}

export class SAConfig {
    /**
    * You can group Secure Acceptance profiles under parent profiles. By changing the parent profile, you can update all profiles underneath that parent. Specify the Parent Profile ID here.
    */
    'parentProfileId'?: string;
    'contactInformation'?: SAConfigContactInformation;
    'notifications'?: SAConfigNotifications;
    'service'?: SAConfigService;
    'paymentMethods'?: SAConfigPaymentMethods;
    'checkout'?: SAConfigCheckout;
    'paymentTypes'?: SAConfigPaymentTypes;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "parentProfileId",
            "baseName": "parentProfileId",
            "type": "string"
        },
        {
            "name": "contactInformation",
            "baseName": "contactInformation",
            "type": "SAConfigContactInformation"
        },
        {
            "name": "notifications",
            "baseName": "notifications",
            "type": "SAConfigNotifications"
        },
        {
            "name": "service",
            "baseName": "service",
            "type": "SAConfigService"
        },
        {
            "name": "paymentMethods",
            "baseName": "paymentMethods",
            "type": "SAConfigPaymentMethods"
        },
        {
            "name": "checkout",
            "baseName": "checkout",
            "type": "SAConfigCheckout"
        },
        {
            "name": "paymentTypes",
            "baseName": "paymentTypes",
            "type": "SAConfigPaymentTypes"
        }    ];

    static getAttributeTypeMap() {
        return SAConfig.attributeTypeMap;
    }
}

export class SAConfigCheckout {
    /**
    * Toggles whether or not the tax amount is displayed on the Hosted Checkout.
    */
    'displayTaxAmount'?: boolean;
    /**
    * Specifies whether the Hosted Checkout is displayed as a single page form or multi page checkout.   Valid values:  `multi`  `single` 
    */
    'templateType'?: string;
    /**
    * URL of the website linked to from the Secure Acceptance receipt page. Only used if the profile does not have custom receipt pages configured.
    */
    'returnToMerchantSiteUrl'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "displayTaxAmount",
            "baseName": "displayTaxAmount",
            "type": "boolean"
        },
        {
            "name": "templateType",
            "baseName": "templateType",
            "type": "string"
        },
        {
            "name": "returnToMerchantSiteUrl",
            "baseName": "returnToMerchantSiteUrl",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return SAConfigCheckout.attributeTypeMap;
    }
}

/**
* Optional contact information to be associated with the Secure Acceptance profile - for example the developer of the integration to the Hosted Checkout.
*/
export class SAConfigContactInformation {
    'phone'?: string;
    'companyName'?: string;
    'email'?: string;
    'name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "phone",
            "baseName": "phone",
            "type": "string"
        },
        {
            "name": "companyName",
            "baseName": "companyName",
            "type": "string"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return SAConfigContactInformation.attributeTypeMap;
    }
}

export class SAConfigNotifications {
    'merchantNotifications'?: SAConfigNotificationsMerchantNotifications;
    'customerNotifications'?: SAConfigNotificationsCustomerNotifications;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "merchantNotifications",
            "baseName": "merchantNotifications",
            "type": "SAConfigNotificationsMerchantNotifications"
        },
        {
            "name": "customerNotifications",
            "baseName": "customerNotifications",
            "type": "SAConfigNotificationsCustomerNotifications"
        }    ];

    static getAttributeTypeMap() {
        return SAConfigNotifications.attributeTypeMap;
    }
}

/**
* Features relating to notifications being sent directly to the payer using the Hosted Checkout.
*/
export class SAConfigNotificationsCustomerNotifications {
    /**
    * Toggles the custom receipt page, where merchants can receive the results of the transaction and display appropriate messaging. Usually set by web developers integrating to Secure Acceptance.
    */
    'customReceiptPageEnabled'?: boolean;
    /**
    * Email address where a copy of the payer's receipt email is sent, when notificationReceiptEmailEnabled is true.
    */
    'receiptEmailAddress'?: string;
    /**
    * Toggles an email receipt sent to the payer's email address on payment success.
    */
    'customerReceiptEmailEnabled'?: boolean;
    /**
    * URL to which transaction results are POSTed when the payer clicks 'Cancel' on the Hosted Checkout. Triggered when customCancelPageEnabled is true. Usually set by web developers integrating to Secure Acceptance.
    */
    'customCancelPage'?: string;
    /**
    * URL to which transaction results are POSTed when the payer requests a payment on the Hosted Checkout. Triggered when customCancelPageEnabled is true. Usually set by web developers integrating to Secure Acceptance.
    */
    'customReceiptPage'?: string;
    /**
    * Toggles the custom cancel page, where merchants can receive notice that the payer has canceled, and display appropriate messaging and direction. Usually set by web developers integrating to Secure Acceptance.
    */
    'customCancelPageEnabled'?: boolean;
    /**
    * Toggles whether merchant receives a copy of the payer's receipt email.
    */
    'notificationReceiptEmailEnabled'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "customReceiptPageEnabled",
            "baseName": "customReceiptPageEnabled",
            "type": "boolean"
        },
        {
            "name": "receiptEmailAddress",
            "baseName": "receiptEmailAddress",
            "type": "string"
        },
        {
            "name": "customerReceiptEmailEnabled",
            "baseName": "customerReceiptEmailEnabled",
            "type": "boolean"
        },
        {
            "name": "customCancelPage",
            "baseName": "customCancelPage",
            "type": "string"
        },
        {
            "name": "customReceiptPage",
            "baseName": "customReceiptPage",
            "type": "string"
        },
        {
            "name": "customCancelPageEnabled",
            "baseName": "customCancelPageEnabled",
            "type": "boolean"
        },
        {
            "name": "notificationReceiptEmailEnabled",
            "baseName": "notificationReceiptEmailEnabled",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return SAConfigNotificationsCustomerNotifications.attributeTypeMap;
    }
}

export class SAConfigNotificationsMerchantNotifications {
    /**
    * Enables Webhook transaction confirmation messages sent to URL defined in backofficePostUrl. Usually enabled by web developers integrating to Secure Acceptance.
    */
    'backofficePostEnabled'?: boolean;
    /**
    * Email address to receive transaction confirmation messages.
    */
    'backofficeEmailAddress'?: string;
    /**
    * Enables email transaction confirmation messages, sent to the address specified in backofficeEmailAddress.
    */
    'backofficeEmailEnabled'?: boolean;
    /**
    * Webhook URL to which transaction confirmation is sent. Usually completed by the web developers integrating to Secure Acceptance.
    */
    'backofficePostUrl'?: string;
    /**
    * Format in which the card number should be masked in the notifications.   Valid values: `1` - Display first 6 digits only (e.g. \"444433**********\")  `2` - Display last four digits only (e.g. \"************1111\")  `3` - Display First six and last four digits (e.g. \"444433******1111\") 
    */
    'cardNumberFormat'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "backofficePostEnabled",
            "baseName": "backofficePostEnabled",
            "type": "boolean"
        },
        {
            "name": "backofficeEmailAddress",
            "baseName": "backofficeEmailAddress",
            "type": "string"
        },
        {
            "name": "backofficeEmailEnabled",
            "baseName": "backofficeEmailEnabled",
            "type": "boolean"
        },
        {
            "name": "backofficePostUrl",
            "baseName": "backofficePostUrl",
            "type": "string"
        },
        {
            "name": "cardNumberFormat",
            "baseName": "cardNumberFormat",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return SAConfigNotificationsMerchantNotifications.attributeTypeMap;
    }
}

export class SAConfigPaymentMethods {
    'enabledPaymentMethods'?: Array<SAConfigPaymentMethods.EnabledPaymentMethodsEnum>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "enabledPaymentMethods",
            "baseName": "enabledPaymentMethods",
            "type": "Array<SAConfigPaymentMethods.EnabledPaymentMethodsEnum>"
        }    ];

    static getAttributeTypeMap() {
        return SAConfigPaymentMethods.attributeTypeMap;
    }
}

export namespace SAConfigPaymentMethods {
    export enum EnabledPaymentMethodsEnum {
        CARD = <any> 'CARD',
        ECHECK = <any> 'ECHECK',
        VISACHECKOUT = <any> 'VISACHECKOUT',
        PAYPAL = <any> 'PAYPAL'
    }
}
/**
* Object containing Payment Types supported
*/
export class SAConfigPaymentTypes {
    'cardTypes'?: SAConfigPaymentTypesCardTypes;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "cardTypes",
            "baseName": "cardTypes",
            "type": "SAConfigPaymentTypesCardTypes"
        }    ];

    static getAttributeTypeMap() {
        return SAConfigPaymentTypes.attributeTypeMap;
    }
}

export class SAConfigPaymentTypesCardTypes {
    'discover'?: SAConfigPaymentTypesCardTypesDiscover;
    'amex'?: SAConfigPaymentTypesCardTypesDiscover;
    'masterCard'?: SAConfigPaymentTypesCardTypesDiscover;
    'visa'?: SAConfigPaymentTypesCardTypesDiscover;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "discover",
            "baseName": "discover",
            "type": "SAConfigPaymentTypesCardTypesDiscover"
        },
        {
            "name": "amex",
            "baseName": "amex",
            "type": "SAConfigPaymentTypesCardTypesDiscover"
        },
        {
            "name": "masterCard",
            "baseName": "masterCard",
            "type": "SAConfigPaymentTypesCardTypesDiscover"
        },
        {
            "name": "visa",
            "baseName": "visa",
            "type": "SAConfigPaymentTypesCardTypesDiscover"
        }    ];

    static getAttributeTypeMap() {
        return SAConfigPaymentTypesCardTypes.attributeTypeMap;
    }
}

/**
* Object containing supported Card Types and settings
*/
export class SAConfigPaymentTypesCardTypesDiscover {
    /**
    * Dictates whether or Card Verification Number is supported by the card type. Usually this is set at system level.
    */
    'cardVerificationNumberSupported'?: boolean;
    /**
    * Toggles whether or Card Verification Number is displayed on the Hosted Checkout.
    */
    'cardVerificationNumberDisplay'?: boolean;
    /**
    * Dictates whether or Payer Authentication is supported by the card type. Usually this is set at system level.
    */
    'payerAuthenticationSupported'?: boolean;
    /**
    * Array of the supported  ISO 4217 alphabetic currency codes.
    */
    'supportedCurrencies'?: Array<string>;
    'method'?: string;
    'cardVerificationNumberRequired'?: boolean;
    'payerAuthenticationEnabled'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "cardVerificationNumberSupported",
            "baseName": "cardVerificationNumberSupported",
            "type": "boolean"
        },
        {
            "name": "cardVerificationNumberDisplay",
            "baseName": "cardVerificationNumberDisplay",
            "type": "boolean"
        },
        {
            "name": "payerAuthenticationSupported",
            "baseName": "payerAuthenticationSupported",
            "type": "boolean"
        },
        {
            "name": "supportedCurrencies",
            "baseName": "supportedCurrencies",
            "type": "Array<string>"
        },
        {
            "name": "method",
            "baseName": "method",
            "type": "string"
        },
        {
            "name": "cardVerificationNumberRequired",
            "baseName": "cardVerificationNumberRequired",
            "type": "boolean"
        },
        {
            "name": "payerAuthenticationEnabled",
            "baseName": "payerAuthenticationEnabled",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return SAConfigPaymentTypesCardTypesDiscover.attributeTypeMap;
    }
}

export class SAConfigService {
    /**
    * Toggles whether verbose Decision Manager results should be present in the Secure Acceptance response. As this response passes through the browser, it is recommended to set this to \"false\" outside of debugging.
    */
    'decisionManagerVerboseEnabled'?: boolean;
    /**
    * Defines the number of retries a payer is presented with on payment declines on Hosted Checkout. Valid values are between 0 and 5.
    */
    'declinedRetryLimit'?: number;
    /**
    * Toggles whether Decision Manager is enabled or not for Secure Acceptance transactions. Requires the transacting MID to be enabled and configured for Decicion Manager.
    */
    'decisionManagerEnabled'?: boolean;
    /**
    * Toggles whether Tokenization is enabled or not for Secure Acceptance transactions. Requires the transacting MID to be enabled and configured for Tokenization.
    */
    'tokenizationEnabled'?: boolean;
    /**
    * Toggles whether or not an approved Authorization that fails AVS should be automatically reversed.
    */
    'reverseAuthOnAddressVerificationSystemFailure'?: boolean;
    /**
    * Toggles whether or not fraud Device Fingerprinting is enabled on the Hosted Checkout. This simplifies enablement for Decision Manager.
    */
    'deviceFingerprintEnabled'?: boolean;
    /**
    * Toggles whether or not an approved Authorization that fails CVN check that should be automatically reversed.
    */
    'reverseAuthOnCardVerificationNumberFailure'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "decisionManagerVerboseEnabled",
            "baseName": "decisionManagerVerboseEnabled",
            "type": "boolean"
        },
        {
            "name": "declinedRetryLimit",
            "baseName": "declinedRetryLimit",
            "type": "number"
        },
        {
            "name": "decisionManagerEnabled",
            "baseName": "decisionManagerEnabled",
            "type": "boolean"
        },
        {
            "name": "tokenizationEnabled",
            "baseName": "tokenizationEnabled",
            "type": "boolean"
        },
        {
            "name": "reverseAuthOnAddressVerificationSystemFailure",
            "baseName": "reverseAuthOnAddressVerificationSystemFailure",
            "type": "boolean"
        },
        {
            "name": "deviceFingerprintEnabled",
            "baseName": "deviceFingerprintEnabled",
            "type": "boolean"
        },
        {
            "name": "reverseAuthOnCardVerificationNumberFailure",
            "baseName": "reverseAuthOnCardVerificationNumberFailure",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return SAConfigService.attributeTypeMap;
    }
}

export class SaveAsymEgressKey {
    'clientReferenceInformation'?: Kmsegressv2keysasymClientReferenceInformation;
    /**
    * Client request action. 
    */
    'clientRequestAction'?: string;
    'keyInformation'?: Kmsegressv2keysasymKeyInformation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "clientReferenceInformation",
            "baseName": "clientReferenceInformation",
            "type": "Kmsegressv2keysasymClientReferenceInformation"
        },
        {
            "name": "clientRequestAction",
            "baseName": "clientRequestAction",
            "type": "string"
        },
        {
            "name": "keyInformation",
            "baseName": "keyInformation",
            "type": "Kmsegressv2keysasymKeyInformation"
        }    ];

    static getAttributeTypeMap() {
        return SaveAsymEgressKey.attributeTypeMap;
    }
}

export class SaveSymEgressKey {
    'clientReferenceInformation'?: Kmsegressv2keyssymClientReferenceInformation;
    /**
    * Client request action. 
    */
    'clientRequestAction'?: string;
    'keyInformation'?: Kmsegressv2keyssymKeyInformation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "clientReferenceInformation",
            "baseName": "clientReferenceInformation",
            "type": "Kmsegressv2keyssymClientReferenceInformation"
        },
        {
            "name": "clientRequestAction",
            "baseName": "clientRequestAction",
            "type": "string"
        },
        {
            "name": "keyInformation",
            "baseName": "keyInformation",
            "type": "Kmsegressv2keyssymKeyInformation"
        }    ];

    static getAttributeTypeMap() {
        return SaveSymEgressKey.attributeTypeMap;
    }
}

export class SearchRequest {
    /**
    * This is the orgId of the organization which the user belongs to.
    */
    'organizationId'?: string;
    /**
    * User ID of the user you want to get details on.
    */
    'userName'?: string;
    /**
    * role of the user you are trying to search on.
    */
    'roleId'?: string;
    /**
    * permission that you are trying to search user on.
    */
    'permissionId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "organizationId",
            "baseName": "organizationId",
            "type": "string"
        },
        {
            "name": "userName",
            "baseName": "userName",
            "type": "string"
        },
        {
            "name": "roleId",
            "baseName": "roleId",
            "type": "string"
        },
        {
            "name": "permissionId",
            "baseName": "permissionId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return SearchRequest.attributeTypeMap;
    }
}

/**
* A paginated container of Shipping Addresses. 
*/
export class ShippingAddressListForCustomer {
    'links'?: ShippingAddressListForCustomerLinks;
    /**
    * The offset parameter supplied in the request.
    */
    'offset'?: number;
    /**
    * The limit parameter supplied in the request.
    */
    'limit'?: number;
    /**
    * The number of Shipping Addresses returned in the array.
    */
    'count'?: number;
    /**
    * The total number of Shipping Addresses associated with the Customer.
    */
    'total'?: number;
    'embedded'?: ShippingAddressListForCustomerEmbedded;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "ShippingAddressListForCustomerLinks"
        },
        {
            "name": "offset",
            "baseName": "offset",
            "type": "number"
        },
        {
            "name": "limit",
            "baseName": "limit",
            "type": "number"
        },
        {
            "name": "count",
            "baseName": "count",
            "type": "number"
        },
        {
            "name": "total",
            "baseName": "total",
            "type": "number"
        },
        {
            "name": "embedded",
            "baseName": "_embedded",
            "type": "ShippingAddressListForCustomerEmbedded"
        }    ];

    static getAttributeTypeMap() {
        return ShippingAddressListForCustomer.attributeTypeMap;
    }
}

/**
* Shipping Address Resources. 
*/
export class ShippingAddressListForCustomerEmbedded {
    'shippingAddresses'?: Array<Tmsv2customersEmbeddedDefaultShippingAddress>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "shippingAddresses",
            "baseName": "shippingAddresses",
            "type": "Array<Tmsv2customersEmbeddedDefaultShippingAddress>"
        }    ];

    static getAttributeTypeMap() {
        return ShippingAddressListForCustomerEmbedded.attributeTypeMap;
    }
}

export class ShippingAddressListForCustomerLinks {
    'self'?: ShippingAddressListForCustomerLinksSelf;
    'first'?: ShippingAddressListForCustomerLinksFirst;
    'prev'?: ShippingAddressListForCustomerLinksPrev;
    'next'?: ShippingAddressListForCustomerLinksNext;
    'last'?: ShippingAddressListForCustomerLinksLast;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "self",
            "baseName": "self",
            "type": "ShippingAddressListForCustomerLinksSelf"
        },
        {
            "name": "first",
            "baseName": "first",
            "type": "ShippingAddressListForCustomerLinksFirst"
        },
        {
            "name": "prev",
            "baseName": "prev",
            "type": "ShippingAddressListForCustomerLinksPrev"
        },
        {
            "name": "next",
            "baseName": "next",
            "type": "ShippingAddressListForCustomerLinksNext"
        },
        {
            "name": "last",
            "baseName": "last",
            "type": "ShippingAddressListForCustomerLinksLast"
        }    ];

    static getAttributeTypeMap() {
        return ShippingAddressListForCustomerLinks.attributeTypeMap;
    }
}

export class ShippingAddressListForCustomerLinksFirst {
    /**
    * Link to the first page. 
    */
    'href'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "href",
            "baseName": "href",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ShippingAddressListForCustomerLinksFirst.attributeTypeMap;
    }
}

export class ShippingAddressListForCustomerLinksLast {
    /**
    * Link to the last page. 
    */
    'href'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "href",
            "baseName": "href",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ShippingAddressListForCustomerLinksLast.attributeTypeMap;
    }
}

export class ShippingAddressListForCustomerLinksNext {
    /**
    * Link to the next page. 
    */
    'href'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "href",
            "baseName": "href",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ShippingAddressListForCustomerLinksNext.attributeTypeMap;
    }
}

export class ShippingAddressListForCustomerLinksPrev {
    /**
    * Link to the previous page. 
    */
    'href'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "href",
            "baseName": "href",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ShippingAddressListForCustomerLinksPrev.attributeTypeMap;
    }
}

export class ShippingAddressListForCustomerLinksSelf {
    /**
    * Link to the current page. 
    */
    'href'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "href",
            "baseName": "href",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ShippingAddressListForCustomerLinksSelf.attributeTypeMap;
    }
}

export class SuspendSubscriptionResponse {
    'links'?: PtsV2IncrementalAuthorizationPatch201ResponseLinks;
    /**
    * An unique identification number generated by Cybersource to identify the submitted request. Returned by all services. It is also appended to the endpoint of the resource. On incremental authorizations, this value with be the same as the identification number returned in the original authorization response. 
    */
    'id'?: string;
    /**
    * Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ` **Example** `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.). The `T` separates the date and the time. The `Z` indicates UTC.  Returned by Cybersource for all services. 
    */
    'submitTimeUtc'?: string;
    /**
    * The status of the submitted transaction.  Possible values:  - ACCEPTED 
    */
    'status'?: string;
    'subscriptionInformation'?: SuspendSubscriptionResponseSubscriptionInformation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "PtsV2IncrementalAuthorizationPatch201ResponseLinks"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "submitTimeUtc",
            "baseName": "submitTimeUtc",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "subscriptionInformation",
            "baseName": "subscriptionInformation",
            "type": "SuspendSubscriptionResponseSubscriptionInformation"
        }    ];

    static getAttributeTypeMap() {
        return SuspendSubscriptionResponse.attributeTypeMap;
    }
}

export class SuspendSubscriptionResponseSubscriptionInformation {
    /**
    * Subscription code. 
    */
    'code'?: string;
    /**
    * Subscription Status: - `SUSPENDED` 
    */
    'status'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return SuspendSubscriptionResponseSubscriptionInformation.attributeTypeMap;
    }
}

export class TaxRequest {
    'clientReferenceInformation'?: Vasv2taxClientReferenceInformation;
    'taxInformation'?: Vasv2taxTaxInformation;
    'orderInformation'?: Vasv2taxOrderInformation;
    'merchantInformation'?: Vasv2taxMerchantInformation;
    'buyerInformation'?: Vasv2taxBuyerInformation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "clientReferenceInformation",
            "baseName": "clientReferenceInformation",
            "type": "Vasv2taxClientReferenceInformation"
        },
        {
            "name": "taxInformation",
            "baseName": "taxInformation",
            "type": "Vasv2taxTaxInformation"
        },
        {
            "name": "orderInformation",
            "baseName": "orderInformation",
            "type": "Vasv2taxOrderInformation"
        },
        {
            "name": "merchantInformation",
            "baseName": "merchantInformation",
            "type": "Vasv2taxMerchantInformation"
        },
        {
            "name": "buyerInformation",
            "baseName": "buyerInformation",
            "type": "Vasv2taxBuyerInformation"
        }    ];

    static getAttributeTypeMap() {
        return TaxRequest.attributeTypeMap;
    }
}

export class TmsAuthorizationOptions {
    'initiator'?: TmsAuthorizationOptionsInitiator;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "initiator",
            "baseName": "initiator",
            "type": "TmsAuthorizationOptionsInitiator"
        }    ];

    static getAttributeTypeMap() {
        return TmsAuthorizationOptions.attributeTypeMap;
    }
}

export class TmsAuthorizationOptionsInitiator {
    'merchantInitiatedTransaction'?: TmsAuthorizationOptionsInitiatorMerchantInitiatedTransaction;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "merchantInitiatedTransaction",
            "baseName": "merchantInitiatedTransaction",
            "type": "TmsAuthorizationOptionsInitiatorMerchantInitiatedTransaction"
        }    ];

    static getAttributeTypeMap() {
        return TmsAuthorizationOptionsInitiator.attributeTypeMap;
    }
}

export class TmsAuthorizationOptionsInitiatorMerchantInitiatedTransaction {
    /**
    * Network transaction identifier that was returned in the payment response field _processorInformation.transactionID_ in the reply message for either the original merchant-initiated payment in the series or the previous merchant-initiated payment in the series. 
    */
    'previousTransactionId'?: string;
    /**
    * Amount of the original authorization. 
    */
    'originalAuthorizedAmount'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "previousTransactionId",
            "baseName": "previousTransactionId",
            "type": "string"
        },
        {
            "name": "originalAuthorizedAmount",
            "baseName": "originalAuthorizedAmount",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TmsAuthorizationOptionsInitiatorMerchantInitiatedTransaction.attributeTypeMap;
    }
}

/**
* Bin Information of the PAN provided by BinLookUp Service. This is only retrieved when retrieveBinDetails=true is passed as a query parameter. 
*/
export class TmsBinLookup {
    'paymentAccountInformation'?: TmsBinLookupPaymentAccountInformation;
    'issuerInformation'?: TmsBinLookupIssuerInformation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "paymentAccountInformation",
            "baseName": "paymentAccountInformation",
            "type": "TmsBinLookupPaymentAccountInformation"
        },
        {
            "name": "issuerInformation",
            "baseName": "issuerInformation",
            "type": "TmsBinLookupIssuerInformation"
        }    ];

    static getAttributeTypeMap() {
        return TmsBinLookup.attributeTypeMap;
    }
}

export class TmsBinLookupIssuerInformation {
    /**
    * This field contains the issuer name. 
    */
    'name'?: string;
    /**
    * This field contains [2-character ISO Country Codes](http://apps.cybersource.com/library/documentation/sbc/quickref/countries_alpha_list.pdf) for the issuer. 
    */
    'country'?: string;
    /**
    * This field contains the length of the BIN. In some cases, this field may be absent if we do not receive accurate information from the network source. 
    */
    'binLength'?: string;
    /**
    * This field contains the first 6 to 8 digits of a primary account number (PAN). The length of the field is determined by [PCI-DSS standards for truncation](https://pcissc.secure.force.com/faq/articles/Frequently_Asked_Question/What-are-acceptable-formats-for-truncation-of-primary-account-numbers).In case the input is not the full intrument (PAN or TOKEN), this field may be truncated. 
    */
    'accountPrefix'?: string;
    /**
    * This field contains the customer service phone number for the issuer. 
    */
    'phoneNumber'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "country",
            "baseName": "country",
            "type": "string"
        },
        {
            "name": "binLength",
            "baseName": "binLength",
            "type": "string"
        },
        {
            "name": "accountPrefix",
            "baseName": "accountPrefix",
            "type": "string"
        },
        {
            "name": "phoneNumber",
            "baseName": "phoneNumber",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TmsBinLookupIssuerInformation.attributeTypeMap;
    }
}

export class TmsBinLookupPaymentAccountInformation {
    'card'?: TmsBinLookupPaymentAccountInformationCard;
    'features'?: TmsBinLookupPaymentAccountInformationFeatures;
    'network'?: TmsBinLookupPaymentAccountInformationNetwork;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "card",
            "baseName": "card",
            "type": "TmsBinLookupPaymentAccountInformationCard"
        },
        {
            "name": "features",
            "baseName": "features",
            "type": "TmsBinLookupPaymentAccountInformationFeatures"
        },
        {
            "name": "network",
            "baseName": "network",
            "type": "TmsBinLookupPaymentAccountInformationNetwork"
        }    ];

    static getAttributeTypeMap() {
        return TmsBinLookupPaymentAccountInformation.attributeTypeMap;
    }
}

export class TmsBinLookupPaymentAccountInformationCard {
    /**
    * This field contains a 3-digit numeric value that indicates the card type within Cybersource eco-system. Possible values from BIN Lookup Service (based on availability and enablement): - `000`: Unsupported Card Type - `001`: Visa - `002`: Mastercard - `003`: American Express - `004`: Discover - `005`: Diners Club - `007`: JCB - `036`: Cartes Bancaire - `042`: Maestro - `054`: Elo - `058`: Carnet - `060`: MADA - `061`: RuPay - `062`: China UnionPay - `064`: Prompt Card - `067`: Meeza - `068`: PayPak - `070`: EFTPOS - `081`: Jaywan - `082`: TPN  Glossary of possible values in the payments ecosystem: - `001`: Visa - `002`: Mastercard - `003`: American Express - `004`: Discover - `005`: Diners Club - `006`: Carte Blanche - `007`: JCB - `008`: Optima - `009`: GE Private Label - `010`: Beneficial Private Label - `011`: Twinpay Credit Card - `012`: Twinpay Debit Card - `013`: Walmart - `014`: EnRoute - `015`: Lowe's Consumer - `016`: Home Depot Consumer - `017`: MBNA - `018`: Dick's Sportwear - `019`: Casual Corner - `020`: Sears - `021`: JAL - `023`: Disney Card - `024`: Switch/Solo - `025`: Sam's Club Consumer - `026`: Sam's Club Business - `027`: Nico's - `028`: Paymentech Bill Me Later - `029`: Bebe - `030`: Restoration Hardware - `031`: Delta Online - `032`: Solo - `033`: Visa Electron - `034`: Dankort - `035`: Laser - `036`: Cartes Bancaire - `037`: Carta Si - `040`: UATP - `041`: HOUSEHOLD - `042`: Maestro - `043`: GE MONEY - `044`: Korean Cards - `045`: Style Cards - `046`: J.Crew - `047`: Payeasecn eWallet - `048`: Payeasecn Bank Transfer - `049`: Meijer - `050`: Hipercard - `051`: Aura - `052`: Redecard - `053`: Orico Card - `054`: Elo - `055`: Capital One Private Label - `057`: Costco Private Label - `058`: Carnet - `059`: ValueLink - `060`: MADA - `061`: RuPay - `062`: China UnionPay - `063`: Falabella Private Label - `064`: Prompt Card - `065`: Korean Domestic - `066`: Banricompras - `067`: Meeza - `068`: PayPak - `070`: EFTPOS - `071`: Codensa - `072`: Olimpica - `073`: Colsubsidio - `074`: Tuya - `075`: Sodexo - `076`: Naranja - `077`: Cabal - `078`: DINELCO - `079`: PANAL - `080`: EPM - `081`: Jaywan - `082`: TPN 
    */
    'type'?: string;
    /**
    * This field contains the card brand name.   Some of the possible values (not an exhaustive list) are -    - VISA   - MASTERCARD   - AMERICAN EXPRESS   - DISCOVER   - DINERS CLUB   - CARTE BLANCHE   - JCB   - OPTIMA   - TWINPAY CREDIT CARD   - TWINPAY DEBIT CARD   - WALMART   - ENROUTE   - LOWES CONSUMER   - HOME DEPOT CONSUMER   - MBNA   - DICKS SPORTWEAR   - CASUAL CORNER   - SEARS   - JAL   - DISNEY CARD   - SWITCH/SOLO   - SAMS CLUB CONSUMER   - SAMS CLUB BUSINESS   - NICOS HOUSE CARD   - BEBE   - RESTORATION HARDWARE   - DELTA ONLINE   - SOLO   - VISA ELECTRON   - DANKORT   - LASER   - CARTE BANCAIRE   - CARTA SI   - ENCODED ACCOUNT   - UATP   - HOUSEHOLD   - MAESTRO   - GE CAPITAL   - KOREAN CARDS   - STYLE CARDS   - JCREW   - MEIJER   - HIPERCARD   - AURA   - REDECARD   - ORICO HOUSE CARD   - MADA   - ELO   - CAPITAL ONE PRIVATE LABEL   - CARNET   - RUPAY   - CHINA UNION PAY   - FALABELLA PRIVATE LABEL   - PROMPTCARD   - KOREAN DOMESTIC   - BANRICOMPRAS   - MEEZA   - PAYPAK   - JAYWAN   - TPN 
    */
    'brandName'?: string;
    /**
    * This field indicates the 3-letter [ISO Standard Currency Codes](http://apps.cybersource.com/library/documentation/sbc/quickref/currencies.pdf) for the card currency. 
    */
    'currency'?: string;
    /**
    * This field contains the max length of the card. 
    */
    'maxLength'?: string;
    /**
    * This field contains the type of the payment credential. Possible values:   - PAN   - TOKEN  
    */
    'credentialType'?: string;
    /**
    * Array of brands
    */
    'brands'?: Array<TmsBinLookupPaymentAccountInformationCardBrands>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "brandName",
            "baseName": "brandName",
            "type": "string"
        },
        {
            "name": "currency",
            "baseName": "currency",
            "type": "string"
        },
        {
            "name": "maxLength",
            "baseName": "maxLength",
            "type": "string"
        },
        {
            "name": "credentialType",
            "baseName": "credentialType",
            "type": "string"
        },
        {
            "name": "brands",
            "baseName": "brands",
            "type": "Array<TmsBinLookupPaymentAccountInformationCardBrands>"
        }    ];

    static getAttributeTypeMap() {
        return TmsBinLookupPaymentAccountInformationCard.attributeTypeMap;
    }
}

export class TmsBinLookupPaymentAccountInformationCardBrands {
    /**
    * This field contains a 3-digit numeric value that indicates the card type within Cybersource eco-system. Possible values from BIN Lookup Service (based on availability and enablement): - `000`: Unsupported Card Type - `001`: Visa - `002`: Mastercard - `003`: American Express - `004`: Discover - `005`: Diners Club - `007`: JCB - `036`: Cartes Bancaire - `042`: Maestro - `054`: Elo - `058`: Carnet - `060`: MADA - `061`: RuPay - `062`: China UnionPay - `064`: Prompt Card - `067`: Meeza - `068`: PayPak - `070`: EFTPOS - `081`: Jaywan - `082`: TPN  Glossary of possible values in the payments ecosystem: - `001`: Visa - `002`: Mastercard - `003`: American Express - `004`: Discover - `005`: Diners Club - `006`: Carte Blanche - `007`: JCB - `008`: Optima - `009`: GE Private Label - `010`: Beneficial Private Label - `011`: Twinpay Credit Card - `012`: Twinpay Debit Card - `013`: Walmart - `014`: EnRoute - `015`: Lowe's Consumer - `016`: Home Depot Consumer - `017`: MBNA - `018`: Dick's Sportwear - `019`: Casual Corner - `020`: Sears - `021`: JAL - `023`: Disney Card - `024`: Switch/Solo - `025`: Sam's Club Consumer - `026`: Sam's Club Business - `027`: Nico's - `028`: Paymentech Bill Me Later - `029`: Bebe - `030`: Restoration Hardware - `031`: Delta Online - `032`: Solo - `033`: Visa Electron - `034`: Dankort - `035`: Laser - `036`: Cartes Bancaire - `037`: Carta Si - `040`: UATP - `041`: HOUSEHOLD - `042`: Maestro - `043`: GE MONEY - `044`: Korean Cards - `045`: Style Cards - `046`: J.Crew - `047`: Payeasecn eWallet - `048`: Payeasecn Bank Transfer - `049`: Meijer - `050`: Hipercard - `051`: Aura - `052`: Redecard - `053`: Orico Card - `054`: Elo - `055`: Capital One Private Label - `057`: Costco Private Label - `058`: Carnet - `059`: ValueLink - `060`: MADA - `061`: RuPay - `062`: China UnionPay - `063`: Falabella Private Label - `064`: Prompt Card - `065`: Korean Domestic - `066`: Banricompras - `067`: Meeza - `068`: PayPak - `070`: EFTPOS - `071`: Codensa - `072`: Olimpica - `073`: Colsubsidio - `074`: Tuya - `075`: Sodexo - `076`: Naranja - `077`: Cabal - `078`: DINELCO - `079`: PANAL - `080`: EPM - `081`: Jaywan - `082`: TPN 
    */
    'type'?: string;
    /**
    * This field contains the card brand name.   Some of the possible values (not an exhaustive list) are -    - VISA   - MASTERCARD   - AMERICAN EXPRESS   - DISCOVER   - DINERS CLUB   - CARTE BLANCHE   - JCB   - OPTIMA   - TWINPAY CREDIT CARD   - TWINPAY DEBIT CARD   - WALMART   - ENROUTE   - LOWES CONSUMER   - HOME DEPOT CONSUMER   - MBNA   - DICKS SPORTWEAR   - CASUAL CORNER   - SEARS   - JAL   - DISNEY CARD   - SWITCH/SOLO   - SAMS CLUB CONSUMER   - SAMS CLUB BUSINESS   - NICOS HOUSE CARD   - BEBE   - RESTORATION HARDWARE   - DELTA ONLINE   - SOLO   - VISA ELECTRON   - DANKORT   - LASER   - CARTE BANCAIRE   - CARTA SI   - ENCODED ACCOUNT   - UATP   - HOUSEHOLD   - MAESTRO   - GE CAPITAL   - KOREAN CARDS   - STYLE CARDS   - JCREW   - MEIJER   - HIPERCARD   - AURA   - REDECARD   - ORICO HOUSE CARD   - MADA   - ELO   - CAPITAL ONE PRIVATE LABEL   - CARNET   - RUPAY   - CHINA UNION PAY   - FALABELLA PRIVATE LABEL   - PROMPTCARD   - KOREAN DOMESTIC   - BANRICOMPRAS   - MEEZA   - PAYPAK   - JAYWAN   - TPN 
    */
    'brandName'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "brandName",
            "baseName": "brandName",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TmsBinLookupPaymentAccountInformationCardBrands.attributeTypeMap;
    }
}

export class TmsBinLookupPaymentAccountInformationFeatures {
    /**
    * This field contains the account funding source. Possible values:   - `CREDIT`   - `DEBIT`   - `PREPAID`   - `DEFERRED DEBIT`   - `CHARGE` 
    */
    'accountFundingSource'?: string;
    /**
    * This field contains the type of prepaid card. Possible values:   - `Reloadable`   - `Non-reloadable` 
    */
    'accountFundingSourceSubType'?: string;
    /**
    * This field contains the type of issuer product. Example values:   - Visa Classic   - Visa Signature   - Visa Infinite 
    */
    'cardProduct'?: string;
    /**
    * This field contains the type of BIN based authentication. Possible values:   - `S`: Single Message   - `D`: Dual Message 
    */
    'messageType'?: string;
    /**
    * This field contains the acceptance level of the PAN. Possible values:   - `0` : Normal   - `1` : Monitor   - `2` : Refuse   - `3` : Not Allowed   - `4` : Private   - `5` : Test 
    */
    'acceptanceLevel'?: string;
    /**
    * This field contains the type of card platform. Possible values:   - `BUSINESS`   - `CONSUMER`   - `CORPORATE`   - `COMMERCIAL`   - `GOVERNMENT` 
    */
    'cardPlatform'?: string;
    /**
    * This field indicates the type of combo card. Possible values:   - 0 (Not a combo card)   - 1 (Credit and Prepaid Combo card)   - 2 (Credit and Debit Combo card)   - 3 (Prepaid Credit and Prepaid Debit combo card) 
    */
    'comboCard'?: string;
    /**
    * This field indicates if the instrument can be used for corporate purchasing. This field is only applicable for American Express cards. Possible values:   - `true`   - `false` 
    */
    'corporatePurchase'?: boolean;
    /**
    * This field indicates if the BIN is for healthcare (HSA/FSA). Currently, this field is only supported for Visa BINs. Possible values:     - `true`     - `false` 
    */
    'healthCard'?: boolean;
    /**
    * This field indicates if the BIN is shared by multiple issuers Possible values:     - `true`     - `false` 
    */
    'sharedBIN'?: boolean;
    /**
    * This field indicates if the BIN is valid only for POS domestic usage. Possible values:     - `true`     - `false` 
    */
    'posDomesticOnly'?: boolean;
    /**
    * This field indicates if gambling transactions are allowed on the BIN. Possible values:     - `true`     - `false` 
    */
    'gamblingAllowed'?: boolean;
    /**
    * This field indicates if a transaction on the instrument qualifies for level 2 interchange rates. Possible values:     - `true`     - `false` 
    */
    'commercialCardLevel2'?: boolean;
    /**
    * This field indicates if a transaction on the instrument qualifies for level 3 interchange rates. Possible values:     - `true`     - `false` 
    */
    'commercialCardLevel3'?: boolean;
    /**
    * This field indicates if a transaction on the instrument qualifies for government exempt interchange fee. Possible values:     - `true`     - `false` 
    */
    'exemptBIN'?: boolean;
    /**
    * This field indicates if the BIN participates in Account Level Management (ALM). Possible values:     - `true`     - `false` 
    */
    'accountLevelManagement'?: boolean;
    /**
    * This field indicates if online gambling is blocked on the BIN. Possible values:     - `true`     - `false` 
    */
    'onlineGamblingBlock'?: boolean;
    /**
    * This field indicates if auto-substantiation is enabled on the BIN. Possible values:     - `true`     - `false` 
    */
    'autoSubstantiation'?: boolean;
    /**
    * This field indicates if the instrument is a flex credential. Possible values:     - `true`     - `false` 
    */
    'flexCredential'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "accountFundingSource",
            "baseName": "accountFundingSource",
            "type": "string"
        },
        {
            "name": "accountFundingSourceSubType",
            "baseName": "accountFundingSourceSubType",
            "type": "string"
        },
        {
            "name": "cardProduct",
            "baseName": "cardProduct",
            "type": "string"
        },
        {
            "name": "messageType",
            "baseName": "messageType",
            "type": "string"
        },
        {
            "name": "acceptanceLevel",
            "baseName": "acceptanceLevel",
            "type": "string"
        },
        {
            "name": "cardPlatform",
            "baseName": "cardPlatform",
            "type": "string"
        },
        {
            "name": "comboCard",
            "baseName": "comboCard",
            "type": "string"
        },
        {
            "name": "corporatePurchase",
            "baseName": "corporatePurchase",
            "type": "boolean"
        },
        {
            "name": "healthCard",
            "baseName": "healthCard",
            "type": "boolean"
        },
        {
            "name": "sharedBIN",
            "baseName": "sharedBIN",
            "type": "boolean"
        },
        {
            "name": "posDomesticOnly",
            "baseName": "posDomesticOnly",
            "type": "boolean"
        },
        {
            "name": "gamblingAllowed",
            "baseName": "gamblingAllowed",
            "type": "boolean"
        },
        {
            "name": "commercialCardLevel2",
            "baseName": "commercialCardLevel2",
            "type": "boolean"
        },
        {
            "name": "commercialCardLevel3",
            "baseName": "commercialCardLevel3",
            "type": "boolean"
        },
        {
            "name": "exemptBIN",
            "baseName": "exemptBIN",
            "type": "boolean"
        },
        {
            "name": "accountLevelManagement",
            "baseName": "accountLevelManagement",
            "type": "boolean"
        },
        {
            "name": "onlineGamblingBlock",
            "baseName": "onlineGamblingBlock",
            "type": "boolean"
        },
        {
            "name": "autoSubstantiation",
            "baseName": "autoSubstantiation",
            "type": "boolean"
        },
        {
            "name": "flexCredential",
            "baseName": "flexCredential",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return TmsBinLookupPaymentAccountInformationFeatures.attributeTypeMap;
    }
}

export class TmsBinLookupPaymentAccountInformationNetwork {
    /**
    * This field contains a code that identifies the network. [List of Network ID and Sharing Group Code](https://developer.visa.com/request_response_codes#network_id_and_sharing_group_code) 
    */
    'id'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TmsBinLookupPaymentAccountInformationNetwork.attributeTypeMap;
    }
}

export class TmsBusinessInformation {
    /**
    * Name of the network token merchant.
    */
    'name'?: string;
    /**
    * Name the network token merchant does business as
    */
    'doingBusinessAs'?: string;
    'address'?: TmsBusinessInformationAddress;
    /**
    * Website of network token merchant.
    */
    'websiteUrl'?: string;
    /**
    * The Identifier associated with the business type; required unless both acquirerId and acquirerMerchantId are provided. 
    */
    'businessIdentificationType'?: string;
    /**
    * The value associated with the business identifier type; required unless both acquirerId and acquirerMerchantId are provided. 
    */
    'businessIdentificationValue'?: string;
    'acquirer'?: TmsBusinessInformationAcquirer;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "doingBusinessAs",
            "baseName": "doingBusinessAs",
            "type": "string"
        },
        {
            "name": "address",
            "baseName": "address",
            "type": "TmsBusinessInformationAddress"
        },
        {
            "name": "websiteUrl",
            "baseName": "websiteUrl",
            "type": "string"
        },
        {
            "name": "businessIdentificationType",
            "baseName": "businessIdentificationType",
            "type": "string"
        },
        {
            "name": "businessIdentificationValue",
            "baseName": "businessIdentificationValue",
            "type": "string"
        },
        {
            "name": "acquirer",
            "baseName": "acquirer",
            "type": "TmsBusinessInformationAcquirer"
        }    ];

    static getAttributeTypeMap() {
        return TmsBusinessInformation.attributeTypeMap;
    }
}

export class TmsBusinessInformationAcquirer {
    /**
    * Acquirer ID; required unless both businessIdentificationType and businessIdentificationValue are provided. 
    */
    'acquirerId'?: string;
    /**
    * Acquirer merchant ID; required unless both businessIdentificationType and businessIdentificationValue are provided. 
    */
    'acquirerMerchantId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "acquirerId",
            "baseName": "acquirerId",
            "type": "string"
        },
        {
            "name": "acquirerMerchantId",
            "baseName": "acquirerMerchantId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TmsBusinessInformationAcquirer.attributeTypeMap;
    }
}

export class TmsBusinessInformationAddress {
    /**
    * Country of network token merchant.
    */
    'country'?: string;
    /**
    * City of network token merchant.
    */
    'locality'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "country",
            "baseName": "country",
            "type": "string"
        },
        {
            "name": "locality",
            "baseName": "locality",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TmsBusinessInformationAddress.attributeTypeMap;
    }
}

/**
* Card art associated with the tokenized card. 
*/
export class TmsCardArt {
    /**
    * Card foreground color. 
    */
    'foregroundColor'?: string;
    'combinedAsset'?: TmsCardArtCombinedAsset;
    'brandLogoAsset'?: TmsCardArtBrandLogoAsset;
    'issuerLogoAsset'?: TmsCardArtIssuerLogoAsset;
    'iconAsset'?: TmsCardArtIconAsset;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "foregroundColor",
            "baseName": "foregroundColor",
            "type": "string"
        },
        {
            "name": "combinedAsset",
            "baseName": "combinedAsset",
            "type": "TmsCardArtCombinedAsset"
        },
        {
            "name": "brandLogoAsset",
            "baseName": "brandLogoAsset",
            "type": "TmsCardArtBrandLogoAsset"
        },
        {
            "name": "issuerLogoAsset",
            "baseName": "issuerLogoAsset",
            "type": "TmsCardArtIssuerLogoAsset"
        },
        {
            "name": "iconAsset",
            "baseName": "iconAsset",
            "type": "TmsCardArtIconAsset"
        }    ];

    static getAttributeTypeMap() {
        return TmsCardArt.attributeTypeMap;
    }
}

/**
* Brand logo card art asset associated with the tokenized card. 
*/
export class TmsCardArtBrandLogoAsset {
    /**
    * Unique identifier for the asset 
    */
    'id'?: string;
    'links'?: TmsCardArtBrandLogoAssetLinks;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "links",
            "baseName": "_links",
            "type": "TmsCardArtBrandLogoAssetLinks"
        }    ];

    static getAttributeTypeMap() {
        return TmsCardArtBrandLogoAsset.attributeTypeMap;
    }
}

export class TmsCardArtBrandLogoAssetLinks {
    'self'?: TmsCardArtBrandLogoAssetLinksSelf;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "self",
            "baseName": "self",
            "type": "TmsCardArtBrandLogoAssetLinksSelf"
        }    ];

    static getAttributeTypeMap() {
        return TmsCardArtBrandLogoAssetLinks.attributeTypeMap;
    }
}

export class TmsCardArtBrandLogoAssetLinksSelf {
    /**
    * Link to the card art asset. example: 'tms/v2/tokens/7020000000010603216/visa/assets/brand-logo' 
    */
    'href'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "href",
            "baseName": "href",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TmsCardArtBrandLogoAssetLinksSelf.attributeTypeMap;
    }
}

/**
* Combined card art asset associated with the tokenized card. 
*/
export class TmsCardArtCombinedAsset {
    /**
    * Unique identifier for the asset 
    */
    'id'?: string;
    'links'?: TmsCardArtCombinedAssetLinks;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "links",
            "baseName": "_links",
            "type": "TmsCardArtCombinedAssetLinks"
        }    ];

    static getAttributeTypeMap() {
        return TmsCardArtCombinedAsset.attributeTypeMap;
    }
}

export class TmsCardArtCombinedAssetLinks {
    'self'?: TmsCardArtCombinedAssetLinksSelf;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "self",
            "baseName": "self",
            "type": "TmsCardArtCombinedAssetLinksSelf"
        }    ];

    static getAttributeTypeMap() {
        return TmsCardArtCombinedAssetLinks.attributeTypeMap;
    }
}

export class TmsCardArtCombinedAssetLinksSelf {
    /**
    * Link to the card art asset. example: 'tms/v2/tokens/7020000000010603216/visa/assets/card-art-combined' 
    */
    'href'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "href",
            "baseName": "href",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TmsCardArtCombinedAssetLinksSelf.attributeTypeMap;
    }
}

/**
* Icon card art asset associated with the tokenized card. 
*/
export class TmsCardArtIconAsset {
    /**
    * Unique identifier for the asset 
    */
    'id'?: string;
    'links'?: TmsCardArtIconAssetLinks;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "links",
            "baseName": "_links",
            "type": "TmsCardArtIconAssetLinks"
        }    ];

    static getAttributeTypeMap() {
        return TmsCardArtIconAsset.attributeTypeMap;
    }
}

export class TmsCardArtIconAssetLinks {
    'self'?: TmsCardArtIconAssetLinksSelf;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "self",
            "baseName": "self",
            "type": "TmsCardArtIconAssetLinksSelf"
        }    ];

    static getAttributeTypeMap() {
        return TmsCardArtIconAssetLinks.attributeTypeMap;
    }
}

export class TmsCardArtIconAssetLinksSelf {
    /**
    * Link to the card art asset. example: 'tms/v2/tokens/7020000000010603216/visa/assets/icon' 
    */
    'href'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "href",
            "baseName": "href",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TmsCardArtIconAssetLinksSelf.attributeTypeMap;
    }
}

/**
* Issuer logo card art asset associated with the tokenized card. 
*/
export class TmsCardArtIssuerLogoAsset {
    /**
    * Unique identifier for the asset 
    */
    'id'?: string;
    'links'?: TmsCardArtIssuerLogoAssetLinks;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "links",
            "baseName": "_links",
            "type": "TmsCardArtIssuerLogoAssetLinks"
        }    ];

    static getAttributeTypeMap() {
        return TmsCardArtIssuerLogoAsset.attributeTypeMap;
    }
}

export class TmsCardArtIssuerLogoAssetLinks {
    'self'?: TmsCardArtIssuerLogoAssetLinksSelf;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "self",
            "baseName": "self",
            "type": "TmsCardArtIssuerLogoAssetLinksSelf"
        }    ];

    static getAttributeTypeMap() {
        return TmsCardArtIssuerLogoAssetLinks.attributeTypeMap;
    }
}

export class TmsCardArtIssuerLogoAssetLinksSelf {
    /**
    * Link to the card art asset. example: 'tms/v2/tokens/7020000000010603216/visa/assets/issuer-logo' 
    */
    'href'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "href",
            "baseName": "href",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TmsCardArtIssuerLogoAssetLinksSelf.attributeTypeMap;
    }
}

export class TmsEmbeddedInstrumentIdentifier {
    'links'?: TmsEmbeddedInstrumentIdentifierLinks;
    /**
    * The Id of the Instrument Identifier Token. 
    */
    'id'?: string;
    /**
    * The type.  Possible Values: - instrumentIdentifier 
    */
    'object'?: string;
    /**
    * Issuers state for the card number. Possible Values: - ACTIVE - CLOSED : The account has been closed. 
    */
    'state'?: string;
    /**
    * The type of Instrument Identifier. Possible Values: - enrollable card - enrollable token 
    */
    'type'?: string;
    'tokenProvisioningInformation'?: Ptsv2paymentsTokenInformationTokenProvisioningInformation;
    'card'?: TmsEmbeddedInstrumentIdentifierCard;
    'bankAccount'?: TmsEmbeddedInstrumentIdentifierBankAccount;
    'tokenizedCard'?: Tmsv2TokenizedCard;
    'issuer'?: TmsEmbeddedInstrumentIdentifierIssuer;
    'processingInformation'?: TmsEmbeddedInstrumentIdentifierProcessingInformation;
    'billTo'?: TmsEmbeddedInstrumentIdentifierBillTo;
    'metadata'?: TmsEmbeddedInstrumentIdentifierMetadata;
    'embedded'?: TmsEmbeddedInstrumentIdentifierEmbedded;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "TmsEmbeddedInstrumentIdentifierLinks"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "object",
            "baseName": "object",
            "type": "string"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "tokenProvisioningInformation",
            "baseName": "tokenProvisioningInformation",
            "type": "Ptsv2paymentsTokenInformationTokenProvisioningInformation"
        },
        {
            "name": "card",
            "baseName": "card",
            "type": "TmsEmbeddedInstrumentIdentifierCard"
        },
        {
            "name": "bankAccount",
            "baseName": "bankAccount",
            "type": "TmsEmbeddedInstrumentIdentifierBankAccount"
        },
        {
            "name": "tokenizedCard",
            "baseName": "tokenizedCard",
            "type": "Tmsv2TokenizedCard"
        },
        {
            "name": "issuer",
            "baseName": "issuer",
            "type": "TmsEmbeddedInstrumentIdentifierIssuer"
        },
        {
            "name": "processingInformation",
            "baseName": "processingInformation",
            "type": "TmsEmbeddedInstrumentIdentifierProcessingInformation"
        },
        {
            "name": "billTo",
            "baseName": "billTo",
            "type": "TmsEmbeddedInstrumentIdentifierBillTo"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "TmsEmbeddedInstrumentIdentifierMetadata"
        },
        {
            "name": "embedded",
            "baseName": "_embedded",
            "type": "TmsEmbeddedInstrumentIdentifierEmbedded"
        }    ];

    static getAttributeTypeMap() {
        return TmsEmbeddedInstrumentIdentifier.attributeTypeMap;
    }
}

export class TmsEmbeddedInstrumentIdentifierBankAccount {
    /**
    * Account number.  When processing encoded account numbers, use this field for the encoded account number. 
    */
    'number'?: string;
    /**
    * Bank routing number. This is also called the transit number.  # For details, see `ecp_rdfi` field description in the [Electronic Check Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/EChecks_SCMP_API/html/) 
    */
    'routingNumber'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "number",
            "baseName": "number",
            "type": "string"
        },
        {
            "name": "routingNumber",
            "baseName": "routingNumber",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TmsEmbeddedInstrumentIdentifierBankAccount.attributeTypeMap;
    }
}

/**
* This information is sent to the issuer as part of network token enrollment and is not stored under the Instrument Identifier. 
*/
export class TmsEmbeddedInstrumentIdentifierBillTo {
    /**
    * Payment card billing street address as it appears on the credit card issuer’s records. 
    */
    'address1'?: string;
    /**
    * Additional address information. 
    */
    'address2'?: string;
    /**
    * Payment card billing city. 
    */
    'locality'?: string;
    /**
    * State or province of the billing address. Use the State, Province, and Territory Codes for the United States and Canada. 
    */
    'administrativeArea'?: string;
    /**
    * Postal code for the billing address. The postal code must consist of 5 to 9 digits.  When the billing country is the U.S., the 9-digit postal code must follow this format: [5 digits][dash][4 digits]  **Example** `12345-6789`  When the billing country is Canada, the 6-digit postal code must follow this format: [alpha][numeric][alpha][space][numeric][alpha][numeric]  **Example** `A1B 2C3` 
    */
    'postalCode'?: string;
    /**
    * Payment card billing country. Use the two-character ISO Standard Country Codes. 
    */
    'country'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "address1",
            "baseName": "address1",
            "type": "string"
        },
        {
            "name": "address2",
            "baseName": "address2",
            "type": "string"
        },
        {
            "name": "locality",
            "baseName": "locality",
            "type": "string"
        },
        {
            "name": "administrativeArea",
            "baseName": "administrativeArea",
            "type": "string"
        },
        {
            "name": "postalCode",
            "baseName": "postalCode",
            "type": "string"
        },
        {
            "name": "country",
            "baseName": "country",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TmsEmbeddedInstrumentIdentifierBillTo.attributeTypeMap;
    }
}

/**
* The expirationMonth, expirationYear and securityCode is sent to the issuer as part of network token enrollment and is not stored under the Instrument Identifier. 
*/
export class TmsEmbeddedInstrumentIdentifierCard {
    /**
    * The customer’s payment card number, also known as the Primary Account Number (PAN). You can also use this field for encoded account numbers. 
    */
    'number'?: string;
    /**
    * Two-digit month in which the payment card expires.  Format: `MM`.  Possible Values: `01` through `12`. 
    */
    'expirationMonth'?: string;
    /**
    * Four-digit year in which the credit card expires.  Format: `YYYY`. 
    */
    'expirationYear'?: string;
    /**
    * Card Verification Code.  This value is sent to the issuer to support the approval of a network token provision. It is not persisted against the Instrument Identifier. 
    */
    'securityCode'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "number",
            "baseName": "number",
            "type": "string"
        },
        {
            "name": "expirationMonth",
            "baseName": "expirationMonth",
            "type": "string"
        },
        {
            "name": "expirationYear",
            "baseName": "expirationYear",
            "type": "string"
        },
        {
            "name": "securityCode",
            "baseName": "securityCode",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TmsEmbeddedInstrumentIdentifierCard.attributeTypeMap;
    }
}

export class TmsEmbeddedInstrumentIdentifierEmbedded {
    'binLookup'?: TmsBinLookup;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "binLookup",
            "baseName": "binLookup",
            "type": "TmsBinLookup"
        }    ];

    static getAttributeTypeMap() {
        return TmsEmbeddedInstrumentIdentifierEmbedded.attributeTypeMap;
    }
}

export class TmsEmbeddedInstrumentIdentifierIssuer {
    /**
    * This reference number serves as a link to the cardholder account and to all transactions for that account. 
    */
    'paymentAccountReference'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "paymentAccountReference",
            "baseName": "paymentAccountReference",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TmsEmbeddedInstrumentIdentifierIssuer.attributeTypeMap;
    }
}

export class TmsEmbeddedInstrumentIdentifierLinks {
    'self'?: TmsEmbeddedInstrumentIdentifierLinksSelf;
    'paymentInstruments'?: TmsEmbeddedInstrumentIdentifierLinksPaymentInstruments;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "self",
            "baseName": "self",
            "type": "TmsEmbeddedInstrumentIdentifierLinksSelf"
        },
        {
            "name": "paymentInstruments",
            "baseName": "paymentInstruments",
            "type": "TmsEmbeddedInstrumentIdentifierLinksPaymentInstruments"
        }    ];

    static getAttributeTypeMap() {
        return TmsEmbeddedInstrumentIdentifierLinks.attributeTypeMap;
    }
}

export class TmsEmbeddedInstrumentIdentifierLinksPaymentInstruments {
    /**
    * Link to the Instrument Identifiers Payment Instruments. 
    */
    'href'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "href",
            "baseName": "href",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TmsEmbeddedInstrumentIdentifierLinksPaymentInstruments.attributeTypeMap;
    }
}

export class TmsEmbeddedInstrumentIdentifierLinksSelf {
    /**
    * Link to the Instrument Identifier. 
    */
    'href'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "href",
            "baseName": "href",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TmsEmbeddedInstrumentIdentifierLinksSelf.attributeTypeMap;
    }
}

export class TmsEmbeddedInstrumentIdentifierMetadata {
    /**
    * The creator of the Instrument Identifier.
    */
    'creator'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "creator",
            "baseName": "creator",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TmsEmbeddedInstrumentIdentifierMetadata.attributeTypeMap;
    }
}

export class TmsEmbeddedInstrumentIdentifierProcessingInformation {
    'authorizationOptions'?: TmsAuthorizationOptions;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "authorizationOptions",
            "baseName": "authorizationOptions",
            "type": "TmsAuthorizationOptions"
        }    ];

    static getAttributeTypeMap() {
        return TmsEmbeddedInstrumentIdentifierProcessingInformation.attributeTypeMap;
    }
}

export class TmsNetworkTokenServices {
    'notifications'?: TmsNetworkTokenServicesNotifications;
    'paymentCredentials'?: TmsNetworkTokenServicesPaymentCredentials;
    'synchronousProvisioning'?: TmsNetworkTokenServicesSynchronousProvisioning;
    'visaTokenService'?: TmsNetworkTokenServicesVisaTokenService;
    'mastercardDigitalEnablementService'?: TmsNetworkTokenServicesMastercardDigitalEnablementService;
    'americanExpressTokenService'?: TmsNetworkTokenServicesAmericanExpressTokenService;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "notifications",
            "baseName": "notifications",
            "type": "TmsNetworkTokenServicesNotifications"
        },
        {
            "name": "paymentCredentials",
            "baseName": "paymentCredentials",
            "type": "TmsNetworkTokenServicesPaymentCredentials"
        },
        {
            "name": "synchronousProvisioning",
            "baseName": "synchronousProvisioning",
            "type": "TmsNetworkTokenServicesSynchronousProvisioning"
        },
        {
            "name": "visaTokenService",
            "baseName": "visaTokenService",
            "type": "TmsNetworkTokenServicesVisaTokenService"
        },
        {
            "name": "mastercardDigitalEnablementService",
            "baseName": "mastercardDigitalEnablementService",
            "type": "TmsNetworkTokenServicesMastercardDigitalEnablementService"
        },
        {
            "name": "americanExpressTokenService",
            "baseName": "americanExpressTokenService",
            "type": "TmsNetworkTokenServicesAmericanExpressTokenService"
        }    ];

    static getAttributeTypeMap() {
        return TmsNetworkTokenServices.attributeTypeMap;
    }
}

export class TmsNetworkTokenServicesAmericanExpressTokenService {
    /**
    * Indicates if the service for network tokens for the American Express card association are enabled
    */
    'enableService'?: boolean;
    /**
    * Indicates if network tokens for the American Express card association are enabled for transactions
    */
    'enableTransactionalTokens'?: boolean;
    /**
    * Token Requestor ID provided by American Express during the registration process for the Tokenization Service  Pattern: ^[0-9]{11}\\\\z$\" Min Length: 11 Max Length: 11 Example: \"12345678912\" 
    */
    'tokenRequestorId'?: string;
    /**
    * SE Number assigned by American Express for the merchant's account  Pattern: \"^[0-9]{11}\\\\z$\" Min Length: 10 Max Length: 10 Example: \"9876543212\" 
    */
    'seNumber'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "enableService",
            "baseName": "enableService",
            "type": "boolean"
        },
        {
            "name": "enableTransactionalTokens",
            "baseName": "enableTransactionalTokens",
            "type": "boolean"
        },
        {
            "name": "tokenRequestorId",
            "baseName": "tokenRequestorId",
            "type": "string"
        },
        {
            "name": "seNumber",
            "baseName": "seNumber",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TmsNetworkTokenServicesAmericanExpressTokenService.attributeTypeMap;
    }
}

export class TmsNetworkTokenServicesMastercardDigitalEnablementService {
    /**
    * Indicates if the service for network tokens for the Mastercard card association are enabled
    */
    'enableService'?: boolean;
    /**
    * Indicates if network tokens for the Mastercard card association are enabled for transactions
    */
    'enableTransactionalTokens'?: boolean;
    /**
    * Token Requestor ID provided by Mastercard during the registration process for the Tokenization Service  Pattern: ^[0-9]{11}\\\\z$\" Min Length: 11 Max Length: 11 Example:  \"50162233570\" 
    */
    'tokenRequestorId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "enableService",
            "baseName": "enableService",
            "type": "boolean"
        },
        {
            "name": "enableTransactionalTokens",
            "baseName": "enableTransactionalTokens",
            "type": "boolean"
        },
        {
            "name": "tokenRequestorId",
            "baseName": "tokenRequestorId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TmsNetworkTokenServicesMastercardDigitalEnablementService.attributeTypeMap;
    }
}

export class TmsNetworkTokenServicesNotifications {
    /**
    * Indicates if lifecycle management (LCM) notifications are enabled
    */
    'enabled'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "enabled",
            "baseName": "enabled",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return TmsNetworkTokenServicesNotifications.attributeTypeMap;
    }
}

export class TmsNetworkTokenServicesPaymentCredentials {
    /**
    * Indicates if Payment Credentials are enabled. If enabled, this provides access to the unredacted token and its associated cryptogram.
    */
    'enabled'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "enabled",
            "baseName": "enabled",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return TmsNetworkTokenServicesPaymentCredentials.attributeTypeMap;
    }
}

export class TmsNetworkTokenServicesSynchronousProvisioning {
    /**
    * Indicates if network tokens are provisioned synchronously (i.e. as part of the transaction flow) or asychronously (i.e. in parallel to the payment flow)  NOTE: The synchronous provisioning feature is designed exclusively for aggregator merchants.  Direct merchants should not enable synchronous provisioning as TMS manages the asynchronous creation of network tokens for direct clients.   Activation of this feature by direct merchants will lead to latency in the authorization response. 
    */
    'enabled'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "enabled",
            "baseName": "enabled",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return TmsNetworkTokenServicesSynchronousProvisioning.attributeTypeMap;
    }
}

export class TmsNetworkTokenServicesVisaTokenService {
    /**
    * Indicates if the service for network tokens for the Visa card association are enabled
    */
    'enableService'?: boolean;
    /**
    * Indicates if network tokens for the Visa card association are enabled for transactions
    */
    'enableTransactionalTokens'?: boolean;
    /**
    * Token Requestor ID provided by Visa during the registration process for the Tokenization Service  Pattern: ^[0-9]{11}\\\\z$\" Min Length: 11 Max Length: 11 Example:  \"40000000082\" 
    */
    'tokenRequestorId'?: string;
    /**
    * Relationship ID provided by visa  Min Length: 1 Max Length: 100 Example: \"24681921-40000000082\" 
    */
    'relationshipId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "enableService",
            "baseName": "enableService",
            "type": "boolean"
        },
        {
            "name": "enableTransactionalTokens",
            "baseName": "enableTransactionalTokens",
            "type": "boolean"
        },
        {
            "name": "tokenRequestorId",
            "baseName": "tokenRequestorId",
            "type": "string"
        },
        {
            "name": "relationshipId",
            "baseName": "relationshipId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TmsNetworkTokenServicesVisaTokenService.attributeTypeMap;
    }
}

export class TmsNullify {
    /**
    * Indicates if the card number should be nullified (i.e. not stored)
    */
    'instrumentIdentifierCardNumber'?: boolean;
    /**
    * Indicates if the expiration date associated to the instrument identifier should be nullified (i.e. not stored)
    */
    'instrumentIdentifierCardExpiration'?: boolean;
    /**
    * Indicates if the card details should be nullified (i.e. not stored)
    */
    'paymentInstrumentCardDetails'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "instrumentIdentifierCardNumber",
            "baseName": "instrumentIdentifierCardNumber",
            "type": "boolean"
        },
        {
            "name": "instrumentIdentifierCardExpiration",
            "baseName": "instrumentIdentifierCardExpiration",
            "type": "boolean"
        },
        {
            "name": "paymentInstrumentCardDetails",
            "baseName": "paymentInstrumentCardDetails",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return TmsNullify.attributeTypeMap;
    }
}

export class TmsPaymentInstrumentProcessingInfo {
    /**
    * Flag that indicates that this is a payment for a bill or for an existing contractual loan. Possible Values: - `true`: Bill payment or loan payment. - `false` (default): Not a bill payment or loan payment. # For processor-specific details, see the `bill_payment` field description in [Credit Card Services Using the SCMP API.](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/) 
    */
    'billPaymentProgramEnabled'?: boolean;
    'bankTransferOptions'?: TmsPaymentInstrumentProcessingInfoBankTransferOptions;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "billPaymentProgramEnabled",
            "baseName": "billPaymentProgramEnabled",
            "type": "boolean"
        },
        {
            "name": "bankTransferOptions",
            "baseName": "bankTransferOptions",
            "type": "TmsPaymentInstrumentProcessingInfoBankTransferOptions"
        }    ];

    static getAttributeTypeMap() {
        return TmsPaymentInstrumentProcessingInfo.attributeTypeMap;
    }
}

export class TmsPaymentInstrumentProcessingInfoBankTransferOptions {
    /**
    * Specifies the authorization method for the transaction.  #### TeleCheck Possible Values: - `ARC`: account receivable conversion - `CCD`: corporate cash disbursement - `POP`: point of purchase conversion - `PPD`: prearranged payment and deposit entry - `TEL`: telephone-initiated entry - `WEB`: internet-initiated entry  # For details, see `ecp_sec_code` field description in the [Electronic Check Services Using the SCMP API Guide.](https://apps.cybersource.com/library/documentation/dev_guides/EChecks_SCMP_API/html/) 
    */
    'sECCode'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "sECCode",
            "baseName": "SECCode",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TmsPaymentInstrumentProcessingInfoBankTransferOptions.attributeTypeMap;
    }
}

export class TmsSensitivePrivileges {
    /**
    * Indicates which digits of the card number will be unmasked.  Possible Values:    - 'FIRST_6_LAST_4'   - 'LAST_4'   - 'MASKED' 
    */
    'cardNumberMaskingFormat'?: TmsSensitivePrivileges.CardNumberMaskingFormatEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "cardNumberMaskingFormat",
            "baseName": "cardNumberMaskingFormat",
            "type": "TmsSensitivePrivileges.CardNumberMaskingFormatEnum"
        }    ];

    static getAttributeTypeMap() {
        return TmsSensitivePrivileges.attributeTypeMap;
    }
}

export namespace TmsSensitivePrivileges {
    export enum CardNumberMaskingFormatEnum {
        FIRST6LAST4 = <any> 'FIRST_6_LAST_4',
        LAST4 = <any> 'LAST_4',
        MASKED = <any> 'MASKED'
    }
}
export class TmsTokenFormats {
    /**
    * Format for customer tokens.  Possible Values:   - '16_DIGIT'   - '19_DIGIT'   - '22_DIGIT'   - '32_HEX' 
    */
    'customer'?: TmsTokenFormats.CustomerEnum;
    /**
    * Format for payment instrument tokens.  Possible Values:   - '16_DIGIT'   - '19_DIGIT'   - '22_DIGIT'   - '32_HEX' 
    */
    'paymentInstrument'?: TmsTokenFormats.PaymentInstrumentEnum;
    /**
    * Format for card based instrument identifier tokens.  Possible Values:   - '16_DIGIT'   - '16_DIGIT_LAST_4'   - '19_DIGIT'   - '19_DIGIT_LAST_4'   - '22_DIGIT'   - '32_HEX' 
    */
    'instrumentIdentifierCard'?: TmsTokenFormats.InstrumentIdentifierCardEnum;
    /**
    * Format for bank account based instrument identifier tokens.  Possible Values:    - '16_DIGIT'   - '19_DIGIT'   - '22_DIGIT'   - '32_HEX' 
    */
    'instrumentIdentifierBankAccount'?: TmsTokenFormats.InstrumentIdentifierBankAccountEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "customer",
            "baseName": "customer",
            "type": "TmsTokenFormats.CustomerEnum"
        },
        {
            "name": "paymentInstrument",
            "baseName": "paymentInstrument",
            "type": "TmsTokenFormats.PaymentInstrumentEnum"
        },
        {
            "name": "instrumentIdentifierCard",
            "baseName": "instrumentIdentifierCard",
            "type": "TmsTokenFormats.InstrumentIdentifierCardEnum"
        },
        {
            "name": "instrumentIdentifierBankAccount",
            "baseName": "instrumentIdentifierBankAccount",
            "type": "TmsTokenFormats.InstrumentIdentifierBankAccountEnum"
        }    ];

    static getAttributeTypeMap() {
        return TmsTokenFormats.attributeTypeMap;
    }
}

export namespace TmsTokenFormats {
    export enum CustomerEnum {
        _16DIGIT = <any> '16_DIGIT',
        _19DIGIT = <any> '19_DIGIT',
        _22DIGIT = <any> '22_DIGIT',
        _32HEX = <any> '32_HEX'
    }
    export enum PaymentInstrumentEnum {
        _16DIGIT = <any> '16_DIGIT',
        _19DIGIT = <any> '19_DIGIT',
        _22DIGIT = <any> '22_DIGIT',
        _32HEX = <any> '32_HEX'
    }
    export enum InstrumentIdentifierCardEnum {
        _16DIGIT = <any> '16_DIGIT',
        _16DIGITLAST4 = <any> '16_DIGIT_LAST_4',
        _19DIGIT = <any> '19_DIGIT',
        _19DIGITLAST4 = <any> '19_DIGIT_LAST_4',
        _22DIGIT = <any> '22_DIGIT',
        _32HEX = <any> '32_HEX'
    }
    export enum InstrumentIdentifierBankAccountEnum {
        _16DIGIT = <any> '16_DIGIT',
        _19DIGIT = <any> '19_DIGIT',
        _22DIGIT = <any> '22_DIGIT',
        _32HEX = <any> '32_HEX'
    }
}
export class Tmsv2TokenizedCard {
    'links'?: Tmsv2TokenizedCardLinks;
    /**
    * The Id of the Tokenized Card. 
    */
    'id'?: string;
    /**
    * The type. Possible Values: - tokenizedCard 
    */
    'object'?: string;
    /**
    * An identifier provided by the issuer for the account. 
    */
    'accountReferenceId'?: string;
    /**
    * Identifier of the consumer within the wallet. Maximum 24 characters for VTS.
    */
    'consumerId'?: string;
    /**
    * Specifies whether the InstrumentId should be created (true) or not (false). Possible Values: - `true`: The InstrumentId should be created. - `false`: The InstrumentId should be created. 
    */
    'createInstrumentIdentifier'?: boolean;
    /**
    * Source of the payment instrument. Possible Values: - ONFILE - TOKEN - ISSUER 
    */
    'source'?: string;
    /**
    * State of the network token or network token provision. Possible Values:   ACTIVE : Network token is active.   SUSPENDED : Network token is suspended. This state can change back to ACTIVE.   DELETED : This is a final state for a network token instance.   UNPROVISIONED : A previous network token. 
    */
    'state'?: string;
    /**
    * Issuers state for the network token Possible Values: - INVALID_REQUEST : The network token provision request contained invalid data. - CARD_VERIFICATION_FAILED : The network token provision request contained data that could not be verified. - CARD_NOT_ELIGIBLE : Card can currently not be used with issuer for tokenization. - CARD_NOT_ALLOWED : Card can currently not be used with card association for tokenization. - DECLINED : Card can currently not be used with issuer for tokenization. - SERVICE_UNAVAILABLE : The network token service was unavailable or timed out. - SYSTEM_ERROR : An unexpected error occurred with network token service, check configuration. 
    */
    'reason'?: string;
    /**
    * The token requestor's network token for the provided PAN and consumer Id, if available. 
    */
    'number'?: string;
    /**
    * Two-digit month in which the network token expires. Format: `MM`. Possible Values: `01` through `12`. 
    */
    'expirationMonth'?: string;
    /**
    * Four-digit year in which the network token expires. Format: `YYYY`. 
    */
    'expirationYear'?: string;
    /**
    * The type of card (Card Network). Possible Values: - visa - mastercard - americanexpress 
    */
    'type'?: string;
    /**
    * Value generated by the card association to be used alongside the network token for processing a payment. 
    */
    'cryptogram'?: string;
    /**
    * 4-digit number generated by the card association to be used alogside the network token for processing a payment. Only supported for Amex and SCOF. 
    */
    'securityCode'?: string;
    /**
    * Raw Electronic Commerce Indicator provided by the card association with the result of the cardholder authentication. 
    */
    'eci'?: string;
    /**
    * 11-digit identifier that uniquely identifies the Token Requestor. 
    */
    'requestorId'?: string;
    /**
    * Unique id to identify this PAN/ enrollment. 
    */
    'enrollmentId'?: string;
    /**
    * Unique ID for netwrok token. 
    */
    'tokenReferenceId'?: string;
    /**
    * Payment account reference. 
    */
    'paymentAccountReference'?: string;
    'card'?: Tmsv2TokenizedCardCard;
    'passcode'?: Tmsv2TokenizedCardPasscode;
    'metadata'?: Tmsv2TokenizedCardMetadata;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "Tmsv2TokenizedCardLinks"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "object",
            "baseName": "object",
            "type": "string"
        },
        {
            "name": "accountReferenceId",
            "baseName": "accountReferenceId",
            "type": "string"
        },
        {
            "name": "consumerId",
            "baseName": "consumerId",
            "type": "string"
        },
        {
            "name": "createInstrumentIdentifier",
            "baseName": "createInstrumentIdentifier",
            "type": "boolean"
        },
        {
            "name": "source",
            "baseName": "source",
            "type": "string"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "string"
        },
        {
            "name": "reason",
            "baseName": "reason",
            "type": "string"
        },
        {
            "name": "number",
            "baseName": "number",
            "type": "string"
        },
        {
            "name": "expirationMonth",
            "baseName": "expirationMonth",
            "type": "string"
        },
        {
            "name": "expirationYear",
            "baseName": "expirationYear",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "cryptogram",
            "baseName": "cryptogram",
            "type": "string"
        },
        {
            "name": "securityCode",
            "baseName": "securityCode",
            "type": "string"
        },
        {
            "name": "eci",
            "baseName": "eci",
            "type": "string"
        },
        {
            "name": "requestorId",
            "baseName": "requestorId",
            "type": "string"
        },
        {
            "name": "enrollmentId",
            "baseName": "enrollmentId",
            "type": "string"
        },
        {
            "name": "tokenReferenceId",
            "baseName": "tokenReferenceId",
            "type": "string"
        },
        {
            "name": "paymentAccountReference",
            "baseName": "paymentAccountReference",
            "type": "string"
        },
        {
            "name": "card",
            "baseName": "card",
            "type": "Tmsv2TokenizedCardCard"
        },
        {
            "name": "passcode",
            "baseName": "passcode",
            "type": "Tmsv2TokenizedCardPasscode"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "Tmsv2TokenizedCardMetadata"
        }    ];

    static getAttributeTypeMap() {
        return Tmsv2TokenizedCard.attributeTypeMap;
    }
}

/**
* Card object used to create a network token 
*/
export class Tmsv2TokenizedCardCard {
    /**
    * The customer’s payment card number, also known as the Primary Account Number (PAN). 
    */
    'number'?: string;
    /**
    * Two-digit month in which the payment card expires.  Format: `MM`.  Possible Values: `01` through `12`. 
    */
    'expirationMonth'?: string;
    /**
    * Four-digit year in which the credit card expires.  Format: `YYYY`. 
    */
    'expirationYear'?: string;
    /**
    * The type of card (Card Network). Possible Values: - 001: visa 
    */
    'type'?: string;
    /**
    * The customer’s latest payment card number suffix. 
    */
    'suffix'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "number",
            "baseName": "number",
            "type": "string"
        },
        {
            "name": "expirationMonth",
            "baseName": "expirationMonth",
            "type": "string"
        },
        {
            "name": "expirationYear",
            "baseName": "expirationYear",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "suffix",
            "baseName": "suffix",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Tmsv2TokenizedCardCard.attributeTypeMap;
    }
}

export class Tmsv2TokenizedCardLinks {
    'self'?: Tmsv2TokenizedCardLinksSelf;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "self",
            "baseName": "self",
            "type": "Tmsv2TokenizedCardLinksSelf"
        }    ];

    static getAttributeTypeMap() {
        return Tmsv2TokenizedCardLinks.attributeTypeMap;
    }
}

export class Tmsv2TokenizedCardLinksSelf {
    /**
    * Link to the Tokenized Card. example: 'tms/v2/tokenized-cards/7010000000016241111' 
    */
    'href'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "href",
            "baseName": "href",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Tmsv2TokenizedCardLinksSelf.attributeTypeMap;
    }
}

/**
* Metadata associated with the tokenized card. 
*/
export class Tmsv2TokenizedCardMetadata {
    'cardArt'?: TmsCardArt;
    'issuer'?: Tmsv2TokenizedCardMetadataIssuer;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "cardArt",
            "baseName": "cardArt",
            "type": "TmsCardArt"
        },
        {
            "name": "issuer",
            "baseName": "issuer",
            "type": "Tmsv2TokenizedCardMetadataIssuer"
        }    ];

    static getAttributeTypeMap() {
        return Tmsv2TokenizedCardMetadata.attributeTypeMap;
    }
}

/**
* Issuer associated with the tokenized card. 
*/
export class Tmsv2TokenizedCardMetadataIssuer {
    /**
    * issuer name. 
    */
    'name'?: string;
    /**
    * issuer short description. 
    */
    'shortDescription'?: string;
    /**
    * issuer long  description. 
    */
    'longDescription'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "shortDescription",
            "baseName": "shortDescription",
            "type": "string"
        },
        {
            "name": "longDescription",
            "baseName": "longDescription",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Tmsv2TokenizedCardMetadataIssuer.attributeTypeMap;
    }
}

/**
* Passcode by issuer for ID&V. 
*/
export class Tmsv2TokenizedCardPasscode {
    /**
    * OTP generated at issuer. 
    */
    'value'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "value",
            "baseName": "value",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Tmsv2TokenizedCardPasscode.attributeTypeMap;
    }
}

export class Tmsv2customersBuyerInformation {
    /**
    * Your identifier for the customer. 
    */
    'merchantCustomerID'?: string;
    /**
    * Customer's primary email address, including the full domain name. 
    */
    'email'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "merchantCustomerID",
            "baseName": "merchantCustomerID",
            "type": "string"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Tmsv2customersBuyerInformation.attributeTypeMap;
    }
}

export class Tmsv2customersClientReferenceInformation {
    /**
    * Client-generated order reference or tracking number. 
    */
    'code'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Tmsv2customersClientReferenceInformation.attributeTypeMap;
    }
}

export class Tmsv2customersDefaultPaymentInstrument {
    /**
    * The Id of the Customers default Payment Instrument 
    */
    'id'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Tmsv2customersDefaultPaymentInstrument.attributeTypeMap;
    }
}

export class Tmsv2customersDefaultShippingAddress {
    /**
    * The Id of the Customers default Shipping Address 
    */
    'id'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Tmsv2customersDefaultShippingAddress.attributeTypeMap;
    }
}

/**
* Additional resources for the Customer. 
*/
export class Tmsv2customersEmbedded {
    'defaultPaymentInstrument'?: Tmsv2customersEmbeddedDefaultPaymentInstrument;
    'defaultShippingAddress'?: Tmsv2customersEmbeddedDefaultShippingAddress;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "defaultPaymentInstrument",
            "baseName": "defaultPaymentInstrument",
            "type": "Tmsv2customersEmbeddedDefaultPaymentInstrument"
        },
        {
            "name": "defaultShippingAddress",
            "baseName": "defaultShippingAddress",
            "type": "Tmsv2customersEmbeddedDefaultShippingAddress"
        }    ];

    static getAttributeTypeMap() {
        return Tmsv2customersEmbedded.attributeTypeMap;
    }
}

export class Tmsv2customersEmbeddedDefaultPaymentInstrument {
    'links'?: Tmsv2customersEmbeddedDefaultPaymentInstrumentLinks;
    /**
    * The Id of the Payment Instrument Token.
    */
    'id'?: string;
    /**
    * The type.  Possible Values: - paymentInstrument 
    */
    'object'?: string;
    /**
    * Flag that indicates whether customer payment instrument is the dafault. Possible Values:  - `true`: Payment instrument is customer's default.  - `false`: Payment instrument is not customer's default. 
    */
    '_default'?: boolean;
    /**
    * Issuers state for the card number. Possible Values: - ACTIVE - CLOSED : The account has been closed. 
    */
    'state'?: string;
    /**
    * The type of Payment Instrument. Possible Values: - cardHash 
    */
    'type'?: string;
    'bankAccount'?: Tmsv2customersEmbeddedDefaultPaymentInstrumentBankAccount;
    'card'?: Tmsv2customersEmbeddedDefaultPaymentInstrumentCard;
    'buyerInformation'?: Tmsv2customersEmbeddedDefaultPaymentInstrumentBuyerInformation;
    'billTo'?: Tmsv2customersEmbeddedDefaultPaymentInstrumentBillTo;
    'processingInformation'?: TmsPaymentInstrumentProcessingInfo;
    'merchantInformation'?: Tmsv2customersEmbeddedDefaultPaymentInstrumentMerchantInformation;
    'instrumentIdentifier'?: Tmsv2customersEmbeddedDefaultPaymentInstrumentInstrumentIdentifier;
    'metadata'?: Tmsv2customersEmbeddedDefaultPaymentInstrumentMetadata;
    'embedded'?: Tmsv2customersEmbeddedDefaultPaymentInstrumentEmbedded;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "Tmsv2customersEmbeddedDefaultPaymentInstrumentLinks"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "object",
            "baseName": "object",
            "type": "string"
        },
        {
            "name": "_default",
            "baseName": "default",
            "type": "boolean"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "bankAccount",
            "baseName": "bankAccount",
            "type": "Tmsv2customersEmbeddedDefaultPaymentInstrumentBankAccount"
        },
        {
            "name": "card",
            "baseName": "card",
            "type": "Tmsv2customersEmbeddedDefaultPaymentInstrumentCard"
        },
        {
            "name": "buyerInformation",
            "baseName": "buyerInformation",
            "type": "Tmsv2customersEmbeddedDefaultPaymentInstrumentBuyerInformation"
        },
        {
            "name": "billTo",
            "baseName": "billTo",
            "type": "Tmsv2customersEmbeddedDefaultPaymentInstrumentBillTo"
        },
        {
            "name": "processingInformation",
            "baseName": "processingInformation",
            "type": "TmsPaymentInstrumentProcessingInfo"
        },
        {
            "name": "merchantInformation",
            "baseName": "merchantInformation",
            "type": "Tmsv2customersEmbeddedDefaultPaymentInstrumentMerchantInformation"
        },
        {
            "name": "instrumentIdentifier",
            "baseName": "instrumentIdentifier",
            "type": "Tmsv2customersEmbeddedDefaultPaymentInstrumentInstrumentIdentifier"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "Tmsv2customersEmbeddedDefaultPaymentInstrumentMetadata"
        },
        {
            "name": "embedded",
            "baseName": "_embedded",
            "type": "Tmsv2customersEmbeddedDefaultPaymentInstrumentEmbedded"
        }    ];

    static getAttributeTypeMap() {
        return Tmsv2customersEmbeddedDefaultPaymentInstrument.attributeTypeMap;
    }
}

export class Tmsv2customersEmbeddedDefaultPaymentInstrumentBankAccount {
    /**
    * Account type.  Possible Values:  - checking : C  - general ledger : G This value is supported only on Wells Fargo ACH  - savings : S (U.S. dollars only)  - corporate checking : X (U.S. dollars only) 
    */
    'type'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Tmsv2customersEmbeddedDefaultPaymentInstrumentBankAccount.attributeTypeMap;
    }
}

export class Tmsv2customersEmbeddedDefaultPaymentInstrumentBillTo {
    /**
    * Customer’s first name. This name must be the same as the name on the card. 
    */
    'firstName'?: string;
    /**
    * Customer’s last name. This name must be the same as the name on the card. 
    */
    'lastName'?: string;
    /**
    * Name of the customer’s company. 
    */
    'company'?: string;
    /**
    * Payment card billing street address as it appears on the credit card issuer’s records. 
    */
    'address1'?: string;
    /**
    * Additional address information. 
    */
    'address2'?: string;
    /**
    * Payment card billing city. 
    */
    'locality'?: string;
    /**
    * State or province of the billing address. Use the State, Province, and Territory Codes for the United States and Canada. 
    */
    'administrativeArea'?: string;
    /**
    * Postal code for the billing address. The postal code must consist of 5 to 9 digits.  When the billing country is the U.S., the 9-digit postal code must follow this format: [5 digits][dash][4 digits]  **Example** `12345-6789`  When the billing country is Canada, the 6-digit postal code must follow this format: [alpha][numeric][alpha][space][numeric][alpha][numeric]  **Example** `A1B 2C3` 
    */
    'postalCode'?: string;
    /**
    * Payment card billing country. Use the two-character ISO Standard Country Codes. 
    */
    'country'?: string;
    /**
    * Customer's email address, including the full domain name. 
    */
    'email'?: string;
    /**
    * Customer’s phone number. 
    */
    'phoneNumber'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "firstName",
            "baseName": "firstName",
            "type": "string"
        },
        {
            "name": "lastName",
            "baseName": "lastName",
            "type": "string"
        },
        {
            "name": "company",
            "baseName": "company",
            "type": "string"
        },
        {
            "name": "address1",
            "baseName": "address1",
            "type": "string"
        },
        {
            "name": "address2",
            "baseName": "address2",
            "type": "string"
        },
        {
            "name": "locality",
            "baseName": "locality",
            "type": "string"
        },
        {
            "name": "administrativeArea",
            "baseName": "administrativeArea",
            "type": "string"
        },
        {
            "name": "postalCode",
            "baseName": "postalCode",
            "type": "string"
        },
        {
            "name": "country",
            "baseName": "country",
            "type": "string"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "phoneNumber",
            "baseName": "phoneNumber",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Tmsv2customersEmbeddedDefaultPaymentInstrumentBillTo.attributeTypeMap;
    }
}

export class Tmsv2customersEmbeddedDefaultPaymentInstrumentBuyerInformation {
    /**
    * Company’s tax identifier. This is only used for eCheck service. 
    */
    'companyTaxID'?: string;
    /**
    * Currency used for the order. Use the three-character I[ISO Standard Currency Codes.](http://apps.cybersource.com/library/documentation/sbc/quickref/currencies.pdf)  For an authorization reversal (`reversalInformation`) or a capture (`processingOptions.capture` is set to `true`), you must use the same currency that you used in your payment authorization request.  #### DCC for First Data Your local currency. For details, see the `currency` field description in [Dynamic Currency Conversion For First Data Using the SCMP API](http://apps.cybersource.com/library/documentation/dev_guides/DCC_FirstData_SCMP/DCC_FirstData_SCMP_API.pdf). # For details about currency as used in partial authorizations, see \"Features for Debit Cards and Prepaid Cards\" in the [Credit Card Services Using the SCMP API Guide](https://apps.cybersource.com/library/documentation/dev_guides/CC_Svcs_SCMP_API/html/) 
    */
    'currency'?: string;
    /**
    * Date of birth of the customer. Format: YYYY-MM-DD 
    */
    'dateOfBirth'?: string;
    'personalIdentification'?: Array<Tmsv2customersEmbeddedDefaultPaymentInstrumentBuyerInformationPersonalIdentification>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "companyTaxID",
            "baseName": "companyTaxID",
            "type": "string"
        },
        {
            "name": "currency",
            "baseName": "currency",
            "type": "string"
        },
        {
            "name": "dateOfBirth",
            "baseName": "dateOfBirth",
            "type": "string"
        },
        {
            "name": "personalIdentification",
            "baseName": "personalIdentification",
            "type": "Array<Tmsv2customersEmbeddedDefaultPaymentInstrumentBuyerInformationPersonalIdentification>"
        }    ];

    static getAttributeTypeMap() {
        return Tmsv2customersEmbeddedDefaultPaymentInstrumentBuyerInformation.attributeTypeMap;
    }
}

export class Tmsv2customersEmbeddedDefaultPaymentInstrumentBuyerInformationIssuedBy {
    /**
    * The State or province where the customer’s driver’s license was issued.  Use the two-character State, Province, and Territory Codes for the United States and Canada. 
    */
    'administrativeArea'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "administrativeArea",
            "baseName": "administrativeArea",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Tmsv2customersEmbeddedDefaultPaymentInstrumentBuyerInformationIssuedBy.attributeTypeMap;
    }
}

export class Tmsv2customersEmbeddedDefaultPaymentInstrumentBuyerInformationPersonalIdentification {
    /**
    * The value of the identification type. 
    */
    'id'?: string;
    /**
    * The type of the identification.  Possible Values:   - driver license 
    */
    'type'?: string;
    'issuedBy'?: Tmsv2customersEmbeddedDefaultPaymentInstrumentBuyerInformationIssuedBy;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "issuedBy",
            "baseName": "issuedBy",
            "type": "Tmsv2customersEmbeddedDefaultPaymentInstrumentBuyerInformationIssuedBy"
        }    ];

    static getAttributeTypeMap() {
        return Tmsv2customersEmbeddedDefaultPaymentInstrumentBuyerInformationPersonalIdentification.attributeTypeMap;
    }
}

export class Tmsv2customersEmbeddedDefaultPaymentInstrumentCard {
    /**
    * Two-digit month in which the payment card expires.  Format: `MM`.  Possible Values: `01` through `12`. 
    */
    'expirationMonth'?: string;
    /**
    * Four-digit year in which the credit card expires.  Format: `YYYY`. 
    */
    'expirationYear'?: string;
    /**
    * Value that indicates the card type. Possible Values v2 : v1:   * 001 : visa   * 002 : mastercard - Eurocard—European regional brand of Mastercard   * 003 : american express   * 004 : discover   * 005 : diners club   * 006 : carte blanche   * 007 : jcb   * 008 : optima   * 011 : twinpay credit   * 012 : twinpay debit   * 013 : walmart   * 014 : enRoute   * 015 : lowes consumer   * 016 : home depot consumer   * 017 : mbna   * 018 : dicks sportswear   * 019 : casual corner   * 020 : sears   * 021 : jal   * 023 : disney   * 024 : maestro uk domestic   * 025 : sams club consumer   * 026 : sams club business   * 028 : bill me later   * 029 : bebe   * 030 : restoration hardware   * 031 : delta online — use this value only for Ingenico ePayments. For other processors, use 001 for all Visa card types.   * 032 : solo   * 033 : visa electron   * 034 : dankort   * 035 : laser   * 036 : carte bleue — formerly Cartes Bancaires   * 037 : carta si   * 038 : pinless debit   * 039 : encoded account   * 040 : uatp   * 041 : household   * 042 : maestro international   * 043 : ge money uk   * 044 : korean cards   * 045 : style   * 046 : jcrew   * 047 : payease china processing ewallet   * 048 : payease china processing bank transfer   * 049 : meijer private label   * 050 : hipercard — supported only by the Comercio Latino processor.   * 051 : aura — supported only by the Comercio Latino processor.   * 052 : redecard   * 054 : elo — supported only by the Comercio Latino processor.   * 055 : capital one private label   * 056 : synchrony private label   * 057 : costco private label   * 060 : mada   * 062 : china union pay   * 063 : falabella private label 
    */
    'type'?: string;
    /**
    * Number of times a Maestro (UK Domestic) card has been issued to the account holder. The card might or might not have an issue number. The number can consist of one or two digits, and the first digit might be a zero. When you include this value in your request, include exactly what is printed on the card. A value of 2 is different than a value of 02. Do not include the field, even with a blank value, if the card is not a Maestro (UK Domestic) card.  **Note** The issue number is not required for Maestro (UK Domestic) transactions. 
    */
    'issueNumber'?: string;
    /**
    * Month of the start of the Maestro (UK Domestic) card validity period. Do not include the field, even with a blank value, if the card is not a Maestro (UK Domestic) card. `Format: MM`. Possible Values: 01 through 12.  **Note** The start date is not required for Maestro (UK Domestic) transactions. 
    */
    'startMonth'?: string;
    /**
    * Year of the start of the Maestro (UK Domestic) card validity period. Do not include the field, even with a blank value, if the card is not a Maestro (UK Domestic) card. `Format: YYYY`.  **Note** The start date is not required for Maestro (UK Domestic) transactions. 
    */
    'startYear'?: string;
    /**
    * 'Payment Instrument was created / updated as part of a pinless debit transaction.' 
    */
    'useAs'?: string;
    /**
    * Hash value representing the card. 
    */
    'hash'?: string;
    'tokenizedInformation'?: Tmsv2customersEmbeddedDefaultPaymentInstrumentCardTokenizedInformation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "expirationMonth",
            "baseName": "expirationMonth",
            "type": "string"
        },
        {
            "name": "expirationYear",
            "baseName": "expirationYear",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "issueNumber",
            "baseName": "issueNumber",
            "type": "string"
        },
        {
            "name": "startMonth",
            "baseName": "startMonth",
            "type": "string"
        },
        {
            "name": "startYear",
            "baseName": "startYear",
            "type": "string"
        },
        {
            "name": "useAs",
            "baseName": "useAs",
            "type": "string"
        },
        {
            "name": "hash",
            "baseName": "hash",
            "type": "string"
        },
        {
            "name": "tokenizedInformation",
            "baseName": "tokenizedInformation",
            "type": "Tmsv2customersEmbeddedDefaultPaymentInstrumentCardTokenizedInformation"
        }    ];

    static getAttributeTypeMap() {
        return Tmsv2customersEmbeddedDefaultPaymentInstrumentCard.attributeTypeMap;
    }
}

export class Tmsv2customersEmbeddedDefaultPaymentInstrumentCardTokenizedInformation {
    /**
    * Value that identifies your business and indicates that the cardholder’s account number is tokenized. This value is assigned by the token service provider and is unique within the token service provider’s database.  **Note** This field is supported only through **VisaNet** and **FDC Nashville Global**. 
    */
    'requestorID'?: string;
    /**
    * Type of transaction that provided the token data. This value does not specify the token service provider; it specifies the entity that provided you with information about the token.  Set the value for this field to 1. An application on the customer’s mobile device provided the token data. 
    */
    'transactionType'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "requestorID",
            "baseName": "requestorID",
            "type": "string"
        },
        {
            "name": "transactionType",
            "baseName": "transactionType",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Tmsv2customersEmbeddedDefaultPaymentInstrumentCardTokenizedInformation.attributeTypeMap;
    }
}

/**
* Additional resources for the Payment Instrument. 
*/
export class Tmsv2customersEmbeddedDefaultPaymentInstrumentEmbedded {
    'instrumentIdentifier'?: TmsEmbeddedInstrumentIdentifier;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "instrumentIdentifier",
            "baseName": "instrumentIdentifier",
            "type": "TmsEmbeddedInstrumentIdentifier"
        }    ];

    static getAttributeTypeMap() {
        return Tmsv2customersEmbeddedDefaultPaymentInstrumentEmbedded.attributeTypeMap;
    }
}

export class Tmsv2customersEmbeddedDefaultPaymentInstrumentInstrumentIdentifier {
    /**
    * The Id of the Instrument Identifier linked to the Payment Instrument. 
    */
    'id'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Tmsv2customersEmbeddedDefaultPaymentInstrumentInstrumentIdentifier.attributeTypeMap;
    }
}

export class Tmsv2customersEmbeddedDefaultPaymentInstrumentLinks {
    'self'?: Tmsv2customersEmbeddedDefaultPaymentInstrumentLinksSelf;
    'customer'?: Tmsv2customersLinksSelf;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "self",
            "baseName": "self",
            "type": "Tmsv2customersEmbeddedDefaultPaymentInstrumentLinksSelf"
        },
        {
            "name": "customer",
            "baseName": "customer",
            "type": "Tmsv2customersLinksSelf"
        }    ];

    static getAttributeTypeMap() {
        return Tmsv2customersEmbeddedDefaultPaymentInstrumentLinks.attributeTypeMap;
    }
}

export class Tmsv2customersEmbeddedDefaultPaymentInstrumentLinksSelf {
    /**
    * Link to the Payment Instrument. 
    */
    'href'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "href",
            "baseName": "href",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Tmsv2customersEmbeddedDefaultPaymentInstrumentLinksSelf.attributeTypeMap;
    }
}

export class Tmsv2customersEmbeddedDefaultPaymentInstrumentMerchantInformation {
    'merchantDescriptor'?: Tmsv2customersEmbeddedDefaultPaymentInstrumentMerchantInformationMerchantDescriptor;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "merchantDescriptor",
            "baseName": "merchantDescriptor",
            "type": "Tmsv2customersEmbeddedDefaultPaymentInstrumentMerchantInformationMerchantDescriptor"
        }    ];

    static getAttributeTypeMap() {
        return Tmsv2customersEmbeddedDefaultPaymentInstrumentMerchantInformation.attributeTypeMap;
    }
}

export class Tmsv2customersEmbeddedDefaultPaymentInstrumentMerchantInformationMerchantDescriptor {
    /**
    * Alternate contact information for your business,such as an email address or URL. This value might be displayed on the cardholder’s statement. When you do not include this value in your capture or credit request, the merchant URL from your CyberSource account is used. Important This value must consist of English characters 
    */
    'alternateName'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "alternateName",
            "baseName": "alternateName",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Tmsv2customersEmbeddedDefaultPaymentInstrumentMerchantInformationMerchantDescriptor.attributeTypeMap;
    }
}

export class Tmsv2customersEmbeddedDefaultPaymentInstrumentMetadata {
    /**
    * The creator of the Payment Instrument. 
    */
    'creator'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "creator",
            "baseName": "creator",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Tmsv2customersEmbeddedDefaultPaymentInstrumentMetadata.attributeTypeMap;
    }
}

export class Tmsv2customersEmbeddedDefaultShippingAddress {
    'links'?: Tmsv2customersEmbeddedDefaultShippingAddressLinks;
    /**
    * The Id of the Shipping Address Token.
    */
    'id'?: string;
    /**
    * Flag that indicates whether customer shipping address is the dafault. Possible Values:  - `true`: Shipping Address is customer's default.  - `false`: Shipping Address is not customer's default. 
    */
    '_default'?: boolean;
    'shipTo'?: Tmsv2customersEmbeddedDefaultShippingAddressShipTo;
    'metadata'?: Tmsv2customersEmbeddedDefaultShippingAddressMetadata;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "Tmsv2customersEmbeddedDefaultShippingAddressLinks"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "_default",
            "baseName": "default",
            "type": "boolean"
        },
        {
            "name": "shipTo",
            "baseName": "shipTo",
            "type": "Tmsv2customersEmbeddedDefaultShippingAddressShipTo"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "Tmsv2customersEmbeddedDefaultShippingAddressMetadata"
        }    ];

    static getAttributeTypeMap() {
        return Tmsv2customersEmbeddedDefaultShippingAddress.attributeTypeMap;
    }
}

export class Tmsv2customersEmbeddedDefaultShippingAddressLinks {
    'self'?: Tmsv2customersEmbeddedDefaultShippingAddressLinksSelf;
    'customer'?: Tmsv2customersEmbeddedDefaultShippingAddressLinksCustomer;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "self",
            "baseName": "self",
            "type": "Tmsv2customersEmbeddedDefaultShippingAddressLinksSelf"
        },
        {
            "name": "customer",
            "baseName": "customer",
            "type": "Tmsv2customersEmbeddedDefaultShippingAddressLinksCustomer"
        }    ];

    static getAttributeTypeMap() {
        return Tmsv2customersEmbeddedDefaultShippingAddressLinks.attributeTypeMap;
    }
}

export class Tmsv2customersEmbeddedDefaultShippingAddressLinksCustomer {
    /**
    * Link to the Customer 
    */
    'href'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "href",
            "baseName": "href",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Tmsv2customersEmbeddedDefaultShippingAddressLinksCustomer.attributeTypeMap;
    }
}

export class Tmsv2customersEmbeddedDefaultShippingAddressLinksSelf {
    /**
    * Link to the Customers Shipping Address 
    */
    'href'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "href",
            "baseName": "href",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Tmsv2customersEmbeddedDefaultShippingAddressLinksSelf.attributeTypeMap;
    }
}

export class Tmsv2customersEmbeddedDefaultShippingAddressMetadata {
    /**
    * The creator of the Shipping Address.
    */
    'creator'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "creator",
            "baseName": "creator",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Tmsv2customersEmbeddedDefaultShippingAddressMetadata.attributeTypeMap;
    }
}

export class Tmsv2customersEmbeddedDefaultShippingAddressShipTo {
    /**
    * First name of the recipient. 
    */
    'firstName'?: string;
    /**
    * Last name of the recipient. 
    */
    'lastName'?: string;
    /**
    * Company associated with the shipping address. 
    */
    'company'?: string;
    /**
    * First line of the shipping address. 
    */
    'address1'?: string;
    /**
    * Second line of the shipping address. 
    */
    'address2'?: string;
    /**
    * City of the shipping address. 
    */
    'locality'?: string;
    /**
    * State or province of the shipping address. Use 2 character the State, Province, and Territory Codes for the United States and Canada. 
    */
    'administrativeArea'?: string;
    /**
    * Postal code for the shipping address. The postal code must consist of 5 to 9 digits.  When the billing country is the U.S., the 9-digit postal code must follow this format: [5 digits][dash][4 digits]  Example 12345-6789  When the billing country is Canada, the 6-digit postal code must follow this format: [alpha][numeric][alpha][space][numeric][alpha][numeric]  Example A1B 2C3  **American Express Direct**\\ Before sending the postal code to the processor, all nonalphanumeric characters are removed and, if the remaining value is longer than nine characters, truncates the value starting from the right side. 
    */
    'postalCode'?: string;
    /**
    * Country of the shipping address. Use the two-character ISO Standard Country Codes. 
    */
    'country'?: string;
    /**
    * Email associated with the shipping address. 
    */
    'email'?: string;
    /**
    * Phone number associated with the shipping address. 
    */
    'phoneNumber'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "firstName",
            "baseName": "firstName",
            "type": "string"
        },
        {
            "name": "lastName",
            "baseName": "lastName",
            "type": "string"
        },
        {
            "name": "company",
            "baseName": "company",
            "type": "string"
        },
        {
            "name": "address1",
            "baseName": "address1",
            "type": "string"
        },
        {
            "name": "address2",
            "baseName": "address2",
            "type": "string"
        },
        {
            "name": "locality",
            "baseName": "locality",
            "type": "string"
        },
        {
            "name": "administrativeArea",
            "baseName": "administrativeArea",
            "type": "string"
        },
        {
            "name": "postalCode",
            "baseName": "postalCode",
            "type": "string"
        },
        {
            "name": "country",
            "baseName": "country",
            "type": "string"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "phoneNumber",
            "baseName": "phoneNumber",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Tmsv2customersEmbeddedDefaultShippingAddressShipTo.attributeTypeMap;
    }
}

export class Tmsv2customersLinks {
    'self'?: Tmsv2customersLinksSelf;
    'paymentInstruments'?: Tmsv2customersLinksPaymentInstruments;
    'shippingAddress'?: Tmsv2customersLinksShippingAddress;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "self",
            "baseName": "self",
            "type": "Tmsv2customersLinksSelf"
        },
        {
            "name": "paymentInstruments",
            "baseName": "paymentInstruments",
            "type": "Tmsv2customersLinksPaymentInstruments"
        },
        {
            "name": "shippingAddress",
            "baseName": "shippingAddress",
            "type": "Tmsv2customersLinksShippingAddress"
        }    ];

    static getAttributeTypeMap() {
        return Tmsv2customersLinks.attributeTypeMap;
    }
}

export class Tmsv2customersLinksPaymentInstruments {
    /**
    * Link to the Customers Payment Instruments. 
    */
    'href'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "href",
            "baseName": "href",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Tmsv2customersLinksPaymentInstruments.attributeTypeMap;
    }
}

export class Tmsv2customersLinksSelf {
    /**
    * Link to the Customer. 
    */
    'href'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "href",
            "baseName": "href",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Tmsv2customersLinksSelf.attributeTypeMap;
    }
}

export class Tmsv2customersLinksShippingAddress {
    /**
    * Link to the Customers Shipping Addresses. 
    */
    'href'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "href",
            "baseName": "href",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Tmsv2customersLinksShippingAddress.attributeTypeMap;
    }
}

export class Tmsv2customersMerchantDefinedInformation {
    /**
    * The number you assign as the name for your merchant-defined data or secure field. Possible Values are data1 to data4 and sensitive1 to sensitive4  For example, to set the name for merchant-defined data 2 field, you would reference merchantDefinedInformation[x].name as data2 Possible Values: - data1 - data2 - data3 - data4 - sensitive1 - sensitive2 - sensitive3 - sensitive4 
    */
    'name'?: string;
    /**
    * The value you assign for your merchant-defined data field.  **Warning** Merchant-defined data fields are not intended to and must not be used to capture personally identifying information. Accordingly, merchants are prohibited from capturing, obtaining, and/or transmitting any personally identifying information in or via the merchant-defined data fields. Personally identifying information includes, but is not limited to, address, credit card number, social security number, driver's license number, state-issued identification number, passport number, and card verification numbers (CVV, CVC2, CVV2, CID, CVN). In the event it is discovered a merchant is capturing and/or transmitting personally identifying information via the merchant-defined data fields, whether or not intentionally, the merchant's account will immediately be suspended, which will result in a rejection of any and all transaction requests submitted by the merchant after the point of suspension. 
    */
    'value'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Tmsv2customersMerchantDefinedInformation.attributeTypeMap;
    }
}

export class Tmsv2customersMetadata {
    /**
    * The creator of the Customer. 
    */
    'creator'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "creator",
            "baseName": "creator",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Tmsv2customersMetadata.attributeTypeMap;
    }
}

export class Tmsv2customersObjectInformation {
    /**
    * Name or title of the customer. 
    */
    'title'?: string;
    /**
    * Comments that you can make about the customer. 
    */
    'comment'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "comment",
            "baseName": "comment",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Tmsv2customersObjectInformation.attributeTypeMap;
    }
}

export class TokenPermissions {
    /**
    * Indicates if tokens may be created
    */
    'create'?: boolean;
    /**
    * Indicates if tokens may be read
    */
    'read'?: boolean;
    /**
    * Indicates if tokens may be updated
    */
    'update'?: boolean;
    /**
    * Indicates if tokens may be deleted
    */
    '_delete'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "create",
            "baseName": "create",
            "type": "boolean"
        },
        {
            "name": "read",
            "baseName": "read",
            "type": "boolean"
        },
        {
            "name": "update",
            "baseName": "update",
            "type": "boolean"
        },
        {
            "name": "_delete",
            "baseName": "delete",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return TokenPermissions.attributeTypeMap;
    }
}

export class TokenizedcardRequest {
    'links'?: Tmsv2TokenizedCardLinks;
    /**
    * The Id of the Tokenized Card. 
    */
    'id'?: string;
    /**
    * The type. Possible Values: - tokenizedCard 
    */
    'object'?: string;
    /**
    * An identifier provided by the issuer for the account. 
    */
    'accountReferenceId'?: string;
    /**
    * Identifier of the consumer within the wallet. Maximum 24 characters for VTS.
    */
    'consumerId'?: string;
    /**
    * Specifies whether the InstrumentId should be created (true) or not (false). Possible Values: - `true`: The InstrumentId should be created. - `false`: The InstrumentId should be created. 
    */
    'createInstrumentIdentifier'?: boolean;
    /**
    * Source of the payment instrument. Possible Values: - ONFILE - TOKEN - ISSUER 
    */
    'source'?: string;
    /**
    * State of the network token or network token provision. Possible Values:   ACTIVE : Network token is active.   SUSPENDED : Network token is suspended. This state can change back to ACTIVE.   DELETED : This is a final state for a network token instance.   UNPROVISIONED : A previous network token. 
    */
    'state'?: string;
    /**
    * Issuers state for the network token Possible Values: - INVALID_REQUEST : The network token provision request contained invalid data. - CARD_VERIFICATION_FAILED : The network token provision request contained data that could not be verified. - CARD_NOT_ELIGIBLE : Card can currently not be used with issuer for tokenization. - CARD_NOT_ALLOWED : Card can currently not be used with card association for tokenization. - DECLINED : Card can currently not be used with issuer for tokenization. - SERVICE_UNAVAILABLE : The network token service was unavailable or timed out. - SYSTEM_ERROR : An unexpected error occurred with network token service, check configuration. 
    */
    'reason'?: string;
    /**
    * The token requestor's network token for the provided PAN and consumer Id, if available. 
    */
    'number'?: string;
    /**
    * Two-digit month in which the network token expires. Format: `MM`. Possible Values: `01` through `12`. 
    */
    'expirationMonth'?: string;
    /**
    * Four-digit year in which the network token expires. Format: `YYYY`. 
    */
    'expirationYear'?: string;
    /**
    * The type of card (Card Network). Possible Values: - visa - mastercard - americanexpress 
    */
    'type'?: string;
    /**
    * Value generated by the card association to be used alongside the network token for processing a payment. 
    */
    'cryptogram'?: string;
    /**
    * 4-digit number generated by the card association to be used alogside the network token for processing a payment. Only supported for Amex and SCOF. 
    */
    'securityCode'?: string;
    /**
    * Raw Electronic Commerce Indicator provided by the card association with the result of the cardholder authentication. 
    */
    'eci'?: string;
    /**
    * 11-digit identifier that uniquely identifies the Token Requestor. 
    */
    'requestorId'?: string;
    /**
    * Unique id to identify this PAN/ enrollment. 
    */
    'enrollmentId'?: string;
    /**
    * Unique ID for netwrok token. 
    */
    'tokenReferenceId'?: string;
    /**
    * Payment account reference. 
    */
    'paymentAccountReference'?: string;
    'card'?: Tmsv2TokenizedCardCard;
    'passcode'?: Tmsv2TokenizedCardPasscode;
    'metadata'?: Tmsv2TokenizedCardMetadata;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "Tmsv2TokenizedCardLinks"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "object",
            "baseName": "object",
            "type": "string"
        },
        {
            "name": "accountReferenceId",
            "baseName": "accountReferenceId",
            "type": "string"
        },
        {
            "name": "consumerId",
            "baseName": "consumerId",
            "type": "string"
        },
        {
            "name": "createInstrumentIdentifier",
            "baseName": "createInstrumentIdentifier",
            "type": "boolean"
        },
        {
            "name": "source",
            "baseName": "source",
            "type": "string"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "string"
        },
        {
            "name": "reason",
            "baseName": "reason",
            "type": "string"
        },
        {
            "name": "number",
            "baseName": "number",
            "type": "string"
        },
        {
            "name": "expirationMonth",
            "baseName": "expirationMonth",
            "type": "string"
        },
        {
            "name": "expirationYear",
            "baseName": "expirationYear",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "cryptogram",
            "baseName": "cryptogram",
            "type": "string"
        },
        {
            "name": "securityCode",
            "baseName": "securityCode",
            "type": "string"
        },
        {
            "name": "eci",
            "baseName": "eci",
            "type": "string"
        },
        {
            "name": "requestorId",
            "baseName": "requestorId",
            "type": "string"
        },
        {
            "name": "enrollmentId",
            "baseName": "enrollmentId",
            "type": "string"
        },
        {
            "name": "tokenReferenceId",
            "baseName": "tokenReferenceId",
            "type": "string"
        },
        {
            "name": "paymentAccountReference",
            "baseName": "paymentAccountReference",
            "type": "string"
        },
        {
            "name": "card",
            "baseName": "card",
            "type": "Tmsv2TokenizedCardCard"
        },
        {
            "name": "passcode",
            "baseName": "passcode",
            "type": "Tmsv2TokenizedCardPasscode"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "Tmsv2TokenizedCardMetadata"
        }    ];

    static getAttributeTypeMap() {
        return TokenizedcardRequest.attributeTypeMap;
    }
}

export class TssV2TransactionsGet200Response {
    /**
    * An unique identification number generated by Cybersource to identify the submitted request. Returned by all services. It is also appended to the endpoint of the resource. On incremental authorizations, this value with be the same as the identification number returned in the original authorization response. 
    */
    'id'?: string;
    /**
    * Contains the transaction identifier for the first transaction in the series of transactions. For example, you might send an authorization request for a payment, followed by a capture request for that payment, and then a refund request for that captured payment. Each of those requests, if successful, creates a resource that is assigned an identifier, which is returned in the response. The rootId identifies the first ID in the series, which in this case would be the ID of the original authorization.
    */
    'rootId'?: string;
    /**
    * Reference number for the transaction. Depending on how your Cybersource account is configured, this value could either be provided in the API request or generated by CyberSource. The actual value used in the request to the processor is provided back to you by Cybersource in the response. 
    */
    'reconciliationId'?: string;
    /**
    * Your CyberSource merchant ID.
    */
    'merchantId'?: string;
    /**
    * Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ` **Example** `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.). The `T` separates the date and the time. The `Z` indicates UTC.  Returned by Cybersource for all services. 
    */
    'submitTimeUTC'?: string;
    /**
    * The status of the submitted transaction.
    */
    'status'?: string;
    'applicationInformation'?: TssV2TransactionsGet200ResponseApplicationInformation;
    'bankAccountValidation'?: TssV2TransactionsGet200ResponseBankAccountValidation;
    'buyerInformation'?: TssV2TransactionsGet200ResponseBuyerInformation;
    'clientReferenceInformation'?: TssV2TransactionsGet200ResponseClientReferenceInformation;
    'consumerAuthenticationInformation'?: TssV2TransactionsGet200ResponseConsumerAuthenticationInformation;
    'deviceInformation'?: TssV2TransactionsGet200ResponseDeviceInformation;
    'errorInformation'?: TssV2TransactionsGet200ResponseErrorInformation;
    'installmentInformation'?: TssV2TransactionsGet200ResponseInstallmentInformation;
    'fraudMarkingInformation'?: TssV2TransactionsGet200ResponseFraudMarkingInformation;
    'healthCareInformation'?: Ptsv2paymentsHealthCareInformation;
    /**
    * The object containing the custom data that the merchant defines. 
    */
    'merchantDefinedInformation'?: Array<Ptsv2paymentsMerchantDefinedInformation>;
    'merchantInformation'?: TssV2TransactionsGet200ResponseMerchantInformation;
    'orderInformation'?: TssV2TransactionsGet200ResponseOrderInformation;
    'paymentInformation'?: TssV2TransactionsGet200ResponsePaymentInformation;
    'paymentInsightsInformation'?: PtsV2PaymentsPost201ResponsePaymentInsightsInformation;
    'payoutOptions'?: TssV2TransactionsGet200ResponsePayoutOptions;
    'unscheduledPaymentInformation'?: Ptsv2paymentsUnscheduledPaymentInformation;
    'processingInformation'?: TssV2TransactionsGet200ResponseProcessingInformation;
    'processorInformation'?: TssV2TransactionsGet200ResponseProcessorInformation;
    'recurringPaymentInformation'?: TssV2TransactionsGet200ResponseRecurringPaymentInformation;
    'pointOfSaleInformation'?: TssV2TransactionsGet200ResponsePointOfSaleInformation;
    'riskInformation'?: TssV2TransactionsGet200ResponseRiskInformation;
    'senderInformation'?: TssV2TransactionsGet200ResponseSenderInformation;
    'tokenInformation'?: TssV2TransactionsGet200ResponseTokenInformation;
    'links'?: TssV2TransactionsGet200ResponseLinks;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "rootId",
            "baseName": "rootId",
            "type": "string"
        },
        {
            "name": "reconciliationId",
            "baseName": "reconciliationId",
            "type": "string"
        },
        {
            "name": "merchantId",
            "baseName": "merchantId",
            "type": "string"
        },
        {
            "name": "submitTimeUTC",
            "baseName": "submitTimeUTC",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "applicationInformation",
            "baseName": "applicationInformation",
            "type": "TssV2TransactionsGet200ResponseApplicationInformation"
        },
        {
            "name": "bankAccountValidation",
            "baseName": "bankAccountValidation",
            "type": "TssV2TransactionsGet200ResponseBankAccountValidation"
        },
        {
            "name": "buyerInformation",
            "baseName": "buyerInformation",
            "type": "TssV2TransactionsGet200ResponseBuyerInformation"
        },
        {
            "name": "clientReferenceInformation",
            "baseName": "clientReferenceInformation",
            "type": "TssV2TransactionsGet200ResponseClientReferenceInformation"
        },
        {
            "name": "consumerAuthenticationInformation",
            "baseName": "consumerAuthenticationInformation",
            "type": "TssV2TransactionsGet200ResponseConsumerAuthenticationInformation"
        },
        {
            "name": "deviceInformation",
            "baseName": "deviceInformation",
            "type": "TssV2TransactionsGet200ResponseDeviceInformation"
        },
        {
            "name": "errorInformation",
            "baseName": "errorInformation",
            "type": "TssV2TransactionsGet200ResponseErrorInformation"
        },
        {
            "name": "installmentInformation",
            "baseName": "installmentInformation",
            "type": "TssV2TransactionsGet200ResponseInstallmentInformation"
        },
        {
            "name": "fraudMarkingInformation",
            "baseName": "fraudMarkingInformation",
            "type": "TssV2TransactionsGet200ResponseFraudMarkingInformation"
        },
        {
            "name": "healthCareInformation",
            "baseName": "healthCareInformation",
            "type": "Ptsv2paymentsHealthCareInformation"
        },
        {
            "name": "merchantDefinedInformation",
            "baseName": "merchantDefinedInformation",
            "type": "Array<Ptsv2paymentsMerchantDefinedInformation>"
        },
        {
            "name": "merchantInformation",
            "baseName": "merchantInformation",
            "type": "TssV2TransactionsGet200ResponseMerchantInformation"
        },
        {
            "name": "orderInformation",
            "baseName": "orderInformation",
            "type": "TssV2TransactionsGet200ResponseOrderInformation"
        },
        {
            "name": "paymentInformation",
            "baseName": "paymentInformation",
            "type": "TssV2TransactionsGet200ResponsePaymentInformation"
        },
        {
            "name": "paymentInsightsInformation",
            "baseName": "paymentInsightsInformation",
            "type": "PtsV2PaymentsPost201ResponsePaymentInsightsInformation"
        },
        {
            "name": "payoutOptions",
            "baseName": "payoutOptions",
            "type": "TssV2TransactionsGet200ResponsePayoutOptions"
        },
        {
            "name": "unscheduledPaymentInformation",
            "baseName": "unscheduledPaymentInformation",
            "type": "Ptsv2paymentsUnscheduledPaymentInformation"
        },
        {
            "name": "processingInformation",
            "baseName": "processingInformation",
            "type": "TssV2TransactionsGet200ResponseProcessingInformation"
        },
        {
            "name": "processorInformation",
            "baseName": "processorInformation",
            "type": "TssV2TransactionsGet200ResponseProcessorInformation"
        },
        {
            "name": "recurringPaymentInformation",
            "baseName": "recurringPaymentInformation",
            "type": "TssV2TransactionsGet200ResponseRecurringPaymentInformation"
        },
        {
            "name": "pointOfSaleInformation",
            "baseName": "pointOfSaleInformation",
            "type": "TssV2TransactionsGet200ResponsePointOfSaleInformation"
        },
        {
            "name": "riskInformation",
            "baseName": "riskInformation",
            "type": "TssV2TransactionsGet200ResponseRiskInformation"
        },
        {
            "name": "senderInformation",
            "baseName": "senderInformation",
            "type": "TssV2TransactionsGet200ResponseSenderInformation"
        },
        {
            "name": "tokenInformation",
            "baseName": "tokenInformation",
            "type": "TssV2TransactionsGet200ResponseTokenInformation"
        },
        {
            "name": "links",
            "baseName": "_links",
            "type": "TssV2TransactionsGet200ResponseLinks"
        }    ];

    static getAttributeTypeMap() {
        return TssV2TransactionsGet200Response.attributeTypeMap;
    }
}

export class TssV2TransactionsGet200ResponseApplicationInformation {
    /**
    * The status of the submitted transaction.
    */
    'status'?: string;
    /**
    * Indicates the reason why a request succeeded or failed and possible action to take if a request fails.  For details, see the appendix of reason codes in the documentation for the relevant payment method. 
    */
    'reasonCode'?: string;
    /**
    * Indicates whether the service request was successful. Possible values:  - `-1`: An error occurred. - `0`: The request was declined. - `1`: The request was successful. 
    */
    'rCode'?: string;
    /**
    * One-word description of the result of the application. 
    */
    'rFlag'?: string;
    'applications'?: Array<TssV2TransactionsGet200ResponseApplicationInformationApplications>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "reasonCode",
            "baseName": "reasonCode",
            "type": "string"
        },
        {
            "name": "rCode",
            "baseName": "rCode",
            "type": "string"
        },
        {
            "name": "rFlag",
            "baseName": "rFlag",
            "type": "string"
        },
        {
            "name": "applications",
            "baseName": "applications",
            "type": "Array<TssV2TransactionsGet200ResponseApplicationInformationApplications>"
        }    ];

    static getAttributeTypeMap() {
        return TssV2TransactionsGet200ResponseApplicationInformation.attributeTypeMap;
    }
}

export class TssV2TransactionsGet200ResponseApplicationInformationApplications {
    /**
    * The name of the CyberSource transaction type (such as CC settlement or CC authorization) that the merchant wants to process in a transaction request. More than one transaction type can included in a transaction request. Each transaction type separately returns their own status, reasonCode, rCode, and rFlag messages. 
    */
    'name'?: string;
    /**
    * The description for this field is not available.
    */
    'status'?: string;
    /**
    * 3-digit reason code that indicates why the customer profile payment succeeded or failed.
    */
    'reasonCode'?: string;
    /**
    * Indicates whether the service request was successful. Possible values:  - `-1`: An error occurred. - `0`: The request was declined. - `1`: The request was successful. 
    */
    'rCode'?: string;
    /**
    * One-word description of the result of the application. 
    */
    'rFlag'?: string;
    /**
    * Reference number that you use to reconcile your CyberSource reports with your processor reports. 
    */
    'reconciliationId'?: string;
    /**
    * Message that explains the reply flag for the application. 
    */
    'rMessage'?: string;
    /**
    * The description for this field is not available.
    */
    'returnCode'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "reasonCode",
            "baseName": "reasonCode",
            "type": "string"
        },
        {
            "name": "rCode",
            "baseName": "rCode",
            "type": "string"
        },
        {
            "name": "rFlag",
            "baseName": "rFlag",
            "type": "string"
        },
        {
            "name": "reconciliationId",
            "baseName": "reconciliationId",
            "type": "string"
        },
        {
            "name": "rMessage",
            "baseName": "rMessage",
            "type": "string"
        },
        {
            "name": "returnCode",
            "baseName": "returnCode",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return TssV2TransactionsGet200ResponseApplicationInformationApplications.attributeTypeMap;
    }
}

export class TssV2TransactionsGet200ResponseBankAccountValidation {
    /**
    * Raw Validation Codes for routing number and account number      Possible values:     • -1: Unable to perform validation/Unknown error     • -2: Service Unavailable     • 12 to 16: Validation results 
    */
    'rawValidationCode'?: number;
    /**
    * Result codes for account number and routing number      Possible values: 00, 04, 98, 99 
    */
    'resultCode'?: number;
    'resultMessage'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "rawValidationCode",
            "baseName": "rawValidationCode",
            "type": "number"
        },
        {
            "name": "resultCode",
            "baseName": "resultCode",
            "type": "number"
        },
        {
            "name": "resultMessage",
            "baseName": "resultMessage",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TssV2TransactionsGet200ResponseBankAccountValidation.attributeTypeMap;
    }
}

export class TssV2TransactionsGet200ResponseBuyerInformation {
    /**
    * Your identifier for the customer.  When a subscription or customer profile is being created, the maximum length for this field for most processors is 30. Otherwise, the maximum length is 100.  #### Comercio Latino For recurring payments in Mexico, the value is the customer’s contract number. Note Before you request the authorization, you must inform the issuer of the customer contract numbers that will be used for recurring transactions.  #### Worldpay VAP For a follow-on credit with Worldpay VAP, CyberSource checks the following locations, in the order given, for a customer account ID value and uses the first value it finds: 1. `customer_account_id` value in the follow-on credit request 2. Customer account ID value that was used for the capture that is being credited 3. Customer account ID value that was used for the original authorization If a customer account ID value cannot be found in any of these locations, then no value is used. 
    */
    'merchantCustomerId'?: string;
    /**
    * The merchant's password that CyberSource hashes and stores as a hashed password. 
    */
    'hashedPassword'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "merchantCustomerId",
            "baseName": "merchantCustomerId",
            "type": "string"
        },
        {
            "name": "hashedPassword",
            "baseName": "hashedPassword",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TssV2TransactionsGet200ResponseBuyerInformation.attributeTypeMap;
    }
}

export class TssV2TransactionsGet200ResponseClientReferenceInformation {
    /**
    * Merchant-generated order reference or tracking number. It is recommended that you send a unique value for each transaction so that you can perform meaningful searches for the transaction.  #### Used by **Authorization** Required field.  #### PIN Debit Requests for PIN debit reversals need to use the same merchant reference number that was used in the transaction that is being reversed.  Required field for all PIN Debit requests (purchase, credit, and reversal).  #### FDC Nashville Global Certain circumstances can cause the processor to truncate this value to 15 or 17 characters for Level II and Level III processing, which can cause a discrepancy between the value you submit and the value included in some processor reports. 
    */
    'code'?: string;
    /**
    * Version of the CyberSource application or integration used for a transaction. 
    */
    'applicationVersion'?: string;
    /**
    * The name of the Connection Method client (such as Virtual Terminal or SOAP Toolkit API) that the merchant uses to send a transaction request to CyberSource. 
    */
    'applicationName'?: string;
    /**
    * The entity that is responsible for running the transaction and submitting the processing request to CyberSource. This could be a person, a system, or a connection method. 
    */
    'applicationUser'?: string;
    'partner'?: TssV2TransactionsGet200ResponseClientReferenceInformationPartner;
    /**
    * Brief description of the order or any comment you wish to add to the order. 
    */
    'comments'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        },
        {
            "name": "applicationVersion",
            "baseName": "applicationVersion",
            "type": "string"
        },
        {
            "name": "applicationName",
            "baseName": "applicationName",
            "type": "string"
        },
        {
            "name": "applicationUser",
            "baseName": "applicationUser",
            "type": "string"
        },
        {
            "name": "partner",
            "baseName": "partner",
            "type": "TssV2TransactionsGet200ResponseClientReferenceInformationPartner"
        },
        {
            "name": "comments",
            "baseName": "comments",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TssV2TransactionsGet200ResponseClientReferenceInformation.attributeTypeMap;
    }
}

export class TssV2TransactionsGet200ResponseClientReferenceInformationPartner {
    /**
    * Identifier for the partner that is integrated to CyberSource.  Send this value in all requests that are sent through the partner solution. CyberSource assigns the ID to the partner.  **Note** When you see a solutionId of 999 in reports, the solutionId that was submitted is incorrect. 
    */
    'solutionId'?: string;
    /**
    * Value that identifies the application vendor and application version for a third party gateway. CyberSource provides you with this value during testing and validation. This field is supported only on CyberSource through VisaNet.  #### Used by **Authorization, Authorization Reversal, Capture, Credit, Incremental Authorization, and Void** Optional field.  #### PIN debit Required field for PIN debit credit, PIN debit purchase, or PIN debit reversal request. 
    */
    'thirdPartyCertificationNumber'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "solutionId",
            "baseName": "solutionId",
            "type": "string"
        },
        {
            "name": "thirdPartyCertificationNumber",
            "baseName": "thirdPartyCertificationNumber",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TssV2TransactionsGet200ResponseClientReferenceInformationPartner.attributeTypeMap;
    }
}

export class TssV2TransactionsGet200ResponseConsumerAuthenticationInformation {
    /**
    * Raw electronic commerce indicator (ECI). 
    */
    'eciRaw'?: string;
    /**
    * Cardholder authentication verification value (CAVV).
    */
    'cavv'?: string;
    /**
    * Transaction identifier. 
    */
    'xid'?: string;
    /**
    * Payer auth Transaction identifier.
    */
    'transactionId'?: string;
    'strongAuthentication'?: TssV2TransactionsGet200ResponseConsumerAuthenticationInformationStrongAuthentication;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "eciRaw",
            "baseName": "eciRaw",
            "type": "string"
        },
        {
            "name": "cavv",
            "baseName": "cavv",
            "type": "string"
        },
        {
            "name": "xid",
            "baseName": "xid",
            "type": "string"
        },
        {
            "name": "transactionId",
            "baseName": "transactionId",
            "type": "string"
        },
        {
            "name": "strongAuthentication",
            "baseName": "strongAuthentication",
            "type": "TssV2TransactionsGet200ResponseConsumerAuthenticationInformationStrongAuthentication"
        }    ];

    static getAttributeTypeMap() {
        return TssV2TransactionsGet200ResponseConsumerAuthenticationInformation.attributeTypeMap;
    }
}

export class TssV2TransactionsGet200ResponseConsumerAuthenticationInformationStrongAuthentication {
    /**
    * This field will contain the low value exemption indicator with one of the following values: Possible values: - `0`  ( low value exemption does not apply to the transaction) - `1` (Transaction exempt from SCA as the merchant/acquirer has determined it to be a low value payment) 
    */
    'lowValueExemptionIndicator'?: string;
    /**
    * This field will contain the transaction risk analysis exemption indicator with one of the following values: Possible values: - `0`  (TRA exemption does not apply to the transaction) - `1` (Transaction exempt from SCA as the merchant/acquirer has determined it to be low risk in accordance with the criteria defined by PSD2/RTS) 
    */
    'riskAnalysisExemptionIndicator'?: string;
    /**
    * Possible values: - `0`  (Trusted merchant exemption does not apply to the transaction) - `1` (Transaction exempt from SCA as it originated at a merchant trusted by the cardholder) 
    */
    'trustedMerchantExemptionIndicator'?: string;
    /**
    * This field will contain the secure corporate payment exemption indicator with one of the following values: Possible values: - `0`  (SCA exemption does not apply to the transaction) - `1` (Transaction exempt from SCA as the merchant/acquirer has determined it as a secure corporate payment) 
    */
    'secureCorporatePaymentIndicator'?: string;
    /**
    * This field will contain the delegated authentication exemption indicator with one of the following values: Possible values: - `0`  (delegated Authentication exemption does not apply to the transaction) - `1` (Transaction exempt from SCA as authentication has been delegated to other provider (PSP,Acquirer)) 
    */
    'delegatedAuthenticationExemptionIndicator'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "lowValueExemptionIndicator",
            "baseName": "lowValueExemptionIndicator",
            "type": "string"
        },
        {
            "name": "riskAnalysisExemptionIndicator",
            "baseName": "riskAnalysisExemptionIndicator",
            "type": "string"
        },
        {
            "name": "trustedMerchantExemptionIndicator",
            "baseName": "trustedMerchantExemptionIndicator",
            "type": "string"
        },
        {
            "name": "secureCorporatePaymentIndicator",
            "baseName": "secureCorporatePaymentIndicator",
            "type": "string"
        },
        {
            "name": "delegatedAuthenticationExemptionIndicator",
            "baseName": "delegatedAuthenticationExemptionIndicator",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TssV2TransactionsGet200ResponseConsumerAuthenticationInformationStrongAuthentication.attributeTypeMap;
    }
}

export class TssV2TransactionsGet200ResponseDeviceInformation {
    /**
    * IP address of the customer.  #### Used by **Authorization, Capture, and Credit** Optional field. 
    */
    'ipAddress'?: string;
    /**
    * DNS resolved hostname from `ipAddress`.
    */
    'hostName'?: string;
    /**
    * Whether the customer’s browser accepts cookies. This field can contain one of the following values: - `yes`: The customer’s browser accepts cookies. - `no`: The customer’s browser does not accept cookies. 
    */
    'cookiesAccepted'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "ipAddress",
            "baseName": "ipAddress",
            "type": "string"
        },
        {
            "name": "hostName",
            "baseName": "hostName",
            "type": "string"
        },
        {
            "name": "cookiesAccepted",
            "baseName": "cookiesAccepted",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TssV2TransactionsGet200ResponseDeviceInformation.attributeTypeMap;
    }
}

export class TssV2TransactionsGet200ResponseErrorInformation {
    /**
    * 1-word description of why a request succeeded or failed. 
    */
    'reason'?: string;
    /**
    * The user-facing description for why a request succeeded or failed. 
    */
    'message'?: string;
    'details'?: Array<PtsV2PaymentsPost201ResponseErrorInformationDetails>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "reason",
            "baseName": "reason",
            "type": "string"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        },
        {
            "name": "details",
            "baseName": "details",
            "type": "Array<PtsV2PaymentsPost201ResponseErrorInformationDetails>"
        }    ];

    static getAttributeTypeMap() {
        return TssV2TransactionsGet200ResponseErrorInformation.attributeTypeMap;
    }
}

export class TssV2TransactionsGet200ResponseFraudMarkingInformation {
    /**
    * Reason for adding the transaction to the negative list. This field can contain one of the following values: - fraud_chargeback: You have received a fraudrelated chargeback for the transaction. - non_fraud_chargeback: You have received a non-fraudulent chargeback for the transaction. - suspected: You believe that you will probably receive a chargeback for the transaction. - creditback: You issued a refund to the customer to avoid a chargeback for the transaction. 
    */
    'reason'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "reason",
            "baseName": "reason",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TssV2TransactionsGet200ResponseFraudMarkingInformation.attributeTypeMap;
    }
}

export class TssV2TransactionsGet200ResponseInstallmentInformation {
    /**
    * Number of Installments.
    */
    'numberOfInstallments'?: string;
    /**
    * Standing Instruction/Installment identifier. 
    */
    'identifier'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "numberOfInstallments",
            "baseName": "numberOfInstallments",
            "type": "string"
        },
        {
            "name": "identifier",
            "baseName": "identifier",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TssV2TransactionsGet200ResponseInstallmentInformation.attributeTypeMap;
    }
}

export class TssV2TransactionsGet200ResponseLinks {
    'self'?: PtsV2PaymentsPost201ResponseLinksSelf;
    'relatedTransactions'?: Array<PtsV2PaymentsPost201ResponseLinksSelf>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "self",
            "baseName": "self",
            "type": "PtsV2PaymentsPost201ResponseLinksSelf"
        },
        {
            "name": "relatedTransactions",
            "baseName": "relatedTransactions",
            "type": "Array<PtsV2PaymentsPost201ResponseLinksSelf>"
        }    ];

    static getAttributeTypeMap() {
        return TssV2TransactionsGet200ResponseLinks.attributeTypeMap;
    }
}

export class TssV2TransactionsGet200ResponseMerchantInformation {
    'merchantDescriptor'?: TssV2TransactionsGet200ResponseMerchantInformationMerchantDescriptor;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "merchantDescriptor",
            "baseName": "merchantDescriptor",
            "type": "TssV2TransactionsGet200ResponseMerchantInformationMerchantDescriptor"
        }    ];

    static getAttributeTypeMap() {
        return TssV2TransactionsGet200ResponseMerchantInformation.attributeTypeMap;
    }
}

export class TssV2TransactionsGet200ResponseMerchantInformationMerchantDescriptor {
    /**
    * Your merchant name.  **Note** For Paymentech processor using Cybersource Payouts, the maximum data length is 22.  #### PIN debit Your business name. This name is displayed on the cardholder’s statement. When you include more than one consecutive space, extra spaces are removed.  When you do not include this value in your PIN debit request, the merchant name from your account is used. **Important** This value must consist of English characters.  Optional field for PIN debit credit or PIN debit purchase requests.  #### Airline processing Your merchant name. This name is displayed on the cardholder’s statement. When you include more than one consecutive space, extra spaces are removed.  **Note** Some airline fee programs may require the original ticket number (ticket identifier) or the ancillary service description in positions 13 through 23 of this field.  **Important** This value must consist of English characters.  Required for captures and credits. 
    */
    'name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TssV2TransactionsGet200ResponseMerchantInformationMerchantDescriptor.attributeTypeMap;
    }
}

export class TssV2TransactionsGet200ResponseOrderInformation {
    'billTo'?: TssV2TransactionsGet200ResponseOrderInformationBillTo;
    'shipTo'?: TssV2TransactionsGet200ResponseOrderInformationShipTo;
    /**
    * Transaction Line Item data.
    */
    'lineItems'?: Array<TssV2TransactionsGet200ResponseOrderInformationLineItems>;
    'amountDetails'?: TssV2TransactionsGet200ResponseOrderInformationAmountDetails;
    'shippingDetails'?: TssV2TransactionsGet200ResponseOrderInformationShippingDetails;
    'invoiceDetails'?: TssV2TransactionsGet200ResponseOrderInformationInvoiceDetails;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "billTo",
            "baseName": "billTo",
            "type": "TssV2TransactionsGet200ResponseOrderInformationBillTo"
        },
        {
            "name": "shipTo",
            "baseName": "shipTo",
            "type": "TssV2TransactionsGet200ResponseOrderInformationShipTo"
        },
        {
            "name": "lineItems",
            "baseName": "lineItems",
            "type": "Array<TssV2TransactionsGet200ResponseOrderInformationLineItems>"
        },
        {
            "name": "amountDetails",
            "baseName": "amountDetails",
            "type": "TssV2TransactionsGet200ResponseOrderInformationAmountDetails"
        },
        {
            "name": "shippingDetails",
            "baseName": "shippingDetails",
            "type": "TssV2TransactionsGet200ResponseOrderInformationShippingDetails"
        },
        {
            "name": "invoiceDetails",
            "baseName": "invoiceDetails",
            "type": "TssV2TransactionsGet200ResponseOrderInformationInvoiceDetails"
        }    ];

    static getAttributeTypeMap() {
        return TssV2TransactionsGet200ResponseOrderInformation.attributeTypeMap;
    }
}

export class TssV2TransactionsGet200ResponseOrderInformationAmountDetails {
    /**
    * Grand total for the order. This value cannot be negative. You can include a decimal point (.), but no other special characters. CyberSource truncates the amount to the correct number of decimal places.  **Note** For CTV, FDCCompass, Paymentech processors, the maximum length for this field is 12.  **Important** Some processors have specific requirements and limitations, such as maximum amounts and maximum field lengths.  If your processor supports zero amount authorizations, you can set this field to 0 for the authorization to check if the card is lost or stolen.   #### Card Present Required to include either this field or `orderInformation.lineItems[].unitPrice` for the order.  #### Invoicing / Pay By Link Required for creating a new invoice or payment link.  #### PIN Debit Amount you requested for the PIN debit purchase. This value is returned for partial authorizations. The issuing bank can approve a partial amount if the balance on the debit card is less than the requested transaction amount.  Required field for PIN Debit purchase and PIN Debit credit requests. Optional field for PIN Debit reversal requests.  #### GPX This field is optional for reversing an authorization or credit; however, for all other processors, these fields are required.  #### DCC with a Third-Party Provider Set this field to the converted amount that was returned by the DCC provider. You must include either this field or the 1st line item in the order and the specific line-order amount in your request.   #### DCC for First Data Not used. 
    */
    'totalAmount'?: string;
    /**
    * Currency used for the order. Use the three-character [ISO Standard Currency Codes.](http://apps.cybersource.com/library/documentation/sbc/quickref/currencies.pdf)  #### Used by **Authorization** Required field.  **Authorization Reversal** For an authorization reversal (`reversalInformation`) or a capture (`processingOptions.capture` is set to `true`), you must use the same currency that you used in your payment authorization request.  #### PIN Debit Currency for the amount you requested for the PIN debit purchase. This value is returned for partial authorizations. The issuing bank can approve a partial amount if the balance on the debit card is less than the requested transaction amount. For the possible values, see the [ISO Standard Currency Codes](https://developer.cybersource.com/library/documentation/sbc/quickref/currencies.pdf). Returned by PIN debit purchase.  For PIN debit reversal requests, you must use the same currency that was used for the PIN debit purchase or PIN debit credit that you are reversing. For the possible values, see the [ISO Standard Currency Codes](https://developer.cybersource.com/library/documentation/sbc/quickref/currencies.pdf).  Required field for PIN Debit purchase and PIN Debit credit requests. Optional field for PIN Debit reversal requests.  #### GPX This field is optional for reversing an authorization or credit.  #### DCC for First Data Your local currency.  #### Tax Calculation Required for international tax and value added tax only. Optional for U.S. and Canadian taxes. Your local currency. 
    */
    'currency'?: string;
    /**
    * Total tax amount for all the items in the order. 
    */
    'taxAmount'?: string;
    /**
    * Amount that was authorized.  Returned by authorization service.  #### PIN debit Amount of the purchase.  Returned by PIN debit purchase. 
    */
    'authorizedAmount'?: string;
    /**
    * This is a multicurrency field. It contains the transaction amount (field 4), converted to the Currency used to bill the cardholder’s account. This field is returned for OCT transactions. 
    */
    'settlementAmount'?: string;
    /**
    * This is a multicurrency-only field. It contains a 3-digit numeric code that identifies the currency used by the issuer to bill the cardholder's account. This field is returned for OCT transactions. 
    */
    'settlementCurrency'?: string;
    'surcharge'?: Ptsv2payoutsOrderInformationAmountDetailsSurcharge;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "totalAmount",
            "baseName": "totalAmount",
            "type": "string"
        },
        {
            "name": "currency",
            "baseName": "currency",
            "type": "string"
        },
        {
            "name": "taxAmount",
            "baseName": "taxAmount",
            "type": "string"
        },
        {
            "name": "authorizedAmount",
            "baseName": "authorizedAmount",
            "type": "string"
        },
        {
            "name": "settlementAmount",
            "baseName": "settlementAmount",
            "type": "string"
        },
        {
            "name": "settlementCurrency",
            "baseName": "settlementCurrency",
            "type": "string"
        },
        {
            "name": "surcharge",
            "baseName": "surcharge",
            "type": "Ptsv2payoutsOrderInformationAmountDetailsSurcharge"
        }    ];

    static getAttributeTypeMap() {
        return TssV2TransactionsGet200ResponseOrderInformationAmountDetails.attributeTypeMap;
    }
}

export class TssV2TransactionsGet200ResponseOrderInformationBillTo {
    /**
    * Customer’s first name. This name must be the same as the name on the card.  **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.  #### SEPA Required for Create Mandate and Import Mandate #### BACS Required for Import Mandate  #### CyberSource Latin American Processing **Important** For an authorization request, CyberSource Latin American Processing concatenates `orderInformation.billTo.firstName` and `orderInformation.billTo.lastName`. If the concatenated value exceeds 30 characters, CyberSource Latin American Processing declines the authorization request.\\ **Note** CyberSource Latin American Processing is the name of a specific processing connection that CyberSource supports. In the CyberSource API documentation, CyberSource Latin American Processing does not refer to the general topic of processing in Latin America. The information in this field description is for the specific processing connection called _CyberSource Latin American Processing_. It is not for any other Latin American processors that CyberSource supports.  #### CyberSource through VisaNet Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.  #### For Payouts: This field may be sent only for FDC Compass.  #### Chase Paymentech Solutions Optional field.  ####  Credit Mutuel-CIC Optional field.  #### OmniPay Direct Optional field.  #### SIX Optional field.  #### TSYS Acquiring Solutions Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.  #### Worldpay VAP Optional field.  #### All other processors Not used. 
    */
    'firstName'?: string;
    /**
    * Customer’s last name. This name must be the same as the name on the card.  **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.  #### SEPA Required for Create Mandate and Import Mandate #### BACS Required for Import Mandate #### Chase Paymentech Solutions Optional field.  ####  Credit Mutuel-CIC Optional field.  #### CyberSource Latin American Processing **Important** For an authorization request, CyberSource Latin American Processing concatenates `orderInformation.billTo.firstName` and `orderInformation.billTo.lastName`. If the concatenated value exceeds 30 characters, CyberSource Latin American Processing declines the authorization request.\\ **Note** CyberSource Latin American Processing is the name of a specific processing connection that CyberSource supports. In the CyberSource API documentation, CyberSource Latin American Processing does not refer to the general topic of processing in Latin America. The information in this field description is for the specific processing connection called CyberSource Latin American Processing. It is not for any other Latin American processors that CyberSource supports.  #### CyberSource through VisaNet Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.  #### For Payouts: This field may be sent only for FDC Compass.  #### OmniPay Direct Optional field.  #### RBS WorldPay Atlanta Optional field.  #### SIX Optional field.  #### TSYS Acquiring Solutions Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.  #### Worldpay VAP Optional field.  #### All other processors Not used. 
    */
    'lastName'?: string;
    /**
    * Customer’s middle name. 
    */
    'middleName'?: string;
    /**
    * Customer’s name suffix. 
    */
    'nameSuffix'?: string;
    /**
    * Payment card billing street address as it appears on the credit card issuer’s records.  #### SEPA Required for Create Mandate and Import Mandate  #### Atos This field must not contain colons (:).  #### CyberSource through VisaNet **Important** When you populate orderInformation.billTo.address1 and orderInformation.billTo.address2, CyberSource through VisaNet concatenates the two values. If the concatenated value exceeds 40 characters, CyberSource through VisaNet truncates the value at 40 characters before sending it to Visa and the issuing bank. Truncating this value affects AVS results and therefore might also affect risk decisions and chargebacks. Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.  #### FDMS Nashville When the street name is numeric, it must be sent in numeric format. For example, if the address is _One First Street_, it must be sent as _1 1st Street_.  Required if keyed; not used if swiped.  String (20)  #### TSYS Acquiring Solutions Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.  #### All other processors: Optional. String (60)  #### For Payouts This field may be sent only for FDC Compass.  **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting. 
    */
    'address1'?: string;
    /**
    * Used for additional address information. For example: _Attention: Accounts Payable_ Optional field.  For Payouts: This field may be sent only for FDC Compass.  #### Atos This field must not contain colons (:).  #### CyberSource through VisaNet **Important** When you populate `orderInformation.billTo.address1` and `orderInformation.billTo.address2`, CyberSource through VisaNet concatenates the two values. If the concatenated value exceeds 40 characters, CyberSource through VisaNet truncates the value at 40 characters before sending it to Visa and the issuing bank. Truncating this value affects AVS results and therefore might also affect risk decisions and chargebacks. Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.  #### Chase Paymentech Solutions, FDC Compass, and TSYS Acquiring Solutions This value is used for AVS.  #### FDMS Nashville `orderInformation.billTo.address1` and `orderInformation.billTo.address2` together cannot exceed 20 characters. String (20)  #### All Other Processors String (60) 
    */
    'address2'?: string;
    /**
    * Payment card billing city.  #### SEPA Required for Create Mandate and Import Mandate  #### Atos This field must not contain colons (:).  #### CyberSource through VisaNet Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.  #### For Payouts: This field may be sent only for FDC Compass.  #### Chase Paymentech Solutions Optional field.  ####  Credit Mutuel-CIC Optional field.  #### OmniPay Direct Optional field.  #### SIX Optional field.  #### TSYS Acquiring Solutions Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.  #### Worldpay VAP Optional field.  #### All other processors Not used. 
    */
    'locality'?: string;
    /**
    * State or province of the billing address. Use the [State, Province, and Territory Codes for the United States and Canada](https://developer.cybersource.com/library/documentation/sbc/quickref/states_and_provinces.pdf).  For Payouts: This field may be sent only for FDC Compass.  ##### CyberSource through VisaNet Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.  **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.  #### Chase Paymentech Solutions Optional field.  ####  Credit Mutuel-CIC Optional field.  #### OmniPay Direct Optional field.  #### SIX Optional field.  #### TSYS Acquiring Solutions Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.  #### Worldpay VAP Optional field.  #### All other processors Not used. 
    */
    'administrativeArea'?: string;
    /**
    * Postal code for the billing address. The postal code must consist of 5 to 9 digits.  When the billing country is the U.S., the 9-digit postal code must follow this format: [5 digits][dash][4 digits]  **Example** `12345-6789`  When the billing country is Canada, the 6-digit postal code must follow this format: [alpha][numeric][alpha][space][numeric][alpha][numeric]  **Example** `A1B 2C3`  **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.  #### SEPA Required for Create Mandate and Import Mandate  #### For Payouts:  This field may be sent only for FDC Compass.  #### American Express Direct Before sending the postal code to the processor, CyberSource removes all nonalphanumeric characters and, if the remaining value is longer than nine characters, truncates the value starting from the right side.  #### Atos This field must not contain colons (:).  #### CyberSource through VisaNet Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.  #### FDMS Nashville Required if `pointOfSaleInformation.entryMode=keyed` and the address is in the U.S. or Canada. Optional if `pointOfSaleInformation.entryMode=keyed` and the address is **not** in the U.S. or Canada. Not used if swiped.  #### RBS WorldPay Atlanta: For best card-present keyed rates, send the postal code if `pointOfSaleInformation.entryMode=keyed`.  #### TSYS Acquiring Solutions Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.  #### All other processors: Optional field. 
    */
    'postalCode'?: string;
    /**
    * Name of the customer’s company.  **CyberSource through VisaNet** Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks. 
    */
    'company'?: string;
    /**
    * Customer's email address, including the full domain name.  #### CyberSource through VisaNet Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.  **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.  #### Invoicing Email address for the customer for sending the invoice. If the invoice is in SENT status and email is updated, the old email customer payment link won't work and you must resend the invoice with the new payment link.  #### Chase Paymentech Solutions Optional field.  ####  Credit Mutuel-CIC Optional field.  #### OmniPay Direct Optional field.  #### SIX Optional field.  #### TSYS Acquiring Solutions Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.  #### Worldpay VAP Optional field.  #### All other processors Not used. 
    */
    'email'?: string;
    /**
    * Payment card billing country. Use the two-character [ISO Standard Country Codes](http://apps.cybersource.com/library/documentation/sbc/quickref/countries_alpha_list.pdf).  #### SEPA/BACS Required for Create Mandate and Import Mandate  #### CyberSource through VisaNet Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.  **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.  #### Chase Paymentech Solutions Optional field.  ####  Credit Mutuel-CIC Optional field.  #### OmniPay Direct Optional field.  #### SIX Optional field.  #### TSYS Acquiring Solutions Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.  #### Worldpay VAP Optional field.  #### All other processors Not used. 
    */
    'country'?: string;
    /**
    * Title. 
    */
    'title'?: string;
    /**
    * Customer’s phone number.  It is recommended that you include the country code when the order is from outside the U.S.  #### Chase Paymentech Solutions Optional field.  ####  Credit Mutuel-CIC Optional field.  #### CyberSource through VisaNet Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.  #### For Payouts: This field may be sent only for FDC Compass.  #### OmniPay Direct Optional field.  #### SIX Optional field.  #### TSYS Acquiring Solutions Optional field.  #### Worldpay VAP Optional field.  #### All other processors Not used. 
    */
    'phoneNumber'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "firstName",
            "baseName": "firstName",
            "type": "string"
        },
        {
            "name": "lastName",
            "baseName": "lastName",
            "type": "string"
        },
        {
            "name": "middleName",
            "baseName": "middleName",
            "type": "string"
        },
        {
            "name": "nameSuffix",
            "baseName": "nameSuffix",
            "type": "string"
        },
        {
            "name": "address1",
            "baseName": "address1",
            "type": "string"
        },
        {
            "name": "address2",
            "baseName": "address2",
            "type": "string"
        },
        {
            "name": "locality",
            "baseName": "locality",
            "type": "string"
        },
        {
            "name": "administrativeArea",
            "baseName": "administrativeArea",
            "type": "string"
        },
        {
            "name": "postalCode",
            "baseName": "postalCode",
            "type": "string"
        },
        {
            "name": "company",
            "baseName": "company",
            "type": "string"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "country",
            "baseName": "country",
            "type": "string"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "phoneNumber",
            "baseName": "phoneNumber",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TssV2TransactionsGet200ResponseOrderInformationBillTo.attributeTypeMap;
    }
}

export class TssV2TransactionsGet200ResponseOrderInformationInvoiceDetails {
    /**
    * Transaction identifier that is generated. You have the option of printing the sales slip number on the receipt. This field is supported only on Cybersource through Visanet and JCN gateway.  Optional field.  #### Card Present processing message If you included this field in the request, the returned value is the value that you sent in the request. If you did not include this field in the request, the system generated this value for you.  The difference between this reply field and the `processorInformation.systemTraceAuditNumber` field is that the system generates the system trace audit number (STAN), and you must print the receipt number on the receipt; whereas you can generate the sales slip number, and you can choose to print the sales slip number on the receipt. 
    */
    'salesSlipNumber'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "salesSlipNumber",
            "baseName": "salesSlipNumber",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return TssV2TransactionsGet200ResponseOrderInformationInvoiceDetails.attributeTypeMap;
    }
}

export class TssV2TransactionsGet200ResponseOrderInformationLineItems {
    /**
    * Type of product. This value is used to determine the category that the product is in: electronic, handling, physical, service, or shipping. The default value is **default**.  For a payment, when you set this field to a value other than default or any of the values related to shipping and handling, below fields _quantity_, _productName_, and _productSKU_ are required. 
    */
    'productCode'?: string;
    /**
    * For PAYMENT and CAPTURE API, this field is required when above _productCode_ is not **default** or one of the values related to shipping and handling. 
    */
    'productName'?: string;
    /**
    * Identification code for the product. For Payment and Capture APIs, this field is required when above `productCode` is not **default** or one of the values related to shipping and/or handling. 
    */
    'productSku'?: string;
    /**
    * Total tax to apply to the product. This value cannot be negative. The tax amount and the offer amount must be in the same currency. The tax amount field is additive.  The following example uses a two-exponent currency such as USD:  1. You include each line item in your request.     - 1st line item has `amount=10.00`, `quantity=1`, and `taxAmount=0.80`     - 2nd line item has `amount=20.00`, `quantity=1`, and `taxAmount=1.60` 2. The total amount authorized will be 32.40, not 30.00 with 2.40 of tax included.  This field is frequently used for Level II and Level III transactions. 
    */
    'taxAmount'?: string;
    /**
    * For a payment or capture, this field is required when _productCode_ is not **default** or one of the values related to shipping and handling. 
    */
    'quantity'?: number;
    /**
    * Per-item price of the product. This value cannot be negative. You can include a decimal point (.), but you cannot include any other special characters. CyberSource truncates the amount to the correct number of decimal places. 
    */
    'unitPrice'?: string;
    /**
    * The description for this field is not available.
    */
    'fulfillmentType'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "productCode",
            "baseName": "productCode",
            "type": "string"
        },
        {
            "name": "productName",
            "baseName": "productName",
            "type": "string"
        },
        {
            "name": "productSku",
            "baseName": "productSku",
            "type": "string"
        },
        {
            "name": "taxAmount",
            "baseName": "taxAmount",
            "type": "string"
        },
        {
            "name": "quantity",
            "baseName": "quantity",
            "type": "number"
        },
        {
            "name": "unitPrice",
            "baseName": "unitPrice",
            "type": "string"
        },
        {
            "name": "fulfillmentType",
            "baseName": "fulfillmentType",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TssV2TransactionsGet200ResponseOrderInformationLineItems.attributeTypeMap;
    }
}

export class TssV2TransactionsGet200ResponseOrderInformationShipTo {
    /**
    * First name of the recipient.  #### Litle Maximum length: 25  #### All other processors Maximum length: 60  Optional field. 
    */
    'firstName'?: string;
    /**
    * Last name of the recipient.  #### Litle Maximum length: 25  #### All other processors Maximum length: 60  Optional field. 
    */
    'lastName'?: string;
    /**
    * First line of the shipping address.  Required field for authorization if any shipping address information is included in the request; otherwise, optional.  #### Tax Calculation Optional field for U.S. and Canadian taxes. Not applicable to international and value added taxes. Billing address objects will be used to determine the cardholder’s location when shipTo objects are not present. 
    */
    'address1'?: string;
    /**
    * Second line of the shipping address.  Optional field.  #### Tax Calculation Optional field for U.S. and Canadian taxes. Not applicable to international and value added taxes. Billing address objects will be used to determine the cardholder’s location when shipTo objects are not present. 
    */
    'address2'?: string;
    /**
    * City of the shipping address.  Required field for authorization if any shipping address information is included in the request and shipping to the U.S. or Canada; otherwise, optional.  #### Tax Calculation Optional field for U.S. and Canadian taxes. Not applicable to international and value added taxes. Billing address objects will be used to determine the cardholder’s location when shipTo objects are not present. 
    */
    'locality'?: string;
    /**
    * State or province of the billing address. Use the [State, Province, and Territory Codes for the United States and Canada](https://developer.cybersource.com/library/documentation/sbc/quickref/states_and_provinces.pdf).  For Payouts: This field may be sent only for FDC Compass.  ##### CyberSource through VisaNet Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.  **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.  #### Chase Paymentech Solutions Optional field.  ####  Credit Mutuel-CIC Optional field.  #### OmniPay Direct Optional field.  #### SIX Optional field.  #### TSYS Acquiring Solutions Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.  #### Worldpay VAP Optional field.  #### All other processors Not used. 
    */
    'administrativeArea'?: string;
    /**
    * Postal code for the shipping address. The postal code must consist of 5 to 9 digits.  Required field for authorization if any shipping address information is included in the request and shipping to the U.S. or Canada; otherwise, optional.  When the billing country is the U.S., the 9-digit postal code must follow this format: [5 digits][dash][4 digits]  Example 12345-6789  When the billing country is Canada, the 6-digit postal code must follow this format: [alpha][numeric][alpha][space][numeric][alpha][numeric]  Example A1B 2C3  #### American Express Direct Before sending the postal code to the processor, all nonalphanumeric characters are removed and, if the remaining value is longer than nine characters, the value is truncated starting from the right side. #### Tax Calculation Optional field for U.S. and Canadian taxes. Not applicable to international and value added taxes. Billing address objects will be used to determine the cardholder’s location when shipTo objects are not present. 
    */
    'postalCode'?: string;
    /**
    * Name of the customer’s company. 
    */
    'company'?: string;
    /**
    * Country of the shipping address. Use the two-character [ISO Standard Country Codes.](http://apps.cybersource.com/library/documentation/sbc/quickref/countries_alpha_list.pdf)  Required field for authorization if any shipping address information is included in the request; otherwise, optional.  #### Tax Calculation Optional field for U.S., Canadian, international tax, and value added taxes. Billing address objects will be used to determine the cardholder’s location when shipTo objects are not present. 
    */
    'country'?: string;
    /**
    * Phone number associated with the shipping address.
    */
    'phoneNumber'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "firstName",
            "baseName": "firstName",
            "type": "string"
        },
        {
            "name": "lastName",
            "baseName": "lastName",
            "type": "string"
        },
        {
            "name": "address1",
            "baseName": "address1",
            "type": "string"
        },
        {
            "name": "address2",
            "baseName": "address2",
            "type": "string"
        },
        {
            "name": "locality",
            "baseName": "locality",
            "type": "string"
        },
        {
            "name": "administrativeArea",
            "baseName": "administrativeArea",
            "type": "string"
        },
        {
            "name": "postalCode",
            "baseName": "postalCode",
            "type": "string"
        },
        {
            "name": "company",
            "baseName": "company",
            "type": "string"
        },
        {
            "name": "country",
            "baseName": "country",
            "type": "string"
        },
        {
            "name": "phoneNumber",
            "baseName": "phoneNumber",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TssV2TransactionsGet200ResponseOrderInformationShipTo.attributeTypeMap;
    }
}

export class TssV2TransactionsGet200ResponseOrderInformationShippingDetails {
    /**
    * Boolean that indicates whether the customer requested gift wrapping for this purchase. This field can contain one of the following values: - true: The customer requested gift wrapping. - false: The customer did not request gift wrapping. 
    */
    'giftWrap'?: boolean;
    /**
    * Shipping method for the product. Possible values:   - `lowcost`: Lowest-cost service  - `sameday`: Courier or same-day service  - `oneday`: Next-day or overnight service  - `twoday`: Two-day service  - `threeday`: Three-day service  - `pickup`: Store pick-up  - `other`: Other shipping method  - `none`: No shipping method because product is a service or subscription 
    */
    'shippingMethod'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "giftWrap",
            "baseName": "giftWrap",
            "type": "boolean"
        },
        {
            "name": "shippingMethod",
            "baseName": "shippingMethod",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TssV2TransactionsGet200ResponseOrderInformationShippingDetails.attributeTypeMap;
    }
}

export class TssV2TransactionsGet200ResponsePaymentInformation {
    'paymentType'?: TssV2TransactionsGet200ResponsePaymentInformationPaymentType;
    'customer'?: TssV2TransactionsGet200ResponsePaymentInformationCustomer;
    'card'?: TssV2TransactionsGet200ResponsePaymentInformationCard;
    /**
    * This array contains the supported brands. 
    */
    'brands'?: Array<TssV2TransactionsGet200ResponsePaymentInformationBrands>;
    'features'?: TssV2TransactionsGet200ResponsePaymentInformationFeatures;
    'invoice'?: TssV2TransactionsGet200ResponsePaymentInformationInvoice;
    'network'?: TssV2TransactionsGet200ResponsePaymentInformationNetwork;
    'issuerInformation'?: TssV2TransactionsGet200ResponsePaymentInformationIssuerInformation;
    'bank'?: TssV2TransactionsGet200ResponsePaymentInformationBank;
    'accountFeatures'?: TssV2TransactionsGet200ResponsePaymentInformationAccountFeatures;
    'paymentInstrument'?: PtsV2PaymentsPost201ResponseTokenInformationPaymentInstrument;
    'instrumentIdentifier'?: TssV2TransactionsGet200ResponsePaymentInformationInstrumentIdentifier;
    'shippingAddress'?: PtsV2PaymentsPost201ResponseTokenInformationShippingAddress;
    'fluidData'?: TssV2TransactionsGet200ResponsePaymentInformationFluidData;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "paymentType",
            "baseName": "paymentType",
            "type": "TssV2TransactionsGet200ResponsePaymentInformationPaymentType"
        },
        {
            "name": "customer",
            "baseName": "customer",
            "type": "TssV2TransactionsGet200ResponsePaymentInformationCustomer"
        },
        {
            "name": "card",
            "baseName": "card",
            "type": "TssV2TransactionsGet200ResponsePaymentInformationCard"
        },
        {
            "name": "brands",
            "baseName": "brands",
            "type": "Array<TssV2TransactionsGet200ResponsePaymentInformationBrands>"
        },
        {
            "name": "features",
            "baseName": "features",
            "type": "TssV2TransactionsGet200ResponsePaymentInformationFeatures"
        },
        {
            "name": "invoice",
            "baseName": "invoice",
            "type": "TssV2TransactionsGet200ResponsePaymentInformationInvoice"
        },
        {
            "name": "network",
            "baseName": "network",
            "type": "TssV2TransactionsGet200ResponsePaymentInformationNetwork"
        },
        {
            "name": "issuerInformation",
            "baseName": "issuerInformation",
            "type": "TssV2TransactionsGet200ResponsePaymentInformationIssuerInformation"
        },
        {
            "name": "bank",
            "baseName": "bank",
            "type": "TssV2TransactionsGet200ResponsePaymentInformationBank"
        },
        {
            "name": "accountFeatures",
            "baseName": "accountFeatures",
            "type": "TssV2TransactionsGet200ResponsePaymentInformationAccountFeatures"
        },
        {
            "name": "paymentInstrument",
            "baseName": "paymentInstrument",
            "type": "PtsV2PaymentsPost201ResponseTokenInformationPaymentInstrument"
        },
        {
            "name": "instrumentIdentifier",
            "baseName": "instrumentIdentifier",
            "type": "TssV2TransactionsGet200ResponsePaymentInformationInstrumentIdentifier"
        },
        {
            "name": "shippingAddress",
            "baseName": "shippingAddress",
            "type": "PtsV2PaymentsPost201ResponseTokenInformationShippingAddress"
        },
        {
            "name": "fluidData",
            "baseName": "fluidData",
            "type": "TssV2TransactionsGet200ResponsePaymentInformationFluidData"
        }    ];

    static getAttributeTypeMap() {
        return TssV2TransactionsGet200ResponsePaymentInformation.attributeTypeMap;
    }
}

export class TssV2TransactionsGet200ResponsePaymentInformationAccountFeatures {
    /**
    * Remaining balance on the account.  Returned by authorization service.  #### PIN debit Remaining balance on the prepaid card.  Returned by PIN debit purchase. 
    */
    'balanceAmount'?: string;
    /**
    * Remaining balance on the account.  Returned by authorization service.  #### PIN debit Remaining balance on the prepaid card.  Returned by PIN debit purchase. 
    */
    'previousBalanceAmount'?: string;
    /**
    * Currency of the remaining balance on the account. For the possible values, see the [ISO Standard Currency Codes.](http://apps.cybersource.com/library/documentation/sbc/quickref/currencies.pdf)  Returned by authorization service.  #### PIN debit Currency of the remaining balance on the prepaid card.  Returned by PIN debit purchase. 
    */
    'currency'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "balanceAmount",
            "baseName": "balanceAmount",
            "type": "string"
        },
        {
            "name": "previousBalanceAmount",
            "baseName": "previousBalanceAmount",
            "type": "string"
        },
        {
            "name": "currency",
            "baseName": "currency",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TssV2TransactionsGet200ResponsePaymentInformationAccountFeatures.attributeTypeMap;
    }
}

export class TssV2TransactionsGet200ResponsePaymentInformationBank {
    /**
    * Bank routing number. This is also called the transit number. 
    */
    'routingNumber'?: string;
    /**
    * Code used to identify the branch of the customer’s bank. Required for some countries if you do not or are not allowed to provide the IBAN. Use this field only when scoring a direct debit transaction. 
    */
    'branchCode'?: string;
    /**
    * Bank’s SWIFT code. You can use this field only when scoring a direct debit transaction. Required only for crossborder transactions. 
    */
    'swiftCode'?: string;
    /**
    * Country-specific code used to identify the customer’s bank. Required for some countries if you do not or are not allowed to provide the IBAN instead. You can use this field only when scoring a direct debit transaction. 
    */
    'bankCode'?: string;
    /**
    * International Bank Account Number (IBAN) for the bank account. For some countries you can provide this number instead of the traditional bank account information. You can use this field only when scoring a direct debit transaction. 
    */
    'iban'?: string;
    'account'?: TssV2TransactionsGet200ResponsePaymentInformationBankAccount;
    'mandate'?: TssV2TransactionsGet200ResponsePaymentInformationBankMandate;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "routingNumber",
            "baseName": "routingNumber",
            "type": "string"
        },
        {
            "name": "branchCode",
            "baseName": "branchCode",
            "type": "string"
        },
        {
            "name": "swiftCode",
            "baseName": "swiftCode",
            "type": "string"
        },
        {
            "name": "bankCode",
            "baseName": "bankCode",
            "type": "string"
        },
        {
            "name": "iban",
            "baseName": "iban",
            "type": "string"
        },
        {
            "name": "account",
            "baseName": "account",
            "type": "TssV2TransactionsGet200ResponsePaymentInformationBankAccount"
        },
        {
            "name": "mandate",
            "baseName": "mandate",
            "type": "TssV2TransactionsGet200ResponsePaymentInformationBankMandate"
        }    ];

    static getAttributeTypeMap() {
        return TssV2TransactionsGet200ResponsePaymentInformationBank.attributeTypeMap;
    }
}

export class TssV2TransactionsGet200ResponsePaymentInformationBankAccount {
    /**
    * Last four digits of the customer’s payment account number. 
    */
    'suffix'?: string;
    /**
    * Bank Identification Number (BIN). This is the initial four to six numbers on a credit card account number. 
    */
    'prefix'?: string;
    /**
    * Check number.  Chase Paymentech Solutions - Optional. CyberSource ACH Service - Not used. RBS WorldPay Atlanta - Optional on debits. Required on credits. TeleCheck - Strongly recommended on debit requests. Optional on credits. 
    */
    'checkNumber'?: string;
    /**
    * Account type.  Possible values:  - **C**: Checking.  - **G**: General ledger. This value is supported only on Wells Fargo ACH.  - **S**: Savings (U.S. dollars only).  - **X**: Corporate checking (U.S. dollars only). 
    */
    'type'?: string;
    /**
    * Name used on the bank account. You can use this field only when scoring a direct debit transaction 
    */
    'name'?: string;
    /**
    * Code used to validate the customer’s account number. Required for some countries if you do not or are not allowed to provide the IBAN instead. You may use this field only when scoring a direct debit transaction. 
    */
    'checkDigit'?: string;
    /**
    * Identifier for the bank that provided the customer’s encoded account number.  To obtain the bank identifier, contact your processor. 
    */
    'encoderId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "suffix",
            "baseName": "suffix",
            "type": "string"
        },
        {
            "name": "prefix",
            "baseName": "prefix",
            "type": "string"
        },
        {
            "name": "checkNumber",
            "baseName": "checkNumber",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "checkDigit",
            "baseName": "checkDigit",
            "type": "string"
        },
        {
            "name": "encoderId",
            "baseName": "encoderId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TssV2TransactionsGet200ResponsePaymentInformationBankAccount.attributeTypeMap;
    }
}

export class TssV2TransactionsGet200ResponsePaymentInformationBankMandate {
    /**
    * Unique value generated by CyberSource that identifies the transaction. Use this value to identify transactions in the Collections Report, which provides settlement information.  For details, see the `direct_debit_reconciliation_reference_number` reply field description in [Ingenico ePayments Developer Guide For Direct Debits.](https://apps.cybersource.com/library/documentation/dev_guides/Ingenico_ePayments_Dev/html/) 
    */
    'referenceNumber'?: string;
    /**
    * Whether the direct debit is the first or last direct debit associated with the mandate, or one in between. Required only for the United Kingdom. Possible values: - `001`: First direct debit associated with this mandate. Use this value if a one-time direct debit). - `002`: Subsequent direct debits associated with this mandate. - `003`: Last direct debit associated with this mandate.  For details, see the `direct_debit_recurring_type` request field description in [Ingenico ePayments Developer Guide For Direct Debits.](https://apps.cybersource.com/library/documentation/dev_guides/Ingenico_ePayments_Dev/html/) 
    */
    'recurringType'?: string;
    /**
    * The mandate ID. Required only for the United Kingdom.  For details, see the `mandate_id` request field description in [Ingenico ePayments Developer Guide For Direct Debits.](https://apps.cybersource.com/library/documentation/dev_guides/Ingenico_ePayments_Dev/html/) 
    */
    'id'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "referenceNumber",
            "baseName": "referenceNumber",
            "type": "string"
        },
        {
            "name": "recurringType",
            "baseName": "recurringType",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TssV2TransactionsGet200ResponsePaymentInformationBankMandate.attributeTypeMap;
    }
}

export class TssV2TransactionsGet200ResponsePaymentInformationBrands {
    /**
    * Three-digit value that indicates the card type.  **IMPORTANT** It is strongly recommended that you include the card type field in request messages even if it is optional for your processor and card type. Omitting the card type can cause the transaction to be processed with the wrong card type.  Possible values: - `001`: Visa. Use card type value `001` for Visa Electron. - `002`: Mastercard, Eurocard[^1], which is a European regional brand of Mastercard. - `003`: American Express - `004`: Discover - `005`: Diners Club - `006`: Carte Blanche[^1] - `007`: JCB[^1] - `008`: Optima - `009`: GE Private Label - `010`: Beneficial Private Label - `011`: Twinpay Credit Card - `012`: Twinpay Debit Card - `013`: WalMart - `014`: Enroute[^1] - `015`: Lowe's Consumer - `016`: Home Depot Consumer - `017`: MBNA - `018`: Dick's Sportswear - `019`: Casual Corner - `020`: Sears - `021`: JAL[^1] - `023`: Disney Card - `024`: Maestro (UK Domestic)[^1] - `025`: Sam's Club Consumer - `026`: Sam's Club Business - `027`: Nico's - `028`: Paymentech Bill Me Later - `029`: Bebe - `030`: Restoration Hardware - `031`: Delta Online - `032`: Solo - `033`: Visa Electron[^1]. Do not use this value. Use `001` for all Visa card types. - `034`: Dankort[^1] - `035`: Laser - `036`: Cartes Bancaires[^1,4] - `037`: Carta Si[^1] - `038`: Pinless Debit - `039`: Encoded account number[^1] - `040`: UATP[^1] - `041`: HOUSEHOLD - `042`: Maestro (International)[^1] - `043`: GE MONEY - `044`: Korean Cards - `045`: Style Cards - `046`: JCrew - `047`: Payeasecn eWallet - `048`: Payeasecn Bank Transfer - `049`: Meijer - `050`: Hipercard[^2,3] - `051`: Aura - `052`: Redecard - `053`: Orico card - `054`: Elo[^3] - `055`: Capitol One Private Label - `056`: Carnet - `057`: Costco Private Label - `058`: Carnet - `059`: ValueLink - `060`: MADA - `061`: RuPay - `062`: China UnionPay - `063`: Falabella Private Label - `064`: Prompt Card - `065`: Korean Domestic - `066`: Banricompras - `067`: MEEZA - `068`: PayPak - `070`: EFTPOS - `071`: Codensa - `072`: Olimpica - `073`: Colsubsidio - `074`: Tuya - `075`: Sodexo - `076`: Naranja - `077`: Cabal - `078`: DINELCO - `079`: PANAL - `080`: EPM - `081`: Jaywan  [^1]: For this card type, you must include the `paymentInformation.card.type` or `paymentInformation.tokenizedCard.type` field in your request for an authorization or a stand-alone credit. [^2]: For this card type on Cielo 3.0, you must include the `paymentInformation.card.type` or `paymentInformation.tokenizedCard.type` field in a request for an authorization or a stand-alone credit. This card type is not supported on Cielo 1.5. [^3]: For this card type on Getnet and Rede, you must include the `paymentInformation.card.type` or `paymentInformation.tokenizedCard.type` field in a request for an authorization or a stand-alone credit. [^4]: For this card type, you must include the `paymentInformation.card.type` in your request for any payer authentication services.  #### Used by **Authorization** Required for Carte Blanche and JCB. Optional for all other card types.  #### Card Present reply This field is included in the reply message when the client software that is installed on the POS terminal uses the token management service (TMS) to retrieve tokenized payment details. You must contact customer support to have your account enabled to receive these fields in the credit reply message.  Returned by the Credit service.  This reply field is only supported by the following processors: - American Express Direct - Credit Mutuel-CIC - FDC Nashville Global - OmniPay Direct - SIX  #### Google Pay transactions For PAN-based Google Pay transactions, this field is returned in the API response.  #### GPX This field only supports transactions from the following card types: - Visa - Mastercard - AMEX - Discover - Diners - JCB - Union Pay International 
    */
    'type'?: string;
    /**
    * This field contains the card brand name.   Some of the possible values (not an exhaustive list) are -    - VISA   - MASTERCARD   - AMERICAN EXPRESS   - DISCOVER   - DINERS CLUB   - CARTE BLANCHE   - JCB   - OPTIMA   - TWINPAY CREDIT CARD   - TWINPAY DEBIT CARD   - WALMART   - ENROUTE   - LOWES CONSUMER   - HOME DEPOT CONSUMER   - MBNA   - DICKS SPORTWEAR   - CASUAL CORNER   - SEARS   - JAL   - DISNEY CARD   - SWITCH/SOLO   - SAMS CLUB CONSUMER   - SAMS CLUB BUSINESS   - NICOS HOUSE CARD   - BEBE   - RESTORATION HARDWARE   - DELTA ONLINE   - SOLO   - VISA ELECTRON   - DANKORT   - LASER   - CARTE BANCAIRE   - CARTA SI   - ENCODED ACCOUNT   - UATP   - HOUSEHOLD   - MAESTRO   - GE CAPITAL   - KOREAN CARDS   - STYLE CARDS   - JCREW   - MEIJER   - HIPERCARD   - AURA   - REDECARD   - ORICO HOUSE CARD   - ELO   - CAPITAL ONE PRIVATE LABEL   - CARNET   - RUPAY   - CHINA UNION PAY   - FALABELLA PRIVATE LABEL   - PROMPTCARD   - KOREAN DOMESTIC   - BANRICOMPRAS 
    */
    'brandName'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "brandName",
            "baseName": "brandName",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TssV2TransactionsGet200ResponsePaymentInformationBrands.attributeTypeMap;
    }
}

export class TssV2TransactionsGet200ResponsePaymentInformationCard {
    /**
    * Last four digits of the cardholder’s account number. This field is included in the reply message when the client software that is installed on the POS terminal uses the token management service (TMS) to retrieve tokenized payment details.  You must contact customer support to have your account enabled to receive these fields in the credit reply message.  #### Google Pay transactions For PAN-based Google Pay transactions, this field is returned in the API response.  #### PIN debit This field is returned only for tokenized transactions. You can use this value on the receipt that you give to the cardholder.  Returned by PIN debit credit and PIN debit purchase.  This field is supported only by the following processors: - American Express Direct - Credit Mutuel-CIC - FDC Nashville Global - OmniPay Direct - SIX 
    */
    'suffix'?: string;
    /**
    * Bank Identification Number (BIN). This is the initial four to six numbers on a credit card account number.  #### Google Pay transactions For PAN-based Google Pay transactions, this field is returned in the API response. 
    */
    'prefix'?: string;
    /**
    * Two-digit month in which the payment card expires.  Format: `MM`.  Valid values: `01` through `12`. Leading 0 is required.  #### Barclays and Streamline For Maestro (UK Domestic) and Maestro (International) cards on Barclays and Streamline, this must be a valid value (`01` through `12`) but is not required to be a valid expiration date. In other words, an expiration date that is in the past does not cause CyberSource to reject your request. However, an invalid expiration date might cause the issuer to reject your request.  #### Encoded Account Numbers For encoded account numbers (_type_=039), if there is no expiration date on the card, use `12`.  #### FDMS Nashville Required field.  #### All other processors Required if `pointOfSaleInformation.entryMode=keyed`. However, this field is optional if your account is configured for relaxed requirements for address data and expiration date. **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.  #### Google Pay transactions For PAN-based Google Pay transactions, this field is returned in the API response. 
    */
    'expirationMonth'?: string;
    /**
    * Four-digit year in which the payment card expires.  Format: `YYYY`.  #### Barclays and Streamline For Maestro (UK Domestic) and Maestro (International) cards on Barclays and Streamline, this must be a valid value (`1900` through `3000`) but is not required to be a valid expiration date. In other words, an expiration date that is in the past does not cause CyberSource to reject your request. However, an invalid expiration date might cause the issuer to reject your request.  #### Encoded Account Numbers For encoded account numbers (**_type_**`=039`), if there is no expiration date on the card, use `2021`.  #### FDMS Nashville Required field.  #### FDC Nashville Global and FDMS South You can send in 2 digits or 4 digits. If you send in 2 digits, they must be the last 2 digits of the year.  #### All other processors Required if `pointOfSaleInformation.entryMode=keyed`. However, this field is optional if your account is configured for relaxed requirements for address data and expiration date. **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.  #### Google Pay transactions For PAN-based Google Pay transactions, this field is returned in the API response. 
    */
    'expirationYear'?: string;
    /**
    * Month of the start of the Maestro (UK Domestic) card validity period. Do not include the field, even with a blank value, if the card is not a Maestro (UK Domestic) card. `Format: MM`. Possible values: 01 through 12.  **Note** The start date is not required for Maestro (UK Domestic) transactions. 
    */
    'startMonth'?: string;
    /**
    * Year of the start of the Maestro (UK Domestic) card validity period. Do not include the field, even with a blank value, if the card is not a Maestro (UK Domestic) card. `Format: YYYY`.  **Note** The start date is not required for Maestro (UK Domestic) transactions. 
    */
    'startYear'?: string;
    /**
    * Number of times a Maestro (UK Domestic) card has been issued to the account holder. The card might or might not have an issue number. The number can consist of one or two digits, and the first digit might be a zero. When you include this value in your request, include exactly what is printed on the card. A value of 2 is different than a value of 02. Do not include the field, even with a blank value, if the card is not a Maestro (UK Domestic) card.  **Note** The issue number is not required for Maestro (UK Domestic) transactions. 
    */
    'issueNumber'?: string;
    /**
    * Three-digit value that indicates the card type.  **IMPORTANT** It is strongly recommended that you include the card type field in request messages even if it is optional for your processor and card type. Omitting the card type can cause the transaction to be processed with the wrong card type.  Possible values: - `001`: Visa. Use card type value `001` for Visa Electron. - `002`: Mastercard, Eurocard[^1], which is a European regional brand of Mastercard. - `003`: American Express - `004`: Discover - `005`: Diners Club - `006`: Carte Blanche[^1] - `007`: JCB[^1] - `008`: Optima - `009`: GE Private Label - `010`: Beneficial Private Label - `011`: Twinpay Credit Card - `012`: Twinpay Debit Card - `013`: WalMart - `014`: Enroute[^1] - `015`: Lowe's Consumer - `016`: Home Depot Consumer - `017`: MBNA - `018`: Dick's Sportswear - `019`: Casual Corner - `020`: Sears - `021`: JAL[^1] - `023`: Disney Card - `024`: Maestro (UK Domestic)[^1] - `025`: Sam's Club Consumer - `026`: Sam's Club Business - `027`: Nico's - `028`: Paymentech Bill Me Later - `029`: Bebe - `030`: Restoration Hardware - `031`: Delta Online - `032`: Solo - `033`: Visa Electron[^1]. Do not use this value. Use `001` for all Visa card types. - `034`: Dankort[^1] - `035`: Laser - `036`: Cartes Bancaires[^1,4] - `037`: Carta Si[^1] - `038`: Pinless Debit - `039`: Encoded account number[^1] - `040`: UATP[^1] - `041`: HOUSEHOLD - `042`: Maestro (International)[^1] - `043`: GE MONEY - `044`: Korean Cards - `045`: Style Cards - `046`: JCrew - `047`: Payeasecn eWallet - `048`: Payeasecn Bank Transfer - `049`: Meijer - `050`: Hipercard[^2,3] - `051`: Aura - `052`: Redecard - `053`: Orico card - `054`: Elo[^3] - `055`: Capitol One Private Label - `056`: Carnet - `057`: Costco Private Label - `058`: Carnet - `059`: ValueLink - `060`: MADA - `061`: RuPay - `062`: China UnionPay - `063`: Falabella Private Label - `064`: Prompt Card - `065`: Korean Domestic - `066`: Banricompras - `067`: MEEZA - `068`: PayPak - `070`: EFTPOS - `071`: Codensa - `072`: Olimpica - `073`: Colsubsidio - `074`: Tuya - `075`: Sodexo - `076`: Naranja - `077`: Cabal - `078`: DINELCO - `079`: PANAL - `080`: EPM - `081`: Jaywan  [^1]: For this card type, you must include the `paymentInformation.card.type` or `paymentInformation.tokenizedCard.type` field in your request for an authorization or a stand-alone credit. [^2]: For this card type on Cielo 3.0, you must include the `paymentInformation.card.type` or `paymentInformation.tokenizedCard.type` field in a request for an authorization or a stand-alone credit. This card type is not supported on Cielo 1.5. [^3]: For this card type on Getnet and Rede, you must include the `paymentInformation.card.type` or `paymentInformation.tokenizedCard.type` field in a request for an authorization or a stand-alone credit. [^4]: For this card type, you must include the `paymentInformation.card.type` in your request for any payer authentication services.  #### Used by **Authorization** Required for Carte Blanche and JCB. Optional for all other card types.  #### Card Present reply This field is included in the reply message when the client software that is installed on the POS terminal uses the token management service (TMS) to retrieve tokenized payment details. You must contact customer support to have your account enabled to receive these fields in the credit reply message.  Returned by the Credit service.  This reply field is only supported by the following processors: - American Express Direct - Credit Mutuel-CIC - FDC Nashville Global - OmniPay Direct - SIX  #### Google Pay transactions For PAN-based Google Pay transactions, this field is returned in the API response.  #### GPX This field only supports transactions from the following card types: - Visa - Mastercard - AMEX - Discover - Diners - JCB - Union Pay International 
    */
    'type'?: string;
    /**
    * This field contains the card brand name.   Some of the possible values (not an exhaustive list) are -    - VISA   - MASTERCARD   - AMERICAN EXPRESS   - DISCOVER   - DINERS CLUB   - CARTE BLANCHE   - JCB   - OPTIMA   - TWINPAY CREDIT CARD   - TWINPAY DEBIT CARD   - WALMART   - ENROUTE   - LOWES CONSUMER   - HOME DEPOT CONSUMER   - MBNA   - DICKS SPORTWEAR   - CASUAL CORNER   - SEARS   - JAL   - DISNEY CARD   - SWITCH/SOLO   - SAMS CLUB CONSUMER   - SAMS CLUB BUSINESS   - NICOS HOUSE CARD   - BEBE   - RESTORATION HARDWARE   - DELTA ONLINE   - SOLO   - VISA ELECTRON   - DANKORT   - LASER   - CARTE BANCAIRE   - CARTA SI   - ENCODED ACCOUNT   - UATP   - HOUSEHOLD   - MAESTRO   - GE CAPITAL   - KOREAN CARDS   - STYLE CARDS   - JCREW   - MEIJER   - HIPERCARD   - AURA   - REDECARD   - ORICO HOUSE CARD   - ELO   - CAPITAL ONE PRIVATE LABEL   - CARNET   - RUPAY   - CHINA UNION PAY   - FALABELLA PRIVATE LABEL   - PROMPTCARD   - KOREAN DOMESTIC   - BANRICOMPRAS 
    */
    'brandName'?: string;
    /**
    * This field indicates the 3-letter [ISO Standard Currency Codes](http://apps.cybersource.com/library/documentation/sbc/quickref/currencies.pdf) for the card currency. 
    */
    'currency'?: string;
    /**
    * Identifier for the issuing bank that provided the customer’s encoded account number. Contact your processor for the bank’s ID. 
    */
    'accountEncoderId'?: string;
    /**
    * Flag that specifies the type of account associated with the card.  This field is available only for China UnionPay, Cielo, Comercio Latino and Visa Platform Connect. The cardholder provides this information during the payment process.  This field is required for:  - Debit transactions on Cielo and Comercio Latino.  - Transactions with Brazilian-issued cards on CyberSource through VisaNet.  **China UnionPayCard Transactions on China UnionPay:** Possible values:  - C: Domestic credit card  - D: Domestic debit card  - F: International credit card  - I: International debit card  When the value is D, the e-commerce indicator and CAVV fields must be included in the authorization request. When the value is C, F or I the card verification number, expiration month and expiration year fields must in included in the authorization request.  **Cielo and Comercio Latino Credit Card Transactions:** On these processors, this field is supported only for authorizations.  Possible values:  - CR: Credit card  - DB: Debit card       **Visa Platform Connect Credit Card Transactions:** This field is supported for all card types on Visa Platform Connect. For combo **card present** transactions with Mastercard on Brazilian-issued cards, possible values:  - CR: Credit card  - DB: Debit Card  For combo **card not present** transactions with Mastercard on Brazilian-issued cards, possible values:  - C: Credit card  - D: Debit card  A value of CR or DB in the useAs field takes precedence over any value in the Source Account Type field. 
    */
    'useAs'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "suffix",
            "baseName": "suffix",
            "type": "string"
        },
        {
            "name": "prefix",
            "baseName": "prefix",
            "type": "string"
        },
        {
            "name": "expirationMonth",
            "baseName": "expirationMonth",
            "type": "string"
        },
        {
            "name": "expirationYear",
            "baseName": "expirationYear",
            "type": "string"
        },
        {
            "name": "startMonth",
            "baseName": "startMonth",
            "type": "string"
        },
        {
            "name": "startYear",
            "baseName": "startYear",
            "type": "string"
        },
        {
            "name": "issueNumber",
            "baseName": "issueNumber",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "brandName",
            "baseName": "brandName",
            "type": "string"
        },
        {
            "name": "currency",
            "baseName": "currency",
            "type": "string"
        },
        {
            "name": "accountEncoderId",
            "baseName": "accountEncoderId",
            "type": "string"
        },
        {
            "name": "useAs",
            "baseName": "useAs",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TssV2TransactionsGet200ResponsePaymentInformationCard.attributeTypeMap;
    }
}

export class TssV2TransactionsGet200ResponsePaymentInformationCustomer {
    /**
    * Unique identifier for the customer's card and billing information.  When you use Payment Tokenization or Recurring Billing and you include this value in your request, many of the fields that are normally required for an authorization or credit become optional.  **NOTE** When you use Payment Tokenization or Recurring Billing, the value for the Customer ID is actually the Cybersource payment token for a customer. This token stores information such as the consumer’s card number so it can be applied towards bill payments, recurring payments, or one-time payments. By using this token in a payment API request, the merchant doesn't need to pass in data such as the card number or expiration date in the request itself. 
    */
    'customerId'?: string;
    /**
    * Unique identifier for the Customer token that was created as part of a bundled TOKEN_CREATE action. 
    */
    'id'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "customerId",
            "baseName": "customerId",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TssV2TransactionsGet200ResponsePaymentInformationCustomer.attributeTypeMap;
    }
}

export class TssV2TransactionsGet200ResponsePaymentInformationFeatures {
    /**
    * This field contains the account funding source. Possible values:   - `CREDIT`   - `DEBIT`   - `PREPAID`   - `DEFERRED DEBIT`   - `CHARGE` 
    */
    'accountFundingSource'?: string;
    /**
    * This field contains the type of prepaid card. Possible values:   - `Reloadable`   - `Non-reloadable` 
    */
    'accountFundingSourceSubType'?: string;
    /**
    * This field contains the type of issuer product. Example values:   - Visa Classic   - Visa Signature   - Visa Infinite 
    */
    'cardProduct'?: string;
    /**
    * This field contains the type of BIN based authentication. Possible values:   - `S`: Single Message   - `D`: Dual Message 
    */
    'messageType'?: string;
    /**
    * This field contains the acceptance level of the PAN. Possible values:   - `0` : Normal   - `1` : Monitor   - `2` : Refuse   - `3` : Not Allowed   - `4` : Private   - `5` : Test 
    */
    'acceptanceLevel'?: string;
    /**
    * This field contains the type of card platform. Possible values:   - `BUSINESS`   - `CONSUMER`   - `COMMERCIAL`   - `GOVERNMENT` 
    */
    'cardPlatform'?: string;
    /**
    * This field indicates the type of combo card. Possible values:   - 0 (Not a combo card)   - 1 (Credit and Prepaid Combo card)   - 2 (Credit and Debit Combo card) 
    */
    'comboCard'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "accountFundingSource",
            "baseName": "accountFundingSource",
            "type": "string"
        },
        {
            "name": "accountFundingSourceSubType",
            "baseName": "accountFundingSourceSubType",
            "type": "string"
        },
        {
            "name": "cardProduct",
            "baseName": "cardProduct",
            "type": "string"
        },
        {
            "name": "messageType",
            "baseName": "messageType",
            "type": "string"
        },
        {
            "name": "acceptanceLevel",
            "baseName": "acceptanceLevel",
            "type": "string"
        },
        {
            "name": "cardPlatform",
            "baseName": "cardPlatform",
            "type": "string"
        },
        {
            "name": "comboCard",
            "baseName": "comboCard",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TssV2TransactionsGet200ResponsePaymentInformationFeatures.attributeTypeMap;
    }
}

export class TssV2TransactionsGet200ResponsePaymentInformationFluidData {
    /**
    * The identifier for a payment solution, which is sending the encrypted payment data for decryption. Valid values: Samsung Pay: RklEPUNPTU1PTi5TQU1TVU5HLklOQVBQLlBBWU1FTlQ= Note: For other payment solutions, the value may be specific to the terminal or device initiatinf the payment. For example, the descriptor for a Bluefin payment encryption would be a device-generated descriptor. Used by Authorization and Standalone Credits. Required for authorizations and standalone credits.  Card Present processing: Format of the encrypted payment data. The value for Bluefin PCI P2PE is `Ymx1ZWZpbg==`. paymentInformation.fluidData.encoding must be `Base64`. The value for Cybersource P2PE decryption depends on the encoding method used and identified in encoding field. If paymentInformation.fluidData.encoding is `Base64`, the value is: `RklEPUVNVi5QQVlNRU5ULkFQSQ==` If paymentInformation.fluidData.encoding is `HEX`, the value is: `4649443D454D562E5041594D454E542E41504` 
    */
    'descriptor'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "descriptor",
            "baseName": "descriptor",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TssV2TransactionsGet200ResponsePaymentInformationFluidData.attributeTypeMap;
    }
}

export class TssV2TransactionsGet200ResponsePaymentInformationInstrumentIdentifier {
    /**
    * Unique identifier for the Instrument Identifier token that was created as part of a bundled TOKEN_CREATE action. 
    */
    'id'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TssV2TransactionsGet200ResponsePaymentInformationInstrumentIdentifier.attributeTypeMap;
    }
}

export class TssV2TransactionsGet200ResponsePaymentInformationInvoice {
    /**
    * Invoice Number.
    */
    'number'?: string;
    /**
    * Barcode Number.
    */
    'barcodeNumber'?: string;
    /**
    * Expiration Date.
    */
    'expirationDate'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "number",
            "baseName": "number",
            "type": "string"
        },
        {
            "name": "barcodeNumber",
            "baseName": "barcodeNumber",
            "type": "string"
        },
        {
            "name": "expirationDate",
            "baseName": "expirationDate",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TssV2TransactionsGet200ResponsePaymentInformationInvoice.attributeTypeMap;
    }
}

export class TssV2TransactionsGet200ResponsePaymentInformationIssuerInformation {
    /**
    * This field contains the issuer name. 
    */
    'name'?: string;
    /**
    * This field contains [2-character ISO Country Codes](http://apps.cybersource.com/library/documentation/sbc/quickref/countries_alpha_list.pdf) for the issuer. 
    */
    'country'?: string;
    /**
    * This field contains the length of the BIN. 
    */
    'binLength'?: string;
    /**
    * This field contains the customer service phone number for the issuer. 
    */
    'phoneNumber'?: string;
    /**
    * In a Mastercard Transaction, this field contains the unique identifier (Transaction Link ID) for the first transaction in a transaction life cycle.  This ID is crucial for maintaining continuity and linking subsequent operations to the original transaction. 
    */
    'transactionInformation'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "country",
            "baseName": "country",
            "type": "string"
        },
        {
            "name": "binLength",
            "baseName": "binLength",
            "type": "string"
        },
        {
            "name": "phoneNumber",
            "baseName": "phoneNumber",
            "type": "string"
        },
        {
            "name": "transactionInformation",
            "baseName": "transactionInformation",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TssV2TransactionsGet200ResponsePaymentInformationIssuerInformation.attributeTypeMap;
    }
}

export class TssV2TransactionsGet200ResponsePaymentInformationNetwork {
    /**
    * This field contains a code that identifies the network. Please refer [Network ID and Sharing Group Code](https://developer.visa.com/request_response_codes#network_id_and_sharing_group_code) 
    */
    'id'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TssV2TransactionsGet200ResponsePaymentInformationNetwork.attributeTypeMap;
    }
}

export class TssV2TransactionsGet200ResponsePaymentInformationPaymentType {
    /**
    * A Payment Type is an agreed means for a payee to receive legal tender from a payer. The way one pays for a commercial financial transaction. Examples: Card, Bank Transfer, Digital, Direct Debit. Possible values: - `CARD` (use this for a PIN debit transaction) - `CHECK` (use this for all eCheck payment transactions - ECP Debit, ECP Follow-on Credit, ECP StandAlone Credit) - `bankTransfer` (use for Online Bank Transafer for methods such as P24, iDeal, Estonia Bank, KCP) - `localCard` (KCP Local card via Altpay) - `carrierBilling` (KCP Carrier Billing via Altpay) 
    */
    'name'?: string;
    /**
    * Indicates the payment type used in this payment transaction. Example: credit card, check
    */
    'type'?: string;
    /**
    * Indicates the payment method used in this payment transaction.
    */
    'method'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "method",
            "baseName": "method",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TssV2TransactionsGet200ResponsePaymentInformationPaymentType.attributeTypeMap;
    }
}

export class TssV2TransactionsGet200ResponsePayoutOptions {
    /**
    * If true then provide attributes related to fund transfer/payouts. If payout information not found then response will have standard account lookup. Possible values: - `true` - `false` 
    */
    'payoutInquiry'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "payoutInquiry",
            "baseName": "payoutInquiry",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TssV2TransactionsGet200ResponsePayoutOptions.attributeTypeMap;
    }
}

export class TssV2TransactionsGet200ResponsePointOfSaleInformation {
    /**
    * Identifier for the terminal at your retail location. You can define this value yourself, but consult the processor for requirements.  #### CyberSource through VisaNet A list of all possible values is stored in your CyberSource account. If terminal ID validation is enabled for your CyberSource account, the value you send for this field is validated against the list each time you include the field in a request. To enable or disable terminal ID validation, contact CyberSource Customer Support.  When you do not include this field in a request, CyberSource uses the default value that is defined in your CyberSource account.  #### FDC Nashville Global To have your account configured to support this field, contact CyberSource Customer Support. This value must be a value that FDC Nashville Global issued to you.  #### For Payouts This field is applicable for CyberSource through VisaNet.  #### GPX Identifier for the terminal at your retail location. A list of all possible values is stored in your account. If terminal ID validation is enabled for your account, the value you send for this field is validated against the list each time you include the field in a request. To enable or disable terminal ID validation, contact customer support.  When you do not include this field in a request, the default value that is defined in your account is used.  Optional for authorizations.  #### Used by **Authorization** Optional for the following processors. When you do not include this field in a request, the default value that is defined in your account is used.   - American Express Direct   - Credit Mutuel-CIC   - FDC Nashville Global   - SIX - Chase Paymentech Solutions: Optional field. If you include this field in your request, you must also include `pointOfSaleInformation.catLevel`. - FDMS Nashville: The default value that is defined in your account is used. - GPX - OmniPay Direct: Optional field.  For the following processors, this field is not used. - GPN - JCN Gateway - RBS WorldPay Atlanta - TSYS Acquiring Solutions - Worldpay VAP  #### Card Present reply Terminal identifier assigned by the acquirer. This value must be printed on the receipt. 
    */
    'terminalId'?: string;
    /**
    * Method of entering payment card information into the POS terminal. Possible values:   - `contact`: Read from direct contact with chip card.  - `contactless`: Read from a contactless interface using chip data.  - `keyed`: Manually keyed into POS terminal. This value is not supported on OmniPay Direct.  - `msd`: Read from a contactless interface using magnetic stripe data (MSD). This value is not supported on OmniPay Direct.  - `swiped`: Read from credit card magnetic stripe.  The `contact`, `contactless`, and `msd` values are supported only for EMV transactions.  #### Used by **Authorization** Required field.  #### Card Present Card present information about EMV applies only to credit card processing and PIN debit processing. All other card present information applies only to credit card processing.  #### PIN debit Required for a PIN debit purchase and a PIN debit credit request. 
    */
    'entryMode'?: string;
    /**
    * POS terminal’s capability. Possible values:   - `1`: Terminal has a magnetic stripe reader only.  - `2`: Terminal has a magnetic stripe reader and manual entry capability.  - `3`: Terminal has manual entry capability only.  - `4`: Terminal can read chip cards.  - `5`: Terminal can read contactless chip cards; cannot use contact to read chip cards.  For an EMV transaction, the value of this field must be `4` or `5`.  #### PIN debit Required for PIN debit purchase and PIN debit credit request.  #### Used by **Authorization** Required for the following processors: - American Express Direct - Chase Paymentech Solutions - Credit Mutuel-CIC - FDC Nashville Global - FDMS Nashville - OmniPay Direct - SIX - Worldpay VAP  Optional for the following processors: - CyberSource through VisaNet - GPN - GPX - JCN Gateway - RBS WorldPay Atlanta - TSYS Acquiring Solutions 
    */
    'terminalCapability'?: number;
    /**
    * Method that was used to verify the cardholder's identity. Possible values:    - `0`: No verification   - `1`: Signature   - `2`: PIN   - `3`: Cardholder device CVM   - `4`: Biometric   - `5`: OTP 
    */
    'cardholderVerificationMethodUsed'?: number;
    'emv'?: Ptsv2paymentsidreversalsPointOfSaleInformationEmv;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "terminalId",
            "baseName": "terminalId",
            "type": "string"
        },
        {
            "name": "entryMode",
            "baseName": "entryMode",
            "type": "string"
        },
        {
            "name": "terminalCapability",
            "baseName": "terminalCapability",
            "type": "number"
        },
        {
            "name": "cardholderVerificationMethodUsed",
            "baseName": "cardholderVerificationMethodUsed",
            "type": "number"
        },
        {
            "name": "emv",
            "baseName": "emv",
            "type": "Ptsv2paymentsidreversalsPointOfSaleInformationEmv"
        }    ];

    static getAttributeTypeMap() {
        return TssV2TransactionsGet200ResponsePointOfSaleInformation.attributeTypeMap;
    }
}

export class TssV2TransactionsGet200ResponseProcessingInformation {
    /**
    * Bin Source File Identifier. Possible values: - itmx - rupay 
    */
    'binSource'?: string;
    /**
    * Indicates that the transaction includes industry-specific data.  Possible Values: - `airline` - `restaurant` - `lodging` - `auto_rental` - `transit` - `healthcare_medical` - `healthcare_transit` - `transit`  #### Card Present, Airlines and Auto Rental You must set this field to `airline` in order for airline data to be sent to the processor. For example, if this field is not set to `airline` or is not included in the request, no airline data is sent to the processor.  You must set this field to `restaurant` in order for restaurant data to be sent to the processor. When this field is not set to `restaurant` or is not included in the request, no restaurant data is sent to the processor.  You must set this field to `auto_rental` in order for auto rental data to be sent to the processor. For example, if this field is not set to `auto_rental` or is not included in the request, no auto rental data is sent to the processor.  Restaurant data is supported only on CyberSource through VisaNet. 
    */
    'industryDataType'?: string;
    /**
    * Type of digital payment solution for the transaction. 
    */
    'paymentSolution'?: string;
    /**
    * Type of transaction. Some payment card companies use this information when determining discount rates.  #### Used by **Authorization** Required payer authentication transactions; otherwise, optional. **Credit** Required for standalone credits on Chase Paymentech solutions; otherwise, optional.  The list of valid values in this field depends on your processor.  #### Ingenico ePayments When you omit this field for Ingenico ePayments, the processor uses the default transaction type they have on file for you instead of the default value   #### Card Present You must set this field to `retail`. This field is required for a card-present transaction. Note that this should ONLY be used when the cardholder and card are present at the time of the transaction. For all keyed transactions originated from a POS terminal where the cardholder and card are not present, commerceIndicator should be submitted as “moto\" 
    */
    'commerceIndicator'?: string;
    /**
    * Type of transaction. Some payment card companies use this information when determining discount rates.  #### Used by **Authorization** Required payer authentication transactions; otherwise, optional. **Credit** Required for standalone credits on Chase Paymentech solutions; otherwise, optional.  The list of valid values in this field depends on your processor.  #### Ingenico ePayments When you omit this field for Ingenico ePayments, the processor uses the default transaction type they have on file for you instead of the default value   #### Card Present You must set this field to `retail`. This field is required for a card-present transaction. Note that this should ONLY be used when the cardholder and card are present at the time of the transaction. For all keyed transactions originated from a POS terminal where the cardholder and card are not present, commerceIndicator should be submitted as `moto` 
    */
    'commerceIndicatorLabel'?: string;
    /**
    * Required for AFT and OCT transactions.  Given below is a list of all the BAI values available. However, the processors may support only few specific BAI values.  - AA : Account-to-account  - BB : Supplier Payments - BI : Bank-Initiated P2P Money Transfer - BP : Non-Card Bill Pay/Bill Pay - CD : Cash Deposit - CP : Credit card Bill Payment - FD : Funds disbursement  - FT : Funds transfer - GD : Government Disbursement - GP : Gambling payout (non-online gambling) - LO : Loyalty credits and rebates - MD : Merchant Settlement - OG : Online Gambling Payout - PD : Payroll and pension disbursement - PP : Person-to-Person or Peer-to-Peer - TU : Top up, prepaid load - WT : Digital wallet  
    */
    'businessApplicationId'?: string;
    'authorizationOptions'?: TssV2TransactionsGet200ResponseProcessingInformationAuthorizationOptions;
    'bankTransferOptions'?: TssV2TransactionsGet200ResponseProcessingInformationBankTransferOptions;
    'captureOptions'?: TssV2TransactionsGet200ResponseProcessingInformationCaptureOptions;
    /**
    * Reference number for the transaction. Depending on how your Cybersource account is configured, this value could either be provided in the API request or generated by CyberSource. The actual value used in the request to the processor is provided back to you by Cybersource in the response. 
    */
    'reconciliationId'?: string;
    'japanPaymentOptions'?: TssV2TransactionsGet200ResponseProcessingInformationJapanPaymentOptions;
    /**
    * Enter 1 for routing and account number validation. 
    */
    'validationLevel'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "binSource",
            "baseName": "binSource",
            "type": "string"
        },
        {
            "name": "industryDataType",
            "baseName": "industryDataType",
            "type": "string"
        },
        {
            "name": "paymentSolution",
            "baseName": "paymentSolution",
            "type": "string"
        },
        {
            "name": "commerceIndicator",
            "baseName": "commerceIndicator",
            "type": "string"
        },
        {
            "name": "commerceIndicatorLabel",
            "baseName": "commerceIndicatorLabel",
            "type": "string"
        },
        {
            "name": "businessApplicationId",
            "baseName": "businessApplicationId",
            "type": "string"
        },
        {
            "name": "authorizationOptions",
            "baseName": "authorizationOptions",
            "type": "TssV2TransactionsGet200ResponseProcessingInformationAuthorizationOptions"
        },
        {
            "name": "bankTransferOptions",
            "baseName": "bankTransferOptions",
            "type": "TssV2TransactionsGet200ResponseProcessingInformationBankTransferOptions"
        },
        {
            "name": "captureOptions",
            "baseName": "captureOptions",
            "type": "TssV2TransactionsGet200ResponseProcessingInformationCaptureOptions"
        },
        {
            "name": "reconciliationId",
            "baseName": "reconciliationId",
            "type": "string"
        },
        {
            "name": "japanPaymentOptions",
            "baseName": "japanPaymentOptions",
            "type": "TssV2TransactionsGet200ResponseProcessingInformationJapanPaymentOptions"
        },
        {
            "name": "validationLevel",
            "baseName": "validationLevel",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return TssV2TransactionsGet200ResponseProcessingInformation.attributeTypeMap;
    }
}

export class TssV2TransactionsGet200ResponseProcessingInformationAuthorizationOptions {
    /**
    * Authorization type. Possible values:   - `AUTOCAPTURE`: automatic capture.  - `STANDARDCAPTURE`: standard capture.  - `VERBAL`: forced capture. Include it in the payment request for a forced capture. Include it in the capture request for a verbal payment.  #### Asia, Middle East, and Africa Gateway; Cielo; Comercio Latino; and CyberSource Latin American Processing Set this field to `AUTOCAPTURE` and include it in a bundled request to indicate that you are requesting an automatic capture. If your account is configured to enable automatic captures, set this field to `STANDARDCAPTURE` and include it in a standard authorization or bundled request to indicate that you are overriding an automatic capture.  #### Forced Capture Set this field to `VERBAL` and include it in the authorization request to indicate that you are performing a forced capture; therefore, you receive the authorization code outside the CyberSource system.  #### Verbal Authorization Set this field to `VERBAL` and include it in the capture request to indicate that the request is for a verbal authorization.  #### for PayPal ptsV2CreateOrderPost400Response Set this field to 'AUTHORIZE' or 'CAPTURE' depending on whether you want to invoke delayed capture or sale respectively. 
    */
    'authType'?: string;
    /**
    * Flag that specifies the purpose of the authorization.  Possible values:  - **0**: Preauthorization  - **1**: Final authorization  To set the default for this field, contact CyberSource Customer Support.  #### Barclays and Elavon The default for Barclays and Elavon is 1 (final authorization). To change the default for this field, contact CyberSource Customer Support.  #### CyberSource through VisaNet When the value for this field is 0, it corresponds to the following data in the TC 33 capture file:  - Record: CP01 TCR0  - Position: 164  - Field: Additional Authorization Indicators When the value for this field is 1, it does not correspond to any data in the TC 33 capture file. 
    */
    'authIndicator'?: string;
    /**
    * Indicates Authorization extension transaction. Extension transaction is used to prolong the settlement period by one additional settlement cycle period.  Possible values: - true: Transaction is an Authorization Extension transaction.  - false: Transaction is not an Authorization Extension transaction. 
    */
    'extendAuthIndicator'?: string;
    /**
    * This API field will indicate whether a card verification check is being performed during the transaction  Possible values:   - `true`   - `false` (default value) 
    */
    'cardVerificationIndicator'?: boolean;
    'initiator'?: TssV2TransactionsGet200ResponseProcessingInformationAuthorizationOptionsInitiator;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "authType",
            "baseName": "authType",
            "type": "string"
        },
        {
            "name": "authIndicator",
            "baseName": "authIndicator",
            "type": "string"
        },
        {
            "name": "extendAuthIndicator",
            "baseName": "extendAuthIndicator",
            "type": "string"
        },
        {
            "name": "cardVerificationIndicator",
            "baseName": "cardVerificationIndicator",
            "type": "boolean"
        },
        {
            "name": "initiator",
            "baseName": "initiator",
            "type": "TssV2TransactionsGet200ResponseProcessingInformationAuthorizationOptionsInitiator"
        }    ];

    static getAttributeTypeMap() {
        return TssV2TransactionsGet200ResponseProcessingInformationAuthorizationOptions.attributeTypeMap;
    }
}

export class TssV2TransactionsGet200ResponseProcessingInformationAuthorizationOptionsInitiator {
    /**
    * This field indicates whether the transaction is a merchant-initiated transaction or customer-initiated transaction.  Valid values: - **customer** - **merchant** 
    */
    'type'?: string;
    /**
    * Indicates to the issuing bank two things: - The merchant has received consent from the cardholder to store their card details on file - The merchant wants the issuing bank to check out the card details before the merchant initiates their first transaction for this cardholder. The purpose of the merchant-initiated transaction is to ensure that the cardholder’s credentials are valid (that the card is not stolen or has restrictions) and that the card details are good to be stored on the merchant’s file for future transactions.  Valid values: - `Y` means merchant will use this transaction to store payment credentials for follow-up merchant-initiated transactions. - `N` means merchant will not use this transaction to store payment credentials for follow-up merchant-initiated transactions.  **NOTE:** The value for this field does not correspond to any data in the TC 33 capture file5.  This field is supported only for Visa transactions on CyberSource through VisaNet. 
    */
    'credentialStoredOnFile'?: string;
    /**
    * Indicates to an issuing bank whether a merchant-initiated transaction came from a card that was already stored on file.  Possible values: - **Y** means the merchant-initiated transaction came from a card that was already stored on file. - **N**  means the merchant-initiated transaction came from a card that was not stored on file. 
    */
    'storedCredentialUsed'?: string;
    'merchantInitiatedTransaction'?: MerchantInitiatedTransactionObject;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "credentialStoredOnFile",
            "baseName": "credentialStoredOnFile",
            "type": "string"
        },
        {
            "name": "storedCredentialUsed",
            "baseName": "storedCredentialUsed",
            "type": "string"
        },
        {
            "name": "merchantInitiatedTransaction",
            "baseName": "merchantInitiatedTransaction",
            "type": "MerchantInitiatedTransactionObject"
        }    ];

    static getAttributeTypeMap() {
        return TssV2TransactionsGet200ResponseProcessingInformationAuthorizationOptionsInitiator.attributeTypeMap;
    }
}

export class TssV2TransactionsGet200ResponseProcessingInformationBankTransferOptions {
    /**
    * Specifies the authorization method for the transaction.  Possible values: - `ARC`: account receivable conversion - `CCD`: corporate cash disbursement - `POP`: point of purchase conversion - `PPD`: prearranged payment and deposit entry - `TEL`: telephone-initiated entry - `WEB`: internet-initiated entry 
    */
    'secCode'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "secCode",
            "baseName": "secCode",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TssV2TransactionsGet200ResponseProcessingInformationBankTransferOptions.attributeTypeMap;
    }
}

export class TssV2TransactionsGet200ResponseProcessingInformationCaptureOptions {
    /**
    * Total number of captures when requesting multiple partial captures for one payment. Used along with `captureSequenceNumber` field to track which capture is being processed.  For example, the second of five captures would be passed to CyberSource as:   - `captureSequenceNumber = 2`, and   - `totalCaptureCount = 5` 
    */
    'totalCaptureCount'?: number;
    /**
    * Capture number when requesting multiple partial captures for one authorization. Used along with `totalCaptureCount` to track which capture is being processed.  For example, the second of five captures would be passed to CyberSource as:   - `captureSequenceNumber_ = 2`, and   - `totalCaptureCount = 5` 
    */
    'captureSequenceNumber'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "totalCaptureCount",
            "baseName": "totalCaptureCount",
            "type": "number"
        },
        {
            "name": "captureSequenceNumber",
            "baseName": "captureSequenceNumber",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return TssV2TransactionsGet200ResponseProcessingInformationCaptureOptions.attributeTypeMap;
    }
}

export class TssV2TransactionsGet200ResponseProcessingInformationJapanPaymentOptions {
    /**
    * This value is a 2-digit code indicating the payment method. Use Payment Method Code value that applies to the tranasction. - 10 (One-time payment) - 21, 22, 23, 24  (Bonus(one-time)payment) - 61 (Installment payment) - 31, 32, 33, 34  (Integrated (Bonus + Installment)payment) - 80 (Revolving payment) 
    */
    'paymentMethod'?: string;
    /**
    * Unique Japan Credit Card Association (JCCA) terminal identifier.  The difference between this field and the `pointOfSaleInformation.terminalID` field is that you can define `pointOfSaleInformation.terminalID`, but `processingInformation.japanPaymentOptions.terminalId` is defined by the JCCA and is used only in Japan.  This field is supported only on CyberSource through VisaNet and JCN Gateway.  Optional field. 
    */
    'terminalId'?: string;
    /**
    * Business name in Japanese characters. This field is supported only on JCN Gateway and for the Sumitomo Mitsui Card Co. acquirer on CyberSource through VisaNet. 
    */
    'businessName'?: string;
    /**
    * Business name in Katakana characters. This field is supported only on JCN Gateway and for the Sumitomo Mitsui Card Co. acquirer on CyberSource through VisaNet. 
    */
    'businessNameKatakana'?: string;
    /**
    * Business name in English characters. This field is supported only on JCN Gateway and for the Sumitomo Mitsui Card Co. acquirer on CyberSource through VisaNet. 
    */
    'businessNameEnglish'?: string;
    /**
    * An array of objects, each of which contains a bonus month and bonus amount.  Length of bonuses array is equal to the number of bonuses.  Max length = 6.  In case of bonus month and amount not specified, null objects to be returned in the array. Example: bonuses : [ {\"month\": \"1\",\"amount\": \"200\"}, {\"month\": \"3\",\"amount\": \"2500\"}, null] 
    */
    'bonuses'?: Array<Ptsv2paymentsProcessingInformationJapanPaymentOptionsBonuses>;
    /**
    * Billing month in MM format. 
    */
    'firstBillingMonth'?: string;
    /**
    * Number of Installments. 
    */
    'numberOfInstallments'?: string;
    /**
    * This will contain the details of the kind of transaction that has been processe. Used only for Japan. Possible Values: - 0 = Normal (authorization with amount and clearing/settlement; data capture or paper draft) - 1 = Negative card authorization (authorization-only with 0 or 1 amount) - 2 = Reservation of authorization (authorization-only with amount) - 3 = Cancel transaction - 4 = Merchant-initiated reversal/refund transactions - 5 = Cancel reservation of authorization - 6 = Post authorization 
    */
    'preApprovalType'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "paymentMethod",
            "baseName": "paymentMethod",
            "type": "string"
        },
        {
            "name": "terminalId",
            "baseName": "terminalId",
            "type": "string"
        },
        {
            "name": "businessName",
            "baseName": "businessName",
            "type": "string"
        },
        {
            "name": "businessNameKatakana",
            "baseName": "businessNameKatakana",
            "type": "string"
        },
        {
            "name": "businessNameEnglish",
            "baseName": "businessNameEnglish",
            "type": "string"
        },
        {
            "name": "bonuses",
            "baseName": "bonuses",
            "type": "Array<Ptsv2paymentsProcessingInformationJapanPaymentOptionsBonuses>"
        },
        {
            "name": "firstBillingMonth",
            "baseName": "firstBillingMonth",
            "type": "string"
        },
        {
            "name": "numberOfInstallments",
            "baseName": "numberOfInstallments",
            "type": "string"
        },
        {
            "name": "preApprovalType",
            "baseName": "preApprovalType",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TssV2TransactionsGet200ResponseProcessingInformationJapanPaymentOptions.attributeTypeMap;
    }
}

export class TssV2TransactionsGet200ResponseProcessorInformation {
    'processor'?: TssV2TransactionsGet200ResponseProcessorInformationProcessor;
    /**
    * An array of object that contains the list of acquirer response codes & reasons if a transaction is routed to multiple acquirers.
    */
    'multiProcessorRouting'?: Array<TssV2TransactionsGet200ResponseProcessorInformationMultiProcessorRouting>;
    /**
    * Network transaction identifier (TID). You can use this value to identify a specific transaction when you are discussing the transaction with your processor. Not all processors provide this value.  Returned by the authorization service.  #### PIN debit Transaction identifier generated by the processor.  Returned by PIN debit credit.  #### GPX Processor transaction ID.  #### Cielo For Cielo, this value is the non-sequential unit (NSU) and is supported for all transactions. The value is generated by Cielo or the issuing bank.  #### Comercio Latino For Comercio Latino, this value is the proof of sale or non-sequential unit (NSU) number generated by the acquirers Cielo and Rede, or the issuing bank.  #### CyberSource through VisaNet and GPN For details about this value for CyberSource through VisaNet and GPN, see \"processorInformation.networkTransactionId\" in [REST API Fields](https://developer.cybersource.com/content/dam/docs/cybs/en-us/apifields/reference/all/rest/api-fields.pdf)  #### Moneris This value identifies the transaction on a host system. It contains the following information: - Terminal used to process the transaction - Shift during which the transaction took place - Batch number - Transaction number within the batch You must store this value. If you give the customer a receipt, display this value on the receipt.  **Example** For the value 66012345001069003: - Terminal ID = 66012345 - Shift number = 001 - Batch number = 069 - Transaction number = 003 
    */
    'transactionId'?: string;
    /**
    * Same value as `processorInformation.transactionId`
    */
    'networkTransactionId'?: string;
    /**
    * #### Ingenico ePayments Unique number that CyberSource generates to identify the transaction. You can use this value to identify transactions in the Ingenico ePayments Collections Report, which provides settlement information. Contact customer support for information about the report.  ### CyberSource through VisaNet Retrieval request number. 
    */
    'retrievalReferenceNumber'?: string;
    /**
    * Response ID sent from the processor. 
    */
    'responseId'?: string;
    /**
    * Authorization code. Returned only when the processor returns this value.  The length of this value depends on your processor.  Returned by authorization service.  #### PIN debit Authorization code that is returned by the processor.  Returned by PIN debit credit.  #### Elavon Encrypted Account Number Program The returned value is OFFLINE.  #### TSYS Acquiring Solutions The returned value for a successful zero amount authorization is 000000. 
    */
    'approvalCode'?: string;
    /**
    * For most processors, this is the error message sent directly from the bank. Returned only when the processor returns this value.  **Important** Do not use this field to evaluate the result of the authorization.  #### PIN debit Response value that is returned by the processor or bank. **Important** Do not use this field to evaluate the results of the transaction request.  Returned by PIN debit credit, PIN debit purchase, and PIN debit reversal.  #### AIBMS If this value is `08`, you can accept the transaction if the customer provides you with identification.  #### Atos This value is the response code sent from Atos and it might also include the response code from the bank. Format: `aa,bb` with the two values separated by a comma and where: - `aa` is the two-digit error message from Atos. - `bb` is the optional two-digit error message from the bank.  #### Comercio Latino This value is the status code and the error or response code received from the processor separated by a colon. Format: [status code]:E[error code] or [status code]:R[response code] Example `2:R06`  #### JCN Gateway Processor-defined detail error code. The associated response category code is in the `processorInformation.responseCategoryCode` field. String (3)  #### paypalgateway Processor generated ID for the itemized detail. 
    */
    'responseCode'?: string;
    'avs'?: PtsV2PaymentsPost201ResponseProcessorInformationAvs;
    'cardVerification'?: Riskv1decisionsProcessorInformationCardVerification;
    'achVerification'?: PtsV2PaymentsPost201ResponseProcessorInformationAchVerification;
    'electronicVerificationResults'?: TssV2TransactionsGet200ResponseProcessorInformationElectronicVerificationResults;
    /**
    * The event status. 
    */
    'eventStatus'?: string;
    /**
    * This field is returned only for **American Express Direct** and **CyberSource through VisaNet**. Returned by authorization and incremental authorization services.  #### American Express Direct  System trace audit number (STAN). This value identifies the transaction and is useful when investigating a chargeback dispute.  #### CyberSource through VisaNet  System trace number that must be printed on the customer’s receipt. 
    */
    'systemTraceAuditNumber'?: string;
    /**
    * Used by Visa only and contains the response source/reason code that identifies the source of the response decision. 
    */
    'responseCodeSource'?: string;
    /**
    * Payment Account Reference (PAR) is a non-financial reference assigned to each unique payment account and used to link a payment account to associated network tokens, i.e. the same PAR is returned for PAN-based and tokenized transactions, such as from digital wallets. PAR can be returned in authorisation responses for requests initiated with both real PANs and tokenized PANs. PAR can be used by merchants for fraud detection and regulatory compliance across different channels and digital wallets. PAR allows all participants in the payments chain to have a single, non-sensitive value assigned to a consumer. This value can be used in place of sensitive card holder identification fields, and transmitted across the payments ecosystem to facilitate card holder identification.  **Note** On CyberSource through VisaNet, the value for this field corresponds to the following data in the TC 33 capture file: - Record: CP01 TCR8 - Position: 79-110 - Field: Payment Account Reference  The TC 33 Capture file contains information about the purchases and refunds that a merchant submits to CyberSource. CyberSource through VisaNet creates the TC 33 Capture file at the end of the day and sends it to the merchant’s acquirer, who uses this information to facilitate end-of-day clearing processing with payment networks. 
    */
    'paymentAccountReferenceNumber'?: string;
    'routing'?: PtsV2PaymentsPost201ResponseProcessorInformationRouting;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "processor",
            "baseName": "processor",
            "type": "TssV2TransactionsGet200ResponseProcessorInformationProcessor"
        },
        {
            "name": "multiProcessorRouting",
            "baseName": "multiProcessorRouting",
            "type": "Array<TssV2TransactionsGet200ResponseProcessorInformationMultiProcessorRouting>"
        },
        {
            "name": "transactionId",
            "baseName": "transactionId",
            "type": "string"
        },
        {
            "name": "networkTransactionId",
            "baseName": "networkTransactionId",
            "type": "string"
        },
        {
            "name": "retrievalReferenceNumber",
            "baseName": "retrievalReferenceNumber",
            "type": "string"
        },
        {
            "name": "responseId",
            "baseName": "responseId",
            "type": "string"
        },
        {
            "name": "approvalCode",
            "baseName": "approvalCode",
            "type": "string"
        },
        {
            "name": "responseCode",
            "baseName": "responseCode",
            "type": "string"
        },
        {
            "name": "avs",
            "baseName": "avs",
            "type": "PtsV2PaymentsPost201ResponseProcessorInformationAvs"
        },
        {
            "name": "cardVerification",
            "baseName": "cardVerification",
            "type": "Riskv1decisionsProcessorInformationCardVerification"
        },
        {
            "name": "achVerification",
            "baseName": "achVerification",
            "type": "PtsV2PaymentsPost201ResponseProcessorInformationAchVerification"
        },
        {
            "name": "electronicVerificationResults",
            "baseName": "electronicVerificationResults",
            "type": "TssV2TransactionsGet200ResponseProcessorInformationElectronicVerificationResults"
        },
        {
            "name": "eventStatus",
            "baseName": "eventStatus",
            "type": "string"
        },
        {
            "name": "systemTraceAuditNumber",
            "baseName": "systemTraceAuditNumber",
            "type": "string"
        },
        {
            "name": "responseCodeSource",
            "baseName": "responseCodeSource",
            "type": "string"
        },
        {
            "name": "paymentAccountReferenceNumber",
            "baseName": "paymentAccountReferenceNumber",
            "type": "string"
        },
        {
            "name": "routing",
            "baseName": "routing",
            "type": "PtsV2PaymentsPost201ResponseProcessorInformationRouting"
        }    ];

    static getAttributeTypeMap() {
        return TssV2TransactionsGet200ResponseProcessorInformation.attributeTypeMap;
    }
}

export class TssV2TransactionsGet200ResponseProcessorInformationElectronicVerificationResults {
    /**
    * Mapped Electronic Verification response code for the customer’s email address. 
    */
    'email'?: string;
    /**
    * Raw Electronic Verification response code from the processor for the customer’s email address.
    */
    'emailRaw'?: string;
    /**
    * #### Visa Platform Connect Mapped Electronic Verification response code for the customer’s name.  Valid values :  'Y'   Yes, the data Matches 'N'   No Match 'O'   Partial Match 
    */
    'name'?: string;
    /**
    * #### Visa Platform Connect Raw Electronic Verification response code from the processor for the customer’s name.  Valid values :  '01'     Match '50'     Partial Match '99'     No Match 
    */
    'nameRaw'?: string;
    /**
    * Mapped Electronic Verification response code for the customer’s phone number. 
    */
    'phoneNumber'?: string;
    /**
    * Raw Electronic Verification response code from the processor for the customer’s phone number.
    */
    'phoneNumberRaw'?: string;
    /**
    * Mapped Electronic Verification response code for the customer’s street address. 
    */
    'street'?: string;
    /**
    * Raw Electronic Verification response code from the processor for the customer’s street address.
    */
    'streetRaw'?: string;
    /**
    * Mapped Electronic Verification response code for the customer’s postal code. 
    */
    'postalCode'?: string;
    /**
    * Raw Electronic Verification response code from the processor for the customer’s postal code.
    */
    'postalCodeRaw'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "emailRaw",
            "baseName": "emailRaw",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "nameRaw",
            "baseName": "nameRaw",
            "type": "string"
        },
        {
            "name": "phoneNumber",
            "baseName": "phoneNumber",
            "type": "string"
        },
        {
            "name": "phoneNumberRaw",
            "baseName": "phoneNumberRaw",
            "type": "string"
        },
        {
            "name": "street",
            "baseName": "street",
            "type": "string"
        },
        {
            "name": "streetRaw",
            "baseName": "streetRaw",
            "type": "string"
        },
        {
            "name": "postalCode",
            "baseName": "postalCode",
            "type": "string"
        },
        {
            "name": "postalCodeRaw",
            "baseName": "postalCodeRaw",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TssV2TransactionsGet200ResponseProcessorInformationElectronicVerificationResults.attributeTypeMap;
    }
}

export class TssV2TransactionsGet200ResponseProcessorInformationMultiProcessorRouting {
    /**
    * Name of the Processor. 
    */
    'name'?: string;
    /**
    * For most processors, this is the error message sent directly from the bank. Returned only when the processor returns this value.  **Important** Do not use this field to evaluate the result of the authorization.  #### PIN debit Response value that is returned by the processor or bank. **Important** Do not use this field to evaluate the results of the transaction request.  Returned by PIN debit credit, PIN debit purchase, and PIN debit reversal.  #### AIBMS If this value is `08`, you can accept the transaction if the customer provides you with identification.  #### Atos This value is the response code sent from Atos and it might also include the response code from the bank. Format: `aa,bb` with the two values separated by a comma and where: - `aa` is the two-digit error message from Atos. - `bb` is the optional two-digit error message from the bank.  #### Comercio Latino This value is the status code and the error or response code received from the processor separated by a colon. Format: [status code]:E[error code] or [status code]:R[response code] Example `2:R06`  #### JCN Gateway Processor-defined detail error code. The associated response category code is in the `processorInformation.responseCategoryCode` field. String (3)  #### paypalgateway Processor generated ID for the itemized detail. 
    */
    'responseCode'?: string;
    /**
    * Indicates the reason why a request succeeded or failed and possible action to take if a request fails.  For details, see the appendix of reason codes in the documentation for the relevant payment method. 
    */
    'reasonCode'?: string;
    /**
    * The order in which the transaction was routed to the processor 
    */
    'sequence'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "responseCode",
            "baseName": "responseCode",
            "type": "string"
        },
        {
            "name": "reasonCode",
            "baseName": "reasonCode",
            "type": "string"
        },
        {
            "name": "sequence",
            "baseName": "sequence",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TssV2TransactionsGet200ResponseProcessorInformationMultiProcessorRouting.attributeTypeMap;
    }
}

export class TssV2TransactionsGet200ResponseProcessorInformationProcessor {
    /**
    * Name of the Processor. 
    */
    'name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TssV2TransactionsGet200ResponseProcessorInformationProcessor.attributeTypeMap;
    }
}

export class TssV2TransactionsGet200ResponseRecurringPaymentInformation {
    /**
    * Indicates recurring amount type agreed by the cardholder Valid Values : 1- Fixed amount recurring payment 2- Recurring payment with maximum amount 
    */
    'amountType'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "amountType",
            "baseName": "amountType",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TssV2TransactionsGet200ResponseRecurringPaymentInformation.attributeTypeMap;
    }
}

export class TssV2TransactionsGet200ResponseRiskInformation {
    'profile'?: TssV2TransactionsGet200ResponseRiskInformationProfile;
    'rules'?: Array<TssV2TransactionsGet200ResponseRiskInformationRules>;
    'passiveProfile'?: TssV2TransactionsGet200ResponseRiskInformationProfile;
    'passiveRules'?: Array<TssV2TransactionsGet200ResponseRiskInformationRules>;
    'score'?: TssV2TransactionsGet200ResponseRiskInformationScore;
    /**
    * Time that the transaction was submitted in local time. Generated by Cybersource.
    */
    'localTime'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "profile",
            "baseName": "profile",
            "type": "TssV2TransactionsGet200ResponseRiskInformationProfile"
        },
        {
            "name": "rules",
            "baseName": "rules",
            "type": "Array<TssV2TransactionsGet200ResponseRiskInformationRules>"
        },
        {
            "name": "passiveProfile",
            "baseName": "passiveProfile",
            "type": "TssV2TransactionsGet200ResponseRiskInformationProfile"
        },
        {
            "name": "passiveRules",
            "baseName": "passiveRules",
            "type": "Array<TssV2TransactionsGet200ResponseRiskInformationRules>"
        },
        {
            "name": "score",
            "baseName": "score",
            "type": "TssV2TransactionsGet200ResponseRiskInformationScore"
        },
        {
            "name": "localTime",
            "baseName": "localTime",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TssV2TransactionsGet200ResponseRiskInformation.attributeTypeMap;
    }
}

export class TssV2TransactionsGet200ResponseRiskInformationProfile {
    /**
    * The name of the profile. 
    */
    'name'?: string;
    /**
    * Decision returned by the profile; this field contains one of these values: - ACCEPT - REJECT - REVIEW 
    */
    'decision'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "decision",
            "baseName": "decision",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TssV2TransactionsGet200ResponseRiskInformationProfile.attributeTypeMap;
    }
}

/**
* Names of one or more rules that were processed, and the decisions made by the rules.
*/
export class TssV2TransactionsGet200ResponseRiskInformationRules {
    /**
    * Description of the rule as it appears in the Profile Editor.
    */
    'name'?: string;
    /**
    * Summarizes the result for the rule according to the setting that you chose in the Profile Editor. This field can contain one of the following values: - `IGNORE` - `REVIEW` - `REJECT` - `ACCEPT` 
    */
    'decision'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "decision",
            "baseName": "decision",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TssV2TransactionsGet200ResponseRiskInformationRules.attributeTypeMap;
    }
}

export class TssV2TransactionsGet200ResponseRiskInformationScore {
    /**
    * Array of factor codes.
    */
    'factorCodes'?: Array<string>;
    /**
    * The description for this field is not available. 
    */
    'result'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "factorCodes",
            "baseName": "factorCodes",
            "type": "Array<string>"
        },
        {
            "name": "result",
            "baseName": "result",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return TssV2TransactionsGet200ResponseRiskInformationScore.attributeTypeMap;
    }
}

export class TssV2TransactionsGet200ResponseSenderInformation {
    /**
    * Reference number generated by you that uniquely identifies the sender.
    */
    'referenceNumber'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "referenceNumber",
            "baseName": "referenceNumber",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TssV2TransactionsGet200ResponseSenderInformation.attributeTypeMap;
    }
}

export class TssV2TransactionsGet200ResponseTokenInformation {
    'customer'?: PtsV2PaymentsPost201ResponseTokenInformationCustomer;
    'paymentInstrument'?: PtsV2PaymentsPost201ResponseTokenInformationPaymentInstrument;
    'shippingAddress'?: PtsV2PaymentsPost201ResponseTokenInformationShippingAddress;
    'instrumentIdentifier'?: TssV2TransactionsGet200ResponsePaymentInformationInstrumentIdentifier;
    /**
    * TMS Transient Token, 64 hexadecimal id value representing captured payment credentials (including Sensitive Authentication Data, e.g. CVV). 
    */
    'jti'?: string;
    /**
    * Flex API Transient Token encoded as JWT (JSON Web Token), e.g. Flex microform or Unified Payment checkout result. 
    */
    'transientTokenJwt'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "customer",
            "baseName": "customer",
            "type": "PtsV2PaymentsPost201ResponseTokenInformationCustomer"
        },
        {
            "name": "paymentInstrument",
            "baseName": "paymentInstrument",
            "type": "PtsV2PaymentsPost201ResponseTokenInformationPaymentInstrument"
        },
        {
            "name": "shippingAddress",
            "baseName": "shippingAddress",
            "type": "PtsV2PaymentsPost201ResponseTokenInformationShippingAddress"
        },
        {
            "name": "instrumentIdentifier",
            "baseName": "instrumentIdentifier",
            "type": "TssV2TransactionsGet200ResponsePaymentInformationInstrumentIdentifier"
        },
        {
            "name": "jti",
            "baseName": "jti",
            "type": "string"
        },
        {
            "name": "transientTokenJwt",
            "baseName": "transientTokenJwt",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TssV2TransactionsGet200ResponseTokenInformation.attributeTypeMap;
    }
}

export class TssV2TransactionsPost201Response {
    /**
    * An unique identification number assigned by CyberSource to identify each Search request.
    */
    'searchId'?: string;
    /**
    * Indicates whether or not you want to save this search request for future use. The options are:  * `true` * `false` (default value)  If set to `true`, this field returns `searchID` in the response. You can use this value to retrieve the details of the saved search. 
    */
    'save'?: boolean;
    /**
    * Name of this search. When `save` is set to `true`, this search is saved with this name. 
    */
    'name'?: string;
    /**
    * Merchant’s time zone in ISO standard, using the TZ database format. For example: `America/Chicago` 
    */
    'timezone'?: string;
    /**
    * String that contains the filters and variables for which you want to search. For information about supported field-filters and operators, see the [Query Filters]( https://developer.cybersource.com/api/developer-guides/dita-txn-search-details-rest-api-dev-guide-102718/txn-search-intro/txn-filtering.html) section of the Transaction Search Developer Guide. 
    */
    'query'?: string;
    /**
    * Controls the starting point within the collection of results, which defaults to 0. The first item in the collection is retrieved by setting a zero offset.  For example, if you have a collection of 15 items to be retrieved from a resource and you specify limit=5, you can retrieve the entire set of results in 3 successive requests by varying the offset value like this:  `offset=0` `offset=5` `offset=10`  **Note:** If an offset larger than the number of results is provided, this will result in no embedded object being returned. 
    */
    'offset'?: number;
    /**
    * Controls the maximum number of items that may be returned for a single request. The default is 20, the maximum is 2500. 
    */
    'limit'?: number;
    /**
    * A comma separated list of the following form:  `submitTimeUtc:desc` 
    */
    'sort'?: string;
    /**
    * Results for this page, this could be below the limit.
    */
    'count'?: number;
    /**
    * Total number of results.
    */
    'totalCount'?: number;
    /**
    * Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ` **Example** `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.). The `T` separates the date and the time. The `Z` indicates UTC.  Returned by Cybersource for all services. 
    */
    'submitTimeUtc'?: string;
    'embedded'?: TssV2TransactionsPost201ResponseEmbedded;
    'links'?: PtsV2IncrementalAuthorizationPatch201ResponseLinks;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "searchId",
            "baseName": "searchId",
            "type": "string"
        },
        {
            "name": "save",
            "baseName": "save",
            "type": "boolean"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "timezone",
            "baseName": "timezone",
            "type": "string"
        },
        {
            "name": "query",
            "baseName": "query",
            "type": "string"
        },
        {
            "name": "offset",
            "baseName": "offset",
            "type": "number"
        },
        {
            "name": "limit",
            "baseName": "limit",
            "type": "number"
        },
        {
            "name": "sort",
            "baseName": "sort",
            "type": "string"
        },
        {
            "name": "count",
            "baseName": "count",
            "type": "number"
        },
        {
            "name": "totalCount",
            "baseName": "totalCount",
            "type": "number"
        },
        {
            "name": "submitTimeUtc",
            "baseName": "submitTimeUtc",
            "type": "string"
        },
        {
            "name": "embedded",
            "baseName": "_embedded",
            "type": "TssV2TransactionsPost201ResponseEmbedded"
        },
        {
            "name": "links",
            "baseName": "_links",
            "type": "PtsV2IncrementalAuthorizationPatch201ResponseLinks"
        }    ];

    static getAttributeTypeMap() {
        return TssV2TransactionsPost201Response.attributeTypeMap;
    }
}

export class TssV2TransactionsPost201ResponseEmbedded {
    /**
    * transaction search summary
    */
    'transactionSummaries'?: Array<TssV2TransactionsPost201ResponseEmbeddedTransactionSummaries>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "transactionSummaries",
            "baseName": "transactionSummaries",
            "type": "Array<TssV2TransactionsPost201ResponseEmbeddedTransactionSummaries>"
        }    ];

    static getAttributeTypeMap() {
        return TssV2TransactionsPost201ResponseEmbedded.attributeTypeMap;
    }
}

export class TssV2TransactionsPost201ResponseEmbeddedApplicationInformation {
    /**
    * Indicates the reason why a request succeeded or failed and possible action to take if a request fails.  For details, see the appendix of reason codes in the documentation for the relevant payment method. 
    */
    'reasonCode'?: string;
    /**
    * Indicates whether the service request was successful. Possible values:  - `-1`: An error occurred. - `0`: The request was declined. - `1`: The request was successful. 
    */
    'rCode'?: string;
    /**
    * One-word description of the result of the application. 
    */
    'rFlag'?: string;
    'applications'?: Array<TssV2TransactionsPost201ResponseEmbeddedApplicationInformationApplications>;
    /**
    * The description for this field is not available.
    */
    'returnCode'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "reasonCode",
            "baseName": "reasonCode",
            "type": "string"
        },
        {
            "name": "rCode",
            "baseName": "rCode",
            "type": "string"
        },
        {
            "name": "rFlag",
            "baseName": "rFlag",
            "type": "string"
        },
        {
            "name": "applications",
            "baseName": "applications",
            "type": "Array<TssV2TransactionsPost201ResponseEmbeddedApplicationInformationApplications>"
        },
        {
            "name": "returnCode",
            "baseName": "returnCode",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return TssV2TransactionsPost201ResponseEmbeddedApplicationInformation.attributeTypeMap;
    }
}

export class TssV2TransactionsPost201ResponseEmbeddedApplicationInformationApplications {
    /**
    * The name of the CyberSource transaction type (such as CC settlement or CC authorization) that the merchant wants to process in a transaction request. More than one transaction type can included in a transaction request. Each transaction type separately returns their own status, reasonCode, rCode, and rFlag messages. 
    */
    'name'?: string;
    /**
    * 3-digit reason code that indicates why the customer profile payment succeeded or failed.
    */
    'reasonCode'?: string;
    /**
    * The status of the submitted transaction. Note: This field may not be returned for all transactions. 
    */
    'status'?: string;
    /**
    * Description of why a request failed. Note: This field may not be returned for all transactions. 
    */
    'reason'?: string;
    /**
    * Indicates whether the service request was successful. Possible values:  - `-1`: An error occurred. - `0`: The request was declined. - `1`: The request was successful. 
    */
    'rCode'?: string;
    /**
    * One-word description of the result of the application. 
    */
    'rFlag'?: string;
    /**
    * Reference number that you use to reconcile your CyberSource reports with your processor reports. 
    */
    'reconciliationId'?: string;
    /**
    * Message that explains the reply flag for the application. 
    */
    'rMessage'?: string;
    /**
    * The description for this field is not available.
    */
    'returnCode'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "reasonCode",
            "baseName": "reasonCode",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "reason",
            "baseName": "reason",
            "type": "string"
        },
        {
            "name": "rCode",
            "baseName": "rCode",
            "type": "string"
        },
        {
            "name": "rFlag",
            "baseName": "rFlag",
            "type": "string"
        },
        {
            "name": "reconciliationId",
            "baseName": "reconciliationId",
            "type": "string"
        },
        {
            "name": "rMessage",
            "baseName": "rMessage",
            "type": "string"
        },
        {
            "name": "returnCode",
            "baseName": "returnCode",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return TssV2TransactionsPost201ResponseEmbeddedApplicationInformationApplications.attributeTypeMap;
    }
}

export class TssV2TransactionsPost201ResponseEmbeddedClientReferenceInformation {
    /**
    * Merchant-generated order reference or tracking number. It is recommended that you send a unique value for each transaction so that you can perform meaningful searches for the transaction.  #### Used by **Authorization** Required field.  #### PIN Debit Requests for PIN debit reversals need to use the same merchant reference number that was used in the transaction that is being reversed.  Required field for all PIN Debit requests (purchase, credit, and reversal).  #### FDC Nashville Global Certain circumstances can cause the processor to truncate this value to 15 or 17 characters for Level II and Level III processing, which can cause a discrepancy between the value you submit and the value included in some processor reports. 
    */
    'code'?: string;
    /**
    * The name of the Connection Method client (such as Virtual Terminal or SOAP Toolkit API) that the merchant uses to send a transaction request to CyberSource. 
    */
    'applicationName'?: string;
    /**
    * The entity that is responsible for running the transaction and submitting the processing request to CyberSource. This could be a person, a system, or a connection method. 
    */
    'applicationUser'?: string;
    'partner'?: TssV2TransactionsPost201ResponseEmbeddedClientReferenceInformationPartner;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        },
        {
            "name": "applicationName",
            "baseName": "applicationName",
            "type": "string"
        },
        {
            "name": "applicationUser",
            "baseName": "applicationUser",
            "type": "string"
        },
        {
            "name": "partner",
            "baseName": "partner",
            "type": "TssV2TransactionsPost201ResponseEmbeddedClientReferenceInformationPartner"
        }    ];

    static getAttributeTypeMap() {
        return TssV2TransactionsPost201ResponseEmbeddedClientReferenceInformation.attributeTypeMap;
    }
}

export class TssV2TransactionsPost201ResponseEmbeddedClientReferenceInformationPartner {
    /**
    * Identifier for the partner that is integrated to CyberSource.  Send this value in all requests that are sent through the partner solution. CyberSource assigns the ID to the partner.  **Note** When you see a solutionId of 999 in reports, the solutionId that was submitted is incorrect. 
    */
    'solutionId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "solutionId",
            "baseName": "solutionId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TssV2TransactionsPost201ResponseEmbeddedClientReferenceInformationPartner.attributeTypeMap;
    }
}

export class TssV2TransactionsPost201ResponseEmbeddedConsumerAuthenticationInformation {
    /**
    * Transaction identifier. 
    */
    'xid'?: string;
    /**
    * Payer auth Transaction identifier.
    */
    'transactionId'?: string;
    /**
    * Raw electronic commerce indicator (ECI). 
    */
    'eciRaw'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "xid",
            "baseName": "xid",
            "type": "string"
        },
        {
            "name": "transactionId",
            "baseName": "transactionId",
            "type": "string"
        },
        {
            "name": "eciRaw",
            "baseName": "eciRaw",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TssV2TransactionsPost201ResponseEmbeddedConsumerAuthenticationInformation.attributeTypeMap;
    }
}

export class TssV2TransactionsPost201ResponseEmbeddedErrorInformation {
    /**
    * Description of why a request failed. Note: This field may not be returned for all transactions. 
    */
    'reason'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "reason",
            "baseName": "reason",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TssV2TransactionsPost201ResponseEmbeddedErrorInformation.attributeTypeMap;
    }
}

export class TssV2TransactionsPost201ResponseEmbeddedLinks {
    'transactionDetail'?: PtsV2PaymentsPost201ResponseLinksSelf;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "transactionDetail",
            "baseName": "transactionDetail",
            "type": "PtsV2PaymentsPost201ResponseLinksSelf"
        }    ];

    static getAttributeTypeMap() {
        return TssV2TransactionsPost201ResponseEmbeddedLinks.attributeTypeMap;
    }
}

export class TssV2TransactionsPost201ResponseEmbeddedMerchantInformation {
    /**
    * An unique identification number generated by Cybersource to identify the submitted request. Returned by all services. It is also appended to the endpoint of the resource. On incremental authorizations, this value with be the same as the identification number returned in the original authorization response. 
    */
    'resellerId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "resellerId",
            "baseName": "resellerId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TssV2TransactionsPost201ResponseEmbeddedMerchantInformation.attributeTypeMap;
    }
}

export class TssV2TransactionsPost201ResponseEmbeddedOrderInformation {
    'billTo'?: TssV2TransactionsPost201ResponseEmbeddedOrderInformationBillTo;
    'shipTo'?: TssV2TransactionsPost201ResponseEmbeddedOrderInformationShipTo;
    'amountDetails'?: Ptsv2paymentsidreversalsReversalInformationAmountDetails;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "billTo",
            "baseName": "billTo",
            "type": "TssV2TransactionsPost201ResponseEmbeddedOrderInformationBillTo"
        },
        {
            "name": "shipTo",
            "baseName": "shipTo",
            "type": "TssV2TransactionsPost201ResponseEmbeddedOrderInformationShipTo"
        },
        {
            "name": "amountDetails",
            "baseName": "amountDetails",
            "type": "Ptsv2paymentsidreversalsReversalInformationAmountDetails"
        }    ];

    static getAttributeTypeMap() {
        return TssV2TransactionsPost201ResponseEmbeddedOrderInformation.attributeTypeMap;
    }
}

export class TssV2TransactionsPost201ResponseEmbeddedOrderInformationBillTo {
    /**
    * Customer’s first name. This name must be the same as the name on the card.  **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.  #### SEPA Required for Create Mandate and Import Mandate #### BACS Required for Import Mandate  #### CyberSource Latin American Processing **Important** For an authorization request, CyberSource Latin American Processing concatenates `orderInformation.billTo.firstName` and `orderInformation.billTo.lastName`. If the concatenated value exceeds 30 characters, CyberSource Latin American Processing declines the authorization request.\\ **Note** CyberSource Latin American Processing is the name of a specific processing connection that CyberSource supports. In the CyberSource API documentation, CyberSource Latin American Processing does not refer to the general topic of processing in Latin America. The information in this field description is for the specific processing connection called _CyberSource Latin American Processing_. It is not for any other Latin American processors that CyberSource supports.  #### CyberSource through VisaNet Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.  #### For Payouts: This field may be sent only for FDC Compass.  #### Chase Paymentech Solutions Optional field.  ####  Credit Mutuel-CIC Optional field.  #### OmniPay Direct Optional field.  #### SIX Optional field.  #### TSYS Acquiring Solutions Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.  #### Worldpay VAP Optional field.  #### All other processors Not used. 
    */
    'firstName'?: string;
    /**
    * Customer’s last name. This name must be the same as the name on the card.  **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.  #### SEPA Required for Create Mandate and Import Mandate #### BACS Required for Import Mandate #### Chase Paymentech Solutions Optional field.  ####  Credit Mutuel-CIC Optional field.  #### CyberSource Latin American Processing **Important** For an authorization request, CyberSource Latin American Processing concatenates `orderInformation.billTo.firstName` and `orderInformation.billTo.lastName`. If the concatenated value exceeds 30 characters, CyberSource Latin American Processing declines the authorization request.\\ **Note** CyberSource Latin American Processing is the name of a specific processing connection that CyberSource supports. In the CyberSource API documentation, CyberSource Latin American Processing does not refer to the general topic of processing in Latin America. The information in this field description is for the specific processing connection called CyberSource Latin American Processing. It is not for any other Latin American processors that CyberSource supports.  #### CyberSource through VisaNet Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.  #### For Payouts: This field may be sent only for FDC Compass.  #### OmniPay Direct Optional field.  #### RBS WorldPay Atlanta Optional field.  #### SIX Optional field.  #### TSYS Acquiring Solutions Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.  #### Worldpay VAP Optional field.  #### All other processors Not used. 
    */
    'lastName'?: string;
    /**
    * Payment card billing street address as it appears on the credit card issuer’s records.  #### SEPA Required for Create Mandate and Import Mandate  #### Atos This field must not contain colons (:).  #### CyberSource through VisaNet **Important** When you populate orderInformation.billTo.address1 and orderInformation.billTo.address2, CyberSource through VisaNet concatenates the two values. If the concatenated value exceeds 40 characters, CyberSource through VisaNet truncates the value at 40 characters before sending it to Visa and the issuing bank. Truncating this value affects AVS results and therefore might also affect risk decisions and chargebacks. Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.  #### FDMS Nashville When the street name is numeric, it must be sent in numeric format. For example, if the address is _One First Street_, it must be sent as _1 1st Street_.  Required if keyed; not used if swiped.  String (20)  #### TSYS Acquiring Solutions Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.  #### All other processors: Optional. String (60)  #### For Payouts This field may be sent only for FDC Compass.  **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting. 
    */
    'address1'?: string;
    /**
    * Customer's email address, including the full domain name.  #### CyberSource through VisaNet Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.  **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.  #### Invoicing Email address for the customer for sending the invoice. If the invoice is in SENT status and email is updated, the old email customer payment link won't work and you must resend the invoice with the new payment link.  #### Chase Paymentech Solutions Optional field.  ####  Credit Mutuel-CIC Optional field.  #### OmniPay Direct Optional field.  #### SIX Optional field.  #### TSYS Acquiring Solutions Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.  #### Worldpay VAP Optional field.  #### All other processors Not used. 
    */
    'email'?: string;
    /**
    * Payment card billing country. Use the two-character [ISO Standard Country Codes](http://apps.cybersource.com/library/documentation/sbc/quickref/countries_alpha_list.pdf).  #### SEPA/BACS Required for Create Mandate and Import Mandate  #### CyberSource through VisaNet Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.  **Important** It is your responsibility to determine whether a field is required for the transaction you are requesting.  #### Chase Paymentech Solutions Optional field.  ####  Credit Mutuel-CIC Optional field.  #### OmniPay Direct Optional field.  #### SIX Optional field.  #### TSYS Acquiring Solutions Required when `processingInformation.billPaymentOptions.billPayment=true` and `pointOfSaleInformation.entryMode=keyed`.  #### Worldpay VAP Optional field.  #### All other processors Not used. 
    */
    'country'?: string;
    /**
    * Customer’s phone number.  It is recommended that you include the country code when the order is from outside the U.S.  #### Chase Paymentech Solutions Optional field.  ####  Credit Mutuel-CIC Optional field.  #### CyberSource through VisaNet Credit card networks cannot process transactions that contain non-ASCII characters. CyberSource through VisaNet accepts and stores non-ASCII characters correctly and displays them correctly in reports. However, the limitations of the credit card networks prevent CyberSource through VisaNet from transmitting non-ASCII characters to the credit card networks. Therefore, CyberSource through VisaNet replaces non-ASCII characters with meaningless ASCII characters for transmission to the credit card networks.  #### For Payouts: This field may be sent only for FDC Compass.  #### OmniPay Direct Optional field.  #### SIX Optional field.  #### TSYS Acquiring Solutions Optional field.  #### Worldpay VAP Optional field.  #### All other processors Not used. 
    */
    'phoneNumber'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "firstName",
            "baseName": "firstName",
            "type": "string"
        },
        {
            "name": "lastName",
            "baseName": "lastName",
            "type": "string"
        },
        {
            "name": "address1",
            "baseName": "address1",
            "type": "string"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "country",
            "baseName": "country",
            "type": "string"
        },
        {
            "name": "phoneNumber",
            "baseName": "phoneNumber",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TssV2TransactionsPost201ResponseEmbeddedOrderInformationBillTo.attributeTypeMap;
    }
}

export class TssV2TransactionsPost201ResponseEmbeddedOrderInformationShipTo {
    /**
    * First name of the recipient.  #### Litle Maximum length: 25  #### All other processors Maximum length: 60  Optional field. 
    */
    'firstName'?: string;
    /**
    * Last name of the recipient.  #### Litle Maximum length: 25  #### All other processors Maximum length: 60  Optional field. 
    */
    'lastName'?: string;
    /**
    * First line of the shipping address.  Required field for authorization if any shipping address information is included in the request; otherwise, optional.  #### Tax Calculation Optional field for U.S. and Canadian taxes. Not applicable to international and value added taxes. Billing address objects will be used to determine the cardholder’s location when shipTo objects are not present. 
    */
    'address1'?: string;
    /**
    * Country of the shipping address. Use the two-character [ISO Standard Country Codes.](http://apps.cybersource.com/library/documentation/sbc/quickref/countries_alpha_list.pdf)  Required field for authorization if any shipping address information is included in the request; otherwise, optional.  #### Tax Calculation Optional field for U.S., Canadian, international tax, and value added taxes. Billing address objects will be used to determine the cardholder’s location when shipTo objects are not present. 
    */
    'country'?: string;
    /**
    * Phone number associated with the shipping address.
    */
    'phoneNumber'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "firstName",
            "baseName": "firstName",
            "type": "string"
        },
        {
            "name": "lastName",
            "baseName": "lastName",
            "type": "string"
        },
        {
            "name": "address1",
            "baseName": "address1",
            "type": "string"
        },
        {
            "name": "country",
            "baseName": "country",
            "type": "string"
        },
        {
            "name": "phoneNumber",
            "baseName": "phoneNumber",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TssV2TransactionsPost201ResponseEmbeddedOrderInformationShipTo.attributeTypeMap;
    }
}

export class TssV2TransactionsPost201ResponseEmbeddedPaymentInformation {
    'paymentType'?: TssV2TransactionsPost201ResponseEmbeddedPaymentInformationPaymentType;
    'customer'?: Ptsv2refreshpaymentstatusidPaymentInformationCustomer;
    'card'?: TssV2TransactionsPost201ResponseEmbeddedPaymentInformationCard;
    'bank'?: TssV2TransactionsPost201ResponseEmbeddedPaymentInformationBank;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "paymentType",
            "baseName": "paymentType",
            "type": "TssV2TransactionsPost201ResponseEmbeddedPaymentInformationPaymentType"
        },
        {
            "name": "customer",
            "baseName": "customer",
            "type": "Ptsv2refreshpaymentstatusidPaymentInformationCustomer"
        },
        {
            "name": "card",
            "baseName": "card",
            "type": "TssV2TransactionsPost201ResponseEmbeddedPaymentInformationCard"
        },
        {
            "name": "bank",
            "baseName": "bank",
            "type": "TssV2TransactionsPost201ResponseEmbeddedPaymentInformationBank"
        }    ];

    static getAttributeTypeMap() {
        return TssV2TransactionsPost201ResponseEmbeddedPaymentInformation.attributeTypeMap;
    }
}

export class TssV2TransactionsPost201ResponseEmbeddedPaymentInformationBank {
    'account'?: TssV2TransactionsPost201ResponseEmbeddedPaymentInformationBankAccount;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "account",
            "baseName": "account",
            "type": "TssV2TransactionsPost201ResponseEmbeddedPaymentInformationBankAccount"
        }    ];

    static getAttributeTypeMap() {
        return TssV2TransactionsPost201ResponseEmbeddedPaymentInformationBank.attributeTypeMap;
    }
}

export class TssV2TransactionsPost201ResponseEmbeddedPaymentInformationBankAccount {
    /**
    * Last four digits of the customer’s payment account number. 
    */
    'suffix'?: string;
    /**
    * Bank Identification Number (BIN). This is the initial four to six numbers on a credit card account number. 
    */
    'prefix'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "suffix",
            "baseName": "suffix",
            "type": "string"
        },
        {
            "name": "prefix",
            "baseName": "prefix",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TssV2TransactionsPost201ResponseEmbeddedPaymentInformationBankAccount.attributeTypeMap;
    }
}

export class TssV2TransactionsPost201ResponseEmbeddedPaymentInformationCard {
    /**
    * Last four digits of the cardholder’s account number. This field is included in the reply message when the client software that is installed on the POS terminal uses the token management service (TMS) to retrieve tokenized payment details.  You must contact customer support to have your account enabled to receive these fields in the credit reply message.  #### Google Pay transactions For PAN-based Google Pay transactions, this field is returned in the API response.  #### PIN debit This field is returned only for tokenized transactions. You can use this value on the receipt that you give to the cardholder.  Returned by PIN debit credit and PIN debit purchase.  This field is supported only by the following processors: - American Express Direct - Credit Mutuel-CIC - FDC Nashville Global - OmniPay Direct - SIX 
    */
    'suffix'?: string;
    /**
    * Bank Identification Number (BIN). This is the initial four to six numbers on a credit card account number.  #### Google Pay transactions For PAN-based Google Pay transactions, this field is returned in the API response. 
    */
    'prefix'?: string;
    /**
    * Three-digit value that indicates the card type.  **IMPORTANT** It is strongly recommended that you include the card type field in request messages even if it is optional for your processor and card type. Omitting the card type can cause the transaction to be processed with the wrong card type.  Possible values: - `001`: Visa. Use card type value `001` for Visa Electron. - `002`: Mastercard, Eurocard[^1], which is a European regional brand of Mastercard. - `003`: American Express - `004`: Discover - `005`: Diners Club - `006`: Carte Blanche[^1] - `007`: JCB[^1] - `008`: Optima - `009`: GE Private Label - `010`: Beneficial Private Label - `011`: Twinpay Credit Card - `012`: Twinpay Debit Card - `013`: WalMart - `014`: Enroute[^1] - `015`: Lowe's Consumer - `016`: Home Depot Consumer - `017`: MBNA - `018`: Dick's Sportswear - `019`: Casual Corner - `020`: Sears - `021`: JAL[^1] - `023`: Disney Card - `024`: Maestro (UK Domestic)[^1] - `025`: Sam's Club Consumer - `026`: Sam's Club Business - `027`: Nico's - `028`: Paymentech Bill Me Later - `029`: Bebe - `030`: Restoration Hardware - `031`: Delta Online - `032`: Solo - `033`: Visa Electron[^1]. Do not use this value. Use `001` for all Visa card types. - `034`: Dankort[^1] - `035`: Laser - `036`: Cartes Bancaires[^1,4] - `037`: Carta Si[^1] - `038`: Pinless Debit - `039`: Encoded account number[^1] - `040`: UATP[^1] - `041`: HOUSEHOLD - `042`: Maestro (International)[^1] - `043`: GE MONEY - `044`: Korean Cards - `045`: Style Cards - `046`: JCrew - `047`: Payeasecn eWallet - `048`: Payeasecn Bank Transfer - `049`: Meijer - `050`: Hipercard[^2,3] - `051`: Aura - `052`: Redecard - `053`: Orico card - `054`: Elo[^3] - `055`: Capitol One Private Label - `056`: Carnet - `057`: Costco Private Label - `058`: Carnet - `059`: ValueLink - `060`: MADA - `061`: RuPay - `062`: China UnionPay - `063`: Falabella Private Label - `064`: Prompt Card - `065`: Korean Domestic - `066`: Banricompras - `067`: MEEZA - `068`: PayPak - `070`: EFTPOS - `071`: Codensa - `072`: Olimpica - `073`: Colsubsidio - `074`: Tuya - `075`: Sodexo - `076`: Naranja - `077`: Cabal - `078`: DINELCO - `079`: PANAL - `080`: EPM - `081`: Jaywan  [^1]: For this card type, you must include the `paymentInformation.card.type` or `paymentInformation.tokenizedCard.type` field in your request for an authorization or a stand-alone credit. [^2]: For this card type on Cielo 3.0, you must include the `paymentInformation.card.type` or `paymentInformation.tokenizedCard.type` field in a request for an authorization or a stand-alone credit. This card type is not supported on Cielo 1.5. [^3]: For this card type on Getnet and Rede, you must include the `paymentInformation.card.type` or `paymentInformation.tokenizedCard.type` field in a request for an authorization or a stand-alone credit. [^4]: For this card type, you must include the `paymentInformation.card.type` in your request for any payer authentication services.  #### Used by **Authorization** Required for Carte Blanche and JCB. Optional for all other card types.  #### Card Present reply This field is included in the reply message when the client software that is installed on the POS terminal uses the token management service (TMS) to retrieve tokenized payment details. You must contact customer support to have your account enabled to receive these fields in the credit reply message.  Returned by the Credit service.  This reply field is only supported by the following processors: - American Express Direct - Credit Mutuel-CIC - FDC Nashville Global - OmniPay Direct - SIX  #### Google Pay transactions For PAN-based Google Pay transactions, this field is returned in the API response.  #### GPX This field only supports transactions from the following card types: - Visa - Mastercard - AMEX - Discover - Diners - JCB - Union Pay International 
    */
    'type'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "suffix",
            "baseName": "suffix",
            "type": "string"
        },
        {
            "name": "prefix",
            "baseName": "prefix",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TssV2TransactionsPost201ResponseEmbeddedPaymentInformationCard.attributeTypeMap;
    }
}

export class TssV2TransactionsPost201ResponseEmbeddedPaymentInformationPaymentType {
    /**
    * Indicates the payment type used in this payment transaction. Example: credit card, check
    */
    'type'?: string;
    /**
    * Indicates the payment method used in this payment transaction.
    */
    'method'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "method",
            "baseName": "method",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TssV2TransactionsPost201ResponseEmbeddedPaymentInformationPaymentType.attributeTypeMap;
    }
}

export class TssV2TransactionsPost201ResponseEmbeddedPointOfSaleInformation {
    /**
    * Identifier for the terminal at your retail location. You can define this value yourself, but consult the processor for requirements.  #### CyberSource through VisaNet A list of all possible values is stored in your CyberSource account. If terminal ID validation is enabled for your CyberSource account, the value you send for this field is validated against the list each time you include the field in a request. To enable or disable terminal ID validation, contact CyberSource Customer Support.  When you do not include this field in a request, CyberSource uses the default value that is defined in your CyberSource account.  #### FDC Nashville Global To have your account configured to support this field, contact CyberSource Customer Support. This value must be a value that FDC Nashville Global issued to you.  #### For Payouts This field is applicable for CyberSource through VisaNet.  #### GPX Identifier for the terminal at your retail location. A list of all possible values is stored in your account. If terminal ID validation is enabled for your account, the value you send for this field is validated against the list each time you include the field in a request. To enable or disable terminal ID validation, contact customer support.  When you do not include this field in a request, the default value that is defined in your account is used.  Optional for authorizations.  #### Used by **Authorization** Optional for the following processors. When you do not include this field in a request, the default value that is defined in your account is used.   - American Express Direct   - Credit Mutuel-CIC   - FDC Nashville Global   - SIX - Chase Paymentech Solutions: Optional field. If you include this field in your request, you must also include `pointOfSaleInformation.catLevel`. - FDMS Nashville: The default value that is defined in your account is used. - GPX - OmniPay Direct: Optional field.  For the following processors, this field is not used. - GPN - JCN Gateway - RBS WorldPay Atlanta - TSYS Acquiring Solutions - Worldpay VAP  #### Card Present reply Terminal identifier assigned by the acquirer. This value must be printed on the receipt. 
    */
    'terminalId'?: string;
    /**
    * Terminal serial number assigned by the hardware manufacturer. This value is provided by the client software that is installed on the POS terminal.  This value is not forwarded to the processor. Instead, the value is forwarded to the reporting functionality.  #### Used by **Authorization and Credit** Optional. This field is supported only by client software that is installed on your POS terminals for the following processors: - American Express Direct - Credit Mutuel-CIC - FDC Nashville Global - OmniPay Direct - SIX 
    */
    'terminalSerialNumber'?: string;
    /**
    * Value created by the client software that uniquely identifies the POS device. CyberSource does not forward this value to the processor. Instead, the value is forwarded to the CyberSource reporting functionality.  This field is supported only for authorizations and credits on these processors: - American Express Direct - Credit Mutuel-CIC - FDC Nashville Global - OmniPay Direct - SIX  Optional field. String (32) 
    */
    'deviceId'?: string;
    'partner'?: TssV2TransactionsPost201ResponseEmbeddedPointOfSaleInformationPartner;
    'emv'?: Ptsv2paymentsidreversalsPointOfSaleInformationEmv;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "terminalId",
            "baseName": "terminalId",
            "type": "string"
        },
        {
            "name": "terminalSerialNumber",
            "baseName": "terminalSerialNumber",
            "type": "string"
        },
        {
            "name": "deviceId",
            "baseName": "deviceId",
            "type": "string"
        },
        {
            "name": "partner",
            "baseName": "partner",
            "type": "TssV2TransactionsPost201ResponseEmbeddedPointOfSaleInformationPartner"
        },
        {
            "name": "emv",
            "baseName": "emv",
            "type": "Ptsv2paymentsidreversalsPointOfSaleInformationEmv"
        }    ];

    static getAttributeTypeMap() {
        return TssV2TransactionsPost201ResponseEmbeddedPointOfSaleInformation.attributeTypeMap;
    }
}

export class TssV2TransactionsPost201ResponseEmbeddedPointOfSaleInformationPartner {
    /**
    * Value that links the previous transaction to the current follow-on request. This value is assigned by the client software that is installed on the POS terminal, which makes it available to the terminal’s software and to CyberSource. Therefore, you can use this value to reconcile transactions between CyberSource and the terminal’s software.  CyberSource does not forward this value to the processor. Instead, the value is forwarded to the CyberSource reporting functionality.  This field is supported only on American Express Direct, FDC Nashville Global, and SIX. 
    */
    'originalTransactionId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "originalTransactionId",
            "baseName": "originalTransactionId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TssV2TransactionsPost201ResponseEmbeddedPointOfSaleInformationPartner.attributeTypeMap;
    }
}

export class TssV2TransactionsPost201ResponseEmbeddedProcessingInformation {
    /**
    * Type of digital payment solution for the transaction. Possible Values:   - `visacheckout`: Visa Checkout. This value is required for Visa Checkout transactions. For details, see `payment_solution` field description in [Visa Checkout Using the REST API.](https://developer.cybersource.com/content/dam/docs/cybs/en-us/apifields/reference/all/rest/api-fields.pdf)  - `001`: Apple Pay.  - `004`: Cybersource In-App Solution.  - `005`: Masterpass. This value is required for Masterpass transactions on OmniPay Direct.   - `006`: Android Pay.  - `007`: Chase Pay.  - `008`: Samsung Pay.  - `012`: Google Pay.  - `013`: Cybersource P2PE Decryption  - `014`: Mastercard credential on file (COF) payment network token. Returned in authorizations that use a payment network token associated with a TMS token.  - `015`: Visa credential on file (COF) payment network token. Returned in authorizations that use a payment network token associated with a TMS token.  - `027`: Click to Pay. 
    */
    'paymentSolution'?: string;
    /**
    * Required for AFT and OCT transactions.  Given below is a list of all the BAI values available. However, the processors may support only few specific BAI values.  - AA : Account-to-account  - BB : Supplier Payments - BI : Bank-Initiated P2P Money Transfer - BP : Non-Card Bill Pay/Bill Pay - CD : Cash Deposit - CP : Credit card Bill Payment - FD : Funds disbursement  - FT : Funds transfer - GD : Government Disbursement - GP : Gambling payout (non-online gambling) - LO : Loyalty credits and rebates - MD : Merchant Settlement - OG : Online Gambling Payout - PD : Payroll and pension disbursement - PP : Person-to-Person or Peer-to-Peer - TU : Top up, prepaid load - WT : Digital wallet  
    */
    'businessApplicationId'?: string;
    /**
    * Type of transaction. Some payment card companies use this information when determining discount rates.  #### Used by **Authorization** Required payer authentication transactions; otherwise, optional. **Credit** Required for standalone credits on Chase Paymentech solutions; otherwise, optional.  The list of valid values in this field depends on your processor.  #### Ingenico ePayments When you omit this field for Ingenico ePayments, the processor uses the default transaction type they have on file for you instead of the default value   #### Card Present You must set this field to `retail`. This field is required for a card-present transaction. Note that this should ONLY be used when the cardholder and card are present at the time of the transaction. For all keyed transactions originated from a POS terminal where the cardholder and card are not present, commerceIndicator should be submitted as “moto\" 
    */
    'commerceIndicator'?: string;
    /**
    * Type of transaction. Some payment card companies use this information when determining discount rates.  #### Used by **Authorization** Required payer authentication transactions; otherwise, optional. **Credit** Required for standalone credits on Chase Paymentech solutions; otherwise, optional.  The list of valid values in this field depends on your processor.  #### Ingenico ePayments When you omit this field for Ingenico ePayments, the processor uses the default transaction type they have on file for you instead of the default value   #### Card Present You must set this field to `retail`. This field is required for a card-present transaction. Note that this should ONLY be used when the cardholder and card are present at the time of the transaction. For all keyed transactions originated from a POS terminal where the cardholder and card are not present, commerceIndicator should be submitted as `moto` 
    */
    'commerceIndicatorLabel'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "paymentSolution",
            "baseName": "paymentSolution",
            "type": "string"
        },
        {
            "name": "businessApplicationId",
            "baseName": "businessApplicationId",
            "type": "string"
        },
        {
            "name": "commerceIndicator",
            "baseName": "commerceIndicator",
            "type": "string"
        },
        {
            "name": "commerceIndicatorLabel",
            "baseName": "commerceIndicatorLabel",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TssV2TransactionsPost201ResponseEmbeddedProcessingInformation.attributeTypeMap;
    }
}

export class TssV2TransactionsPost201ResponseEmbeddedProcessorInformation {
    'processor'?: TssV2TransactionsGet200ResponseProcessorInformationProcessor;
    /**
    * Unique ID [codigo] generated by the processor for real-time payments processed directly by the Iugu processor.
    */
    'providerTransactionId'?: string;
    /**
    * Authorization code. Returned only when the processor returns this value.  The length of this value depends on your processor.  Returned by authorization service.  #### PIN debit Authorization code that is returned by the processor.  Returned by PIN debit credit.  #### Elavon Encrypted Account Number Program The returned value is OFFLINE.  #### TSYS Acquiring Solutions The returned value for a successful zero amount authorization is 000000. 
    */
    'approvalCode'?: string;
    /**
    * The event status. 
    */
    'eventStatus'?: string;
    /**
    * #### Ingenico ePayments Unique number that CyberSource generates to identify the transaction. You can use this value to identify transactions in the Ingenico ePayments Collections Report, which provides settlement information. Contact customer support for information about the report.  ### CyberSource through VisaNet Retrieval request number. 
    */
    'retrievalReferenceNumber'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "processor",
            "baseName": "processor",
            "type": "TssV2TransactionsGet200ResponseProcessorInformationProcessor"
        },
        {
            "name": "providerTransactionId",
            "baseName": "providerTransactionId",
            "type": "string"
        },
        {
            "name": "approvalCode",
            "baseName": "approvalCode",
            "type": "string"
        },
        {
            "name": "eventStatus",
            "baseName": "eventStatus",
            "type": "string"
        },
        {
            "name": "retrievalReferenceNumber",
            "baseName": "retrievalReferenceNumber",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TssV2TransactionsPost201ResponseEmbeddedProcessorInformation.attributeTypeMap;
    }
}

export class TssV2TransactionsPost201ResponseEmbeddedRiskInformation {
    'providers'?: TssV2TransactionsPost201ResponseEmbeddedRiskInformationProviders;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "providers",
            "baseName": "providers",
            "type": "TssV2TransactionsPost201ResponseEmbeddedRiskInformationProviders"
        }    ];

    static getAttributeTypeMap() {
        return TssV2TransactionsPost201ResponseEmbeddedRiskInformation.attributeTypeMap;
    }
}

export class TssV2TransactionsPost201ResponseEmbeddedRiskInformationProviders {
    'fingerprint'?: TssV2TransactionsPost201ResponseEmbeddedRiskInformationProvidersFingerprint;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "fingerprint",
            "baseName": "fingerprint",
            "type": "TssV2TransactionsPost201ResponseEmbeddedRiskInformationProvidersFingerprint"
        }    ];

    static getAttributeTypeMap() {
        return TssV2TransactionsPost201ResponseEmbeddedRiskInformationProviders.attributeTypeMap;
    }
}

export class TssV2TransactionsPost201ResponseEmbeddedRiskInformationProvidersFingerprint {
    /**
    * Customer’s true IP address detected by the application.  For details, see the `true_ipaddress` field description in _Device Fingerprinting Guide_ on the [CyberSource Business Center.](https://ebc2.cybersource.com/ebc2/) Click **Decision Manager** > **Documentation** > **Guides** > _Device Fingerprinting Guide_ (PDF link). 
    */
    'trueIpaddress'?: string;
    /**
    * The unique identifier of the device that is returned in the `riskInformation.providers.fingerprint.device_fingerprint_hash` API reply field. For more details about this field, see the `device_fingerprint_hash` field description in the _Device Fingerprinting Guide_ on the [CyberSource Business Center.](https://ebc2.cybersource.com/ebc2/) Click **Decision Manager** > **Documentation** > **Guides** > _Device Fingerprinting Guide_ (PDF link). 
    */
    'hash'?: string;
    /**
    * The device identifier generated from attributes collected during profiling. Returned by a 3rd party when you use device fingerprinting.  For details, see the `device_fingerprint_smart_id` field description in [CyberSource Decision Manager Device Fingerprinting Guide.](https://www.cybersource.com/developers/documentation/fraud_management) 
    */
    'smartId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "trueIpaddress",
            "baseName": "true_ipaddress",
            "type": "string"
        },
        {
            "name": "hash",
            "baseName": "hash",
            "type": "string"
        },
        {
            "name": "smartId",
            "baseName": "smartId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TssV2TransactionsPost201ResponseEmbeddedRiskInformationProvidersFingerprint.attributeTypeMap;
    }
}

export class TssV2TransactionsPost201ResponseEmbeddedTransactionSummaries {
    /**
    * An unique identification number generated by Cybersource to identify the submitted request. Returned by all services. It is also appended to the endpoint of the resource. On incremental authorizations, this value with be the same as the identification number returned in the original authorization response. 
    */
    'id'?: string;
    /**
    * Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ` **Example** `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.). The `T` separates the date and the time. The `Z` indicates UTC.  Returned by Cybersource for all services. 
    */
    'submitTimeUtc'?: string;
    /**
    * Your CyberSource merchant ID.
    */
    'merchantId'?: string;
    /**
    * The status of the submitted transaction. Note: This field may not be returned for all transactions. 
    */
    'status'?: string;
    'applicationInformation'?: TssV2TransactionsPost201ResponseEmbeddedApplicationInformation;
    'buyerInformation'?: PtsV2CreateOrderPost201ResponseBuyerInformation;
    'clientReferenceInformation'?: TssV2TransactionsPost201ResponseEmbeddedClientReferenceInformation;
    'consumerAuthenticationInformation'?: TssV2TransactionsPost201ResponseEmbeddedConsumerAuthenticationInformation;
    'deviceInformation'?: Riskv1authenticationresultsDeviceInformation;
    'errorInformation'?: TssV2TransactionsPost201ResponseEmbeddedErrorInformation;
    'fraudMarkingInformation'?: TssV2TransactionsGet200ResponseFraudMarkingInformation;
    /**
    * The object containing the custom data that the merchant defines. 
    */
    'merchantDefinedInformation'?: Array<Ptsv2paymentsMerchantDefinedInformation>;
    'merchantInformation'?: TssV2TransactionsPost201ResponseEmbeddedMerchantInformation;
    'orderInformation'?: TssV2TransactionsPost201ResponseEmbeddedOrderInformation;
    'paymentInformation'?: TssV2TransactionsPost201ResponseEmbeddedPaymentInformation;
    'processingInformation'?: TssV2TransactionsPost201ResponseEmbeddedProcessingInformation;
    'processorInformation'?: TssV2TransactionsPost201ResponseEmbeddedProcessorInformation;
    'pointOfSaleInformation'?: TssV2TransactionsPost201ResponseEmbeddedPointOfSaleInformation;
    'riskInformation'?: TssV2TransactionsPost201ResponseEmbeddedRiskInformation;
    'links'?: TssV2TransactionsPost201ResponseEmbeddedLinks;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "submitTimeUtc",
            "baseName": "submitTimeUtc",
            "type": "string"
        },
        {
            "name": "merchantId",
            "baseName": "merchantId",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "applicationInformation",
            "baseName": "applicationInformation",
            "type": "TssV2TransactionsPost201ResponseEmbeddedApplicationInformation"
        },
        {
            "name": "buyerInformation",
            "baseName": "buyerInformation",
            "type": "PtsV2CreateOrderPost201ResponseBuyerInformation"
        },
        {
            "name": "clientReferenceInformation",
            "baseName": "clientReferenceInformation",
            "type": "TssV2TransactionsPost201ResponseEmbeddedClientReferenceInformation"
        },
        {
            "name": "consumerAuthenticationInformation",
            "baseName": "consumerAuthenticationInformation",
            "type": "TssV2TransactionsPost201ResponseEmbeddedConsumerAuthenticationInformation"
        },
        {
            "name": "deviceInformation",
            "baseName": "deviceInformation",
            "type": "Riskv1authenticationresultsDeviceInformation"
        },
        {
            "name": "errorInformation",
            "baseName": "errorInformation",
            "type": "TssV2TransactionsPost201ResponseEmbeddedErrorInformation"
        },
        {
            "name": "fraudMarkingInformation",
            "baseName": "fraudMarkingInformation",
            "type": "TssV2TransactionsGet200ResponseFraudMarkingInformation"
        },
        {
            "name": "merchantDefinedInformation",
            "baseName": "merchantDefinedInformation",
            "type": "Array<Ptsv2paymentsMerchantDefinedInformation>"
        },
        {
            "name": "merchantInformation",
            "baseName": "merchantInformation",
            "type": "TssV2TransactionsPost201ResponseEmbeddedMerchantInformation"
        },
        {
            "name": "orderInformation",
            "baseName": "orderInformation",
            "type": "TssV2TransactionsPost201ResponseEmbeddedOrderInformation"
        },
        {
            "name": "paymentInformation",
            "baseName": "paymentInformation",
            "type": "TssV2TransactionsPost201ResponseEmbeddedPaymentInformation"
        },
        {
            "name": "processingInformation",
            "baseName": "processingInformation",
            "type": "TssV2TransactionsPost201ResponseEmbeddedProcessingInformation"
        },
        {
            "name": "processorInformation",
            "baseName": "processorInformation",
            "type": "TssV2TransactionsPost201ResponseEmbeddedProcessorInformation"
        },
        {
            "name": "pointOfSaleInformation",
            "baseName": "pointOfSaleInformation",
            "type": "TssV2TransactionsPost201ResponseEmbeddedPointOfSaleInformation"
        },
        {
            "name": "riskInformation",
            "baseName": "riskInformation",
            "type": "TssV2TransactionsPost201ResponseEmbeddedRiskInformation"
        },
        {
            "name": "links",
            "baseName": "_links",
            "type": "TssV2TransactionsPost201ResponseEmbeddedLinks"
        }    ];

    static getAttributeTypeMap() {
        return TssV2TransactionsPost201ResponseEmbeddedTransactionSummaries.attributeTypeMap;
    }
}

export class UmsV1UsersGet200Response {
    'users'?: Array<UmsV1UsersGet200ResponseUsers>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "users",
            "baseName": "users",
            "type": "Array<UmsV1UsersGet200ResponseUsers>"
        }    ];

    static getAttributeTypeMap() {
        return UmsV1UsersGet200Response.attributeTypeMap;
    }
}

export class UmsV1UsersGet200ResponseAccountInformation {
    'userName'?: string;
    'roleId'?: string;
    'permissions'?: Array<string>;
    /**
    * Valid values: - active - inactive - locked - disabled - forgotpassword - deleted 
    */
    'status'?: string;
    'createdTime'?: Date;
    'lastAccessTime'?: Date;
    'languagePreference'?: string;
    'timezone'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "userName",
            "baseName": "userName",
            "type": "string"
        },
        {
            "name": "roleId",
            "baseName": "roleId",
            "type": "string"
        },
        {
            "name": "permissions",
            "baseName": "permissions",
            "type": "Array<string>"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "createdTime",
            "baseName": "createdTime",
            "type": "Date"
        },
        {
            "name": "lastAccessTime",
            "baseName": "lastAccessTime",
            "type": "Date"
        },
        {
            "name": "languagePreference",
            "baseName": "languagePreference",
            "type": "string"
        },
        {
            "name": "timezone",
            "baseName": "timezone",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return UmsV1UsersGet200ResponseAccountInformation.attributeTypeMap;
    }
}

export class UmsV1UsersGet200ResponseContactInformation {
    'email'?: string;
    'phoneNumber'?: string;
    'firstName'?: string;
    'lastName'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "phoneNumber",
            "baseName": "phoneNumber",
            "type": "string"
        },
        {
            "name": "firstName",
            "baseName": "firstName",
            "type": "string"
        },
        {
            "name": "lastName",
            "baseName": "lastName",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return UmsV1UsersGet200ResponseContactInformation.attributeTypeMap;
    }
}

export class UmsV1UsersGet200ResponseOrganizationInformation {
    'organizationId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "organizationId",
            "baseName": "organizationId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return UmsV1UsersGet200ResponseOrganizationInformation.attributeTypeMap;
    }
}

export class UmsV1UsersGet200ResponseUsers {
    'accountInformation'?: UmsV1UsersGet200ResponseAccountInformation;
    'organizationInformation'?: UmsV1UsersGet200ResponseOrganizationInformation;
    'contactInformation'?: UmsV1UsersGet200ResponseContactInformation;
    'customFields'?: { [key: string]: string; };

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "accountInformation",
            "baseName": "accountInformation",
            "type": "UmsV1UsersGet200ResponseAccountInformation"
        },
        {
            "name": "organizationInformation",
            "baseName": "organizationInformation",
            "type": "UmsV1UsersGet200ResponseOrganizationInformation"
        },
        {
            "name": "contactInformation",
            "baseName": "contactInformation",
            "type": "UmsV1UsersGet200ResponseContactInformation"
        },
        {
            "name": "customFields",
            "baseName": "customFields",
            "type": "{ [key: string]: string; }"
        }    ];

    static getAttributeTypeMap() {
        return UmsV1UsersGet200ResponseUsers.attributeTypeMap;
    }
}

export class UpdateInvoiceRequest {
    'customerInformation'?: Invoicingv2invoicesCustomerInformation;
    'processingInformation'?: Invoicingv2invoicesProcessingInformation;
    'invoiceInformation': Invoicingv2invoicesidInvoiceInformation;
    'orderInformation': Invoicingv2invoicesOrderInformation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "customerInformation",
            "baseName": "customerInformation",
            "type": "Invoicingv2invoicesCustomerInformation"
        },
        {
            "name": "processingInformation",
            "baseName": "processingInformation",
            "type": "Invoicingv2invoicesProcessingInformation"
        },
        {
            "name": "invoiceInformation",
            "baseName": "invoiceInformation",
            "type": "Invoicingv2invoicesidInvoiceInformation"
        },
        {
            "name": "orderInformation",
            "baseName": "orderInformation",
            "type": "Invoicingv2invoicesOrderInformation"
        }    ];

    static getAttributeTypeMap() {
        return UpdateInvoiceRequest.attributeTypeMap;
    }
}

export class UpdateOrderRequest {
    'clientReferenceInformation'?: Ptsv2intentsClientReferenceInformation;
    'orderInformation'?: Ptsv2intentsidOrderInformation;
    'merchantInformation'?: Ptsv2intentsidMerchantInformation;
    'paymentInformation'?: Ptsv2intentsidPaymentInformation;
    'processingInformation'?: Ptsv2intentsidProcessingInformation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "clientReferenceInformation",
            "baseName": "clientReferenceInformation",
            "type": "Ptsv2intentsClientReferenceInformation"
        },
        {
            "name": "orderInformation",
            "baseName": "orderInformation",
            "type": "Ptsv2intentsidOrderInformation"
        },
        {
            "name": "merchantInformation",
            "baseName": "merchantInformation",
            "type": "Ptsv2intentsidMerchantInformation"
        },
        {
            "name": "paymentInformation",
            "baseName": "paymentInformation",
            "type": "Ptsv2intentsidPaymentInformation"
        },
        {
            "name": "processingInformation",
            "baseName": "processingInformation",
            "type": "Ptsv2intentsidProcessingInformation"
        }    ];

    static getAttributeTypeMap() {
        return UpdateOrderRequest.attributeTypeMap;
    }
}

export class UpdatePaymentLinkRequest {
    /**
    * The status of the purchase or donation link.  Possible values: - ACTIVE - INACTIVE 
    */
    'status'?: string;
    'clientReferenceInformation'?: Invoicingv2invoicesClientReferenceInformation;
    'processingInformation'?: Iplv2paymentlinksidProcessingInformation;
    'purchaseInformation'?: Iplv2paymentlinksidPurchaseInformation;
    'orderInformation'?: Iplv2paymentlinksidOrderInformation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "clientReferenceInformation",
            "baseName": "clientReferenceInformation",
            "type": "Invoicingv2invoicesClientReferenceInformation"
        },
        {
            "name": "processingInformation",
            "baseName": "processingInformation",
            "type": "Iplv2paymentlinksidProcessingInformation"
        },
        {
            "name": "purchaseInformation",
            "baseName": "purchaseInformation",
            "type": "Iplv2paymentlinksidPurchaseInformation"
        },
        {
            "name": "orderInformation",
            "baseName": "orderInformation",
            "type": "Iplv2paymentlinksidOrderInformation"
        }    ];

    static getAttributeTypeMap() {
        return UpdatePaymentLinkRequest.attributeTypeMap;
    }
}

export class UpdatePlanRequest {
    'planInformation'?: Rbsv1plansidPlanInformation;
    'processingInformation'?: Rbsv1plansidProcessingInformation;
    'orderInformation'?: GetAllPlansResponseOrderInformation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "planInformation",
            "baseName": "planInformation",
            "type": "Rbsv1plansidPlanInformation"
        },
        {
            "name": "processingInformation",
            "baseName": "processingInformation",
            "type": "Rbsv1plansidProcessingInformation"
        },
        {
            "name": "orderInformation",
            "baseName": "orderInformation",
            "type": "GetAllPlansResponseOrderInformation"
        }    ];

    static getAttributeTypeMap() {
        return UpdatePlanRequest.attributeTypeMap;
    }
}

export class UpdatePlanResponse {
    'links'?: PtsV2IncrementalAuthorizationPatch201ResponseLinks;
    /**
    * An unique identification number generated by Cybersource to identify the submitted request. Returned by all services. It is also appended to the endpoint of the resource. On incremental authorizations, this value with be the same as the identification number returned in the original authorization response. 
    */
    'id'?: string;
    /**
    * Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ` **Example** `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.). The `T` separates the date and the time. The `Z` indicates UTC.  Returned by Cybersource for all services. 
    */
    'submitTimeUtc'?: string;
    /**
    * The status of the submitted transaction.  Possible values:  - COMPLETED 
    */
    'status'?: string;
    'planInformation'?: UpdatePlanResponsePlanInformation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "PtsV2IncrementalAuthorizationPatch201ResponseLinks"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "submitTimeUtc",
            "baseName": "submitTimeUtc",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "planInformation",
            "baseName": "planInformation",
            "type": "UpdatePlanResponsePlanInformation"
        }    ];

    static getAttributeTypeMap() {
        return UpdatePlanResponse.attributeTypeMap;
    }
}

export class UpdatePlanResponsePlanInformation {
    /**
    * Plan code 
    */
    'code'?: string;
    /**
    * Plan Status:  - `DRAFT`  - `ACTIVE`  - `INACTIVE` 
    */
    'status'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return UpdatePlanResponsePlanInformation.attributeTypeMap;
    }
}

export class UpdateStatus {
    /**
    * The status the user intends to update the subscription to. The supported values are ACTIVE & INACTIVE. If the subscription status is INACTIVE, webhook notifications will not be sent. Webhooks will resume being sent once the subscription is ACTIVE again.
    */
    'status'?: UpdateStatus.StatusEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "status",
            "baseName": "status",
            "type": "UpdateStatus.StatusEnum"
        }    ];

    static getAttributeTypeMap() {
        return UpdateStatus.attributeTypeMap;
    }
}

export namespace UpdateStatus {
    export enum StatusEnum {
        ACTIVE = <any> 'ACTIVE',
        INACTIVE = <any> 'INACTIVE'
    }
}
export class UpdateSubscription {
    'clientReferenceInformation'?: Rbsv1subscriptionsClientReferenceInformation;
    'processingInformation'?: Rbsv1subscriptionsProcessingInformation;
    'planInformation'?: Rbsv1subscriptionsidPlanInformation;
    'subscriptionInformation'?: Rbsv1subscriptionsidSubscriptionInformation;
    'orderInformation'?: Rbsv1subscriptionsidOrderInformation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "clientReferenceInformation",
            "baseName": "clientReferenceInformation",
            "type": "Rbsv1subscriptionsClientReferenceInformation"
        },
        {
            "name": "processingInformation",
            "baseName": "processingInformation",
            "type": "Rbsv1subscriptionsProcessingInformation"
        },
        {
            "name": "planInformation",
            "baseName": "planInformation",
            "type": "Rbsv1subscriptionsidPlanInformation"
        },
        {
            "name": "subscriptionInformation",
            "baseName": "subscriptionInformation",
            "type": "Rbsv1subscriptionsidSubscriptionInformation"
        },
        {
            "name": "orderInformation",
            "baseName": "orderInformation",
            "type": "Rbsv1subscriptionsidOrderInformation"
        }    ];

    static getAttributeTypeMap() {
        return UpdateSubscription.attributeTypeMap;
    }
}

export class UpdateSubscriptionResponse {
    'links'?: GetAllSubscriptionsResponseLinks;
    /**
    * An unique identification number generated by Cybersource to identify the submitted request. Returned by all services. It is also appended to the endpoint of the resource. On incremental authorizations, this value with be the same as the identification number returned in the original authorization response. 
    */
    'id'?: string;
    /**
    * Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ` **Example** `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.). The `T` separates the date and the time. The `Z` indicates UTC.  Returned by Cybersource for all services. 
    */
    'submitTimeUtc'?: string;
    /**
    * The status of the submitted transaction.  Possible values:  - COMPLETED  - PENDING_REVIEW  - DECLINED  - INVALID_REQUEST 
    */
    'status'?: string;
    'subscriptionInformation'?: CreateSubscriptionResponseSubscriptionInformation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "GetAllSubscriptionsResponseLinks"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "submitTimeUtc",
            "baseName": "submitTimeUtc",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "subscriptionInformation",
            "baseName": "subscriptionInformation",
            "type": "CreateSubscriptionResponseSubscriptionInformation"
        }    ];

    static getAttributeTypeMap() {
        return UpdateSubscriptionResponse.attributeTypeMap;
    }
}

export class UpdateWebhook {
    /**
    * Client friendly webhook name.
    */
    'name'?: string;
    /**
    * Organization Id.
    */
    'organizationId'?: string;
    /**
    * Client friendly webhook description.
    */
    'description'?: string;
    'products'?: Array<Notificationsubscriptionsv2webhooksProducts>;
    /**
    * The client's endpoint (URL) to receive webhooks.
    */
    'webhookUrl'?: string;
    /**
    * The webhook scope. 1. SELF The Webhook is used to deliver webhooks for only this Organization (or Merchant). 2. DESCENDANTS The Webhook is used to deliver webhooks for this Organization and its children. This field is optional.  
    */
    'notificationScope'?: UpdateWebhook.NotificationScopeEnum;
    /**
    * The client's health check endpoint (URL).
    */
    'healthCheckUrl'?: string;
    'securityPolicy'?: Notificationsubscriptionsv2webhooksSecurityPolicy;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "organizationId",
            "baseName": "organizationId",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "products",
            "baseName": "products",
            "type": "Array<Notificationsubscriptionsv2webhooksProducts>"
        },
        {
            "name": "webhookUrl",
            "baseName": "webhookUrl",
            "type": "string"
        },
        {
            "name": "notificationScope",
            "baseName": "notificationScope",
            "type": "UpdateWebhook.NotificationScopeEnum"
        },
        {
            "name": "healthCheckUrl",
            "baseName": "healthCheckUrl",
            "type": "string"
        },
        {
            "name": "securityPolicy",
            "baseName": "securityPolicy",
            "type": "Notificationsubscriptionsv2webhooksSecurityPolicy"
        }    ];

    static getAttributeTypeMap() {
        return UpdateWebhook.attributeTypeMap;
    }
}

export namespace UpdateWebhook {
    export enum NotificationScopeEnum {
        SELF = <any> 'SELF',
        DESCENDANTS = <any> 'DESCENDANTS'
    }
}
export class Upv1capturecontextsCaptureMandate {
    /**
    * Configure Unified Checkout to capture billing address information.  Possible values: - FULL: Capture complete billing address information. - PARTIAL: Capture first name, last name, country and postal/zip code only. - NONE: Capture only first name and last name. 
    */
    'billingType'?: string;
    /**
    * Configure Unified Checkout to capture customer email address.  Possible values:  - True  - False 
    */
    'requestEmail'?: boolean;
    /**
    * Configure Unified Checkout to capture customer phone number.  Possible values: - True - False 
    */
    'requestPhone'?: boolean;
    /**
    * Configure Unified Checkout to capture customer shipping details.  Possible values: - True - False 
    */
    'requestShipping'?: boolean;
    /**
    * List of countries available to ship to.   Use the two-character ISO Standard Country Codes. 
    */
    'shipToCountries'?: Array<string>;
    /**
    * Configure Unified Checkout to display the list of accepted card networks beneath the payment button  Possible values: - True - False 
    */
    'showAcceptedNetworkIcons'?: boolean;
    /**
    * Configure Unified Checkout to display the final confirmation screen when using Click to Pay.<br> Where 'BillingType'= NONE and 'requestShipping'= FALSE and the customer is using an existing Click to Pay card as their chosen payment method, a final confirmation screen can be removed allowing the customer to check out as soon as they have selected their payment method from within their Click to Pay card tray.  Possible values: - True - False 
    */
    'showConfirmationStep'?: boolean;
    /**
    * Configure Unified Checkout to display the \"Save card for future use\" checkbox.<br>  Configurable check box that will show in a Manual card entry flow to allow a Cardholder to give consent to store their manually entered credential with the Merchant that they are paying.<br>  Applicable when manually entering the details and not enrolling in Click to Pay.  Possible values:  - True   - False<br><br>  **Use Cases:**  **Offer consumers option to save their card in Unified Checkout:**  - Include the captureMandate.requestSaveCard field in the capture context request and set it to true. - When set to true, this will show a checkbox with the message ‘Save card for future use’ in Unified Checkout. - When selected this provides a response in both the Transient Token and Get Credentials API response.<br><br>  **Do not offer consumers the option to save their card in Unified Checkout:**  - Include the captureMandate.requestSaveCard field in the capture context request and set it to false OR omit the field from the capture context request. - When set to false, the save card option is not shown to consumers when manually entering card details. 
    */
    'requestSaveCard'?: boolean;
    /**
    * Configure Unified Checkout to display combo card at checkout.<br>  A combo debit/credit card is a single card that functions both as a Debit/Credit card.  Unified Checkout / Click to Pay Drop-in UI allows the Cardholder to choose whether they would like the transaction to be paid for using either debit or credit card. **Important:** This is applicable to Visa cards only.  Possible values: - True  - False<br><br>  **Use Cases:**  **Offer Combo Card at Checkout:**  - Include the captureMandate.comboCard field in the capture context request and set it to true. - When set to true, Combo Card selection is shown at checkout <br><br>  **Do not offer Combo Card at Checkout:**  - Include the captureMandate.comboCard field in the capture context request and set it to false OR omit the field from the capture context request. - The Combo Card selection is not shown at checkout. 
    */
    'comboCard'?: boolean;
    /**
    * Configure Unified Checkout to display and capture the CPF number (Cadastro de Pessoas Físicas).  The CPF number is a unique 11-digit identifier issued to Brazilian citizens and residents for tax purposes.  Possible values: - True - False<br><br>  This field is optional.   If set to true the field is required. If set to false the field is optional. If the field is not included in the capture context then it is not captured.<br><br>  **Important:**  - If PANENTRY is specified in the allowedPaymentTypes field, the CPF number will be displayed in Unified Checkout regardless of what card number is entered.  - If CLICKTOPAY is specified in the allowedPaymentTypes field, the CPF number will be displayed in Unified Checkout only when a Visa Click To Pay card is entered. 
    */
    'CPF'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "billingType",
            "baseName": "billingType",
            "type": "string"
        },
        {
            "name": "requestEmail",
            "baseName": "requestEmail",
            "type": "boolean"
        },
        {
            "name": "requestPhone",
            "baseName": "requestPhone",
            "type": "boolean"
        },
        {
            "name": "requestShipping",
            "baseName": "requestShipping",
            "type": "boolean"
        },
        {
            "name": "shipToCountries",
            "baseName": "shipToCountries",
            "type": "Array<string>"
        },
        {
            "name": "showAcceptedNetworkIcons",
            "baseName": "showAcceptedNetworkIcons",
            "type": "boolean"
        },
        {
            "name": "showConfirmationStep",
            "baseName": "showConfirmationStep",
            "type": "boolean"
        },
        {
            "name": "requestSaveCard",
            "baseName": "requestSaveCard",
            "type": "boolean"
        },
        {
            "name": "comboCard",
            "baseName": "comboCard",
            "type": "boolean"
        },
        {
            "name": "CPF",
            "baseName": "CPF",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return Upv1capturecontextsCaptureMandate.attributeTypeMap;
    }
}

/**
* The completeMandate object is designed to provide instructions for orchestrating payment services.  Unified Checkout is capable of orchestrating a number of services on your behalf.<br><br>   By providing this field in the capture context Unified Checkout will initiate services on your behalf from the browser, simplifying your integration. 
*/
export class Upv1capturecontextsCompleteMandate {
    /**
    * This field is used to indicate how a payment should be processed.  Possible values: - AUTH: Use this value when you want to authorize a payment within Unified Checkout without capturing it immediately.  Payment types that initiate an immediate transfer of funds are NOT allowed.  If a capture context request includes a payment type incompatible with this mode, a 400 error will be returned.  A merchant would need to perform their own capture via API where applicable.<br><br>   - CAPTURE: Use this value when you want to perform a sale within Unified Checkout and capture the payment immediately during the transaction.  Note: Some payment types may return a PENDING status, requiring an additional status check call to determine the final outcome of the payment.<br><br> - PREFER_AUTH: Use this value to offer multiple alternative payment options during the Unified Checkout experience. This option authorizes the payment without immediate capture, where available.  It will perform a \"CAPTURE\" where an \"AUTH\" is not allowed by the payment type.  Transactions can be AUTHORIZED, CAPTURED, or PENDING.  If an \"AUTH\" is performed, a merchant would need to perform their own capture via API where applicable. 
    */
    'type'?: string;
    /**
    * Configure Unified Checkout to determine whether Decision Manager is invoked during service orchestration.  Possible values:  - True  - False<br><br>  Setting this value to True indicates that device fingerprinting will be executed to add additional information for risk service Setting this value to False (or not provided) indicates that you do not wish to run device fingerprinting and skip decision manager services. 
    */
    'decisionManager'?: boolean;
    /**
    * Configure Unified Checkout to determine whether Consumer Authentication is invoked during service orchestration.  Possible values:  - True  - False<br><br>  Setting this value to True will attempt to perform authentication using the Payer Authentication Service. Setting this value to False (or not provided) indicates that you do not wish to perform authentication using the Payer Authentication Service. 
    */
    'consumerAuthentication'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "decisionManager",
            "baseName": "decisionManager",
            "type": "boolean"
        },
        {
            "name": "consumerAuthentication",
            "baseName": "consumerAuthentication",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return Upv1capturecontextsCompleteMandate.attributeTypeMap;
    }
}

export class Upv1capturecontextsOrderInformation {
    'amountDetails'?: Upv1capturecontextsOrderInformationAmountDetails;
    'billTo'?: Upv1capturecontextsOrderInformationBillTo;
    'shipTo'?: Upv1capturecontextsOrderInformationShipTo;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "amountDetails",
            "baseName": "amountDetails",
            "type": "Upv1capturecontextsOrderInformationAmountDetails"
        },
        {
            "name": "billTo",
            "baseName": "billTo",
            "type": "Upv1capturecontextsOrderInformationBillTo"
        },
        {
            "name": "shipTo",
            "baseName": "shipTo",
            "type": "Upv1capturecontextsOrderInformationShipTo"
        }    ];

    static getAttributeTypeMap() {
        return Upv1capturecontextsOrderInformation.attributeTypeMap;
    }
}

export class Upv1capturecontextsOrderInformationAmountDetails {
    /**
    * This field defines the total order amount. 
    */
    'totalAmount'?: string;
    /**
    * This field defines the currency applicable to the order. 
    */
    'currency'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "totalAmount",
            "baseName": "totalAmount",
            "type": "string"
        },
        {
            "name": "currency",
            "baseName": "currency",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Upv1capturecontextsOrderInformationAmountDetails.attributeTypeMap;
    }
}

export class Upv1capturecontextsOrderInformationBillTo {
    /**
    * Payment card billing street address as it appears on the credit card issuer’s records. 
    */
    'address1'?: string;
    /**
    * Used for additional address information. For example: _Attention: Accounts Payable_ Optional field. 
    */
    'address2'?: string;
    /**
    * Additional address information (third line of the billing address)
    */
    'address3'?: string;
    /**
    * Additional address information (fourth line of the billing address) 
    */
    'address4'?: string;
    /**
    * State or province of the billing address. Use the [State, Province, and Territory Codes for the United States and Canada](https://developer.cybersource.com/library/documentation/sbc/quickref/states_and_provinces.pdf). 
    */
    'administrativeArea'?: string;
    /**
    * Building number in the street address. 
    */
    'buildingNumber'?: string;
    /**
    * Payment card billing country. Use the two-character [ISO Standard Country Codes](http://apps.cybersource.com/library/documentation/sbc/quickref/countries_alpha_list.pdf). 
    */
    'country'?: string;
    /**
    * Customer’s neighborhood, community, or region (a barrio in Brazil) within the city or municipality 
    */
    'district'?: string;
    /**
    * Payment card billing city. 
    */
    'locality'?: string;
    /**
    * Postal code for the billing address. The postal code must consist of 5 to 9 digits. 
    */
    'postalCode'?: string;
    'company'?: Upv1capturecontextsOrderInformationBillToCompany;
    /**
    * Customer's email address, including the full domain name. 
    */
    'email'?: string;
    /**
    * Customer’s first name. This name must be the same as the name on the card
    */
    'firstName'?: string;
    /**
    * Customer’s last name. This name must be the same as the name on the card. 
    */
    'lastName'?: string;
    /**
    * Customer’s middle name. 
    */
    'middleName'?: string;
    /**
    * Customer’s name suffix. 
    */
    'nameSuffix'?: string;
    /**
    * Title. 
    */
    'title'?: string;
    /**
    * Customer’s phone number. 
    */
    'phoneNumber'?: string;
    /**
    * Customer's phone number type.  #### For Payouts: This field may be sent only for FDC Compass.  Possible Values: * day * home * night * work 
    */
    'phoneType'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "address1",
            "baseName": "address1",
            "type": "string"
        },
        {
            "name": "address2",
            "baseName": "address2",
            "type": "string"
        },
        {
            "name": "address3",
            "baseName": "address3",
            "type": "string"
        },
        {
            "name": "address4",
            "baseName": "address4",
            "type": "string"
        },
        {
            "name": "administrativeArea",
            "baseName": "administrativeArea",
            "type": "string"
        },
        {
            "name": "buildingNumber",
            "baseName": "buildingNumber",
            "type": "string"
        },
        {
            "name": "country",
            "baseName": "country",
            "type": "string"
        },
        {
            "name": "district",
            "baseName": "district",
            "type": "string"
        },
        {
            "name": "locality",
            "baseName": "locality",
            "type": "string"
        },
        {
            "name": "postalCode",
            "baseName": "postalCode",
            "type": "string"
        },
        {
            "name": "company",
            "baseName": "company",
            "type": "Upv1capturecontextsOrderInformationBillToCompany"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "firstName",
            "baseName": "firstName",
            "type": "string"
        },
        {
            "name": "lastName",
            "baseName": "lastName",
            "type": "string"
        },
        {
            "name": "middleName",
            "baseName": "middleName",
            "type": "string"
        },
        {
            "name": "nameSuffix",
            "baseName": "nameSuffix",
            "type": "string"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "phoneNumber",
            "baseName": "phoneNumber",
            "type": "string"
        },
        {
            "name": "phoneType",
            "baseName": "phoneType",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Upv1capturecontextsOrderInformationBillTo.attributeTypeMap;
    }
}

export class Upv1capturecontextsOrderInformationBillToCompany {
    /**
    * Name of the customer’s company.
    */
    'name'?: string;
    /**
    * Payment card billing street address as it appears on the credit card issuer’s records. 
    */
    'address1'?: string;
    /**
    * Used for additional address information. For example: _Attention: Accounts Payable_ Optional field. 
    */
    'address2'?: string;
    /**
    * Additional address information (third line of the billing address)
    */
    'address3'?: string;
    /**
    * Additional address information (fourth line of the billing address) 
    */
    'address4'?: string;
    /**
    * State or province of the billing address. Use the [State, Province, and Territory Codes for the United States and Canada](https://developer.cybersource.com/library/documentation/sbc/quickref/states_and_provinces.pdf). 
    */
    'administrativeArea'?: string;
    /**
    * Building number in the street address. 
    */
    'buildingNumber'?: string;
    /**
    * Payment card billing country. Use the two-character [ISO Standard Country Codes](http://apps.cybersource.com/library/documentation/sbc/quickref/countries_alpha_list.pdf). 
    */
    'country'?: string;
    /**
    * Customer’s neighborhood, community, or region (a barrio in Brazil) within the city or municipality 
    */
    'district'?: string;
    /**
    * Payment card billing city. 
    */
    'locality'?: string;
    /**
    * Postal code for the billing address. The postal code must consist of 5 to 9 digits. 
    */
    'postalCode'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "address1",
            "baseName": "address1",
            "type": "string"
        },
        {
            "name": "address2",
            "baseName": "address2",
            "type": "string"
        },
        {
            "name": "address3",
            "baseName": "address3",
            "type": "string"
        },
        {
            "name": "address4",
            "baseName": "address4",
            "type": "string"
        },
        {
            "name": "administrativeArea",
            "baseName": "administrativeArea",
            "type": "string"
        },
        {
            "name": "buildingNumber",
            "baseName": "buildingNumber",
            "type": "string"
        },
        {
            "name": "country",
            "baseName": "country",
            "type": "string"
        },
        {
            "name": "district",
            "baseName": "district",
            "type": "string"
        },
        {
            "name": "locality",
            "baseName": "locality",
            "type": "string"
        },
        {
            "name": "postalCode",
            "baseName": "postalCode",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Upv1capturecontextsOrderInformationBillToCompany.attributeTypeMap;
    }
}

export class Upv1capturecontextsOrderInformationShipTo {
    /**
    * First line of the shipping address. 
    */
    'address1'?: string;
    /**
    * Second line of the shipping address. 
    */
    'address2'?: string;
    /**
    * Third line of the shipping address. 
    */
    'address3'?: string;
    /**
    * Fourth line of the shipping address.
    */
    'address4'?: string;
    /**
    * State or province of the shipping address.  Use the [State, Province, and Territory Codes for the United States and Canada](https://developer.cybersource.com/library/documentation/sbc/quickref/states_and_provinces.pdf) 
    */
    'administrativeArea'?: string;
    /**
    * Building number in the street address. 
    */
    'buildingNumber'?: string;
    /**
    * Country of the shipping address.  Use the two-character [ISO Standard Country Codes.](http://apps.cybersource.com/library/documentation/sbc/quickref/countries_alpha_list.pdf) 
    */
    'country'?: string;
    /**
    * Neighborhood, community, or region within a city or municipality.
    */
    'district'?: string;
    /**
    * City of the shipping address. 
    */
    'locality'?: string;
    /**
    * Postal code for the shipping address. The postal code must consist of 5 to 9 digits. 
    */
    'postalCode'?: string;
    /**
    * First name of the recipient
    */
    'firstName'?: string;
    /**
    * Last name of the recipient.
    */
    'lastName'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "address1",
            "baseName": "address1",
            "type": "string"
        },
        {
            "name": "address2",
            "baseName": "address2",
            "type": "string"
        },
        {
            "name": "address3",
            "baseName": "address3",
            "type": "string"
        },
        {
            "name": "address4",
            "baseName": "address4",
            "type": "string"
        },
        {
            "name": "administrativeArea",
            "baseName": "administrativeArea",
            "type": "string"
        },
        {
            "name": "buildingNumber",
            "baseName": "buildingNumber",
            "type": "string"
        },
        {
            "name": "country",
            "baseName": "country",
            "type": "string"
        },
        {
            "name": "district",
            "baseName": "district",
            "type": "string"
        },
        {
            "name": "locality",
            "baseName": "locality",
            "type": "string"
        },
        {
            "name": "postalCode",
            "baseName": "postalCode",
            "type": "string"
        },
        {
            "name": "firstName",
            "baseName": "firstName",
            "type": "string"
        },
        {
            "name": "lastName",
            "baseName": "lastName",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Upv1capturecontextsOrderInformationShipTo.attributeTypeMap;
    }
}

export class V1FileDetailsGet200Response {
    'fileDetails'?: Array<V1FileDetailsGet200ResponseFileDetails>;
    'links'?: V1FileDetailsGet200ResponseLinks;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "fileDetails",
            "baseName": "fileDetails",
            "type": "Array<V1FileDetailsGet200ResponseFileDetails>"
        },
        {
            "name": "links",
            "baseName": "_links",
            "type": "V1FileDetailsGet200ResponseLinks"
        }    ];

    static getAttributeTypeMap() {
        return V1FileDetailsGet200Response.attributeTypeMap;
    }
}

export class V1FileDetailsGet200ResponseFileDetails {
    /**
    * Unique identifier of a file
    */
    'fileId'?: string;
    /**
    * Name of the file
    */
    'name'?: string;
    /**
    * Date and time for the file in PST
    */
    'createdTime'?: Date;
    /**
    * Date and time for the file in PST
    */
    'lastModifiedTime'?: Date;
    /**
    * Date and time for the file in PST
    */
    'date'?: string;
    /**
    * 'File extension'  Valid values: - 'application/xml' - 'text/csv' - 'application/pdf' - 'application/octet-stream' 
    */
    'mimeType'?: string;
    /**
    * Size of the file in bytes
    */
    'size'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "fileId",
            "baseName": "fileId",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "createdTime",
            "baseName": "createdTime",
            "type": "Date"
        },
        {
            "name": "lastModifiedTime",
            "baseName": "lastModifiedTime",
            "type": "Date"
        },
        {
            "name": "date",
            "baseName": "date",
            "type": "string"
        },
        {
            "name": "mimeType",
            "baseName": "mimeType",
            "type": "string"
        },
        {
            "name": "size",
            "baseName": "size",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return V1FileDetailsGet200ResponseFileDetails.attributeTypeMap;
    }
}

export class V1FileDetailsGet200ResponseLinks {
    'self'?: V1FileDetailsGet200ResponseLinksSelf;
    'files'?: Array<V1FileDetailsGet200ResponseLinksFiles>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "self",
            "baseName": "self",
            "type": "V1FileDetailsGet200ResponseLinksSelf"
        },
        {
            "name": "files",
            "baseName": "files",
            "type": "Array<V1FileDetailsGet200ResponseLinksFiles>"
        }    ];

    static getAttributeTypeMap() {
        return V1FileDetailsGet200ResponseLinks.attributeTypeMap;
    }
}

export class V1FileDetailsGet200ResponseLinksFiles {
    /**
    * Unique identifier for each file
    */
    'fileId'?: string;
    'href'?: string;
    'method'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "fileId",
            "baseName": "fileId",
            "type": "string"
        },
        {
            "name": "href",
            "baseName": "href",
            "type": "string"
        },
        {
            "name": "method",
            "baseName": "method",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return V1FileDetailsGet200ResponseLinksFiles.attributeTypeMap;
    }
}

export class V1FileDetailsGet200ResponseLinksSelf {
    'href'?: string;
    'method'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "href",
            "baseName": "href",
            "type": "string"
        },
        {
            "name": "method",
            "baseName": "method",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return V1FileDetailsGet200ResponseLinksSelf.attributeTypeMap;
    }
}

export class VTConfig {
    'cardNotPresent'?: VTConfigCardNotPresent;
    'cardPresent'?: VTConfigCardNotPresent;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "cardNotPresent",
            "baseName": "cardNotPresent",
            "type": "VTConfigCardNotPresent"
        },
        {
            "name": "cardPresent",
            "baseName": "cardPresent",
            "type": "VTConfigCardNotPresent"
        }    ];

    static getAttributeTypeMap() {
        return VTConfig.attributeTypeMap;
    }
}

export class VTConfigCardNotPresent {
    'globalPaymentInformation'?: VTConfigCardNotPresentGlobalPaymentInformation;
    'receiptInformation'?: VTConfigCardNotPresentReceiptInformation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "globalPaymentInformation",
            "baseName": "globalPaymentInformation",
            "type": "VTConfigCardNotPresentGlobalPaymentInformation"
        },
        {
            "name": "receiptInformation",
            "baseName": "receiptInformation",
            "type": "VTConfigCardNotPresentReceiptInformation"
        }    ];

    static getAttributeTypeMap() {
        return VTConfigCardNotPresent.attributeTypeMap;
    }
}

export class VTConfigCardNotPresentGlobalPaymentInformation {
    'basicInformation'?: VTConfigCardNotPresentGlobalPaymentInformationBasicInformation;
    'paymentInformation'?: VTConfigCardNotPresentGlobalPaymentInformationPaymentInformation;
    'merchantDefinedDataFields'?: VTConfigCardNotPresentGlobalPaymentInformationMerchantDefinedDataFields;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "basicInformation",
            "baseName": "basicInformation",
            "type": "VTConfigCardNotPresentGlobalPaymentInformationBasicInformation"
        },
        {
            "name": "paymentInformation",
            "baseName": "paymentInformation",
            "type": "VTConfigCardNotPresentGlobalPaymentInformationPaymentInformation"
        },
        {
            "name": "merchantDefinedDataFields",
            "baseName": "merchantDefinedDataFields",
            "type": "VTConfigCardNotPresentGlobalPaymentInformationMerchantDefinedDataFields"
        }    ];

    static getAttributeTypeMap() {
        return VTConfigCardNotPresentGlobalPaymentInformation.attributeTypeMap;
    }
}

export class VTConfigCardNotPresentGlobalPaymentInformationBasicInformation {
    'defaultStandardEntryClassCode'?: string;
    /**
    * ISO 4217 format
    */
    'defaultCountryCode'?: string;
    /**
    * Three-character [ISO Standard Currency Codes.](http://apps.cybersource.com/library/documentation/sbc/quickref/currencies.pdf)
    */
    'defaultCurrencyCode'?: string;
    'defaultTransactionType'?: VTConfigCardNotPresentGlobalPaymentInformationBasicInformation.DefaultTransactionTypeEnum;
    'defaultPaymentType'?: VTConfigCardNotPresentGlobalPaymentInformationBasicInformation.DefaultPaymentTypeEnum;
    'defaultTransactionSource'?: string;
    'displayRetail'?: boolean;
    'displayMoto'?: boolean;
    'displayInternet'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "defaultStandardEntryClassCode",
            "baseName": "defaultStandardEntryClassCode",
            "type": "string"
        },
        {
            "name": "defaultCountryCode",
            "baseName": "defaultCountryCode",
            "type": "string"
        },
        {
            "name": "defaultCurrencyCode",
            "baseName": "defaultCurrencyCode",
            "type": "string"
        },
        {
            "name": "defaultTransactionType",
            "baseName": "defaultTransactionType",
            "type": "VTConfigCardNotPresentGlobalPaymentInformationBasicInformation.DefaultTransactionTypeEnum"
        },
        {
            "name": "defaultPaymentType",
            "baseName": "defaultPaymentType",
            "type": "VTConfigCardNotPresentGlobalPaymentInformationBasicInformation.DefaultPaymentTypeEnum"
        },
        {
            "name": "defaultTransactionSource",
            "baseName": "defaultTransactionSource",
            "type": "string"
        },
        {
            "name": "displayRetail",
            "baseName": "displayRetail",
            "type": "boolean"
        },
        {
            "name": "displayMoto",
            "baseName": "displayMoto",
            "type": "boolean"
        },
        {
            "name": "displayInternet",
            "baseName": "displayInternet",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return VTConfigCardNotPresentGlobalPaymentInformationBasicInformation.attributeTypeMap;
    }
}

export namespace VTConfigCardNotPresentGlobalPaymentInformationBasicInformation {
    export enum DefaultTransactionTypeEnum {
        AUTHORIZATION = <any> 'AUTHORIZATION',
        SALE = <any> 'SALE'
    }
    export enum DefaultPaymentTypeEnum {
        CREDITCARD = <any> 'CREDIT_CARD',
        ECHECK = <any> 'ECHECK'
    }
}
export class VTConfigCardNotPresentGlobalPaymentInformationMerchantDefinedDataFields {
    'displayMerchantDefinedData1'?: boolean;
    'displayMerchantDefinedData2'?: boolean;
    'displayMerchantDefinedData3'?: boolean;
    'displayMerchantDefinedData4'?: boolean;
    'displayMerchantDefinedData5'?: boolean;
    'merchantDefinedData1DefaultValue'?: string;
    'merchantDefinedData1Label'?: string;
    'requireMerchantDefinedData1'?: boolean;
    'merchantDefinedData2DefaultValue'?: string;
    'merchantDefinedData2Label'?: string;
    'requireMerchantDefinedData2'?: boolean;
    'merchantDefinedData3DefaultValue'?: string;
    'merchantDefinedData3Label'?: string;
    'requireMerchantDefinedData3'?: boolean;
    'merchantDefinedData4DefaultValue'?: string;
    'merchantDefinedData4Label'?: string;
    'requireMerchantDefinedData4'?: boolean;
    'merchantDefinedData5DefaultValue'?: string;
    'merchantDefinedData5Label'?: string;
    'requireMerchantDefinedData5'?: boolean;
    'merchantDefinedData1DisplayOnReceipt'?: boolean;
    'merchantDefinedData2DisplayOnReceipt'?: boolean;
    'merchantDefinedData3DisplayOnReceipt'?: boolean;
    'merchantDefinedData4DisplayOnReceipt'?: boolean;
    'merchantDefinedData5DisplayOnReceipt'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "displayMerchantDefinedData1",
            "baseName": "displayMerchantDefinedData1",
            "type": "boolean"
        },
        {
            "name": "displayMerchantDefinedData2",
            "baseName": "displayMerchantDefinedData2",
            "type": "boolean"
        },
        {
            "name": "displayMerchantDefinedData3",
            "baseName": "displayMerchantDefinedData3",
            "type": "boolean"
        },
        {
            "name": "displayMerchantDefinedData4",
            "baseName": "displayMerchantDefinedData4",
            "type": "boolean"
        },
        {
            "name": "displayMerchantDefinedData5",
            "baseName": "displayMerchantDefinedData5",
            "type": "boolean"
        },
        {
            "name": "merchantDefinedData1DefaultValue",
            "baseName": "merchantDefinedData1DefaultValue",
            "type": "string"
        },
        {
            "name": "merchantDefinedData1Label",
            "baseName": "merchantDefinedData1Label",
            "type": "string"
        },
        {
            "name": "requireMerchantDefinedData1",
            "baseName": "requireMerchantDefinedData1",
            "type": "boolean"
        },
        {
            "name": "merchantDefinedData2DefaultValue",
            "baseName": "merchantDefinedData2DefaultValue",
            "type": "string"
        },
        {
            "name": "merchantDefinedData2Label",
            "baseName": "merchantDefinedData2Label",
            "type": "string"
        },
        {
            "name": "requireMerchantDefinedData2",
            "baseName": "requireMerchantDefinedData2",
            "type": "boolean"
        },
        {
            "name": "merchantDefinedData3DefaultValue",
            "baseName": "merchantDefinedData3DefaultValue",
            "type": "string"
        },
        {
            "name": "merchantDefinedData3Label",
            "baseName": "merchantDefinedData3Label",
            "type": "string"
        },
        {
            "name": "requireMerchantDefinedData3",
            "baseName": "requireMerchantDefinedData3",
            "type": "boolean"
        },
        {
            "name": "merchantDefinedData4DefaultValue",
            "baseName": "merchantDefinedData4DefaultValue",
            "type": "string"
        },
        {
            "name": "merchantDefinedData4Label",
            "baseName": "merchantDefinedData4Label",
            "type": "string"
        },
        {
            "name": "requireMerchantDefinedData4",
            "baseName": "requireMerchantDefinedData4",
            "type": "boolean"
        },
        {
            "name": "merchantDefinedData5DefaultValue",
            "baseName": "merchantDefinedData5DefaultValue",
            "type": "string"
        },
        {
            "name": "merchantDefinedData5Label",
            "baseName": "merchantDefinedData5Label",
            "type": "string"
        },
        {
            "name": "requireMerchantDefinedData5",
            "baseName": "requireMerchantDefinedData5",
            "type": "boolean"
        },
        {
            "name": "merchantDefinedData1DisplayOnReceipt",
            "baseName": "merchantDefinedData1DisplayOnReceipt",
            "type": "boolean"
        },
        {
            "name": "merchantDefinedData2DisplayOnReceipt",
            "baseName": "merchantDefinedData2DisplayOnReceipt",
            "type": "boolean"
        },
        {
            "name": "merchantDefinedData3DisplayOnReceipt",
            "baseName": "merchantDefinedData3DisplayOnReceipt",
            "type": "boolean"
        },
        {
            "name": "merchantDefinedData4DisplayOnReceipt",
            "baseName": "merchantDefinedData4DisplayOnReceipt",
            "type": "boolean"
        },
        {
            "name": "merchantDefinedData5DisplayOnReceipt",
            "baseName": "merchantDefinedData5DisplayOnReceipt",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return VTConfigCardNotPresentGlobalPaymentInformationMerchantDefinedDataFields.attributeTypeMap;
    }
}

export class VTConfigCardNotPresentGlobalPaymentInformationPaymentInformation {
    'displayCardVerificationValue'?: Array<VTConfigCardNotPresentGlobalPaymentInformationPaymentInformation.DisplayCardVerificationValueEnum>;
    'requireCardVerificationValue'?: Array<VTConfigCardNotPresentGlobalPaymentInformationPaymentInformation.RequireCardVerificationValueEnum>;
    'acceptedCardTypes'?: Array<VTConfigCardNotPresentGlobalPaymentInformationPaymentInformation.AcceptedCardTypesEnum>;
    'displayCreditCards'?: boolean;
    'displayEchecks'?: boolean;
    'displayDebtIndicator'?: boolean;
    'displayBillPayment'?: boolean;
    'enableEchecks'?: boolean;
    'displayIgnoreECheckAvsCheckbox'?: boolean;
    'firstNameRequired'?: boolean;
    'lastNameRequired'?: boolean;
    'displayFirstName'?: boolean;
    'displayLastName'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "displayCardVerificationValue",
            "baseName": "displayCardVerificationValue",
            "type": "Array<VTConfigCardNotPresentGlobalPaymentInformationPaymentInformation.DisplayCardVerificationValueEnum>"
        },
        {
            "name": "requireCardVerificationValue",
            "baseName": "requireCardVerificationValue",
            "type": "Array<VTConfigCardNotPresentGlobalPaymentInformationPaymentInformation.RequireCardVerificationValueEnum>"
        },
        {
            "name": "acceptedCardTypes",
            "baseName": "acceptedCardTypes",
            "type": "Array<VTConfigCardNotPresentGlobalPaymentInformationPaymentInformation.AcceptedCardTypesEnum>"
        },
        {
            "name": "displayCreditCards",
            "baseName": "displayCreditCards",
            "type": "boolean"
        },
        {
            "name": "displayEchecks",
            "baseName": "displayEchecks",
            "type": "boolean"
        },
        {
            "name": "displayDebtIndicator",
            "baseName": "displayDebtIndicator",
            "type": "boolean"
        },
        {
            "name": "displayBillPayment",
            "baseName": "displayBillPayment",
            "type": "boolean"
        },
        {
            "name": "enableEchecks",
            "baseName": "enableEchecks",
            "type": "boolean"
        },
        {
            "name": "displayIgnoreECheckAvsCheckbox",
            "baseName": "displayIgnoreECheckAvsCheckbox",
            "type": "boolean"
        },
        {
            "name": "firstNameRequired",
            "baseName": "firstNameRequired",
            "type": "boolean"
        },
        {
            "name": "lastNameRequired",
            "baseName": "lastNameRequired",
            "type": "boolean"
        },
        {
            "name": "displayFirstName",
            "baseName": "displayFirstName",
            "type": "boolean"
        },
        {
            "name": "displayLastName",
            "baseName": "displayLastName",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return VTConfigCardNotPresentGlobalPaymentInformationPaymentInformation.attributeTypeMap;
    }
}

export namespace VTConfigCardNotPresentGlobalPaymentInformationPaymentInformation {
    export enum DisplayCardVerificationValueEnum {
        VISA = <any> 'VISA',
        MASTERCARD = <any> 'MASTER_CARD',
        AMEX = <any> 'AMEX',
        DISCOVER = <any> 'DISCOVER',
        DINERSCLUB = <any> 'DINERS_CLUB',
        CARTEBLANCHE = <any> 'CARTE_BLANCHE',
        JCB = <any> 'JCB',
        ENROUTE = <any> 'ENROUTE',
        JAL = <any> 'JAL',
        SWITCHSOLO = <any> 'SWITCH_SOLO',
        DELTA = <any> 'DELTA',
        VISAELECTRON = <any> 'VISA_ELECTRON',
        DANKORT = <any> 'DANKORT',
        LASER = <any> 'LASER',
        CARTESBANCAIRES = <any> 'CARTE_SBANCAIRES',
        CARTASI = <any> 'CARTASI',
        MAESTROINTERNATIONAL = <any> 'MAESTRO_INTERNATIONAL',
        GEMONEYUKCARD = <any> 'GE_MONEY_UK_CARD',
        HIPERCARD = <any> 'HIPER_CARD',
        ELO = <any> 'ELO'
    }
    export enum RequireCardVerificationValueEnum {
        VISA = <any> 'VISA',
        MASTERCARD = <any> 'MASTER_CARD',
        AMEX = <any> 'AMEX',
        DISCOVER = <any> 'DISCOVER',
        DINERSCLUB = <any> 'DINERS_CLUB',
        CARTEBLANCHE = <any> 'CARTE_BLANCHE',
        JCB = <any> 'JCB',
        ENROUTE = <any> 'ENROUTE',
        JAL = <any> 'JAL',
        SWITCHSOLO = <any> 'SWITCH_SOLO',
        DELTA = <any> 'DELTA',
        VISAELECTRON = <any> 'VISA_ELECTRON',
        DANKORT = <any> 'DANKORT',
        LASER = <any> 'LASER',
        CARTESBANCAIRES = <any> 'CARTE_SBANCAIRES',
        CARTASI = <any> 'CARTASI',
        MAESTROINTERNATIONAL = <any> 'MAESTRO_INTERNATIONAL',
        GEMONEYUKCARD = <any> 'GE_MONEY_UK_CARD',
        HIPERCARD = <any> 'HIPER_CARD',
        ELO = <any> 'ELO'
    }
    export enum AcceptedCardTypesEnum {
        VISA = <any> 'VISA',
        MASTERCARD = <any> 'MASTER_CARD',
        AMEX = <any> 'AMEX',
        DISCOVER = <any> 'DISCOVER',
        DINERSCLUB = <any> 'DINERS_CLUB',
        CARTEBLANCHE = <any> 'CARTE_BLANCHE',
        JCB = <any> 'JCB',
        ENROUTE = <any> 'ENROUTE',
        JAL = <any> 'JAL',
        SWITCHSOLO = <any> 'SWITCH_SOLO',
        DELTA = <any> 'DELTA',
        VISAELECTRON = <any> 'VISA_ELECTRON',
        DANKORT = <any> 'DANKORT',
        LASER = <any> 'LASER',
        CARTESBANCAIRES = <any> 'CARTE_SBANCAIRES',
        CARTASI = <any> 'CARTASI',
        MAESTROINTERNATIONAL = <any> 'MAESTRO_INTERNATIONAL',
        GEMONEYUKCARD = <any> 'GE_MONEY_UK_CARD',
        HIPERCARD = <any> 'HIPER_CARD',
        ELO = <any> 'ELO'
    }
}
export class VTConfigCardNotPresentReceiptInformation {
    'header'?: VTConfigCardNotPresentReceiptInformationHeader;
    'orderInformation'?: VTConfigCardNotPresentReceiptInformationOrderInformation;
    'emailReceipt'?: VTConfigCardNotPresentReceiptInformationEmailReceipt;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "header",
            "baseName": "header",
            "type": "VTConfigCardNotPresentReceiptInformationHeader"
        },
        {
            "name": "orderInformation",
            "baseName": "orderInformation",
            "type": "VTConfigCardNotPresentReceiptInformationOrderInformation"
        },
        {
            "name": "emailReceipt",
            "baseName": "emailReceipt",
            "type": "VTConfigCardNotPresentReceiptInformationEmailReceipt"
        }    ];

    static getAttributeTypeMap() {
        return VTConfigCardNotPresentReceiptInformation.attributeTypeMap;
    }
}

export class VTConfigCardNotPresentReceiptInformationEmailReceipt {
    'sendersEmailAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "sendersEmailAddress",
            "baseName": "sendersEmailAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return VTConfigCardNotPresentReceiptInformationEmailReceipt.attributeTypeMap;
    }
}

export class VTConfigCardNotPresentReceiptInformationHeader {
    'virtualTerminalReceiptHeader'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "virtualTerminalReceiptHeader",
            "baseName": "virtualTerminalReceiptHeader",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return VTConfigCardNotPresentReceiptInformationHeader.attributeTypeMap;
    }
}

export class VTConfigCardNotPresentReceiptInformationOrderInformation {
    'emailAliasName'?: string;
    'customReplyToEmailAddress'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "emailAliasName",
            "baseName": "emailAliasName",
            "type": "string"
        },
        {
            "name": "customReplyToEmailAddress",
            "baseName": "customReplyToEmailAddress",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return VTConfigCardNotPresentReceiptInformationOrderInformation.attributeTypeMap;
    }
}

export class ValidateExportComplianceRequest {
    'clientReferenceInformation'?: Riskv1liststypeentriesClientReferenceInformation;
    'orderInformation'?: Riskv1exportcomplianceinquiriesOrderInformation;
    'buyerInformation'?: Riskv1addressverificationsBuyerInformation;
    'deviceInformation'?: Riskv1exportcomplianceinquiriesDeviceInformation;
    'exportComplianceInformation'?: Riskv1exportcomplianceinquiriesExportComplianceInformation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "clientReferenceInformation",
            "baseName": "clientReferenceInformation",
            "type": "Riskv1liststypeentriesClientReferenceInformation"
        },
        {
            "name": "orderInformation",
            "baseName": "orderInformation",
            "type": "Riskv1exportcomplianceinquiriesOrderInformation"
        },
        {
            "name": "buyerInformation",
            "baseName": "buyerInformation",
            "type": "Riskv1addressverificationsBuyerInformation"
        },
        {
            "name": "deviceInformation",
            "baseName": "deviceInformation",
            "type": "Riskv1exportcomplianceinquiriesDeviceInformation"
        },
        {
            "name": "exportComplianceInformation",
            "baseName": "exportComplianceInformation",
            "type": "Riskv1exportcomplianceinquiriesExportComplianceInformation"
        }    ];

    static getAttributeTypeMap() {
        return ValidateExportComplianceRequest.attributeTypeMap;
    }
}

export class ValidateRequest {
    'clientReferenceInformation'?: Riskv1authenticationsetupsClientReferenceInformation;
    'processingInformation'?: Riskv1authenticationsetupsProcessingInformation;
    'orderInformation'?: Riskv1authenticationresultsOrderInformation;
    'paymentInformation'?: Riskv1authenticationresultsPaymentInformation;
    'consumerAuthenticationInformation'?: Riskv1authenticationresultsConsumerAuthenticationInformation;
    'deviceInformation'?: Riskv1authenticationresultsDeviceInformation;
    'tokenInformation'?: Riskv1decisionsTokenInformation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "clientReferenceInformation",
            "baseName": "clientReferenceInformation",
            "type": "Riskv1authenticationsetupsClientReferenceInformation"
        },
        {
            "name": "processingInformation",
            "baseName": "processingInformation",
            "type": "Riskv1authenticationsetupsProcessingInformation"
        },
        {
            "name": "orderInformation",
            "baseName": "orderInformation",
            "type": "Riskv1authenticationresultsOrderInformation"
        },
        {
            "name": "paymentInformation",
            "baseName": "paymentInformation",
            "type": "Riskv1authenticationresultsPaymentInformation"
        },
        {
            "name": "consumerAuthenticationInformation",
            "baseName": "consumerAuthenticationInformation",
            "type": "Riskv1authenticationresultsConsumerAuthenticationInformation"
        },
        {
            "name": "deviceInformation",
            "baseName": "deviceInformation",
            "type": "Riskv1authenticationresultsDeviceInformation"
        },
        {
            "name": "tokenInformation",
            "baseName": "tokenInformation",
            "type": "Riskv1decisionsTokenInformation"
        }    ];

    static getAttributeTypeMap() {
        return ValidateRequest.attributeTypeMap;
    }
}

export class ValueAddedServicesProducts {
    'reporting'?: PaymentsProductsTax;
    'transactionSearch'?: PaymentsProductsTax;
    'bankAccountValidation'?: PaymentsProductsTax;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "reporting",
            "baseName": "reporting",
            "type": "PaymentsProductsTax"
        },
        {
            "name": "transactionSearch",
            "baseName": "transactionSearch",
            "type": "PaymentsProductsTax"
        },
        {
            "name": "bankAccountValidation",
            "baseName": "bankAccountValidation",
            "type": "PaymentsProductsTax"
        }    ];

    static getAttributeTypeMap() {
        return ValueAddedServicesProducts.attributeTypeMap;
    }
}

export class VasV2PaymentsPost201Response {
    'links'?: VasV2PaymentsPost201ResponseLinks;
    /**
    * An unique identification number generated by Cybersource to identify the submitted request. Returned by all services. It is also appended to the endpoint of the resource. On incremental authorizations, this value with be the same as the identification number returned in the original authorization response. 
    */
    'id'?: string;
    /**
    * Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ` **Example** `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.). The `T` separates the date and the time. The `Z` indicates UTC.  Returned by Cybersource for all services. 
    */
    'submitTimeUtc'?: string;
    /**
    * The status of the submitted transaction.  Possible values:  - COMPLETED 
    */
    'status'?: string;
    'clientReferenceInformation'?: PtsV2PaymentsPost201ResponseClientReferenceInformation;
    'taxInformation'?: VasV2PaymentsPost201ResponseTaxInformation;
    'orderInformation'?: VasV2PaymentsPost201ResponseOrderInformation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "links",
            "baseName": "_links",
            "type": "VasV2PaymentsPost201ResponseLinks"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "submitTimeUtc",
            "baseName": "submitTimeUtc",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "clientReferenceInformation",
            "baseName": "clientReferenceInformation",
            "type": "PtsV2PaymentsPost201ResponseClientReferenceInformation"
        },
        {
            "name": "taxInformation",
            "baseName": "taxInformation",
            "type": "VasV2PaymentsPost201ResponseTaxInformation"
        },
        {
            "name": "orderInformation",
            "baseName": "orderInformation",
            "type": "VasV2PaymentsPost201ResponseOrderInformation"
        }    ];

    static getAttributeTypeMap() {
        return VasV2PaymentsPost201Response.attributeTypeMap;
    }
}

export class VasV2PaymentsPost201ResponseLinks {
    '_void'?: PtsV2PaymentsPost201ResponseLinksSelf;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "_void",
            "baseName": "void",
            "type": "PtsV2PaymentsPost201ResponseLinksSelf"
        }    ];

    static getAttributeTypeMap() {
        return VasV2PaymentsPost201ResponseLinks.attributeTypeMap;
    }
}

export class VasV2PaymentsPost201ResponseOrderInformation {
    /**
    * Total amount of tax exempt amounts. This value is the sum of the values for all the `orderInformation.lineItems[].exemptAmount` fields in the tax calculation request. 
    */
    'exemptAmount'?: string;
    /**
    * Total amount of all taxable amounts. This value is the sum of the values for all the `orderInformation.lineItems[].taxAmount` fields in the tax calculation request. 
    */
    'taxableAmount'?: string;
    /**
    * Total amount of tax for all lineItems in the tax calculation request. 
    */
    'taxAmount'?: string;
    'lineItems'?: Array<VasV2PaymentsPost201ResponseOrderInformationLineItems>;
    'taxDetails'?: Array<VasV2PaymentsPost201ResponseOrderInformationTaxDetails>;
    'amountDetails'?: Ptsv2paymentsidreversalsReversalInformationAmountDetails;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "exemptAmount",
            "baseName": "exemptAmount",
            "type": "string"
        },
        {
            "name": "taxableAmount",
            "baseName": "taxableAmount",
            "type": "string"
        },
        {
            "name": "taxAmount",
            "baseName": "taxAmount",
            "type": "string"
        },
        {
            "name": "lineItems",
            "baseName": "lineItems",
            "type": "Array<VasV2PaymentsPost201ResponseOrderInformationLineItems>"
        },
        {
            "name": "taxDetails",
            "baseName": "taxDetails",
            "type": "Array<VasV2PaymentsPost201ResponseOrderInformationTaxDetails>"
        },
        {
            "name": "amountDetails",
            "baseName": "amountDetails",
            "type": "Ptsv2paymentsidreversalsReversalInformationAmountDetails"
        }    ];

    static getAttributeTypeMap() {
        return VasV2PaymentsPost201ResponseOrderInformation.attributeTypeMap;
    }
}

export class VasV2PaymentsPost201ResponseOrderInformationJurisdiction {
    /**
    * Type of tax jurisdiction for the item. Returned only if the `taxInformation.showTaxPerLineItem` field is set to `Yes`.  Possible values: - `city` - `county` - `state` - `country` - `special` 
    */
    'type'?: string;
    /**
    * Name of the jurisdiction tax for the item. For example, CA State Tax. Returned only if the `taxInformation.showTaxPerLineItem` field is set to `Yes`. 
    */
    'taxName'?: string;
    /**
    * Jurisdiction tax amount for the item. Returned only if the `taxInformation.showTaxPerLineItem` field is set to `Yes`. 
    */
    'taxAmount'?: string;
    /**
    * Jurisdiction taxable amount for the item, not including product level exemptions. Returned only if the `taxInformation.showTaxPerLineItem` field is set to `Yes`. 
    */
    'taxable'?: string;
    /**
    * Free-text description of the jurisdiction for the item. For example, San Mateo County. Returned only if the `taxInformation.showTaxPerLineItem` field is set to `Yes`. 
    */
    'name'?: string;
    /**
    * Jurisdiction code assigned by the tax provider. Returned only if the `taxInformation.showTaxPerLineItem` field is set to `Yes`. 
    */
    'code'?: string;
    /**
    * Jurisdiction tax rate for the item. Returned only if the `taxInformation.showTaxPerLineItem` field is set to `Yes`. 
    */
    'rate'?: string;
    /**
    * Free-text description of the jurisdiction region for the item. For example, CA (California State) or GB (Great Britain). Returned only if the `taxInformation.showTaxPerLineItem` field is set to `Yes`. 
    */
    'region'?: string;
    /**
    * Tax jurisdiction country for the item. Returned only if the `taxInformation.showTaxPerLineItem` field is set to `Yes`. 
    */
    'country'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "taxName",
            "baseName": "taxName",
            "type": "string"
        },
        {
            "name": "taxAmount",
            "baseName": "taxAmount",
            "type": "string"
        },
        {
            "name": "taxable",
            "baseName": "taxable",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        },
        {
            "name": "rate",
            "baseName": "rate",
            "type": "string"
        },
        {
            "name": "region",
            "baseName": "region",
            "type": "string"
        },
        {
            "name": "country",
            "baseName": "country",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return VasV2PaymentsPost201ResponseOrderInformationJurisdiction.attributeTypeMap;
    }
}

export class VasV2PaymentsPost201ResponseOrderInformationLineItems {
    'taxDetails'?: Array<VasV2PaymentsPost201ResponseOrderInformationTaxDetails>;
    'jurisdiction'?: Array<VasV2PaymentsPost201ResponseOrderInformationJurisdiction>;
    /**
    * Exempt amount for the lineItem. Returned only if the `taxInformation.showTaxPerLineItem` field is set to `Yes`. 
    */
    'exemptAmount'?: string;
    /**
    * Portion of the item amount that is taxable. 
    */
    'taxableAmount'?: string;
    /**
    * Total tax for the item. This value is the sum of all taxes applied to the item. 
    */
    'taxAmount'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "taxDetails",
            "baseName": "taxDetails",
            "type": "Array<VasV2PaymentsPost201ResponseOrderInformationTaxDetails>"
        },
        {
            "name": "jurisdiction",
            "baseName": "jurisdiction",
            "type": "Array<VasV2PaymentsPost201ResponseOrderInformationJurisdiction>"
        },
        {
            "name": "exemptAmount",
            "baseName": "exemptAmount",
            "type": "string"
        },
        {
            "name": "taxableAmount",
            "baseName": "taxableAmount",
            "type": "string"
        },
        {
            "name": "taxAmount",
            "baseName": "taxAmount",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return VasV2PaymentsPost201ResponseOrderInformationLineItems.attributeTypeMap;
    }
}

export class VasV2PaymentsPost201ResponseOrderInformationTaxDetails {
    /**
    * Allowed tax types: - city - county - state - national - special 
    */
    'type'?: string;
    /**
    * Amount corresponding to different types of taxes applied. 
    */
    'amount'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "amount",
            "baseName": "amount",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return VasV2PaymentsPost201ResponseOrderInformationTaxDetails.attributeTypeMap;
    }
}

export class VasV2PaymentsPost201ResponseTaxInformation {
    /**
    * Indicates whether this is a committed tax transaction. For a committed tax transaction, the status in the Tax Detail Report is “Committed.” For an uncommitted tax transaction, the status in the Tax Detail Report is “Uncommitted.” Possible values: - `true`: This is a committed tax transaction. - `false` (default): This is not a committed tax transaction.  A committed tax request is a tax service request that sets the status field in the Tax Detail Report to committed. The committed status indicates that the amount calculated by the tax service is included in the amount of a capture or credit.  Use a void service request to cancel a committed tax request or a committed refund tax request. The void transaction is included as a separate entry in the Tax Detail Report. The value of the status field is cancelled. The value of the link ID is the request ID of the committed tax request or refund tax request that was voided. You can use the value of the link ID to reconcile your orders.  Optional for U.S., Canadian, international tax, and value added taxes. For more information on Tax Detail Report features refer the [Tax Service Guide](https://developer.cybersource.com/docs/cybs/en-us/tax-calculation/developer/all/rest/tax-calculation/tax-overview.html). 
    */
    'commitIndicator'?: boolean;
    /**
    * Indicates whether this is a refund tax transaction. For a refund tax transaction, amounts in the Tax Detail Report will be negative. Possible values: - `true`: This is a refund tax transaction. - `false` (default): This is not a refund tax transaction.  A refund tax request is a tax service request that sets the transaction type field in the Tax Detail Report to refunded and makes the reported amount negative. Tax amounts are returned as positive amounts in reply messages, but they are saved in reports as negative amounts which enables the reporting software to accurately calculate the aggregate amounts.  Optional for U.S., Canadian, international tax, and value added taxes. For more information on Tax Detail Report features refer the [Tax Service Guide](https://developer.cybersource.com/docs/cybs/en-us/tax-calculation/developer/all/rest/tax-calculation/tax-overview.html). 
    */
    'refundIndicator'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "commitIndicator",
            "baseName": "commitIndicator",
            "type": "boolean"
        },
        {
            "name": "refundIndicator",
            "baseName": "refundIndicator",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return VasV2PaymentsPost201ResponseTaxInformation.attributeTypeMap;
    }
}

export class VasV2PaymentsPost400Response {
    /**
    * Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ` **Example** `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.). The `T` separates the date and the time. The `Z` indicates UTC.  Returned by Cybersource for all services. 
    */
    'submitTimeUtc'?: string;
    /**
    * The status of the submitted transaction.  Possible values:  - INVALID_REQUEST 
    */
    'status'?: string;
    /**
    * The reason of the status.  Possible values:  - MISSING_FIELD  - INVALID_DATA  - INVALID_MERCHANT_CONFIGURATION  - INVALID_ADDRESS 
    */
    'reason'?: string;
    /**
    * The detail message related to the status and reason listed above.
    */
    'message'?: string;
    'details'?: Array<PtsV2PaymentsPost201ResponseErrorInformationDetails>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "submitTimeUtc",
            "baseName": "submitTimeUtc",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "reason",
            "baseName": "reason",
            "type": "string"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        },
        {
            "name": "details",
            "baseName": "details",
            "type": "Array<PtsV2PaymentsPost201ResponseErrorInformationDetails>"
        }    ];

    static getAttributeTypeMap() {
        return VasV2PaymentsPost400Response.attributeTypeMap;
    }
}

export class VasV2TaxVoid200Response {
    /**
    * An unique identification number generated by Cybersource to identify the submitted request. Returned by all services. It is also appended to the endpoint of the resource. On incremental authorizations, this value with be the same as the identification number returned in the original authorization response. 
    */
    'id'?: string;
    /**
    * Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ` **Example** `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.). The `T` separates the date and the time. The `Z` indicates UTC.  Returned by Cybersource for all services. 
    */
    'submitTimeUtc'?: string;
    /**
    * The status of the submitted transaction.  Possible values:  - VOIDED  - CANCELLED  - FAILED 
    */
    'status'?: string;
    'clientReferenceInformation'?: PtsV2IncrementalAuthorizationPatch201ResponseClientReferenceInformation;
    'voidAmountDetails'?: VasV2TaxVoid200ResponseVoidAmountDetails;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "submitTimeUtc",
            "baseName": "submitTimeUtc",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "clientReferenceInformation",
            "baseName": "clientReferenceInformation",
            "type": "PtsV2IncrementalAuthorizationPatch201ResponseClientReferenceInformation"
        },
        {
            "name": "voidAmountDetails",
            "baseName": "voidAmountDetails",
            "type": "VasV2TaxVoid200ResponseVoidAmountDetails"
        }    ];

    static getAttributeTypeMap() {
        return VasV2TaxVoid200Response.attributeTypeMap;
    }
}

export class VasV2TaxVoid200ResponseVoidAmountDetails {
    /**
    * Total amount of the void.  #### PIN Debit Amount of the reversal.  Returned by PIN debit reversal. 
    */
    'voidAmount'?: string;
    /**
    * Currency used for the order. Use the three-character [ISO Standard Currency Codes.](http://apps.cybersource.com/library/documentation/sbc/quickref/currencies.pdf)  #### Used by **Authorization** Required field.  **Authorization Reversal** For an authorization reversal (`reversalInformation`) or a capture (`processingOptions.capture` is set to `true`), you must use the same currency that you used in your payment authorization request.  #### PIN Debit Currency for the amount you requested for the PIN debit purchase. This value is returned for partial authorizations. The issuing bank can approve a partial amount if the balance on the debit card is less than the requested transaction amount. For the possible values, see the [ISO Standard Currency Codes](https://developer.cybersource.com/library/documentation/sbc/quickref/currencies.pdf). Returned by PIN debit purchase.  For PIN debit reversal requests, you must use the same currency that was used for the PIN debit purchase or PIN debit credit that you are reversing. For the possible values, see the [ISO Standard Currency Codes](https://developer.cybersource.com/library/documentation/sbc/quickref/currencies.pdf).  Required field for PIN Debit purchase and PIN Debit credit requests. Optional field for PIN Debit reversal requests.  #### GPX This field is optional for reversing an authorization or credit.  #### DCC for First Data Your local currency.  #### Tax Calculation Required for international tax and value added tax only. Optional for U.S. and Canadian taxes. Your local currency. 
    */
    'currency'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "voidAmount",
            "baseName": "voidAmount",
            "type": "string"
        },
        {
            "name": "currency",
            "baseName": "currency",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return VasV2TaxVoid200ResponseVoidAmountDetails.attributeTypeMap;
    }
}

export class VasV2TaxVoidsPost400Response {
    /**
    * Time of request in UTC. Format: `YYYY-MM-DDThh:mm:ssZ` **Example** `2016-08-11T22:47:57Z` equals August 11, 2016, at 22:47:57 (10:47:57 p.m.). The `T` separates the date and the time. The `Z` indicates UTC.  Returned by Cybersource for all services. 
    */
    'submitTimeUtc'?: string;
    /**
    * The status of the submitted transaction.  Possible values:  - INVALID_REQUEST 
    */
    'status'?: string;
    /**
    * The reason of the status.  Possible values:  - INVALID_DATA  - NOT_VOIDABLE 
    */
    'reason'?: string;
    /**
    * The detail message related to the status and reason listed above.
    */
    'message'?: string;
    'details'?: Array<PtsV2PaymentsPost201ResponseErrorInformationDetails>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "submitTimeUtc",
            "baseName": "submitTimeUtc",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "reason",
            "baseName": "reason",
            "type": "string"
        },
        {
            "name": "message",
            "baseName": "message",
            "type": "string"
        },
        {
            "name": "details",
            "baseName": "details",
            "type": "Array<PtsV2PaymentsPost201ResponseErrorInformationDetails>"
        }    ];

    static getAttributeTypeMap() {
        return VasV2TaxVoidsPost400Response.attributeTypeMap;
    }
}

export class Vasv2taxBuyerInformation {
    /**
    * Customer’s government-assigned tax identification number.  #### Tax Calculation Optional for international and value added taxes only. Not applicable to U.S. and Canadian taxes. 
    */
    'vatRegistrationNumber'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "vatRegistrationNumber",
            "baseName": "vatRegistrationNumber",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Vasv2taxBuyerInformation.attributeTypeMap;
    }
}

export class Vasv2taxClientReferenceInformation {
    /**
    * Merchant-generated order reference or tracking number. It is recommended that you send a unique value for each transaction so that you can perform meaningful searches for the transaction.  #### Used by **Authorization** Required field.  #### PIN Debit Requests for PIN debit reversals need to use the same merchant reference number that was used in the transaction that is being reversed.  Required field for all PIN Debit requests (purchase, credit, and reversal).  #### FDC Nashville Global Certain circumstances can cause the processor to truncate this value to 15 or 17 characters for Level II and Level III processing, which can cause a discrepancy between the value you submit and the value included in some processor reports. 
    */
    'code'?: string;
    'partner'?: Riskv1decisionsClientReferenceInformationPartner;
    /**
    * Brief description of the order or any comment you wish to add to the order.
    */
    'comments'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        },
        {
            "name": "partner",
            "baseName": "partner",
            "type": "Riskv1decisionsClientReferenceInformationPartner"
        },
        {
            "name": "comments",
            "baseName": "comments",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Vasv2taxClientReferenceInformation.attributeTypeMap;
    }
}

export class Vasv2taxMerchantInformation {
    /**
    * Your government-assigned tax identification number.  #### Tax Calculation Required field for value added tax only. Not applicable to U.S. and Canadian taxes.  #### CyberSource through VisaNet For CtV processors, the maximum length is 20. 
    */
    'vatRegistrationNumber'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "vatRegistrationNumber",
            "baseName": "vatRegistrationNumber",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Vasv2taxMerchantInformation.attributeTypeMap;
    }
}

export class Vasv2taxOrderInformation {
    'amountDetails'?: RiskV1DecisionsPost201ResponseOrderInformationAmountDetails;
    'billTo'?: Vasv2taxOrderInformationBillTo;
    'shippingDetails'?: Vasv2taxOrderInformationShippingDetails;
    'shipTo'?: Vasv2taxOrderInformationShipTo;
    'lineItems'?: Array<Vasv2taxOrderInformationLineItems>;
    'invoiceDetails'?: Vasv2taxOrderInformationInvoiceDetails;
    'orderAcceptance'?: Vasv2taxOrderInformationOrderAcceptance;
    'orderOrigin'?: Vasv2taxOrderInformationOrderOrigin;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "amountDetails",
            "baseName": "amountDetails",
            "type": "RiskV1DecisionsPost201ResponseOrderInformationAmountDetails"
        },
        {
            "name": "billTo",
            "baseName": "billTo",
            "type": "Vasv2taxOrderInformationBillTo"
        },
        {
            "name": "shippingDetails",
            "baseName": "shippingDetails",
            "type": "Vasv2taxOrderInformationShippingDetails"
        },
        {
            "name": "shipTo",
            "baseName": "shipTo",
            "type": "Vasv2taxOrderInformationShipTo"
        },
        {
            "name": "lineItems",
            "baseName": "lineItems",
            "type": "Array<Vasv2taxOrderInformationLineItems>"
        },
        {
            "name": "invoiceDetails",
            "baseName": "invoiceDetails",
            "type": "Vasv2taxOrderInformationInvoiceDetails"
        },
        {
            "name": "orderAcceptance",
            "baseName": "orderAcceptance",
            "type": "Vasv2taxOrderInformationOrderAcceptance"
        },
        {
            "name": "orderOrigin",
            "baseName": "orderOrigin",
            "type": "Vasv2taxOrderInformationOrderOrigin"
        }    ];

    static getAttributeTypeMap() {
        return Vasv2taxOrderInformation.attributeTypeMap;
    }
}

export class Vasv2taxOrderInformationBillTo {
    /**
    * First line of the billing street address.  #### Tax Calculation Required for U.S. and Canadian taxes. Not applicable to international and value added taxes. 
    */
    'address1'?: string;
    /**
    * Second line of the billing street address.  #### Tax Calculation Optional for U.S. and Canadian taxes. Not applicable to international and value added taxes. 
    */
    'address2'?: string;
    /**
    * Credit card billing city.  #### Tax Calculation Required for U.S. and Canadian taxes only. Not applicable to international and value added taxes. 
    */
    'locality'?: string;
    /**
    * Credit card billing state or province.  #### Tax Calculation Required for U.S. and Canadian taxes. Not applicable to international and value added taxes. 
    */
    'administrativeArea'?: string;
    /**
    * Postal code for the billing address. The postal code must consist of 5 to 9 digits. If the billing country is the U.S., the 9-digit postal code must follow this format:  [5 digits][dash][4 digits]  **Example**: 12345-6789  If the billing country is Canada, the 6-digit postal code must follow this format:  [alpha][numeric][alpha] [numeric][alpha][numeric]  **Example**: A1B 2C3  #### Tax Calculation Required for U.S. and Canadian taxes. Not applicable to international and value added taxes. 
    */
    'postalCode'?: string;
    /**
    * Credit card billing country. Use the [ISO Standard Country Codes](https://developer.cybersource.com/library/documentation/sbc/quickref/countries_alpha_list.pdf).  If `orderInformation.shipTo.country` is not provided, `orderInformation.billTo.country` is used in its place. If  `orderInformation.billTo.country` is set to `US` or `CA`, then `orderInformation.billTo.postalCode` and `orderInformation.billTo.administrativeArea` are also required.  #### Tax Calculation Required for U.S., Canadian, international and value added taxes. 
    */
    'country'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "address1",
            "baseName": "address1",
            "type": "string"
        },
        {
            "name": "address2",
            "baseName": "address2",
            "type": "string"
        },
        {
            "name": "locality",
            "baseName": "locality",
            "type": "string"
        },
        {
            "name": "administrativeArea",
            "baseName": "administrativeArea",
            "type": "string"
        },
        {
            "name": "postalCode",
            "baseName": "postalCode",
            "type": "string"
        },
        {
            "name": "country",
            "baseName": "country",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Vasv2taxOrderInformationBillTo.attributeTypeMap;
    }
}

export class Vasv2taxOrderInformationInvoiceDetails {
    /**
    * Date of the tax calculation. Use format YYYYMMDD. You can provide a date in the past if you are calculating tax for a refund and want to know what the tax was on the date the order was placed. You can provide a date in the future if you are calculating the tax for a future date, such as an upcoming tax holiday.  The default is the date, in Pacific time, that the bank receives the request. Keep this in mind if you are in a different time zone and want the tax calculated with the rates that are applicable on a specific date.  #### Tax Calculation Optional field for U.S., Canadian, international tax, and value added taxes. 
    */
    'invoiceDate'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "invoiceDate",
            "baseName": "invoiceDate",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Vasv2taxOrderInformationInvoiceDetails.attributeTypeMap;
    }
}

export class Vasv2taxOrderInformationLineItems {
    /**
    * Product identifier code. Also known as the Stock Keeping Unit (SKU) code for the product.  For an authorization or capture transaction (`processingOptions.capture` is set to `true` or `false`), this field is required when `orderInformation.lineItems[].productCode` is not set to **default** or one of the other values that are related to shipping and/or handling.  #### Tax Calculation Optional field for U.S. and Canadian taxes. Not applicable to international and value added taxes. For an authorization or capture transaction (`processingOptions.capture` is set to `true` or `false`), this field is required when `orderInformation.lineItems[].productCode` is not `default` or one of the values related to shipping and/or handling. 
    */
    'productSKU'?: string;
    /**
    * Type of product. The value for this field is used to identify the product category (electronic, handling, physical, service, or shipping). The default value is `default`.  If you are performing an authorization transaction (`processingOptions.capture` is set to `false`), and you set this field to a value other than `default` or one of the values related to shipping and/or handling, then `orderInformation.lineItems[].quantity`, `orderInformation.lineItems[].productName`, and `orderInformation.lineItems[].productSku` fields are required.  Optional field.  #### Tax Calculation Optional field for U.S., Canadian, international tax, and value added taxes.  The Product Codes for the tax service are located in the Cybersource Tax Codes guide. Contact Customer Support to request the guide. If you don’t send a tax service Product Code in your tax request, product-based rules or exemptions will not be applied and the transaction will default to fully taxable in the locations where you’ve indicated you need to collect tax [by way of nexus, no nexus, or seller registration number fields]. 
    */
    'productCode'?: string;
    /**
    * Number of units for this order. Must be a non-negative integer.  The default is `1`. For an authorization or capture transaction (`processingOptions.capture` is set to `true` or `false`), this field is required when `orderInformation.lineItems[].productCode` is not `default` or one of the other values related to shipping and/or handling.  #### Tax Calculation Optional field for U.S., Canadian, international tax, and value added taxes. 
    */
    'quantity'?: number;
    /**
    * For an authorization or capture transaction (`processingOptions.capture` is `true` or `false`), this field is required when `orderInformation.lineItems[].productCode` is not `default` or one of the other values that are related to shipping and/or handling.  #### Tax Calculation Optional field for U.S., Canadian, international tax, and value added taxes. 
    */
    'productName'?: string;
    /**
    * Per-item price of the product. This value for this field cannot be negative.  You must include either this field or the request-level field `orderInformation.amountDetails.totalAmount` in your request.  You can include a decimal point (.), but you cannot include any other special characters. The value is truncated to the correct number of decimal places.  #### DCC with a Third-Party Provider Set this field to the converted amount that was returned by the DCC provider. You must include either the 1st line item in the order and this field, or the request-level field `orderInformation.amountDetails.totalAmount` in your request.  #### Tax Calculation Required field for U.S., Canadian, international and value added taxes.  #### Zero Amount Authorizations If your processor supports zero amount authorizations, you can set this field to 0 for the authorization to check if the card is lost or stolen.  #### Maximum Field Lengths For GPN and JCN Gateway: Decimal (10) All other processors: Decimal (15) 
    */
    'unitPrice'?: string;
    /**
    * Total tax to apply to the product. This value cannot be negative. The tax amount and the offer amount must be in the same currency. The tax amount field is additive.  The following example uses a two-exponent currency such as USD:   1. You include each line item in your request.  ..- 1st line item has amount=10.00, quantity=1, and taxAmount=0.80  ..- 2nd line item has amount=20.00, quantity=1, and taxAmount=1.60  2. The total amount authorized will be 32.40, not 30.00 with 2.40 of tax included.  Optional field.  #### Airlines processing Tax portion of the order amount. This value cannot exceed 99999999999999 (fourteen 9s). Format: English characters only. Optional request field for a line item.  #### Tax Calculation Optional field for U.S., Canadian, international tax, and value added taxes.  Note if you send this field in your tax request, the value in the field will override the tax engine 
    */
    'taxAmount'?: string;
    'orderAcceptance'?: Vasv2taxOrderInformationOrderAcceptance;
    'orderOrigin'?: Vasv2taxOrderInformationOrderOrigin;
    /**
    * Country from which the order is shipped. This field is used only when `orderInformation.shippingDetails.shipFromLocality` and `orderInformation.shippingDetails.shipFromAdministrativeArea` are present. Use the [ISO Standard Country Codes](http://apps.cybersource.com/library/documentation/sbc/quickref/countries_alpha_list.pdf).  **NOTE** If this field appears in a `lineItems` object, then the value of this field in the `lineItems` object overrides the value of the corresponding field at the request-level or order-level object.  #### Tax Calculation This field is used to determine tax rules and/ or rates applied to the transaction based on sourcing.  Optional for U.S., Canadian, international tax, and value added taxes. 
    */
    'shipFromCountry'?: string;
    /**
    * State from which the order is shipped. This field is used only when `orderInformation.shippingDetails.shipFromLocality` and `orderInformation.shippingDetails.shipFromCountry` are present. Use the [State, Province, and Territory Codes for the United States and Canada](http://apps.cybersource.com/library/documentation/sbc/quickref/states_and_provinces.pdf).  **NOTE** If this field appears in a `lineItems` object, then the value of this field in the `lineItems` object overrides the value of the corresponding field at the request-level or order-level object.  #### Tax Calculation This field is used to determine tax rules and/or rates applied to the transaction based on sourcing.  Optional for U.S. and Canadian taxes. Not applicable to international and value added taxes. 
    */
    'shipFromAdministrativeArea'?: string;
    /**
    * City where the product is shipped from. This field is used only when the `orderInformation.shipTo.administrativeArea` and `orderInformation.shipTo.country` fields are present.  **NOTE** If this field appears in a `lineItems` object, then the value of this field in the `lineItems` object overrides the value of the corresponding field at the request-level or order-level object.  #### Tax Calculation This field is used to determine tax rules and/or rates applied to the transaction based on sourcing.  Optional for U.S. and Canadian taxes. Not applicable to international and value added taxes. 
    */
    'shipFromLocality'?: string;
    /**
    * Postal code where the product is shipped from.  #### Tax Calculation This field is used to determine tax rules and/or rates applied to the transaction based on sourcing.  Optional for U.S. and Canadian taxes. Not applicable to international and value added taxes. 
    */
    'shipFromPostalCode'?: string;
    /**
    * Buyer’s VAT registration number.  **NOTE** If this field appears in a `lineItems` object, then the value of this field in the `lineItems` object overrides the value of the corresponding field at the request-level or order-level object.  #### Tax Calculation Optional field for international and value added taxes only. Not applicable to U.S. and Canadian taxes. 
    */
    'buyerVatRegistrationNumber'?: string;
    /**
    * VAT seller registration number.  **NOTE** If this field appears in a `lineItems` object, then the value of this field in the `lineItems` object overrides the value of the corresponding field at the request-level or order-level object.  #### Tax Calculation Optional field for international and value added taxes only. Not applicable to U.S. and Canadian taxes. 
    */
    'sellerVatRegistrationNumber'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "productSKU",
            "baseName": "productSKU",
            "type": "string"
        },
        {
            "name": "productCode",
            "baseName": "productCode",
            "type": "string"
        },
        {
            "name": "quantity",
            "baseName": "quantity",
            "type": "number"
        },
        {
            "name": "productName",
            "baseName": "productName",
            "type": "string"
        },
        {
            "name": "unitPrice",
            "baseName": "unitPrice",
            "type": "string"
        },
        {
            "name": "taxAmount",
            "baseName": "taxAmount",
            "type": "string"
        },
        {
            "name": "orderAcceptance",
            "baseName": "orderAcceptance",
            "type": "Vasv2taxOrderInformationOrderAcceptance"
        },
        {
            "name": "orderOrigin",
            "baseName": "orderOrigin",
            "type": "Vasv2taxOrderInformationOrderOrigin"
        },
        {
            "name": "shipFromCountry",
            "baseName": "shipFromCountry",
            "type": "string"
        },
        {
            "name": "shipFromAdministrativeArea",
            "baseName": "shipFromAdministrativeArea",
            "type": "string"
        },
        {
            "name": "shipFromLocality",
            "baseName": "shipFromLocality",
            "type": "string"
        },
        {
            "name": "shipFromPostalCode",
            "baseName": "shipFromPostalCode",
            "type": "string"
        },
        {
            "name": "buyerVatRegistrationNumber",
            "baseName": "buyerVatRegistrationNumber",
            "type": "string"
        },
        {
            "name": "sellerVatRegistrationNumber",
            "baseName": "sellerVatRegistrationNumber",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Vasv2taxOrderInformationLineItems.attributeTypeMap;
    }
}

/**
* The Order Acceptance address fields may be used by the tax service to determine the taxability of the order or applicable taxing jurisdictions. You should consult your tax, legal and/or accounting advisors to determine if you should include an Order Acceptance address in your tax service request for some or all of your transactions based on your business.
*/
export class Vasv2taxOrderInformationOrderAcceptance {
    /**
    * Order acceptance city. This field is not used unless the `orderInformation.orderAcceptance.administrativeArea` and `orderInformation.orderAcceptance.country` fields are present.  **NOTE** If this field appears in a `lineItems` object, then the value of this field in the `lineItems` object overrides the value of the corresponding field at the request-level or order-level object.  #### Tax Calculation Optional field for U.S. and Canadian taxes. Not applicable to international and value added taxes. 
    */
    'locality'?: string;
    /**
    * Order acceptance state. This field is not used unless the `orderInformation.orderAcceptance.locality` and `orderInformation.orderAcceptance.country` fields are present. Use the [State, Province, and Territory Codes for the United States and Canada](https://developer.cybersource.com/library/documentation/sbc/quickref/states_and_provinces.pdf).  **NOTE** If this field appears in a `lineItems` object, then the value of this field in the `lineItems` object overrides the value of the corresponding field at the request-level or order-level object.  #### Tax Calculation Optional field for U.S. and Canadian taxes. Not applicable to international and value added taxes. 
    */
    'administrativeArea'?: string;
    /**
    * Order acceptance postal code. This field is not used unless the `orderInformation.orderAcceptance.locality`, `orderInformation.orderAcceptance.administrativeArea`, and `orderInformation.orderAcceptance.country` fields are present. Must be sent at the line or offer level to be surfaced in the Tax Detail Report.  **NOTE** If this field appears in a `lineItems` object, then the value of this field in the `lineItems` object overrides the value of the corresponding field at the request-level or order-level object.  #### Tax Calculation Optional field for U.S. and Canadian taxes. Not applicable to international and value added taxes. 
    */
    'postalCode'?: string;
    /**
    * Order acceptance country. This field is not used unless the `orderInformation.orderAcceptance.administrativeArea` and `orderInformation.orderAcceptance.locality` fields are present. Use the [ISO Standard Country Codes.](http://apps.cybersource.com/library/documentation/sbc/quickref/countries_alpha_list.pdf)  **NOTE** If this field appears in a `lineItems` object, then the value of this field in the `lineItems` object overrides the value of the corresponding field at the request-level or order-level object.  #### Tax Calculation Optional field for U.S. and Canadian taxes. Not applicable to international and value added taxes. 
    */
    'country'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "locality",
            "baseName": "locality",
            "type": "string"
        },
        {
            "name": "administrativeArea",
            "baseName": "administrativeArea",
            "type": "string"
        },
        {
            "name": "postalCode",
            "baseName": "postalCode",
            "type": "string"
        },
        {
            "name": "country",
            "baseName": "country",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Vasv2taxOrderInformationOrderAcceptance.attributeTypeMap;
    }
}

/**
* The Order Origin address fields may be used by the tax service to determine the taxability of the order or applicable taxing jurisdictions. You should consult your tax, legal and/or accounting advisors to determine if you should include an Order Origin address in your tax service request for some or all of your transactions based on your business.
*/
export class Vasv2taxOrderInformationOrderOrigin {
    /**
    * Order origin city. This field is not used unless the `orderInformation.orderOrigin.administrativeArea` and `orderInformation.orderOrigin.country` fields are present.  **NOTE** If this field appears in a `lineItems` object, then the value of this field in the `lineItems` object overrides the value of the corresponding field at the request-level or order-level object.  #### Tax Calculation Optional field for U.S. and Canadian taxes. Not applicable to international and value added taxes. 
    */
    'locality'?: string;
    /**
    * Order origin state. This field is not used unless the `orderInformation.orderOrigin.locality` and `orderInformation.orderOrigin.country` fields are present. Use the [State, Province, and Territory Codes for the United States and Canada](http://apps.cybersource.com/library/documentation/sbc/quickref/states_and_provinces.pdf).  **NOTE** If this field appears in a `lineItems` object, then the value of this field in the `lineItems` object overrides the value of the corresponding field at the request-level or order-level object.  #### Tax Calculation Optional field for U.S. and Canadian taxes. Not applicable to international and value added taxes. 
    */
    'administrativeArea'?: string;
    /**
    * Order origin postal code. This field is not used unless the `orderInformation.orderOrigin.locality`, `orderInformation.orderOrigin.administrativeArea` and `orderInformation.orderOrigin.country` fields are present. Must be sent at the lineItem level to appear in the Tax Detail Report.  **NOTE** If this field appears in a `lineItems` object, then the value of this field in the `lineItems` object overrides the value of the corresponding field at the request-level or order-level object.  #### Tax Calculation Optional field for U.S. and Canadian taxes. Not applicable to international and value added taxes. 
    */
    'postalCode'?: string;
    /**
    * Order origin country. This field is not used unless the `orderInformation.orderOrigin.administrativeArea` and `orderInformation.orderOrigin.locality` fields are present. Use the [ISO Standard Country Codes](http://apps.cybersource.com/library/documentation/sbc/quickref/countries_alpha_list.pdf).  **NOTE** If this field appears in a `lineItems` object, then the value of this field in the `lineItems` object overrides the value of the corresponding field at the request-level or order-level object.  #### Tax Calculation Optional field for U.S. and Canadian taxes. Not applicable to international and value added taxes. 
    */
    'country'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "locality",
            "baseName": "locality",
            "type": "string"
        },
        {
            "name": "administrativeArea",
            "baseName": "administrativeArea",
            "type": "string"
        },
        {
            "name": "postalCode",
            "baseName": "postalCode",
            "type": "string"
        },
        {
            "name": "country",
            "baseName": "country",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Vasv2taxOrderInformationOrderOrigin.attributeTypeMap;
    }
}

export class Vasv2taxOrderInformationShipTo {
    /**
    * Country of the shipping address. Use the two-character [ISO Standard Country Codes.](http://apps.cybersource.com/library/documentation/sbc/quickref/countries_alpha_list.pdf)  Required field for authorization if any shipping address information is included in the request; otherwise, optional.  #### Tax Calculation Optional field for U.S., Canadian, international tax, and value added taxes. Billing address objects will be used to determine the cardholder’s location when shipTo objects are not present. 
    */
    'country'?: string;
    /**
    * State or province of the shipping address. Use the [State, Province, and Territory Codes for the United States and Canada](https://developer.cybersource.com/library/documentation/sbc/quickref/states_and_provinces.pdf) (maximum length: 2)   Required field for authorization if any shipping address information is included in the request and shipping to the U.S. or Canada; otherwise, optional.  #### Tax Calculation Optional field for U.S. and Canadian taxes. Not applicable to international and value added taxes. Billing address objects will be used to determine the cardholder’s location when shipTo objects are not present. 
    */
    'administrativeArea'?: string;
    /**
    * City of the shipping address.  Required field for authorization if any shipping address information is included in the request and shipping to the U.S. or Canada; otherwise, optional.  #### Tax Calculation Optional field for U.S. and Canadian taxes. Not applicable to international and value added taxes. Billing address objects will be used to determine the cardholder’s location when shipTo objects are not present. 
    */
    'locality'?: string;
    /**
    * Postal code for the shipping address. The postal code must consist of 5 to 9 digits.  Required field for authorization if any shipping address information is included in the request and shipping to the U.S. or Canada; otherwise, optional.  When the billing country is the U.S., the 9-digit postal code must follow this format: [5 digits][dash][4 digits]  Example 12345-6789  When the billing country is Canada, the 6-digit postal code must follow this format: [alpha][numeric][alpha][space][numeric][alpha][numeric]  Example A1B 2C3  #### American Express Direct Before sending the postal code to the processor, all nonalphanumeric characters are removed and, if the remaining value is longer than nine characters, the value is truncated starting from the right side. #### Tax Calculation Optional field for U.S. and Canadian taxes. Not applicable to international and value added taxes. Billing address objects will be used to determine the cardholder’s location when shipTo objects are not present. 
    */
    'postalCode'?: string;
    /**
    * First line of the shipping address.  Required field for authorization if any shipping address information is included in the request; otherwise, optional.  #### Tax Calculation Optional field for U.S. and Canadian taxes. Not applicable to international and value added taxes. Billing address objects will be used to determine the cardholder’s location when shipTo objects are not present. 
    */
    'address1'?: string;
    /**
    * Second line of the shipping address.  Optional field.  #### Tax Calculation Optional field for U.S. and Canadian taxes. Not applicable to international and value added taxes. Billing address objects will be used to determine the cardholder’s location when shipTo objects are not present. 
    */
    'address2'?: string;
    /**
    * Third line of the shipping address.  #### Tax Calculation Optional field for U.S. and Canadian taxes. Not applicable to international and value added taxes. Billing address objects will be used to determine the cardholder’s location when shipTo objects are not present. 
    */
    'address3'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "country",
            "baseName": "country",
            "type": "string"
        },
        {
            "name": "administrativeArea",
            "baseName": "administrativeArea",
            "type": "string"
        },
        {
            "name": "locality",
            "baseName": "locality",
            "type": "string"
        },
        {
            "name": "postalCode",
            "baseName": "postalCode",
            "type": "string"
        },
        {
            "name": "address1",
            "baseName": "address1",
            "type": "string"
        },
        {
            "name": "address2",
            "baseName": "address2",
            "type": "string"
        },
        {
            "name": "address3",
            "baseName": "address3",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Vasv2taxOrderInformationShipTo.attributeTypeMap;
    }
}

export class Vasv2taxOrderInformationShippingDetails {
    /**
    * City where the product is shipped from. This field is used only when the `orderInformation.shipTo.administrativeArea` and `orderInformation.shipTo.country` fields are present.  **NOTE** If this field appears in a `lineItems` object, then the value of this field in the `lineItems` object overrides the value of the corresponding field at the request-level or order-level object.  #### Tax Calculation This field is used to determine tax rules and/or rates applied to the transaction based on sourcing.  Optional for U.S. and Canadian taxes. Not applicable to international and value added taxes. 
    */
    'shipFromLocality'?: string;
    /**
    * Country from which the order is shipped. This field is used only when `orderInformation.shippingDetails.shipFromLocality` and `orderInformation.shippingDetails.shipFromAdministrativeArea` are present. Use the [ISO Standard Country Codes](http://apps.cybersource.com/library/documentation/sbc/quickref/countries_alpha_list.pdf).  **NOTE** If this field appears in a `lineItems` object, then the value of this field in the `lineItems` object overrides the value of the corresponding field at the request-level or order-level object.  #### Tax Calculation This field is used to determine tax rules and/ or rates applied to the transaction based on sourcing.  Optional for U.S., Canadian, international tax, and value added taxes. 
    */
    'shipFromCountry'?: string;
    /**
    * Postal code where the product is shipped from.  #### Tax Calculation This field is used to determine tax rules and/or rates applied to the transaction based on sourcing.  Optional for U.S. and Canadian taxes. Not applicable to international and value added taxes. 
    */
    'shipFromPostalCode'?: string;
    /**
    * State from which the order is shipped. This field is used only when `orderInformation.shippingDetails.shipFromLocality` and `orderInformation.shippingDetails.shipFromCountry` are present. Use the [State, Province, and Territory Codes for the United States and Canada](http://apps.cybersource.com/library/documentation/sbc/quickref/states_and_provinces.pdf).  **NOTE** If this field appears in a `lineItems` object, then the value of this field in the `lineItems` object overrides the value of the corresponding field at the request-level or order-level object.  #### Tax Calculation This field is used to determine tax rules and/or rates applied to the transaction based on sourcing.  Optional for U.S. and Canadian taxes. Not applicable to international and value added taxes. 
    */
    'shipFromAdministrativeArea'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "shipFromLocality",
            "baseName": "shipFromLocality",
            "type": "string"
        },
        {
            "name": "shipFromCountry",
            "baseName": "shipFromCountry",
            "type": "string"
        },
        {
            "name": "shipFromPostalCode",
            "baseName": "shipFromPostalCode",
            "type": "string"
        },
        {
            "name": "shipFromAdministrativeArea",
            "baseName": "shipFromAdministrativeArea",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Vasv2taxOrderInformationShippingDetails.attributeTypeMap;
    }
}

export class Vasv2taxTaxInformation {
    /**
    * Reporting date of transaction. Format: YYYYMMDD. Defaults to current date if not specified. Optional for U.S., Canadian, international tax, and value added taxes. 
    */
    'reportingDate'?: string;
    /**
    * If a past or future date is specified in `orderInformation.invoiceDetails.invoiceDate`, then provide the reason for that for audit purposes. Typical reasons include: 'Return', 'Layaway', 'Imported'.  Optional for U.S., Canadian, international tax, and value added taxes. 
    */
    'dateOverrideReason'?: string;
    /**
    * Comma-separated list of states or provinces in which merchandise is taxable. Note merchandise may be still be non-taxable or tax exempt depending on the product taxability. Indicate the type of product you are selling in the product code field for product-level taxability rules to be applied. Do not use both the `taxInformation.nexus` and `taxInformation.noNexus` fields in your request. If you do not include this field in a tax calculation service request, the tax system makes its calculations as if you have nexus in every US state or Canadian province. Use the [State, Province, and Territory Codes for the United States and Canada](https://developer.cybersource.com/library/documentation/sbc/quickref/states_and_provinces.pdf).  If you indicate you do not have nexus in the destination state, jurisdiction level fields are left blank in the Tax Detail Report.  Optional field for U.S. and Canadian taxes only. Either this field or `taxInformation.noNexus` is required if you do not have nexus in every state or province.  Not applicable for international and value added taxes. 
    */
    'nexus'?: Array<string>;
    /**
    * Comma-separated list of states or provinces where you do not have nexus. Check with a tax advisor to determine where your business has nexus. Do not use both the `taxInformation.nexus` and `taxInformation.noNexus` fields in your request. If you do not include this field in a tax calculation service request, the tax system makes its calculations as if you have nexus in every US state or Canadian province. Use the [State, Province, and Territory Codes for the United States and Canada](https://developer.cybersource.com/library/documentation/sbc/quickref/states_and_provinces.pdf).  If you indicate you do not have nexus in the destination state, jurisdiction level fields are left blank in the Tax Detail Report.  Optional field for U.S. and Canadian taxes only. Either this field or `taxInformation.nexus` is required if you do not have nexus in every state or province.  Not applicable for international and value added taxes. 
    */
    'noNexus'?: Array<string>;
    /**
    * Whether or not to display tax amounts for each line item. This field can contain one of the following values: - `Yes` - Display tax amounts for each line item - `No` (default) - Do not display tax amounts for each line item  Optional for U.S., Canadian, international tax, and value added taxes. 
    */
    'showTaxPerLineItem'?: string;
    /**
    * Indicates whether this is a committed tax transaction. For a committed tax transaction, the status in the Tax Detail Report is “Committed.” For an uncommitted tax transaction, the status in the Tax Detail Report is “Uncommitted.” Possible values: - `true`: This is a committed tax transaction. - `false` (default): This is not a committed tax transaction.  A committed tax request is a tax service request that sets the status field in the Tax Detail Report to committed. The committed status indicates that the amount calculated by the tax service is included in the amount of a capture or credit.  Use a void service request to cancel a committed tax request or a committed refund tax request. The void transaction is included as a separate entry in the Tax Detail Report. The value of the status field is cancelled. The value of the link ID is the request ID of the committed tax request or refund tax request that was voided. You can use the value of the link ID to reconcile your orders.  Optional for U.S., Canadian, international tax, and value added taxes. For more information on Tax Detail Report features refer the [Tax Service Guide](https://developer.cybersource.com/docs/cybs/en-us/tax-calculation/developer/all/rest/tax-calculation/tax-overview.html). 
    */
    'commitIndicator'?: boolean;
    /**
    * Indicates whether this is a refund tax transaction. For a refund tax transaction, amounts in the Tax Detail Report will be negative. Possible values: - `true`: This is a refund tax transaction. - `false` (default): This is not a refund tax transaction.  A refund tax request is a tax service request that sets the transaction type field in the Tax Detail Report to refunded and makes the reported amount negative. Tax amounts are returned as positive amounts in reply messages, but they are saved in reports as negative amounts which enables the reporting software to accurately calculate the aggregate amounts.  Optional for U.S., Canadian, international tax, and value added taxes. For more information on Tax Detail Report features refer the [Tax Service Guide](https://developer.cybersource.com/docs/cybs/en-us/tax-calculation/developer/all/rest/tax-calculation/tax-overview.html). 
    */
    'refundIndicator'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "reportingDate",
            "baseName": "reportingDate",
            "type": "string"
        },
        {
            "name": "dateOverrideReason",
            "baseName": "dateOverrideReason",
            "type": "string"
        },
        {
            "name": "nexus",
            "baseName": "nexus",
            "type": "Array<string>"
        },
        {
            "name": "noNexus",
            "baseName": "noNexus",
            "type": "Array<string>"
        },
        {
            "name": "showTaxPerLineItem",
            "baseName": "showTaxPerLineItem",
            "type": "string"
        },
        {
            "name": "commitIndicator",
            "baseName": "commitIndicator",
            "type": "boolean"
        },
        {
            "name": "refundIndicator",
            "baseName": "refundIndicator",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return Vasv2taxTaxInformation.attributeTypeMap;
    }
}

export class Vasv2taxidClientReferenceInformation {
    /**
    * Merchant-generated order reference or tracking number. It is recommended that you send a unique value for each transaction so that you can perform meaningful searches for the transaction.  #### Used by **Authorization** Required field.  #### PIN Debit Requests for PIN debit reversals need to use the same merchant reference number that was used in the transaction that is being reversed.  Required field for all PIN Debit requests (purchase, credit, and reversal).  #### FDC Nashville Global Certain circumstances can cause the processor to truncate this value to 15 or 17 characters for Level II and Level III processing, which can cause a discrepancy between the value you submit and the value included in some processor reports. 
    */
    'code'?: string;
    /**
    * Brief description of the order or any comment you wish to add to the order.
    */
    'comments'?: string;
    'partner'?: Vasv2taxidClientReferenceInformationPartner;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "code",
            "baseName": "code",
            "type": "string"
        },
        {
            "name": "comments",
            "baseName": "comments",
            "type": "string"
        },
        {
            "name": "partner",
            "baseName": "partner",
            "type": "Vasv2taxidClientReferenceInformationPartner"
        }    ];

    static getAttributeTypeMap() {
        return Vasv2taxidClientReferenceInformation.attributeTypeMap;
    }
}

export class Vasv2taxidClientReferenceInformationPartner {
    /**
    * Identifier for the partner that is integrated to CyberSource.  Send this value in all requests that are sent through the partner solution. CyberSource assigns the ID to the partner.  **Note** When you see a solutionId of 999 in reports, the solutionId that was submitted is incorrect. 
    */
    'solutionId'?: string;
    /**
    * Identifier for the developer that helped integrate a partner solution to CyberSource.  Send this value in all requests that are sent through the partner solutions built by that developer. CyberSource assigns the ID to the developer.  **Note** When you see a developer ID of 999 in reports, the developer ID that was submitted is incorrect. 
    */
    'developerId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "solutionId",
            "baseName": "solutionId",
            "type": "string"
        },
        {
            "name": "developerId",
            "baseName": "developerId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Vasv2taxidClientReferenceInformationPartner.attributeTypeMap;
    }
}

export class VerifyCustomerAddressRequest {
    'clientReferenceInformation'?: Riskv1liststypeentriesClientReferenceInformation;
    'orderInformation'?: Riskv1addressverificationsOrderInformation;
    'buyerInformation'?: Riskv1addressverificationsBuyerInformation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "clientReferenceInformation",
            "baseName": "clientReferenceInformation",
            "type": "Riskv1liststypeentriesClientReferenceInformation"
        },
        {
            "name": "orderInformation",
            "baseName": "orderInformation",
            "type": "Riskv1addressverificationsOrderInformation"
        },
        {
            "name": "buyerInformation",
            "baseName": "buyerInformation",
            "type": "Riskv1addressverificationsBuyerInformation"
        }    ];

    static getAttributeTypeMap() {
        return VerifyCustomerAddressRequest.attributeTypeMap;
    }
}

export class VoidCaptureRequest {
    'clientReferenceInformation'?: Ptsv2paymentsidreversalsClientReferenceInformation;
    'paymentInformation'?: Ptsv2paymentsidvoidsPaymentInformation;
    'orderInformation'?: Ptsv2paymentsidvoidsOrderInformation;
    'agreementInformation'?: Ptsv2paymentsidvoidsAgreementInformation;
    'merchantInformation'?: Ptsv2paymentsidvoidsMerchantInformation;
    'processingInformation'?: Ptsv2paymentsidvoidsProcessingInformation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "clientReferenceInformation",
            "baseName": "clientReferenceInformation",
            "type": "Ptsv2paymentsidreversalsClientReferenceInformation"
        },
        {
            "name": "paymentInformation",
            "baseName": "paymentInformation",
            "type": "Ptsv2paymentsidvoidsPaymentInformation"
        },
        {
            "name": "orderInformation",
            "baseName": "orderInformation",
            "type": "Ptsv2paymentsidvoidsOrderInformation"
        },
        {
            "name": "agreementInformation",
            "baseName": "agreementInformation",
            "type": "Ptsv2paymentsidvoidsAgreementInformation"
        },
        {
            "name": "merchantInformation",
            "baseName": "merchantInformation",
            "type": "Ptsv2paymentsidvoidsMerchantInformation"
        },
        {
            "name": "processingInformation",
            "baseName": "processingInformation",
            "type": "Ptsv2paymentsidvoidsProcessingInformation"
        }    ];

    static getAttributeTypeMap() {
        return VoidCaptureRequest.attributeTypeMap;
    }
}

export class VoidCreditRequest {
    'clientReferenceInformation'?: Ptsv2paymentsidreversalsClientReferenceInformation;
    'paymentInformation'?: Ptsv2paymentsidvoidsPaymentInformation;
    'orderInformation'?: Ptsv2paymentsidvoidsOrderInformation;
    'agreementInformation'?: Ptsv2paymentsidvoidsAgreementInformation;
    'merchantInformation'?: Ptsv2paymentsidvoidsMerchantInformation;
    'processingInformation'?: Ptsv2paymentsidvoidsProcessingInformation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "clientReferenceInformation",
            "baseName": "clientReferenceInformation",
            "type": "Ptsv2paymentsidreversalsClientReferenceInformation"
        },
        {
            "name": "paymentInformation",
            "baseName": "paymentInformation",
            "type": "Ptsv2paymentsidvoidsPaymentInformation"
        },
        {
            "name": "orderInformation",
            "baseName": "orderInformation",
            "type": "Ptsv2paymentsidvoidsOrderInformation"
        },
        {
            "name": "agreementInformation",
            "baseName": "agreementInformation",
            "type": "Ptsv2paymentsidvoidsAgreementInformation"
        },
        {
            "name": "merchantInformation",
            "baseName": "merchantInformation",
            "type": "Ptsv2paymentsidvoidsMerchantInformation"
        },
        {
            "name": "processingInformation",
            "baseName": "processingInformation",
            "type": "Ptsv2paymentsidvoidsProcessingInformation"
        }    ];

    static getAttributeTypeMap() {
        return VoidCreditRequest.attributeTypeMap;
    }
}

export class VoidPaymentRequest {
    'clientReferenceInformation'?: Ptsv2paymentsidreversalsClientReferenceInformation;
    'paymentInformation'?: Ptsv2paymentsidvoidsPaymentInformation;
    'orderInformation'?: Ptsv2paymentsidvoidsOrderInformation;
    'agreementInformation'?: Ptsv2paymentsidvoidsAgreementInformation;
    'merchantInformation'?: Ptsv2paymentsidvoidsMerchantInformation;
    'processingInformation'?: Ptsv2paymentsidvoidsProcessingInformation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "clientReferenceInformation",
            "baseName": "clientReferenceInformation",
            "type": "Ptsv2paymentsidreversalsClientReferenceInformation"
        },
        {
            "name": "paymentInformation",
            "baseName": "paymentInformation",
            "type": "Ptsv2paymentsidvoidsPaymentInformation"
        },
        {
            "name": "orderInformation",
            "baseName": "orderInformation",
            "type": "Ptsv2paymentsidvoidsOrderInformation"
        },
        {
            "name": "agreementInformation",
            "baseName": "agreementInformation",
            "type": "Ptsv2paymentsidvoidsAgreementInformation"
        },
        {
            "name": "merchantInformation",
            "baseName": "merchantInformation",
            "type": "Ptsv2paymentsidvoidsMerchantInformation"
        },
        {
            "name": "processingInformation",
            "baseName": "processingInformation",
            "type": "Ptsv2paymentsidvoidsProcessingInformation"
        }    ];

    static getAttributeTypeMap() {
        return VoidPaymentRequest.attributeTypeMap;
    }
}

export class VoidRefundRequest {
    'clientReferenceInformation'?: Ptsv2paymentsidreversalsClientReferenceInformation;
    'paymentInformation'?: Ptsv2paymentsidvoidsPaymentInformation;
    'orderInformation'?: Ptsv2paymentsidvoidsOrderInformation;
    'agreementInformation'?: Ptsv2paymentsidvoidsAgreementInformation;
    'merchantInformation'?: Ptsv2paymentsidvoidsMerchantInformation;
    'processingInformation'?: Ptsv2paymentsidvoidsProcessingInformation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "clientReferenceInformation",
            "baseName": "clientReferenceInformation",
            "type": "Ptsv2paymentsidreversalsClientReferenceInformation"
        },
        {
            "name": "paymentInformation",
            "baseName": "paymentInformation",
            "type": "Ptsv2paymentsidvoidsPaymentInformation"
        },
        {
            "name": "orderInformation",
            "baseName": "orderInformation",
            "type": "Ptsv2paymentsidvoidsOrderInformation"
        },
        {
            "name": "agreementInformation",
            "baseName": "agreementInformation",
            "type": "Ptsv2paymentsidvoidsAgreementInformation"
        },
        {
            "name": "merchantInformation",
            "baseName": "merchantInformation",
            "type": "Ptsv2paymentsidvoidsMerchantInformation"
        },
        {
            "name": "processingInformation",
            "baseName": "processingInformation",
            "type": "Ptsv2paymentsidvoidsProcessingInformation"
        }    ];

    static getAttributeTypeMap() {
        return VoidRefundRequest.attributeTypeMap;
    }
}

export class VoidTaxRequest {
    'clientReferenceInformation'?: Vasv2taxidClientReferenceInformation;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "clientReferenceInformation",
            "baseName": "clientReferenceInformation",
            "type": "Vasv2taxidClientReferenceInformation"
        }    ];

    static getAttributeTypeMap() {
        return VoidTaxRequest.attributeTypeMap;
    }
}


let enumsMap: {[index: string]: any} = {
        "Boardingv1registrationsOrganizationInformation.TypeEnum": Boardingv1registrationsOrganizationInformation.TypeEnum,
        "Boardingv1registrationsOrganizationInformation.StatusEnum": Boardingv1registrationsOrganizationInformation.StatusEnum,
        "Boardingv1registrationsOrganizationInformationBusinessInformation.TimeZoneEnum": Boardingv1registrationsOrganizationInformationBusinessInformation.TimeZoneEnum,
        "Boardingv1registrationsOrganizationInformationBusinessInformation.TypeEnum": Boardingv1registrationsOrganizationInformationBusinessInformation.TypeEnum,
        "Boardingv1registrationsOrganizationInformationKYC.WhenIsCustomerChargedEnum": Boardingv1registrationsOrganizationInformationKYC.WhenIsCustomerChargedEnum,
        "Boardingv1registrationsOrganizationInformationKYC.TimeToProductDeliveryEnum": Boardingv1registrationsOrganizationInformationKYC.TimeToProductDeliveryEnum,
        "Boardingv1registrationsOrganizationInformationKYCDepositBankAccount.AccountTypeEnum": Boardingv1registrationsOrganizationInformationKYCDepositBankAccount.AccountTypeEnum,
        "Boardingv1registrationsRegistrationInformation.StatusEnum": Boardingv1registrationsRegistrationInformation.StatusEnum,
        "Boardingv1registrationsRegistrationInformation.BoardingFlowEnum": Boardingv1registrationsRegistrationInformation.BoardingFlowEnum,
        "Boardingv1registrationsRegistrationInformation.ModeEnum": Boardingv1registrationsRegistrationInformation.ModeEnum,
        "Body1.StatusEnum": Body1.StatusEnum,
        "Body1.StatusChangeReasonEnum": Body1.StatusChangeReasonEnum,
        "Body1.ReplacementReasonEnum": Body1.ReplacementReasonEnum,
        "Body1.P2peStatusEnum": Body1.P2peStatusEnum,
        "Body1.P2peConfirmationEnum": Body1.P2peConfirmationEnum,
        "CardProcessingConfigCommon.DefaultAuthTypeCodeEnum": CardProcessingConfigCommon.DefaultAuthTypeCodeEnum,
        "CardProcessingConfigCommonProcessors.IndustryCodeEnum": CardProcessingConfigCommonProcessors.IndustryCodeEnum,
        "CommerceSolutionsProductsTokenManagementConfigurationInformationConfigurationsVault.DefaultTokenTypeEnum": CommerceSolutionsProductsTokenManagementConfigurationInformationConfigurationsVault.DefaultTokenTypeEnum,
        "CommerceSolutionsProductsTokenManagementConfigurationInformationConfigurationsVault.LocationEnum": CommerceSolutionsProductsTokenManagementConfigurationInformationConfigurationsVault.LocationEnum,
        "CreateWebhook.NotificationScopeEnum": CreateWebhook.NotificationScopeEnum,
        "ECheckConfigCommonInternalOnlyProcessors.SettlementMethodEnum": ECheckConfigCommonInternalOnlyProcessors.SettlementMethodEnum,
        "ECheckConfigCommonInternalOnlyProcessors.VerificationLevelEnum": ECheckConfigCommonInternalOnlyProcessors.VerificationLevelEnum,
        "ECheckConfigCommonProcessors.AccuityCheckTypeEnum": ECheckConfigCommonProcessors.AccuityCheckTypeEnum,
        "ECheckConfigFeaturesAccountValidationServiceInternalOnlyProcessors.AvsVersionEnum": ECheckConfigFeaturesAccountValidationServiceInternalOnlyProcessors.AvsVersionEnum,
        "ECheckConfigFeaturesAccountValidationServiceProcessors.AvsCalculatedResponseBehaviorEnum": ECheckConfigFeaturesAccountValidationServiceProcessors.AvsCalculatedResponseBehaviorEnum,
        "ECheckConfigFeaturesAccountValidationServiceProcessors.AvsResultModeEnum": ECheckConfigFeaturesAccountValidationServiceProcessors.AvsResultModeEnum,
        "InlineResponse2002IntegrationInformationTenantConfigurations.StatusEnum": InlineResponse2002IntegrationInformationTenantConfigurations.StatusEnum,
        "InlineResponse2004.NotificationScopeEnum": InlineResponse2004.NotificationScopeEnum,
        "InlineResponse2005.NotificationScopeEnum": InlineResponse2005.NotificationScopeEnum,
        "InlineResponse2007.StatusEnum": InlineResponse2007.StatusEnum,
        "InlineResponse2008Devices.StatusEnum": InlineResponse2008Devices.StatusEnum,
        "InlineResponse20110.StatusEnum": InlineResponse20110.StatusEnum,
        "InlineResponse2013.StatusEnum": InlineResponse2013.StatusEnum,
        "InlineResponse2013IntegrationInformationTenantConfigurations.StatusEnum": InlineResponse2013IntegrationInformationTenantConfigurations.StatusEnum,
        "InlineResponse2013RegistrationInformation.ModeEnum": InlineResponse2013RegistrationInformation.ModeEnum,
        "InlineResponse2013SetupsPaymentsAlternativePaymentMethods.StatusEnum": InlineResponse2013SetupsPaymentsAlternativePaymentMethods.StatusEnum,
        "InlineResponse2013SetupsPaymentsAlternativePaymentMethodsConfigurationStatus.StatusEnum": InlineResponse2013SetupsPaymentsAlternativePaymentMethodsConfigurationStatus.StatusEnum,
        "InlineResponse2013SetupsPaymentsCardProcessingConfigurationStatus.StatusEnum": InlineResponse2013SetupsPaymentsCardProcessingConfigurationStatus.StatusEnum,
        "InlineResponse2013SetupsPaymentsCardProcessingConfigurationStatus.ReasonEnum": InlineResponse2013SetupsPaymentsCardProcessingConfigurationStatus.ReasonEnum,
        "InlineResponse2013SetupsPaymentsCardProcessingSubscriptionStatus.StatusEnum": InlineResponse2013SetupsPaymentsCardProcessingSubscriptionStatus.StatusEnum,
        "InlineResponse2013SetupsPaymentsCardProcessingSubscriptionStatus.ReasonEnum": InlineResponse2013SetupsPaymentsCardProcessingSubscriptionStatus.ReasonEnum,
        "InlineResponse2015.NotificationScopeEnum": InlineResponse2015.NotificationScopeEnum,
        "InlineResponse206.StatusEnum": InlineResponse206.StatusEnum,
        "InlineResponse2061.StatusEnum": InlineResponse2061.StatusEnum,
        "InlineResponse4007.StatusEnum": InlineResponse4007.StatusEnum,
        "InlineResponse4008.ReasonEnum": InlineResponse4008.ReasonEnum,
        "InlineResponse401.StatusEnum": InlineResponse401.StatusEnum,
        "InlineResponse4032.StatusEnum": InlineResponse4032.StatusEnum,
        "InlineResponse4043.StatusEnum": InlineResponse4043.StatusEnum,
        "InlineResponse5003.StatusEnum": InlineResponse5003.StatusEnum,
        "Iplv2paymentlinksProcessingInformation.LinkTypeEnum": Iplv2paymentlinksProcessingInformation.LinkTypeEnum,
        "Iplv2paymentlinksidProcessingInformation.LinkTypeEnum": Iplv2paymentlinksidProcessingInformation.LinkTypeEnum,
        "Notificationsubscriptionsv2webhooksSecurityPolicy.SecurityTypeEnum": Notificationsubscriptionsv2webhooksSecurityPolicy.SecurityTypeEnum,
        "Notificationsubscriptionsv2webhooksSecurityPolicyConfig.OAuthTokenTypeEnum": Notificationsubscriptionsv2webhooksSecurityPolicyConfig.OAuthTokenTypeEnum,
        "PaymentsProductsAlternativePaymentMethodsSubscriptionInformation.SelfServiceabilityEnum": PaymentsProductsAlternativePaymentMethodsSubscriptionInformation.SelfServiceabilityEnum,
        "PaymentsProductsCardPresentConnectSubscriptionInformation.SelfServiceabilityEnum": PaymentsProductsCardPresentConnectSubscriptionInformation.SelfServiceabilityEnum,
        "PaymentsProductsCardProcessingSubscriptionInformation.SelfServiceabilityEnum": PaymentsProductsCardProcessingSubscriptionInformation.SelfServiceabilityEnum,
        "PaymentsProductsDifferentialFeeSubscriptionInformation.SelfServiceabilityEnum": PaymentsProductsDifferentialFeeSubscriptionInformation.SelfServiceabilityEnum,
        "PaymentsProductsDigitalPaymentsSubscriptionInformation.SelfServiceabilityEnum": PaymentsProductsDigitalPaymentsSubscriptionInformation.SelfServiceabilityEnum,
        "PaymentsProductsECheckSubscriptionInformation.SelfServiceabilityEnum": PaymentsProductsECheckSubscriptionInformation.SelfServiceabilityEnum,
        "PaymentsProductsServiceFeeConfigurationInformationConfigurationsPaymentInformation.PaymentTypeEnum": PaymentsProductsServiceFeeConfigurationInformationConfigurationsPaymentInformation.PaymentTypeEnum,
        "PaymentsProductsServiceFeeConfigurationInformationConfigurationsPaymentInformation.FeeTypeEnum": PaymentsProductsServiceFeeConfigurationInformationConfigurationsPaymentInformation.FeeTypeEnum,
        "PaymentsProductsUnifiedCheckoutConfigurationInformationConfigurationsFeaturesPaze.FinancialInstitutionEnum": PaymentsProductsUnifiedCheckoutConfigurationInformationConfigurationsFeaturesPaze.FinancialInstitutionEnum,
        "PaymentsProductsUnifiedCheckoutSubscriptionInformation.EnablementStatusEnum": PaymentsProductsUnifiedCheckoutSubscriptionInformation.EnablementStatusEnum,
        "PaymentsProductsUnifiedCheckoutSubscriptionInformation.SelfServiceabilityEnum": PaymentsProductsUnifiedCheckoutSubscriptionInformation.SelfServiceabilityEnum,
        "PblPaymentLinksAllGet200ResponseProcessingInformation.LinkTypeEnum": PblPaymentLinksAllGet200ResponseProcessingInformation.LinkTypeEnum,
        "SAConfigPaymentMethods.EnabledPaymentMethodsEnum": SAConfigPaymentMethods.EnabledPaymentMethodsEnum,
        "TmsSensitivePrivileges.CardNumberMaskingFormatEnum": TmsSensitivePrivileges.CardNumberMaskingFormatEnum,
        "TmsTokenFormats.CustomerEnum": TmsTokenFormats.CustomerEnum,
        "TmsTokenFormats.PaymentInstrumentEnum": TmsTokenFormats.PaymentInstrumentEnum,
        "TmsTokenFormats.InstrumentIdentifierCardEnum": TmsTokenFormats.InstrumentIdentifierCardEnum,
        "TmsTokenFormats.InstrumentIdentifierBankAccountEnum": TmsTokenFormats.InstrumentIdentifierBankAccountEnum,
        "UpdateStatus.StatusEnum": UpdateStatus.StatusEnum,
        "UpdateWebhook.NotificationScopeEnum": UpdateWebhook.NotificationScopeEnum,
        "VTConfigCardNotPresentGlobalPaymentInformationBasicInformation.DefaultTransactionTypeEnum": VTConfigCardNotPresentGlobalPaymentInformationBasicInformation.DefaultTransactionTypeEnum,
        "VTConfigCardNotPresentGlobalPaymentInformationBasicInformation.DefaultPaymentTypeEnum": VTConfigCardNotPresentGlobalPaymentInformationBasicInformation.DefaultPaymentTypeEnum,
        "VTConfigCardNotPresentGlobalPaymentInformationPaymentInformation.DisplayCardVerificationValueEnum": VTConfigCardNotPresentGlobalPaymentInformationPaymentInformation.DisplayCardVerificationValueEnum,
        "VTConfigCardNotPresentGlobalPaymentInformationPaymentInformation.RequireCardVerificationValueEnum": VTConfigCardNotPresentGlobalPaymentInformationPaymentInformation.RequireCardVerificationValueEnum,
        "VTConfigCardNotPresentGlobalPaymentInformationPaymentInformation.AcceptedCardTypesEnum": VTConfigCardNotPresentGlobalPaymentInformationPaymentInformation.AcceptedCardTypesEnum,
}

let typeMap: {[index: string]: any} = {
    "Accountupdaterv1batchesIncluded": Accountupdaterv1batchesIncluded,
    "Accountupdaterv1batchesIncludedTokens": Accountupdaterv1batchesIncludedTokens,
    "ActivateDeactivatePlanResponse": ActivateDeactivatePlanResponse,
    "ActivateSubscriptionResponse": ActivateSubscriptionResponse,
    "ActivateSubscriptionResponseSubscriptionInformation": ActivateSubscriptionResponseSubscriptionInformation,
    "AddNegativeListRequest": AddNegativeListRequest,
    "AuthReversalRequest": AuthReversalRequest,
    "Binv1binlookupClientReferenceInformation": Binv1binlookupClientReferenceInformation,
    "Binv1binlookupPaymentInformation": Binv1binlookupPaymentInformation,
    "Binv1binlookupPaymentInformationCard": Binv1binlookupPaymentInformationCard,
    "Binv1binlookupProcessingInformation": Binv1binlookupProcessingInformation,
    "Binv1binlookupProcessingInformationPayoutOptions": Binv1binlookupProcessingInformationPayoutOptions,
    "Binv1binlookupTokenInformation": Binv1binlookupTokenInformation,
    "Boardingv1registrationsDocumentInformation": Boardingv1registrationsDocumentInformation,
    "Boardingv1registrationsDocumentInformationSignedDocuments": Boardingv1registrationsDocumentInformationSignedDocuments,
    "Boardingv1registrationsIntegrationInformation": Boardingv1registrationsIntegrationInformation,
    "Boardingv1registrationsIntegrationInformationOauth2": Boardingv1registrationsIntegrationInformationOauth2,
    "Boardingv1registrationsIntegrationInformationTenantConfigurations": Boardingv1registrationsIntegrationInformationTenantConfigurations,
    "Boardingv1registrationsIntegrationInformationTenantInformation": Boardingv1registrationsIntegrationInformationTenantInformation,
    "Boardingv1registrationsOrganizationInformation": Boardingv1registrationsOrganizationInformation,
    "Boardingv1registrationsOrganizationInformationBusinessInformation": Boardingv1registrationsOrganizationInformationBusinessInformation,
    "Boardingv1registrationsOrganizationInformationBusinessInformationAddress": Boardingv1registrationsOrganizationInformationBusinessInformationAddress,
    "Boardingv1registrationsOrganizationInformationBusinessInformationBusinessContact": Boardingv1registrationsOrganizationInformationBusinessInformationBusinessContact,
    "Boardingv1registrationsOrganizationInformationKYC": Boardingv1registrationsOrganizationInformationKYC,
    "Boardingv1registrationsOrganizationInformationKYCDepositBankAccount": Boardingv1registrationsOrganizationInformationKYCDepositBankAccount,
    "Boardingv1registrationsOrganizationInformationOwners": Boardingv1registrationsOrganizationInformationOwners,
    "Boardingv1registrationsProductInformation": Boardingv1registrationsProductInformation,
    "Boardingv1registrationsProductInformationSelectedProducts": Boardingv1registrationsProductInformationSelectedProducts,
    "Boardingv1registrationsRegistrationInformation": Boardingv1registrationsRegistrationInformation,
    "Body": Body,
    "Body1": Body1,
    "Body2": Body2,
    "Body3": Body3,
    "CancelSubscriptionResponse": CancelSubscriptionResponse,
    "CancelSubscriptionResponseSubscriptionInformation": CancelSubscriptionResponseSubscriptionInformation,
    "CapturePaymentRequest": CapturePaymentRequest,
    "CardProcessingConfig": CardProcessingConfig,
    "CardProcessingConfigCommon": CardProcessingConfigCommon,
    "CardProcessingConfigCommonAcquirer": CardProcessingConfigCommonAcquirer,
    "CardProcessingConfigCommonCurrencies": CardProcessingConfigCommonCurrencies,
    "CardProcessingConfigCommonCurrencies1": CardProcessingConfigCommonCurrencies1,
    "CardProcessingConfigCommonMerchantDescriptorInformation": CardProcessingConfigCommonMerchantDescriptorInformation,
    "CardProcessingConfigCommonPaymentTypes": CardProcessingConfigCommonPaymentTypes,
    "CardProcessingConfigCommonProcessors": CardProcessingConfigCommonProcessors,
    "CardProcessingConfigFeatures": CardProcessingConfigFeatures,
    "CardProcessingConfigFeaturesCardNotPresent": CardProcessingConfigFeaturesCardNotPresent,
    "CardProcessingConfigFeaturesCardNotPresentInstallment": CardProcessingConfigFeaturesCardNotPresentInstallment,
    "CardProcessingConfigFeaturesCardNotPresentPayouts": CardProcessingConfigFeaturesCardNotPresentPayouts,
    "CardProcessingConfigFeaturesCardNotPresentPayoutsCurrencies": CardProcessingConfigFeaturesCardNotPresentPayoutsCurrencies,
    "CardProcessingConfigFeaturesCardNotPresentProcessors": CardProcessingConfigFeaturesCardNotPresentProcessors,
    "CardProcessingConfigFeaturesCardPresent": CardProcessingConfigFeaturesCardPresent,
    "CardProcessingConfigFeaturesCardPresentProcessors": CardProcessingConfigFeaturesCardPresentProcessors,
    "CaseManagementActionsRequest": CaseManagementActionsRequest,
    "CaseManagementCommentsRequest": CaseManagementCommentsRequest,
    "CheckPayerAuthEnrollmentRequest": CheckPayerAuthEnrollmentRequest,
    "CommerceSolutionsProducts": CommerceSolutionsProducts,
    "CommerceSolutionsProductsAccountUpdater": CommerceSolutionsProductsAccountUpdater,
    "CommerceSolutionsProductsAccountUpdaterConfigurationInformation": CommerceSolutionsProductsAccountUpdaterConfigurationInformation,
    "CommerceSolutionsProductsAccountUpdaterConfigurationInformationConfigurations": CommerceSolutionsProductsAccountUpdaterConfigurationInformationConfigurations,
    "CommerceSolutionsProductsAccountUpdaterConfigurationInformationConfigurationsAmex": CommerceSolutionsProductsAccountUpdaterConfigurationInformationConfigurationsAmex,
    "CommerceSolutionsProductsAccountUpdaterConfigurationInformationConfigurationsMasterCard": CommerceSolutionsProductsAccountUpdaterConfigurationInformationConfigurationsMasterCard,
    "CommerceSolutionsProductsAccountUpdaterConfigurationInformationConfigurationsVisa": CommerceSolutionsProductsAccountUpdaterConfigurationInformationConfigurationsVisa,
    "CommerceSolutionsProductsBinLookup": CommerceSolutionsProductsBinLookup,
    "CommerceSolutionsProductsBinLookupConfigurationInformation": CommerceSolutionsProductsBinLookupConfigurationInformation,
    "CommerceSolutionsProductsBinLookupConfigurationInformationConfigurations": CommerceSolutionsProductsBinLookupConfigurationInformationConfigurations,
    "CommerceSolutionsProductsTokenManagement": CommerceSolutionsProductsTokenManagement,
    "CommerceSolutionsProductsTokenManagementConfigurationInformation": CommerceSolutionsProductsTokenManagementConfigurationInformation,
    "CommerceSolutionsProductsTokenManagementConfigurationInformationConfigurations": CommerceSolutionsProductsTokenManagementConfigurationInformationConfigurations,
    "CommerceSolutionsProductsTokenManagementConfigurationInformationConfigurationsVault": CommerceSolutionsProductsTokenManagementConfigurationInformationConfigurationsVault,
    "CreateAdhocReportRequest": CreateAdhocReportRequest,
    "CreateBillingAgreement": CreateBillingAgreement,
    "CreateBinLookupRequest": CreateBinLookupRequest,
    "CreateBundledDecisionManagerCaseRequest": CreateBundledDecisionManagerCaseRequest,
    "CreateCreditRequest": CreateCreditRequest,
    "CreateInvoiceRequest": CreateInvoiceRequest,
    "CreateOrderRequest": CreateOrderRequest,
    "CreatePaymentLinkRequest": CreatePaymentLinkRequest,
    "CreatePaymentRequest": CreatePaymentRequest,
    "CreatePlanRequest": CreatePlanRequest,
    "CreatePlanResponse": CreatePlanResponse,
    "CreatePlanResponsePlanInformation": CreatePlanResponsePlanInformation,
    "CreateReportSubscriptionRequest": CreateReportSubscriptionRequest,
    "CreateSearchRequest": CreateSearchRequest,
    "CreateSessionReq": CreateSessionReq,
    "CreateSessionRequest": CreateSessionRequest,
    "CreateSubscriptionRequest": CreateSubscriptionRequest,
    "CreateSubscriptionRequest1": CreateSubscriptionRequest1,
    "CreateSubscriptionResponse": CreateSubscriptionResponse,
    "CreateSubscriptionResponseLinks": CreateSubscriptionResponseLinks,
    "CreateSubscriptionResponseSubscriptionInformation": CreateSubscriptionResponseSubscriptionInformation,
    "CreateWebhook": CreateWebhook,
    "DeletePlanResponse": DeletePlanResponse,
    "DeviceDeAssociateV3Request": DeviceDeAssociateV3Request,
    "DeviceTransferRequest": DeviceTransferRequest,
    "DmConfig": DmConfig,
    "DmConfigOrganization": DmConfigOrganization,
    "DmConfigPortfolioControls": DmConfigPortfolioControls,
    "DmConfigProcessingOptions": DmConfigProcessingOptions,
    "DmConfigThirdparty": DmConfigThirdparty,
    "DmConfigThirdpartyProvider": DmConfigThirdpartyProvider,
    "DmConfigThirdpartyProviderAccurint": DmConfigThirdpartyProviderAccurint,
    "DmConfigThirdpartyProviderAccurintCredentials": DmConfigThirdpartyProviderAccurintCredentials,
    "DmConfigThirdpartyProviderCredilink": DmConfigThirdpartyProviderCredilink,
    "DmConfigThirdpartyProviderCredilinkCredentials": DmConfigThirdpartyProviderCredilinkCredentials,
    "DmConfigThirdpartyProviderEkata": DmConfigThirdpartyProviderEkata,
    "DmConfigThirdpartyProviderEkataCredentials": DmConfigThirdpartyProviderEkataCredentials,
    "DmConfigThirdpartyProviderEmailage": DmConfigThirdpartyProviderEmailage,
    "DmConfigThirdpartyProviderPerseuss": DmConfigThirdpartyProviderPerseuss,
    "DmConfigThirdpartyProviderSignifyd": DmConfigThirdpartyProviderSignifyd,
    "DmConfigThirdpartyProviderSignifydCredentials": DmConfigThirdpartyProviderSignifydCredentials,
    "DmConfigThirdpartyProviderTargus": DmConfigThirdpartyProviderTargus,
    "DmConfigThirdpartyProviderTargusCredentials": DmConfigThirdpartyProviderTargusCredentials,
    "Dmsv2devicesPaymentProcessor": Dmsv2devicesPaymentProcessor,
    "Dmsv2devicetransferDetails": Dmsv2devicetransferDetails,
    "Dmsv2devicetransferDetails1": Dmsv2devicetransferDetails1,
    "Dmsv3devicesdeassociateDevices": Dmsv3devicesdeassociateDevices,
    "ECheckConfig": ECheckConfig,
    "ECheckConfigCommon": ECheckConfigCommon,
    "ECheckConfigCommonInternalOnly": ECheckConfigCommonInternalOnly,
    "ECheckConfigCommonInternalOnlyProcessors": ECheckConfigCommonInternalOnlyProcessors,
    "ECheckConfigCommonProcessors": ECheckConfigCommonProcessors,
    "ECheckConfigFeatures": ECheckConfigFeatures,
    "ECheckConfigFeaturesAccountValidationService": ECheckConfigFeaturesAccountValidationService,
    "ECheckConfigFeaturesAccountValidationServiceInternalOnly": ECheckConfigFeaturesAccountValidationServiceInternalOnly,
    "ECheckConfigFeaturesAccountValidationServiceInternalOnlyProcessors": ECheckConfigFeaturesAccountValidationServiceInternalOnlyProcessors,
    "ECheckConfigFeaturesAccountValidationServiceProcessors": ECheckConfigFeaturesAccountValidationServiceProcessors,
    "ECheckConfigUnderwriting": ECheckConfigUnderwriting,
    "FraudMarkingActionRequest": FraudMarkingActionRequest,
    "GenerateCaptureContextRequest": GenerateCaptureContextRequest,
    "GenerateUnifiedCheckoutCaptureContextRequest": GenerateUnifiedCheckoutCaptureContextRequest,
    "GetAllPlansResponse": GetAllPlansResponse,
    "GetAllPlansResponseLinks": GetAllPlansResponseLinks,
    "GetAllPlansResponseOrderInformation": GetAllPlansResponseOrderInformation,
    "GetAllPlansResponseOrderInformationAmountDetails": GetAllPlansResponseOrderInformationAmountDetails,
    "GetAllPlansResponsePlanInformation": GetAllPlansResponsePlanInformation,
    "GetAllPlansResponsePlanInformationBillingCycles": GetAllPlansResponsePlanInformationBillingCycles,
    "GetAllPlansResponsePlanInformationBillingPeriod": GetAllPlansResponsePlanInformationBillingPeriod,
    "GetAllPlansResponsePlans": GetAllPlansResponsePlans,
    "GetAllSubscriptionsResponse": GetAllSubscriptionsResponse,
    "GetAllSubscriptionsResponseLinks": GetAllSubscriptionsResponseLinks,
    "GetAllSubscriptionsResponseOrderInformation": GetAllSubscriptionsResponseOrderInformation,
    "GetAllSubscriptionsResponseOrderInformationBillTo": GetAllSubscriptionsResponseOrderInformationBillTo,
    "GetAllSubscriptionsResponsePaymentInformation": GetAllSubscriptionsResponsePaymentInformation,
    "GetAllSubscriptionsResponsePaymentInformationCustomer": GetAllSubscriptionsResponsePaymentInformationCustomer,
    "GetAllSubscriptionsResponsePlanInformation": GetAllSubscriptionsResponsePlanInformation,
    "GetAllSubscriptionsResponsePlanInformationBillingCycles": GetAllSubscriptionsResponsePlanInformationBillingCycles,
    "GetAllSubscriptionsResponseSubscriptionInformation": GetAllSubscriptionsResponseSubscriptionInformation,
    "GetAllSubscriptionsResponseSubscriptions": GetAllSubscriptionsResponseSubscriptions,
    "GetPlanCodeResponse": GetPlanCodeResponse,
    "GetPlanResponse": GetPlanResponse,
    "GetSubscriptionCodeResponse": GetSubscriptionCodeResponse,
    "GetSubscriptionResponse": GetSubscriptionResponse,
    "GetSubscriptionResponse1": GetSubscriptionResponse1,
    "GetSubscriptionResponse1BuyerInformation": GetSubscriptionResponse1BuyerInformation,
    "GetSubscriptionResponse1Links": GetSubscriptionResponse1Links,
    "GetSubscriptionResponse1PaymentInstrument": GetSubscriptionResponse1PaymentInstrument,
    "GetSubscriptionResponse1PaymentInstrumentBankAccount": GetSubscriptionResponse1PaymentInstrumentBankAccount,
    "GetSubscriptionResponse1PaymentInstrumentBuyerInformation": GetSubscriptionResponse1PaymentInstrumentBuyerInformation,
    "GetSubscriptionResponse1PaymentInstrumentCard": GetSubscriptionResponse1PaymentInstrumentCard,
    "GetSubscriptionResponse1ShippingAddress": GetSubscriptionResponse1ShippingAddress,
    "GetSubscriptionResponseReactivationInformation": GetSubscriptionResponseReactivationInformation,
    "IncrementAuthRequest": IncrementAuthRequest,
    "InlineResponse200": InlineResponse200,
    "InlineResponse2001": InlineResponse2001,
    "InlineResponse20010": InlineResponse20010,
    "InlineResponse20010Expirations": InlineResponse20010Expirations,
    "InlineResponse20011": InlineResponse20011,
    "InlineResponse20011CustomizationMetadata": InlineResponse20011CustomizationMetadata,
    "InlineResponse20012": InlineResponse20012,
    "InlineResponse20012Embedded": InlineResponse20012Embedded,
    "InlineResponse20012EmbeddedBatches": InlineResponse20012EmbeddedBatches,
    "InlineResponse20012EmbeddedLinks": InlineResponse20012EmbeddedLinks,
    "InlineResponse20012EmbeddedLinksReports": InlineResponse20012EmbeddedLinksReports,
    "InlineResponse20012EmbeddedTotals": InlineResponse20012EmbeddedTotals,
    "InlineResponse20012Links": InlineResponse20012Links,
    "InlineResponse20013": InlineResponse20013,
    "InlineResponse20013Billing": InlineResponse20013Billing,
    "InlineResponse20013Links": InlineResponse20013Links,
    "InlineResponse20013LinksReport": InlineResponse20013LinksReport,
    "InlineResponse20014": InlineResponse20014,
    "InlineResponse20014Records": InlineResponse20014Records,
    "InlineResponse20014ResponseRecord": InlineResponse20014ResponseRecord,
    "InlineResponse20014ResponseRecordAdditionalUpdates": InlineResponse20014ResponseRecordAdditionalUpdates,
    "InlineResponse20014SourceRecord": InlineResponse20014SourceRecord,
    "InlineResponse2001Embedded": InlineResponse2001Embedded,
    "InlineResponse2001EmbeddedCapture": InlineResponse2001EmbeddedCapture,
    "InlineResponse2001EmbeddedCaptureLinks": InlineResponse2001EmbeddedCaptureLinks,
    "InlineResponse2001EmbeddedCaptureLinksSelf": InlineResponse2001EmbeddedCaptureLinksSelf,
    "InlineResponse2001EmbeddedReversal": InlineResponse2001EmbeddedReversal,
    "InlineResponse2001EmbeddedReversalLinks": InlineResponse2001EmbeddedReversalLinks,
    "InlineResponse2001EmbeddedReversalLinksSelf": InlineResponse2001EmbeddedReversalLinksSelf,
    "InlineResponse2002": InlineResponse2002,
    "InlineResponse2002IntegrationInformation": InlineResponse2002IntegrationInformation,
    "InlineResponse2002IntegrationInformationTenantConfigurations": InlineResponse2002IntegrationInformationTenantConfigurations,
    "InlineResponse2003": InlineResponse2003,
    "InlineResponse2004": InlineResponse2004,
    "InlineResponse2005": InlineResponse2005,
    "InlineResponse2006": InlineResponse2006,
    "InlineResponse2007": InlineResponse2007,
    "InlineResponse2008": InlineResponse2008,
    "InlineResponse2008Devices": InlineResponse2008Devices,
    "InlineResponse2008PaymentProcessorToTerminalMap": InlineResponse2008PaymentProcessorToTerminalMap,
    "InlineResponse2009": InlineResponse2009,
    "InlineResponse200Content": InlineResponse200Content,
    "InlineResponse201": InlineResponse201,
    "InlineResponse2011": InlineResponse2011,
    "InlineResponse20110": InlineResponse20110,
    "InlineResponse2012": InlineResponse2012,
    "InlineResponse2012PayoutInformation": InlineResponse2012PayoutInformation,
    "InlineResponse2012PayoutInformationPullFunds": InlineResponse2012PayoutInformationPullFunds,
    "InlineResponse2012PayoutInformationPushFunds": InlineResponse2012PayoutInformationPushFunds,
    "InlineResponse2013": InlineResponse2013,
    "InlineResponse2013IntegrationInformation": InlineResponse2013IntegrationInformation,
    "InlineResponse2013IntegrationInformationTenantConfigurations": InlineResponse2013IntegrationInformationTenantConfigurations,
    "InlineResponse2013OrganizationInformation": InlineResponse2013OrganizationInformation,
    "InlineResponse2013ProductInformationSetups": InlineResponse2013ProductInformationSetups,
    "InlineResponse2013RegistrationInformation": InlineResponse2013RegistrationInformation,
    "InlineResponse2013Setups": InlineResponse2013Setups,
    "InlineResponse2013SetupsCommerceSolutions": InlineResponse2013SetupsCommerceSolutions,
    "InlineResponse2013SetupsPayments": InlineResponse2013SetupsPayments,
    "InlineResponse2013SetupsPaymentsAlternativePaymentMethods": InlineResponse2013SetupsPaymentsAlternativePaymentMethods,
    "InlineResponse2013SetupsPaymentsAlternativePaymentMethodsConfigurationStatus": InlineResponse2013SetupsPaymentsAlternativePaymentMethodsConfigurationStatus,
    "InlineResponse2013SetupsPaymentsCardProcessing": InlineResponse2013SetupsPaymentsCardProcessing,
    "InlineResponse2013SetupsPaymentsCardProcessingConfigurationStatus": InlineResponse2013SetupsPaymentsCardProcessingConfigurationStatus,
    "InlineResponse2013SetupsPaymentsCardProcessingSubscriptionStatus": InlineResponse2013SetupsPaymentsCardProcessingSubscriptionStatus,
    "InlineResponse2013SetupsPaymentsDigitalPayments": InlineResponse2013SetupsPaymentsDigitalPayments,
    "InlineResponse2013SetupsRisk": InlineResponse2013SetupsRisk,
    "InlineResponse2013SetupsValueAddedServices": InlineResponse2013SetupsValueAddedServices,
    "InlineResponse2014": InlineResponse2014,
    "InlineResponse2014KeyInformation": InlineResponse2014KeyInformation,
    "InlineResponse2014KeyInformationErrorInformation": InlineResponse2014KeyInformationErrorInformation,
    "InlineResponse2014KeyInformationErrorInformationDetails": InlineResponse2014KeyInformationErrorInformationDetails,
    "InlineResponse2015": InlineResponse2015,
    "InlineResponse2016": InlineResponse2016,
    "InlineResponse2016Payloads": InlineResponse2016Payloads,
    "InlineResponse2016PayloadsTestPayload": InlineResponse2016PayloadsTestPayload,
    "InlineResponse2017": InlineResponse2017,
    "InlineResponse2018": InlineResponse2018,
    "InlineResponse2019": InlineResponse2019,
    "InlineResponse2019Tokens": InlineResponse2019Tokens,
    "InlineResponse201OrderInformation": InlineResponse201OrderInformation,
    "InlineResponse201OrderInformationShipTo": InlineResponse201OrderInformationShipTo,
    "InlineResponse201PaymentInformation": InlineResponse201PaymentInformation,
    "InlineResponse201PaymentInformationEWallet": InlineResponse201PaymentInformationEWallet,
    "InlineResponse201PaymentInformationTokenizedPaymentMethod": InlineResponse201PaymentInformationTokenizedPaymentMethod,
    "InlineResponse202": InlineResponse202,
    "InlineResponse202Links": InlineResponse202Links,
    "InlineResponse202LinksStatus": InlineResponse202LinksStatus,
    "InlineResponse206": InlineResponse206,
    "InlineResponse2061": InlineResponse2061,
    "InlineResponse400": InlineResponse400,
    "InlineResponse4001": InlineResponse4001,
    "InlineResponse4002": InlineResponse4002,
    "InlineResponse4003": InlineResponse4003,
    "InlineResponse4004": InlineResponse4004,
    "InlineResponse4005": InlineResponse4005,
    "InlineResponse4005Fields": InlineResponse4005Fields,
    "InlineResponse4006": InlineResponse4006,
    "InlineResponse4006Details": InlineResponse4006Details,
    "InlineResponse4007": InlineResponse4007,
    "InlineResponse4007Details": InlineResponse4007Details,
    "InlineResponse4008": InlineResponse4008,
    "InlineResponse4008Details": InlineResponse4008Details,
    "InlineResponse400Details": InlineResponse400Details,
    "InlineResponse400Errors": InlineResponse400Errors,
    "InlineResponse401": InlineResponse401,
    "InlineResponse4011": InlineResponse4011,
    "InlineResponse4011Fields": InlineResponse4011Fields,
    "InlineResponse4011Links": InlineResponse4011Links,
    "InlineResponse4011LinksSelf": InlineResponse4011LinksSelf,
    "InlineResponse403": InlineResponse403,
    "InlineResponse4031": InlineResponse4031,
    "InlineResponse4032": InlineResponse4032,
    "InlineResponse403Errors": InlineResponse403Errors,
    "InlineResponse404": InlineResponse404,
    "InlineResponse4041": InlineResponse4041,
    "InlineResponse4042": InlineResponse4042,
    "InlineResponse4042Details": InlineResponse4042Details,
    "InlineResponse4043": InlineResponse4043,
    "InlineResponse409": InlineResponse409,
    "InlineResponse409Errors": InlineResponse409Errors,
    "InlineResponse410": InlineResponse410,
    "InlineResponse410Errors": InlineResponse410Errors,
    "InlineResponse412": InlineResponse412,
    "InlineResponse412Errors": InlineResponse412Errors,
    "InlineResponse422": InlineResponse422,
    "InlineResponse4221": InlineResponse4221,
    "InlineResponse424": InlineResponse424,
    "InlineResponse424Errors": InlineResponse424Errors,
    "InlineResponse500": InlineResponse500,
    "InlineResponse5001": InlineResponse5001,
    "InlineResponse5002": InlineResponse5002,
    "InlineResponse5003": InlineResponse5003,
    "InlineResponse500Errors": InlineResponse500Errors,
    "InlineResponse502": InlineResponse502,
    "InlineResponse503": InlineResponse503,
    "InlineResponseDefault": InlineResponseDefault,
    "InlineResponseDefaultLinks": InlineResponseDefaultLinks,
    "InlineResponseDefaultLinksNext": InlineResponseDefaultLinksNext,
    "InlineResponseDefaultResponseStatus": InlineResponseDefaultResponseStatus,
    "InlineResponseDefaultResponseStatusDetails": InlineResponseDefaultResponseStatusDetails,
    "IntimateBillingAgreement": IntimateBillingAgreement,
    "InvoiceSettingsRequest": InvoiceSettingsRequest,
    "InvoicingV2InvoiceSettingsGet200Response": InvoicingV2InvoiceSettingsGet200Response,
    "InvoicingV2InvoiceSettingsGet200ResponseInvoiceSettingsInformation": InvoicingV2InvoiceSettingsGet200ResponseInvoiceSettingsInformation,
    "InvoicingV2InvoiceSettingsGet200ResponseInvoiceSettingsInformationHeaderStyle": InvoicingV2InvoiceSettingsGet200ResponseInvoiceSettingsInformationHeaderStyle,
    "InvoicingV2InvoicesAllGet200Response": InvoicingV2InvoicesAllGet200Response,
    "InvoicingV2InvoicesAllGet200ResponseCustomerInformation": InvoicingV2InvoicesAllGet200ResponseCustomerInformation,
    "InvoicingV2InvoicesAllGet200ResponseInvoiceInformation": InvoicingV2InvoicesAllGet200ResponseInvoiceInformation,
    "InvoicingV2InvoicesAllGet200ResponseInvoices": InvoicingV2InvoicesAllGet200ResponseInvoices,
    "InvoicingV2InvoicesAllGet200ResponseLinks": InvoicingV2InvoicesAllGet200ResponseLinks,
    "InvoicingV2InvoicesAllGet200ResponseOrderInformation": InvoicingV2InvoicesAllGet200ResponseOrderInformation,
    "InvoicingV2InvoicesAllGet200ResponseOrderInformationAmountDetails": InvoicingV2InvoicesAllGet200ResponseOrderInformationAmountDetails,
    "InvoicingV2InvoicesAllGet400Response": InvoicingV2InvoicesAllGet400Response,
    "InvoicingV2InvoicesAllGet404Response": InvoicingV2InvoicesAllGet404Response,
    "InvoicingV2InvoicesAllGet502Response": InvoicingV2InvoicesAllGet502Response,
    "InvoicingV2InvoicesCancel200Response": InvoicingV2InvoicesCancel200Response,
    "InvoicingV2InvoicesGet200Response": InvoicingV2InvoicesGet200Response,
    "InvoicingV2InvoicesGet200ResponseInvoiceHistory": InvoicingV2InvoicesGet200ResponseInvoiceHistory,
    "InvoicingV2InvoicesGet200ResponseTransactionDetails": InvoicingV2InvoicesGet200ResponseTransactionDetails,
    "InvoicingV2InvoicesPost201Response": InvoicingV2InvoicesPost201Response,
    "InvoicingV2InvoicesPost201ResponseInvoiceInformation": InvoicingV2InvoicesPost201ResponseInvoiceInformation,
    "InvoicingV2InvoicesPost201ResponseInvoiceInformationCustomLabels": InvoicingV2InvoicesPost201ResponseInvoiceInformationCustomLabels,
    "InvoicingV2InvoicesPost201ResponseOrderInformation": InvoicingV2InvoicesPost201ResponseOrderInformation,
    "InvoicingV2InvoicesPost201ResponseOrderInformationAmountDetails": InvoicingV2InvoicesPost201ResponseOrderInformationAmountDetails,
    "InvoicingV2InvoicesPost202Response": InvoicingV2InvoicesPost202Response,
    "InvoicingV2InvoicesPublish200Response": InvoicingV2InvoicesPublish200Response,
    "InvoicingV2InvoicesPut200Response": InvoicingV2InvoicesPut200Response,
    "InvoicingV2InvoicesSend200Response": InvoicingV2InvoicesSend200Response,
    "Invoicingv2invoiceSettingsInvoiceSettingsInformation": Invoicingv2invoiceSettingsInvoiceSettingsInformation,
    "Invoicingv2invoicesClientReferenceInformation": Invoicingv2invoicesClientReferenceInformation,
    "Invoicingv2invoicesClientReferenceInformationPartner": Invoicingv2invoicesClientReferenceInformationPartner,
    "Invoicingv2invoicesCustomerInformation": Invoicingv2invoicesCustomerInformation,
    "Invoicingv2invoicesCustomerInformationCompany": Invoicingv2invoicesCustomerInformationCompany,
    "Invoicingv2invoicesInvoiceInformation": Invoicingv2invoicesInvoiceInformation,
    "Invoicingv2invoicesOrderInformation": Invoicingv2invoicesOrderInformation,
    "Invoicingv2invoicesOrderInformationAmountDetails": Invoicingv2invoicesOrderInformationAmountDetails,
    "Invoicingv2invoicesOrderInformationAmountDetailsFreight": Invoicingv2invoicesOrderInformationAmountDetailsFreight,
    "Invoicingv2invoicesOrderInformationAmountDetailsTaxDetails": Invoicingv2invoicesOrderInformationAmountDetailsTaxDetails,
    "Invoicingv2invoicesOrderInformationLineItems": Invoicingv2invoicesOrderInformationLineItems,
    "Invoicingv2invoicesProcessingInformation": Invoicingv2invoicesProcessingInformation,
    "Invoicingv2invoicesidInvoiceInformation": Invoicingv2invoicesidInvoiceInformation,
    "Iplv2paymentlinksOrderInformation": Iplv2paymentlinksOrderInformation,
    "Iplv2paymentlinksOrderInformationAmountDetails": Iplv2paymentlinksOrderInformationAmountDetails,
    "Iplv2paymentlinksOrderInformationLineItems": Iplv2paymentlinksOrderInformationLineItems,
    "Iplv2paymentlinksProcessingInformation": Iplv2paymentlinksProcessingInformation,
    "Iplv2paymentlinksPurchaseInformation": Iplv2paymentlinksPurchaseInformation,
    "Iplv2paymentlinksidOrderInformation": Iplv2paymentlinksidOrderInformation,
    "Iplv2paymentlinksidProcessingInformation": Iplv2paymentlinksidProcessingInformation,
    "Iplv2paymentlinksidPurchaseInformation": Iplv2paymentlinksidPurchaseInformation,
    "Kmsegressv2keysasymClientReferenceInformation": Kmsegressv2keysasymClientReferenceInformation,
    "Kmsegressv2keysasymKeyInformation": Kmsegressv2keysasymKeyInformation,
    "Kmsegressv2keyssymClientReferenceInformation": Kmsegressv2keyssymClientReferenceInformation,
    "Kmsegressv2keyssymKeyInformation": Kmsegressv2keyssymKeyInformation,
    "MerchantInitiatedTransactionObject": MerchantInitiatedTransactionObject,
    "Microformv2sessionsTransientTokenResponseOptions": Microformv2sessionsTransientTokenResponseOptions,
    "MitReversalRequest": MitReversalRequest,
    "MitVoidRequest": MitVoidRequest,
    "ModifyBillingAgreement": ModifyBillingAgreement,
    "NetworkTokenEnrollment": NetworkTokenEnrollment,
    "NetworkTokenServicesEnablement": NetworkTokenServicesEnablement,
    "NetworkTokenServicesEnablementMastercardDigitalEnablementService": NetworkTokenServicesEnablementMastercardDigitalEnablementService,
    "NetworkTokenServicesEnablementVisaTokenService": NetworkTokenServicesEnablementVisaTokenService,
    "Notificationsubscriptionsv2productsorganizationIdEventTypes": Notificationsubscriptionsv2productsorganizationIdEventTypes,
    "Notificationsubscriptionsv2webhooksProducts": Notificationsubscriptionsv2webhooksProducts,
    "Notificationsubscriptionsv2webhooksProducts1": Notificationsubscriptionsv2webhooksProducts1,
    "Notificationsubscriptionsv2webhooksRetryPolicy": Notificationsubscriptionsv2webhooksRetryPolicy,
    "Notificationsubscriptionsv2webhooksSecurityPolicy": Notificationsubscriptionsv2webhooksSecurityPolicy,
    "Notificationsubscriptionsv2webhooksSecurityPolicyConfig": Notificationsubscriptionsv2webhooksSecurityPolicyConfig,
    "Notificationsubscriptionsv2webhooksSecurityPolicyConfigAdditionalConfig": Notificationsubscriptionsv2webhooksSecurityPolicyConfigAdditionalConfig,
    "OctCreatePaymentRequest": OctCreatePaymentRequest,
    "OrderPaymentRequest": OrderPaymentRequest,
    "PatchCustomerPaymentInstrumentRequest": PatchCustomerPaymentInstrumentRequest,
    "PatchCustomerRequest": PatchCustomerRequest,
    "PatchCustomerShippingAddressRequest": PatchCustomerShippingAddressRequest,
    "PatchInstrumentIdentifierRequest": PatchInstrumentIdentifierRequest,
    "PatchPaymentInstrumentRequest": PatchPaymentInstrumentRequest,
    "PayerAuthConfig": PayerAuthConfig,
    "PayerAuthConfigCardTypes": PayerAuthConfigCardTypes,
    "PayerAuthConfigCardTypesCB": PayerAuthConfigCardTypesCB,
    "PayerAuthConfigCardTypesJCBJSecure": PayerAuthConfigCardTypesJCBJSecure,
    "PayerAuthConfigCardTypesVerifiedByVisa": PayerAuthConfigCardTypesVerifiedByVisa,
    "PayerAuthConfigCardTypesVerifiedByVisaCurrencies": PayerAuthConfigCardTypesVerifiedByVisaCurrencies,
    "PayerAuthSetupRequest": PayerAuthSetupRequest,
    "PaymentInstrumentList": PaymentInstrumentList,
    "PaymentInstrumentList1": PaymentInstrumentList1,
    "PaymentInstrumentList1Embedded": PaymentInstrumentList1Embedded,
    "PaymentInstrumentList1EmbeddedEmbedded": PaymentInstrumentList1EmbeddedEmbedded,
    "PaymentInstrumentList1EmbeddedPaymentInstruments": PaymentInstrumentList1EmbeddedPaymentInstruments,
    "PaymentInstrumentListEmbedded": PaymentInstrumentListEmbedded,
    "PaymentInstrumentListLinks": PaymentInstrumentListLinks,
    "PaymentInstrumentListLinksFirst": PaymentInstrumentListLinksFirst,
    "PaymentInstrumentListLinksLast": PaymentInstrumentListLinksLast,
    "PaymentInstrumentListLinksNext": PaymentInstrumentListLinksNext,
    "PaymentInstrumentListLinksPrev": PaymentInstrumentListLinksPrev,
    "PaymentInstrumentListLinksSelf": PaymentInstrumentListLinksSelf,
    "PaymentsProducts": PaymentsProducts,
    "PaymentsProductsAlternativePaymentMethods": PaymentsProductsAlternativePaymentMethods,
    "PaymentsProductsAlternativePaymentMethodsConfigurationInformation": PaymentsProductsAlternativePaymentMethodsConfigurationInformation,
    "PaymentsProductsAlternativePaymentMethodsConfigurationInformationConfigurations": PaymentsProductsAlternativePaymentMethodsConfigurationInformationConfigurations,
    "PaymentsProductsAlternativePaymentMethodsConfigurationInformationConfigurationsAdditionalConfigurations": PaymentsProductsAlternativePaymentMethodsConfigurationInformationConfigurationsAdditionalConfigurations,
    "PaymentsProductsAlternativePaymentMethodsConfigurationInformationConfigurationsPaymentMethods": PaymentsProductsAlternativePaymentMethodsConfigurationInformationConfigurationsPaymentMethods,
    "PaymentsProductsAlternativePaymentMethodsConfigurationInformationConfigurationsProcessors": PaymentsProductsAlternativePaymentMethodsConfigurationInformationConfigurationsProcessors,
    "PaymentsProductsAlternativePaymentMethodsSubscriptionInformation": PaymentsProductsAlternativePaymentMethodsSubscriptionInformation,
    "PaymentsProductsCardPresentConnect": PaymentsProductsCardPresentConnect,
    "PaymentsProductsCardPresentConnectConfigurationInformation": PaymentsProductsCardPresentConnectConfigurationInformation,
    "PaymentsProductsCardPresentConnectConfigurationInformationConfigurations": PaymentsProductsCardPresentConnectConfigurationInformationConfigurations,
    "PaymentsProductsCardPresentConnectSubscriptionInformation": PaymentsProductsCardPresentConnectSubscriptionInformation,
    "PaymentsProductsCardProcessing": PaymentsProductsCardProcessing,
    "PaymentsProductsCardProcessingConfigurationInformation": PaymentsProductsCardProcessingConfigurationInformation,
    "PaymentsProductsCardProcessingSubscriptionInformation": PaymentsProductsCardProcessingSubscriptionInformation,
    "PaymentsProductsCardProcessingSubscriptionInformationFeatures": PaymentsProductsCardProcessingSubscriptionInformationFeatures,
    "PaymentsProductsCurrencyConversion": PaymentsProductsCurrencyConversion,
    "PaymentsProductsCurrencyConversionConfigurationInformation": PaymentsProductsCurrencyConversionConfigurationInformation,
    "PaymentsProductsCurrencyConversionConfigurationInformationConfigurations": PaymentsProductsCurrencyConversionConfigurationInformationConfigurations,
    "PaymentsProductsCurrencyConversionConfigurationInformationConfigurationsProcessors": PaymentsProductsCurrencyConversionConfigurationInformationConfigurationsProcessors,
    "PaymentsProductsCybsReadyTerminal": PaymentsProductsCybsReadyTerminal,
    "PaymentsProductsDifferentialFee": PaymentsProductsDifferentialFee,
    "PaymentsProductsDifferentialFeeSubscriptionInformation": PaymentsProductsDifferentialFeeSubscriptionInformation,
    "PaymentsProductsDifferentialFeeSubscriptionInformationFeatures": PaymentsProductsDifferentialFeeSubscriptionInformationFeatures,
    "PaymentsProductsDifferentialFeeSubscriptionInformationFeaturesSurcharge": PaymentsProductsDifferentialFeeSubscriptionInformationFeaturesSurcharge,
    "PaymentsProductsDigitalPayments": PaymentsProductsDigitalPayments,
    "PaymentsProductsDigitalPaymentsSubscriptionInformation": PaymentsProductsDigitalPaymentsSubscriptionInformation,
    "PaymentsProductsDigitalPaymentsSubscriptionInformationFeatures": PaymentsProductsDigitalPaymentsSubscriptionInformationFeatures,
    "PaymentsProductsECheck": PaymentsProductsECheck,
    "PaymentsProductsECheckConfigurationInformation": PaymentsProductsECheckConfigurationInformation,
    "PaymentsProductsECheckSubscriptionInformation": PaymentsProductsECheckSubscriptionInformation,
    "PaymentsProductsPayerAuthentication": PaymentsProductsPayerAuthentication,
    "PaymentsProductsPayerAuthenticationConfigurationInformation": PaymentsProductsPayerAuthenticationConfigurationInformation,
    "PaymentsProductsPayouts": PaymentsProductsPayouts,
    "PaymentsProductsPayoutsConfigurationInformation": PaymentsProductsPayoutsConfigurationInformation,
    "PaymentsProductsPayoutsConfigurationInformationConfigurations": PaymentsProductsPayoutsConfigurationInformationConfigurations,
    "PaymentsProductsPayoutsConfigurationInformationConfigurationsProcessorAccount": PaymentsProductsPayoutsConfigurationInformationConfigurationsProcessorAccount,
    "PaymentsProductsPayoutsConfigurationInformationConfigurationsPullfunds": PaymentsProductsPayoutsConfigurationInformationConfigurationsPullfunds,
    "PaymentsProductsPayoutsConfigurationInformationConfigurationsPushfunds": PaymentsProductsPayoutsConfigurationInformationConfigurationsPushfunds,
    "PaymentsProductsSecureAcceptance": PaymentsProductsSecureAcceptance,
    "PaymentsProductsSecureAcceptanceConfigurationInformation": PaymentsProductsSecureAcceptanceConfigurationInformation,
    "PaymentsProductsServiceFee": PaymentsProductsServiceFee,
    "PaymentsProductsServiceFeeConfigurationInformation": PaymentsProductsServiceFeeConfigurationInformation,
    "PaymentsProductsServiceFeeConfigurationInformationConfigurations": PaymentsProductsServiceFeeConfigurationInformationConfigurations,
    "PaymentsProductsServiceFeeConfigurationInformationConfigurationsMerchantInformation": PaymentsProductsServiceFeeConfigurationInformationConfigurationsMerchantInformation,
    "PaymentsProductsServiceFeeConfigurationInformationConfigurationsPaymentInformation": PaymentsProductsServiceFeeConfigurationInformationConfigurationsPaymentInformation,
    "PaymentsProductsServiceFeeConfigurationInformationConfigurationsProducts": PaymentsProductsServiceFeeConfigurationInformationConfigurationsProducts,
    "PaymentsProductsTax": PaymentsProductsTax,
    "PaymentsProductsUnifiedCheckout": PaymentsProductsUnifiedCheckout,
    "PaymentsProductsUnifiedCheckoutConfigurationInformation": PaymentsProductsUnifiedCheckoutConfigurationInformation,
    "PaymentsProductsUnifiedCheckoutConfigurationInformationConfigurations": PaymentsProductsUnifiedCheckoutConfigurationInformationConfigurations,
    "PaymentsProductsUnifiedCheckoutConfigurationInformationConfigurationsFeatures": PaymentsProductsUnifiedCheckoutConfigurationInformationConfigurationsFeatures,
    "PaymentsProductsUnifiedCheckoutConfigurationInformationConfigurationsFeaturesPaze": PaymentsProductsUnifiedCheckoutConfigurationInformationConfigurationsFeaturesPaze,
    "PaymentsProductsUnifiedCheckoutSubscriptionInformation": PaymentsProductsUnifiedCheckoutSubscriptionInformation,
    "PaymentsProductsUnifiedCheckoutSubscriptionInformationFeatures": PaymentsProductsUnifiedCheckoutSubscriptionInformationFeatures,
    "PaymentsProductsUnifiedCheckoutSubscriptionInformationFeaturesPazeForUnifiedCheckout": PaymentsProductsUnifiedCheckoutSubscriptionInformationFeaturesPazeForUnifiedCheckout,
    "PaymentsProductsVirtualTerminal": PaymentsProductsVirtualTerminal,
    "PaymentsProductsVirtualTerminalConfigurationInformation": PaymentsProductsVirtualTerminalConfigurationInformation,
    "PaymentsStrongAuthIssuerInformation": PaymentsStrongAuthIssuerInformation,
    "PblPaymentLinksAllGet200Response": PblPaymentLinksAllGet200Response,
    "PblPaymentLinksAllGet200ResponseLinks": PblPaymentLinksAllGet200ResponseLinks,
    "PblPaymentLinksAllGet200ResponseOrderInformation": PblPaymentLinksAllGet200ResponseOrderInformation,
    "PblPaymentLinksAllGet200ResponseOrderInformationAmountDetails": PblPaymentLinksAllGet200ResponseOrderInformationAmountDetails,
    "PblPaymentLinksAllGet200ResponseOrderInformationLineItems": PblPaymentLinksAllGet200ResponseOrderInformationLineItems,
    "PblPaymentLinksAllGet200ResponseProcessingInformation": PblPaymentLinksAllGet200ResponseProcessingInformation,
    "PblPaymentLinksAllGet200ResponsePurchaseInformation": PblPaymentLinksAllGet200ResponsePurchaseInformation,
    "PblPaymentLinksAllGet400Response": PblPaymentLinksAllGet400Response,
    "PblPaymentLinksAllGet404Response": PblPaymentLinksAllGet404Response,
    "PblPaymentLinksGet200Response": PblPaymentLinksGet200Response,
    "PblPaymentLinksPost201Response": PblPaymentLinksPost201Response,
    "PblPaymentLinksPost201ResponseLinks": PblPaymentLinksPost201ResponseLinks,
    "PblPaymentLinksPost201ResponseOrderInformation": PblPaymentLinksPost201ResponseOrderInformation,
    "PblPaymentLinksPost201ResponsePurchaseInformation": PblPaymentLinksPost201ResponsePurchaseInformation,
    "PostCustomerPaymentInstrumentRequest": PostCustomerPaymentInstrumentRequest,
    "PostCustomerRequest": PostCustomerRequest,
    "PostCustomerShippingAddressRequest": PostCustomerShippingAddressRequest,
    "PostDeviceSearchRequestV3": PostDeviceSearchRequestV3,
    "PostInstrumentIdentifierEnrollmentRequest": PostInstrumentIdentifierEnrollmentRequest,
    "PostInstrumentIdentifierRequest": PostInstrumentIdentifierRequest,
    "PostPaymentCredentialsRequest": PostPaymentCredentialsRequest,
    "PostPaymentInstrumentRequest": PostPaymentInstrumentRequest,
    "PostRegistrationBody": PostRegistrationBody,
    "PredefinedSubscriptionRequestBean": PredefinedSubscriptionRequestBean,
    "PtsV1TransactionBatchesGet200Response": PtsV1TransactionBatchesGet200Response,
    "PtsV1TransactionBatchesGet200ResponseLinks": PtsV1TransactionBatchesGet200ResponseLinks,
    "PtsV1TransactionBatchesGet200ResponseLinksSelf": PtsV1TransactionBatchesGet200ResponseLinksSelf,
    "PtsV1TransactionBatchesGet200ResponseTransactionBatches": PtsV1TransactionBatchesGet200ResponseTransactionBatches,
    "PtsV1TransactionBatchesGet400Response": PtsV1TransactionBatchesGet400Response,
    "PtsV1TransactionBatchesGet400ResponseErrorInformation": PtsV1TransactionBatchesGet400ResponseErrorInformation,
    "PtsV1TransactionBatchesGet400ResponseErrorInformationDetails": PtsV1TransactionBatchesGet400ResponseErrorInformationDetails,
    "PtsV1TransactionBatchesGet500Response": PtsV1TransactionBatchesGet500Response,
    "PtsV1TransactionBatchesGet500ResponseErrorInformation": PtsV1TransactionBatchesGet500ResponseErrorInformation,
    "PtsV1TransactionBatchesIdGet200Response": PtsV1TransactionBatchesIdGet200Response,
    "PtsV1TransactionBatchesIdGet200ResponseLinks": PtsV1TransactionBatchesIdGet200ResponseLinks,
    "PtsV1TransactionBatchesIdGet200ResponseLinksTransactions": PtsV1TransactionBatchesIdGet200ResponseLinksTransactions,
    "PtsV2CreateBillingAgreementPost201Response": PtsV2CreateBillingAgreementPost201Response,
    "PtsV2CreateBillingAgreementPost201ResponseAgreementInformation": PtsV2CreateBillingAgreementPost201ResponseAgreementInformation,
    "PtsV2CreateBillingAgreementPost201ResponseClientReferenceInformation": PtsV2CreateBillingAgreementPost201ResponseClientReferenceInformation,
    "PtsV2CreateBillingAgreementPost201ResponseInstallmentInformation": PtsV2CreateBillingAgreementPost201ResponseInstallmentInformation,
    "PtsV2CreateBillingAgreementPost201ResponseLinks": PtsV2CreateBillingAgreementPost201ResponseLinks,
    "PtsV2CreateBillingAgreementPost201ResponseProcessorInformation": PtsV2CreateBillingAgreementPost201ResponseProcessorInformation,
    "PtsV2CreateBillingAgreementPost201ResponseRiskInformation": PtsV2CreateBillingAgreementPost201ResponseRiskInformation,
    "PtsV2CreateBillingAgreementPost201ResponseRiskInformationProcessorResults": PtsV2CreateBillingAgreementPost201ResponseRiskInformationProcessorResults,
    "PtsV2CreateBillingAgreementPost400Response": PtsV2CreateBillingAgreementPost400Response,
    "PtsV2CreateBillingAgreementPost502Response": PtsV2CreateBillingAgreementPost502Response,
    "PtsV2CreateOrderPost201Response": PtsV2CreateOrderPost201Response,
    "PtsV2CreateOrderPost201ResponseBuyerInformation": PtsV2CreateOrderPost201ResponseBuyerInformation,
    "PtsV2CreateOrderPost201ResponseProcessorInformation": PtsV2CreateOrderPost201ResponseProcessorInformation,
    "PtsV2CreateOrderPost400Response": PtsV2CreateOrderPost400Response,
    "PtsV2CreditsPost201Response": PtsV2CreditsPost201Response,
    "PtsV2CreditsPost201Response1": PtsV2CreditsPost201Response1,
    "PtsV2CreditsPost201Response1ProcessorInformation": PtsV2CreditsPost201Response1ProcessorInformation,
    "PtsV2CreditsPost201ResponseCreditAmountDetails": PtsV2CreditsPost201ResponseCreditAmountDetails,
    "PtsV2CreditsPost201ResponsePaymentInformation": PtsV2CreditsPost201ResponsePaymentInformation,
    "PtsV2CreditsPost201ResponseProcessingInformation": PtsV2CreditsPost201ResponseProcessingInformation,
    "PtsV2CreditsPost201ResponseProcessingInformationBankTransferOptions": PtsV2CreditsPost201ResponseProcessingInformationBankTransferOptions,
    "PtsV2IncrementalAuthorizationPatch201Response": PtsV2IncrementalAuthorizationPatch201Response,
    "PtsV2IncrementalAuthorizationPatch201ResponseClientReferenceInformation": PtsV2IncrementalAuthorizationPatch201ResponseClientReferenceInformation,
    "PtsV2IncrementalAuthorizationPatch201ResponseErrorInformation": PtsV2IncrementalAuthorizationPatch201ResponseErrorInformation,
    "PtsV2IncrementalAuthorizationPatch201ResponseLinks": PtsV2IncrementalAuthorizationPatch201ResponseLinks,
    "PtsV2IncrementalAuthorizationPatch201ResponseOrderInformation": PtsV2IncrementalAuthorizationPatch201ResponseOrderInformation,
    "PtsV2IncrementalAuthorizationPatch201ResponseOrderInformationInvoiceDetails": PtsV2IncrementalAuthorizationPatch201ResponseOrderInformationInvoiceDetails,
    "PtsV2IncrementalAuthorizationPatch201ResponsePaymentInformation": PtsV2IncrementalAuthorizationPatch201ResponsePaymentInformation,
    "PtsV2IncrementalAuthorizationPatch201ResponsePaymentInformationAccountFeatures": PtsV2IncrementalAuthorizationPatch201ResponsePaymentInformationAccountFeatures,
    "PtsV2IncrementalAuthorizationPatch201ResponseProcessorInformation": PtsV2IncrementalAuthorizationPatch201ResponseProcessorInformation,
    "PtsV2IncrementalAuthorizationPatch400Response": PtsV2IncrementalAuthorizationPatch400Response,
    "PtsV2ModifyBillingAgreementPost201Response": PtsV2ModifyBillingAgreementPost201Response,
    "PtsV2ModifyBillingAgreementPost201ResponseAgreementInformation": PtsV2ModifyBillingAgreementPost201ResponseAgreementInformation,
    "PtsV2ModifyBillingAgreementPost201ResponseLinks": PtsV2ModifyBillingAgreementPost201ResponseLinks,
    "PtsV2ModifyBillingAgreementPost201ResponseOrderInformation": PtsV2ModifyBillingAgreementPost201ResponseOrderInformation,
    "PtsV2ModifyBillingAgreementPost201ResponseOrderInformationBillTo": PtsV2ModifyBillingAgreementPost201ResponseOrderInformationBillTo,
    "PtsV2ModifyBillingAgreementPost201ResponseOrderInformationShipTo": PtsV2ModifyBillingAgreementPost201ResponseOrderInformationShipTo,
    "PtsV2ModifyBillingAgreementPost201ResponsePaymentInformation": PtsV2ModifyBillingAgreementPost201ResponsePaymentInformation,
    "PtsV2ModifyBillingAgreementPost201ResponsePaymentInformationBank": PtsV2ModifyBillingAgreementPost201ResponsePaymentInformationBank,
    "PtsV2ModifyBillingAgreementPost201ResponsePaymentInformationEWallet": PtsV2ModifyBillingAgreementPost201ResponsePaymentInformationEWallet,
    "PtsV2PaymentsCapturesPost201Response": PtsV2PaymentsCapturesPost201Response,
    "PtsV2PaymentsCapturesPost201ResponseEmbeddedActions": PtsV2PaymentsCapturesPost201ResponseEmbeddedActions,
    "PtsV2PaymentsCapturesPost201ResponseEmbeddedActionsApCapture": PtsV2PaymentsCapturesPost201ResponseEmbeddedActionsApCapture,
    "PtsV2PaymentsCapturesPost201ResponseLinks": PtsV2PaymentsCapturesPost201ResponseLinks,
    "PtsV2PaymentsCapturesPost201ResponseOrderInformation": PtsV2PaymentsCapturesPost201ResponseOrderInformation,
    "PtsV2PaymentsCapturesPost201ResponseOrderInformationAmountDetails": PtsV2PaymentsCapturesPost201ResponseOrderInformationAmountDetails,
    "PtsV2PaymentsCapturesPost201ResponseOrderInformationInvoiceDetails": PtsV2PaymentsCapturesPost201ResponseOrderInformationInvoiceDetails,
    "PtsV2PaymentsCapturesPost201ResponsePointOfSaleInformation": PtsV2PaymentsCapturesPost201ResponsePointOfSaleInformation,
    "PtsV2PaymentsCapturesPost201ResponseProcessingInformation": PtsV2PaymentsCapturesPost201ResponseProcessingInformation,
    "PtsV2PaymentsCapturesPost201ResponseProcessorInformation": PtsV2PaymentsCapturesPost201ResponseProcessorInformation,
    "PtsV2PaymentsCapturesPost400Response": PtsV2PaymentsCapturesPost400Response,
    "PtsV2PaymentsOrderPost201Response": PtsV2PaymentsOrderPost201Response,
    "PtsV2PaymentsOrderPost201ResponseBuyerInformation": PtsV2PaymentsOrderPost201ResponseBuyerInformation,
    "PtsV2PaymentsOrderPost201ResponseBuyerInformationPersonalIdentification": PtsV2PaymentsOrderPost201ResponseBuyerInformationPersonalIdentification,
    "PtsV2PaymentsOrderPost201ResponseOrderInformation": PtsV2PaymentsOrderPost201ResponseOrderInformation,
    "PtsV2PaymentsOrderPost201ResponseOrderInformationAmountDetails": PtsV2PaymentsOrderPost201ResponseOrderInformationAmountDetails,
    "PtsV2PaymentsOrderPost201ResponseOrderInformationBillTo": PtsV2PaymentsOrderPost201ResponseOrderInformationBillTo,
    "PtsV2PaymentsOrderPost201ResponseOrderInformationShipTo": PtsV2PaymentsOrderPost201ResponseOrderInformationShipTo,
    "PtsV2PaymentsOrderPost201ResponseOrderInformationShippingDetails": PtsV2PaymentsOrderPost201ResponseOrderInformationShippingDetails,
    "PtsV2PaymentsOrderPost201ResponsePaymentInformation": PtsV2PaymentsOrderPost201ResponsePaymentInformation,
    "PtsV2PaymentsOrderPost201ResponsePaymentInformationEWallet": PtsV2PaymentsOrderPost201ResponsePaymentInformationEWallet,
    "PtsV2PaymentsOrderPost201ResponseProcessingInformation": PtsV2PaymentsOrderPost201ResponseProcessingInformation,
    "PtsV2PaymentsOrderPost201ResponseProcessorInformation": PtsV2PaymentsOrderPost201ResponseProcessorInformation,
    "PtsV2PaymentsOrderPost201ResponseProcessorInformationSellerProtection": PtsV2PaymentsOrderPost201ResponseProcessorInformationSellerProtection,
    "PtsV2PaymentsPost201Response": PtsV2PaymentsPost201Response,
    "PtsV2PaymentsPost201Response1": PtsV2PaymentsPost201Response1,
    "PtsV2PaymentsPost201Response1ErrorInformation": PtsV2PaymentsPost201Response1ErrorInformation,
    "PtsV2PaymentsPost201Response1ErrorInformationDetails": PtsV2PaymentsPost201Response1ErrorInformationDetails,
    "PtsV2PaymentsPost201Response1IssuerInformation": PtsV2PaymentsPost201Response1IssuerInformation,
    "PtsV2PaymentsPost201Response1OrderInformation": PtsV2PaymentsPost201Response1OrderInformation,
    "PtsV2PaymentsPost201Response1OrderInformationAmountDetails": PtsV2PaymentsPost201Response1OrderInformationAmountDetails,
    "PtsV2PaymentsPost201Response1OrderInformationBillTo": PtsV2PaymentsPost201Response1OrderInformationBillTo,
    "PtsV2PaymentsPost201Response1OrderInformationShipTo": PtsV2PaymentsPost201Response1OrderInformationShipTo,
    "PtsV2PaymentsPost201Response1PaymentInformation": PtsV2PaymentsPost201Response1PaymentInformation,
    "PtsV2PaymentsPost201Response1PaymentInformationBank": PtsV2PaymentsPost201Response1PaymentInformationBank,
    "PtsV2PaymentsPost201Response1PaymentInformationBankAccount": PtsV2PaymentsPost201Response1PaymentInformationBankAccount,
    "PtsV2PaymentsPost201Response1PaymentInformationEWallet": PtsV2PaymentsPost201Response1PaymentInformationEWallet,
    "PtsV2PaymentsPost201Response1PaymentInformationPaymentType": PtsV2PaymentsPost201Response1PaymentInformationPaymentType,
    "PtsV2PaymentsPost201Response1PaymentInformationPaymentTypeMethod": PtsV2PaymentsPost201Response1PaymentInformationPaymentTypeMethod,
    "PtsV2PaymentsPost201Response1ProcessorInformation": PtsV2PaymentsPost201Response1ProcessorInformation,
    "PtsV2PaymentsPost201Response1ProcessorInformationAvs": PtsV2PaymentsPost201Response1ProcessorInformationAvs,
    "PtsV2PaymentsPost201Response2": PtsV2PaymentsPost201Response2,
    "PtsV2PaymentsPost201Response2OrderInformation": PtsV2PaymentsPost201Response2OrderInformation,
    "PtsV2PaymentsPost201Response2OrderInformationAmountDetails": PtsV2PaymentsPost201Response2OrderInformationAmountDetails,
    "PtsV2PaymentsPost201Response2PaymentInformation": PtsV2PaymentsPost201Response2PaymentInformation,
    "PtsV2PaymentsPost201Response2PaymentInformationEWallet": PtsV2PaymentsPost201Response2PaymentInformationEWallet,
    "PtsV2PaymentsPost201Response2ProcessorInformation": PtsV2PaymentsPost201Response2ProcessorInformation,
    "PtsV2PaymentsPost201ResponseBuyerInformation": PtsV2PaymentsPost201ResponseBuyerInformation,
    "PtsV2PaymentsPost201ResponseClientReferenceInformation": PtsV2PaymentsPost201ResponseClientReferenceInformation,
    "PtsV2PaymentsPost201ResponseConsumerAuthenticationInformation": PtsV2PaymentsPost201ResponseConsumerAuthenticationInformation,
    "PtsV2PaymentsPost201ResponseConsumerAuthenticationInformationIvr": PtsV2PaymentsPost201ResponseConsumerAuthenticationInformationIvr,
    "PtsV2PaymentsPost201ResponseConsumerAuthenticationInformationStrongAuthentication": PtsV2PaymentsPost201ResponseConsumerAuthenticationInformationStrongAuthentication,
    "PtsV2PaymentsPost201ResponseEmbeddedActions": PtsV2PaymentsPost201ResponseEmbeddedActions,
    "PtsV2PaymentsPost201ResponseEmbeddedActionsCAPTURE": PtsV2PaymentsPost201ResponseEmbeddedActionsCAPTURE,
    "PtsV2PaymentsPost201ResponseEmbeddedActionsCONSUMERAUTHENTICATION": PtsV2PaymentsPost201ResponseEmbeddedActionsCONSUMERAUTHENTICATION,
    "PtsV2PaymentsPost201ResponseEmbeddedActionsDECISION": PtsV2PaymentsPost201ResponseEmbeddedActionsDECISION,
    "PtsV2PaymentsPost201ResponseEmbeddedActionsTOKENCREATE": PtsV2PaymentsPost201ResponseEmbeddedActionsTOKENCREATE,
    "PtsV2PaymentsPost201ResponseEmbeddedActionsTOKENUPDATE": PtsV2PaymentsPost201ResponseEmbeddedActionsTOKENUPDATE,
    "PtsV2PaymentsPost201ResponseEmbeddedActionsWATCHLISTSCREENING": PtsV2PaymentsPost201ResponseEmbeddedActionsWATCHLISTSCREENING,
    "PtsV2PaymentsPost201ResponseErrorInformation": PtsV2PaymentsPost201ResponseErrorInformation,
    "PtsV2PaymentsPost201ResponseErrorInformationDetails": PtsV2PaymentsPost201ResponseErrorInformationDetails,
    "PtsV2PaymentsPost201ResponseInstallmentInformation": PtsV2PaymentsPost201ResponseInstallmentInformation,
    "PtsV2PaymentsPost201ResponseIssuerInformation": PtsV2PaymentsPost201ResponseIssuerInformation,
    "PtsV2PaymentsPost201ResponseLinks": PtsV2PaymentsPost201ResponseLinks,
    "PtsV2PaymentsPost201ResponseLinksSelf": PtsV2PaymentsPost201ResponseLinksSelf,
    "PtsV2PaymentsPost201ResponseMerchantInformation": PtsV2PaymentsPost201ResponseMerchantInformation,
    "PtsV2PaymentsPost201ResponseMerchantInformationMerchantDescriptor": PtsV2PaymentsPost201ResponseMerchantInformationMerchantDescriptor,
    "PtsV2PaymentsPost201ResponseOrderInformation": PtsV2PaymentsPost201ResponseOrderInformation,
    "PtsV2PaymentsPost201ResponseOrderInformationAmountDetails": PtsV2PaymentsPost201ResponseOrderInformationAmountDetails,
    "PtsV2PaymentsPost201ResponseOrderInformationBillTo": PtsV2PaymentsPost201ResponseOrderInformationBillTo,
    "PtsV2PaymentsPost201ResponseOrderInformationInvoiceDetails": PtsV2PaymentsPost201ResponseOrderInformationInvoiceDetails,
    "PtsV2PaymentsPost201ResponseOrderInformationRewardPointsDetails": PtsV2PaymentsPost201ResponseOrderInformationRewardPointsDetails,
    "PtsV2PaymentsPost201ResponseOrderInformationShipTo": PtsV2PaymentsPost201ResponseOrderInformationShipTo,
    "PtsV2PaymentsPost201ResponsePaymentAccountInformation": PtsV2PaymentsPost201ResponsePaymentAccountInformation,
    "PtsV2PaymentsPost201ResponsePaymentAccountInformationCard": PtsV2PaymentsPost201ResponsePaymentAccountInformationCard,
    "PtsV2PaymentsPost201ResponsePaymentInformation": PtsV2PaymentsPost201ResponsePaymentInformation,
    "PtsV2PaymentsPost201ResponsePaymentInformationAccountFeatures": PtsV2PaymentsPost201ResponsePaymentInformationAccountFeatures,
    "PtsV2PaymentsPost201ResponsePaymentInformationAccountFeaturesBalances": PtsV2PaymentsPost201ResponsePaymentInformationAccountFeaturesBalances,
    "PtsV2PaymentsPost201ResponsePaymentInformationBank": PtsV2PaymentsPost201ResponsePaymentInformationBank,
    "PtsV2PaymentsPost201ResponsePaymentInformationBankAccount": PtsV2PaymentsPost201ResponsePaymentInformationBankAccount,
    "PtsV2PaymentsPost201ResponsePaymentInformationEWallet": PtsV2PaymentsPost201ResponsePaymentInformationEWallet,
    "PtsV2PaymentsPost201ResponsePaymentInformationInstrumentIdentifier": PtsV2PaymentsPost201ResponsePaymentInformationInstrumentIdentifier,
    "PtsV2PaymentsPost201ResponsePaymentInformationTokenizedCard": PtsV2PaymentsPost201ResponsePaymentInformationTokenizedCard,
    "PtsV2PaymentsPost201ResponsePaymentInformationTokenizedPaymentMethod": PtsV2PaymentsPost201ResponsePaymentInformationTokenizedPaymentMethod,
    "PtsV2PaymentsPost201ResponsePaymentInsightsInformation": PtsV2PaymentsPost201ResponsePaymentInsightsInformation,
    "PtsV2PaymentsPost201ResponsePaymentInsightsInformationOrchestration": PtsV2PaymentsPost201ResponsePaymentInsightsInformationOrchestration,
    "PtsV2PaymentsPost201ResponsePaymentInsightsInformationResponseInsights": PtsV2PaymentsPost201ResponsePaymentInsightsInformationResponseInsights,
    "PtsV2PaymentsPost201ResponsePointOfSaleInformation": PtsV2PaymentsPost201ResponsePointOfSaleInformation,
    "PtsV2PaymentsPost201ResponsePointOfSaleInformationEmv": PtsV2PaymentsPost201ResponsePointOfSaleInformationEmv,
    "PtsV2PaymentsPost201ResponseProcessingInformation": PtsV2PaymentsPost201ResponseProcessingInformation,
    "PtsV2PaymentsPost201ResponseProcessingInformationAuthorizationOptions": PtsV2PaymentsPost201ResponseProcessingInformationAuthorizationOptions,
    "PtsV2PaymentsPost201ResponseProcessingInformationBankTransferOptions": PtsV2PaymentsPost201ResponseProcessingInformationBankTransferOptions,
    "PtsV2PaymentsPost201ResponseProcessingInformationCaptureOptions": PtsV2PaymentsPost201ResponseProcessingInformationCaptureOptions,
    "PtsV2PaymentsPost201ResponseProcessingInformationPurchaseOptions": PtsV2PaymentsPost201ResponseProcessingInformationPurchaseOptions,
    "PtsV2PaymentsPost201ResponseProcessorInformation": PtsV2PaymentsPost201ResponseProcessorInformation,
    "PtsV2PaymentsPost201ResponseProcessorInformationAchVerification": PtsV2PaymentsPost201ResponseProcessorInformationAchVerification,
    "PtsV2PaymentsPost201ResponseProcessorInformationAvs": PtsV2PaymentsPost201ResponseProcessorInformationAvs,
    "PtsV2PaymentsPost201ResponseProcessorInformationCardVerification": PtsV2PaymentsPost201ResponseProcessorInformationCardVerification,
    "PtsV2PaymentsPost201ResponseProcessorInformationConsumerAuthenticationResponse": PtsV2PaymentsPost201ResponseProcessorInformationConsumerAuthenticationResponse,
    "PtsV2PaymentsPost201ResponseProcessorInformationCustomer": PtsV2PaymentsPost201ResponseProcessorInformationCustomer,
    "PtsV2PaymentsPost201ResponseProcessorInformationElectronicVerificationResults": PtsV2PaymentsPost201ResponseProcessorInformationElectronicVerificationResults,
    "PtsV2PaymentsPost201ResponseProcessorInformationMerchantAdvice": PtsV2PaymentsPost201ResponseProcessorInformationMerchantAdvice,
    "PtsV2PaymentsPost201ResponseProcessorInformationRouting": PtsV2PaymentsPost201ResponseProcessorInformationRouting,
    "PtsV2PaymentsPost201ResponseProcessorInformationSellerProtection": PtsV2PaymentsPost201ResponseProcessorInformationSellerProtection,
    "PtsV2PaymentsPost201ResponseRiskInformation": PtsV2PaymentsPost201ResponseRiskInformation,
    "PtsV2PaymentsPost201ResponseRiskInformationInfoCodes": PtsV2PaymentsPost201ResponseRiskInformationInfoCodes,
    "PtsV2PaymentsPost201ResponseRiskInformationIpAddress": PtsV2PaymentsPost201ResponseRiskInformationIpAddress,
    "PtsV2PaymentsPost201ResponseRiskInformationProcessorResults": PtsV2PaymentsPost201ResponseRiskInformationProcessorResults,
    "PtsV2PaymentsPost201ResponseRiskInformationProfile": PtsV2PaymentsPost201ResponseRiskInformationProfile,
    "PtsV2PaymentsPost201ResponseRiskInformationRules": PtsV2PaymentsPost201ResponseRiskInformationRules,
    "PtsV2PaymentsPost201ResponseRiskInformationScore": PtsV2PaymentsPost201ResponseRiskInformationScore,
    "PtsV2PaymentsPost201ResponseRiskInformationTravel": PtsV2PaymentsPost201ResponseRiskInformationTravel,
    "PtsV2PaymentsPost201ResponseRiskInformationTravelActualFinalDestination": PtsV2PaymentsPost201ResponseRiskInformationTravelActualFinalDestination,
    "PtsV2PaymentsPost201ResponseRiskInformationTravelFirstDeparture": PtsV2PaymentsPost201ResponseRiskInformationTravelFirstDeparture,
    "PtsV2PaymentsPost201ResponseRiskInformationTravelFirstDestination": PtsV2PaymentsPost201ResponseRiskInformationTravelFirstDestination,
    "PtsV2PaymentsPost201ResponseRiskInformationTravelLastDestination": PtsV2PaymentsPost201ResponseRiskInformationTravelLastDestination,
    "PtsV2PaymentsPost201ResponseRiskInformationVelocity": PtsV2PaymentsPost201ResponseRiskInformationVelocity,
    "PtsV2PaymentsPost201ResponseRiskInformationVelocityMorphing": PtsV2PaymentsPost201ResponseRiskInformationVelocityMorphing,
    "PtsV2PaymentsPost201ResponseTokenInformation": PtsV2PaymentsPost201ResponseTokenInformation,
    "PtsV2PaymentsPost201ResponseTokenInformationCustomer": PtsV2PaymentsPost201ResponseTokenInformationCustomer,
    "PtsV2PaymentsPost201ResponseTokenInformationInstrumentIdentifier": PtsV2PaymentsPost201ResponseTokenInformationInstrumentIdentifier,
    "PtsV2PaymentsPost201ResponseTokenInformationPaymentInstrument": PtsV2PaymentsPost201ResponseTokenInformationPaymentInstrument,
    "PtsV2PaymentsPost201ResponseTokenInformationShippingAddress": PtsV2PaymentsPost201ResponseTokenInformationShippingAddress,
    "PtsV2PaymentsPost201ResponseWatchlistScreeningInformation": PtsV2PaymentsPost201ResponseWatchlistScreeningInformation,
    "PtsV2PaymentsPost201ResponseWatchlistScreeningInformationWatchList": PtsV2PaymentsPost201ResponseWatchlistScreeningInformationWatchList,
    "PtsV2PaymentsPost201ResponseWatchlistScreeningInformationWatchListMatches": PtsV2PaymentsPost201ResponseWatchlistScreeningInformationWatchListMatches,
    "PtsV2PaymentsPost400Response": PtsV2PaymentsPost400Response,
    "PtsV2PaymentsPost502Response": PtsV2PaymentsPost502Response,
    "PtsV2PaymentsRefundPost201Response": PtsV2PaymentsRefundPost201Response,
    "PtsV2PaymentsRefundPost201ResponseClientReferenceInformation": PtsV2PaymentsRefundPost201ResponseClientReferenceInformation,
    "PtsV2PaymentsRefundPost201ResponseLinks": PtsV2PaymentsRefundPost201ResponseLinks,
    "PtsV2PaymentsRefundPost201ResponseOrderInformation": PtsV2PaymentsRefundPost201ResponseOrderInformation,
    "PtsV2PaymentsRefundPost201ResponseOrderInformationAmountDetails": PtsV2PaymentsRefundPost201ResponseOrderInformationAmountDetails,
    "PtsV2PaymentsRefundPost201ResponseProcessorInformation": PtsV2PaymentsRefundPost201ResponseProcessorInformation,
    "PtsV2PaymentsRefundPost201ResponseRefundAmountDetails": PtsV2PaymentsRefundPost201ResponseRefundAmountDetails,
    "PtsV2PaymentsRefundPost400Response": PtsV2PaymentsRefundPost400Response,
    "PtsV2PaymentsReversalsPost201Response": PtsV2PaymentsReversalsPost201Response,
    "PtsV2PaymentsReversalsPost201ResponseAuthorizationInformation": PtsV2PaymentsReversalsPost201ResponseAuthorizationInformation,
    "PtsV2PaymentsReversalsPost201ResponseIssuerInformation": PtsV2PaymentsReversalsPost201ResponseIssuerInformation,
    "PtsV2PaymentsReversalsPost201ResponseProcessorInformation": PtsV2PaymentsReversalsPost201ResponseProcessorInformation,
    "PtsV2PaymentsReversalsPost201ResponseReversalAmountDetails": PtsV2PaymentsReversalsPost201ResponseReversalAmountDetails,
    "PtsV2PaymentsReversalsPost400Response": PtsV2PaymentsReversalsPost400Response,
    "PtsV2PaymentsVoidsPost201Response": PtsV2PaymentsVoidsPost201Response,
    "PtsV2PaymentsVoidsPost201ResponseProcessorInformation": PtsV2PaymentsVoidsPost201ResponseProcessorInformation,
    "PtsV2PaymentsVoidsPost201ResponseVoidAmountDetails": PtsV2PaymentsVoidsPost201ResponseVoidAmountDetails,
    "PtsV2PaymentsVoidsPost400Response": PtsV2PaymentsVoidsPost400Response,
    "PtsV2PayoutsPost201Response": PtsV2PayoutsPost201Response,
    "PtsV2PayoutsPost201ResponseErrorInformation": PtsV2PayoutsPost201ResponseErrorInformation,
    "PtsV2PayoutsPost201ResponseIssuerInformation": PtsV2PayoutsPost201ResponseIssuerInformation,
    "PtsV2PayoutsPost201ResponseMerchantInformation": PtsV2PayoutsPost201ResponseMerchantInformation,
    "PtsV2PayoutsPost201ResponseMerchantInformationMerchantDescriptor": PtsV2PayoutsPost201ResponseMerchantInformationMerchantDescriptor,
    "PtsV2PayoutsPost201ResponseOrderInformation": PtsV2PayoutsPost201ResponseOrderInformation,
    "PtsV2PayoutsPost201ResponseOrderInformationAmountDetails": PtsV2PayoutsPost201ResponseOrderInformationAmountDetails,
    "PtsV2PayoutsPost201ResponseProcessingInformation": PtsV2PayoutsPost201ResponseProcessingInformation,
    "PtsV2PayoutsPost201ResponseProcessorInformation": PtsV2PayoutsPost201ResponseProcessorInformation,
    "PtsV2PayoutsPost201ResponseRecipientInformation": PtsV2PayoutsPost201ResponseRecipientInformation,
    "PtsV2PayoutsPost201ResponseRecipientInformationCard": PtsV2PayoutsPost201ResponseRecipientInformationCard,
    "PtsV2PayoutsPost400Response": PtsV2PayoutsPost400Response,
    "PtsV2RetrievePaymentTokenGet400Response": PtsV2RetrievePaymentTokenGet400Response,
    "PtsV2RetrievePaymentTokenGet502Response": PtsV2RetrievePaymentTokenGet502Response,
    "PtsV2UpdateOrderPatch201Response": PtsV2UpdateOrderPatch201Response,
    "Ptsv2billingagreementsAggregatorInformation": Ptsv2billingagreementsAggregatorInformation,
    "Ptsv2billingagreementsAgreementInformation": Ptsv2billingagreementsAgreementInformation,
    "Ptsv2billingagreementsBuyerInformation": Ptsv2billingagreementsBuyerInformation,
    "Ptsv2billingagreementsClientReferenceInformation": Ptsv2billingagreementsClientReferenceInformation,
    "Ptsv2billingagreementsConsumerAuthenticationInformation": Ptsv2billingagreementsConsumerAuthenticationInformation,
    "Ptsv2billingagreementsDeviceInformation": Ptsv2billingagreementsDeviceInformation,
    "Ptsv2billingagreementsInstallmentInformation": Ptsv2billingagreementsInstallmentInformation,
    "Ptsv2billingagreementsMerchantInformation": Ptsv2billingagreementsMerchantInformation,
    "Ptsv2billingagreementsMerchantInformationMerchantDescriptor": Ptsv2billingagreementsMerchantInformationMerchantDescriptor,
    "Ptsv2billingagreementsOrderInformation": Ptsv2billingagreementsOrderInformation,
    "Ptsv2billingagreementsOrderInformationBillTo": Ptsv2billingagreementsOrderInformationBillTo,
    "Ptsv2billingagreementsPaymentInformation": Ptsv2billingagreementsPaymentInformation,
    "Ptsv2billingagreementsPaymentInformationBank": Ptsv2billingagreementsPaymentInformationBank,
    "Ptsv2billingagreementsPaymentInformationBankAccount": Ptsv2billingagreementsPaymentInformationBankAccount,
    "Ptsv2billingagreementsPaymentInformationCard": Ptsv2billingagreementsPaymentInformationCard,
    "Ptsv2billingagreementsPaymentInformationPaymentType": Ptsv2billingagreementsPaymentInformationPaymentType,
    "Ptsv2billingagreementsPaymentInformationPaymentTypeMethod": Ptsv2billingagreementsPaymentInformationPaymentTypeMethod,
    "Ptsv2billingagreementsPaymentInformationTokenizedCard": Ptsv2billingagreementsPaymentInformationTokenizedCard,
    "Ptsv2billingagreementsProcessingInformation": Ptsv2billingagreementsProcessingInformation,
    "Ptsv2billingagreementsidAgreementInformation": Ptsv2billingagreementsidAgreementInformation,
    "Ptsv2billingagreementsidBuyerInformation": Ptsv2billingagreementsidBuyerInformation,
    "Ptsv2billingagreementsidProcessingInformation": Ptsv2billingagreementsidProcessingInformation,
    "Ptsv2creditsInstallmentInformation": Ptsv2creditsInstallmentInformation,
    "Ptsv2creditsProcessingInformation": Ptsv2creditsProcessingInformation,
    "Ptsv2creditsProcessingInformationBankTransferOptions": Ptsv2creditsProcessingInformationBankTransferOptions,
    "Ptsv2creditsProcessingInformationElectronicBenefitsTransfer": Ptsv2creditsProcessingInformationElectronicBenefitsTransfer,
    "Ptsv2creditsProcessingInformationJapanPaymentOptions": Ptsv2creditsProcessingInformationJapanPaymentOptions,
    "Ptsv2creditsProcessingInformationPurchaseOptions": Ptsv2creditsProcessingInformationPurchaseOptions,
    "Ptsv2creditsProcessingInformationRefundOptions": Ptsv2creditsProcessingInformationRefundOptions,
    "Ptsv2creditsRecipientInformation": Ptsv2creditsRecipientInformation,
    "Ptsv2creditsSenderInformation": Ptsv2creditsSenderInformation,
    "Ptsv2creditsSenderInformationAccount": Ptsv2creditsSenderInformationAccount,
    "Ptsv2intentsClientReferenceInformation": Ptsv2intentsClientReferenceInformation,
    "Ptsv2intentsEventInformation": Ptsv2intentsEventInformation,
    "Ptsv2intentsMerchantInformation": Ptsv2intentsMerchantInformation,
    "Ptsv2intentsMerchantInformationMerchantDescriptor": Ptsv2intentsMerchantInformationMerchantDescriptor,
    "Ptsv2intentsOrderInformation": Ptsv2intentsOrderInformation,
    "Ptsv2intentsOrderInformationAmountDetails": Ptsv2intentsOrderInformationAmountDetails,
    "Ptsv2intentsOrderInformationBillTo": Ptsv2intentsOrderInformationBillTo,
    "Ptsv2intentsOrderInformationInvoiceDetails": Ptsv2intentsOrderInformationInvoiceDetails,
    "Ptsv2intentsOrderInformationLineItems": Ptsv2intentsOrderInformationLineItems,
    "Ptsv2intentsOrderInformationShipTo": Ptsv2intentsOrderInformationShipTo,
    "Ptsv2intentsPaymentInformation": Ptsv2intentsPaymentInformation,
    "Ptsv2intentsPaymentInformationEWallet": Ptsv2intentsPaymentInformationEWallet,
    "Ptsv2intentsPaymentInformationPaymentType": Ptsv2intentsPaymentInformationPaymentType,
    "Ptsv2intentsPaymentInformationPaymentTypeMethod": Ptsv2intentsPaymentInformationPaymentTypeMethod,
    "Ptsv2intentsPaymentInformationTokenizedPaymentMethod": Ptsv2intentsPaymentInformationTokenizedPaymentMethod,
    "Ptsv2intentsProcessingInformation": Ptsv2intentsProcessingInformation,
    "Ptsv2intentsProcessingInformationAuthorizationOptions": Ptsv2intentsProcessingInformationAuthorizationOptions,
    "Ptsv2intentsRecipientInformation": Ptsv2intentsRecipientInformation,
    "Ptsv2intentsSenderInformation": Ptsv2intentsSenderInformation,
    "Ptsv2intentsSenderInformationAccount": Ptsv2intentsSenderInformationAccount,
    "Ptsv2intentsTravelInformation": Ptsv2intentsTravelInformation,
    "Ptsv2intentsTravelInformationAgency": Ptsv2intentsTravelInformationAgency,
    "Ptsv2intentsidMerchantInformation": Ptsv2intentsidMerchantInformation,
    "Ptsv2intentsidOrderInformation": Ptsv2intentsidOrderInformation,
    "Ptsv2intentsidPaymentInformation": Ptsv2intentsidPaymentInformation,
    "Ptsv2intentsidProcessingInformation": Ptsv2intentsidProcessingInformation,
    "Ptsv2paymentreferencesAgreementInformation": Ptsv2paymentreferencesAgreementInformation,
    "Ptsv2paymentreferencesBuyerInformation": Ptsv2paymentreferencesBuyerInformation,
    "Ptsv2paymentreferencesDeviceInformation": Ptsv2paymentreferencesDeviceInformation,
    "Ptsv2paymentreferencesMerchantInformation": Ptsv2paymentreferencesMerchantInformation,
    "Ptsv2paymentreferencesOrderInformation": Ptsv2paymentreferencesOrderInformation,
    "Ptsv2paymentreferencesOrderInformationAmountDetails": Ptsv2paymentreferencesOrderInformationAmountDetails,
    "Ptsv2paymentreferencesOrderInformationBillTo": Ptsv2paymentreferencesOrderInformationBillTo,
    "Ptsv2paymentreferencesOrderInformationInvoiceDetails": Ptsv2paymentreferencesOrderInformationInvoiceDetails,
    "Ptsv2paymentreferencesOrderInformationLineItems": Ptsv2paymentreferencesOrderInformationLineItems,
    "Ptsv2paymentreferencesOrderInformationShipTo": Ptsv2paymentreferencesOrderInformationShipTo,
    "Ptsv2paymentreferencesPaymentInformation": Ptsv2paymentreferencesPaymentInformation,
    "Ptsv2paymentreferencesPaymentInformationBank": Ptsv2paymentreferencesPaymentInformationBank,
    "Ptsv2paymentreferencesPaymentInformationBankAccount": Ptsv2paymentreferencesPaymentInformationBankAccount,
    "Ptsv2paymentreferencesPaymentInformationCard": Ptsv2paymentreferencesPaymentInformationCard,
    "Ptsv2paymentreferencesPaymentInformationEWallet": Ptsv2paymentreferencesPaymentInformationEWallet,
    "Ptsv2paymentreferencesPaymentInformationOptions": Ptsv2paymentreferencesPaymentInformationOptions,
    "Ptsv2paymentreferencesProcessingInformation": Ptsv2paymentreferencesProcessingInformation,
    "Ptsv2paymentreferencesTravelInformation": Ptsv2paymentreferencesTravelInformation,
    "Ptsv2paymentreferencesTravelInformationAutoRental": Ptsv2paymentreferencesTravelInformationAutoRental,
    "Ptsv2paymentreferencesUserInterface": Ptsv2paymentreferencesUserInterface,
    "Ptsv2paymentreferencesUserInterfaceColor": Ptsv2paymentreferencesUserInterfaceColor,
    "Ptsv2paymentreferencesidintentsOrderInformation": Ptsv2paymentreferencesidintentsOrderInformation,
    "Ptsv2paymentreferencesidintentsPaymentInformation": Ptsv2paymentreferencesidintentsPaymentInformation,
    "Ptsv2paymentreferencesidintentsPaymentInformationEWallet": Ptsv2paymentreferencesidintentsPaymentInformationEWallet,
    "Ptsv2paymentreferencesidintentsProcessingInformation": Ptsv2paymentreferencesidintentsProcessingInformation,
    "Ptsv2paymentsAcquirerInformation": Ptsv2paymentsAcquirerInformation,
    "Ptsv2paymentsAggregatorInformation": Ptsv2paymentsAggregatorInformation,
    "Ptsv2paymentsAggregatorInformationSubMerchant": Ptsv2paymentsAggregatorInformationSubMerchant,
    "Ptsv2paymentsAgreementInformation": Ptsv2paymentsAgreementInformation,
    "Ptsv2paymentsBuyerInformation": Ptsv2paymentsBuyerInformation,
    "Ptsv2paymentsBuyerInformationPersonalIdentification": Ptsv2paymentsBuyerInformationPersonalIdentification,
    "Ptsv2paymentsClientReferenceInformation": Ptsv2paymentsClientReferenceInformation,
    "Ptsv2paymentsClientReferenceInformationPartner": Ptsv2paymentsClientReferenceInformationPartner,
    "Ptsv2paymentsConsumerAuthenticationInformation": Ptsv2paymentsConsumerAuthenticationInformation,
    "Ptsv2paymentsConsumerAuthenticationInformationStrongAuthentication": Ptsv2paymentsConsumerAuthenticationInformationStrongAuthentication,
    "Ptsv2paymentsConsumerAuthenticationInformationStrongAuthenticationIssuerInformation": Ptsv2paymentsConsumerAuthenticationInformationStrongAuthenticationIssuerInformation,
    "Ptsv2paymentsDeviceInformation": Ptsv2paymentsDeviceInformation,
    "Ptsv2paymentsDeviceInformationRawData": Ptsv2paymentsDeviceInformationRawData,
    "Ptsv2paymentsHealthCareInformation": Ptsv2paymentsHealthCareInformation,
    "Ptsv2paymentsHealthCareInformationAmountDetails": Ptsv2paymentsHealthCareInformationAmountDetails,
    "Ptsv2paymentsHostedPaymentInformation": Ptsv2paymentsHostedPaymentInformation,
    "Ptsv2paymentsHostedPaymentInformationUserAgent": Ptsv2paymentsHostedPaymentInformationUserAgent,
    "Ptsv2paymentsInstallmentInformation": Ptsv2paymentsInstallmentInformation,
    "Ptsv2paymentsInvoiceDetails": Ptsv2paymentsInvoiceDetails,
    "Ptsv2paymentsIssuerInformation": Ptsv2paymentsIssuerInformation,
    "Ptsv2paymentsMerchantDefinedInformation": Ptsv2paymentsMerchantDefinedInformation,
    "Ptsv2paymentsMerchantDefinedSecureInformation": Ptsv2paymentsMerchantDefinedSecureInformation,
    "Ptsv2paymentsMerchantInformation": Ptsv2paymentsMerchantInformation,
    "Ptsv2paymentsMerchantInformationMerchantDescriptor": Ptsv2paymentsMerchantInformationMerchantDescriptor,
    "Ptsv2paymentsMerchantInformationServiceFeeDescriptor": Ptsv2paymentsMerchantInformationServiceFeeDescriptor,
    "Ptsv2paymentsMerchantInformationServiceLocation": Ptsv2paymentsMerchantInformationServiceLocation,
    "Ptsv2paymentsOrderInformation": Ptsv2paymentsOrderInformation,
    "Ptsv2paymentsOrderInformationAmountDetails": Ptsv2paymentsOrderInformationAmountDetails,
    "Ptsv2paymentsOrderInformationAmountDetailsAmexAdditionalAmounts": Ptsv2paymentsOrderInformationAmountDetailsAmexAdditionalAmounts,
    "Ptsv2paymentsOrderInformationAmountDetailsCurrencyConversion": Ptsv2paymentsOrderInformationAmountDetailsCurrencyConversion,
    "Ptsv2paymentsOrderInformationAmountDetailsOctsurcharge": Ptsv2paymentsOrderInformationAmountDetailsOctsurcharge,
    "Ptsv2paymentsOrderInformationAmountDetailsOrder": Ptsv2paymentsOrderInformationAmountDetailsOrder,
    "Ptsv2paymentsOrderInformationAmountDetailsSurcharge": Ptsv2paymentsOrderInformationAmountDetailsSurcharge,
    "Ptsv2paymentsOrderInformationAmountDetailsTaxDetails": Ptsv2paymentsOrderInformationAmountDetailsTaxDetails,
    "Ptsv2paymentsOrderInformationBillTo": Ptsv2paymentsOrderInformationBillTo,
    "Ptsv2paymentsOrderInformationBillToCompany": Ptsv2paymentsOrderInformationBillToCompany,
    "Ptsv2paymentsOrderInformationInvoiceDetails": Ptsv2paymentsOrderInformationInvoiceDetails,
    "Ptsv2paymentsOrderInformationInvoiceDetailsTransactionAdviceAddendum": Ptsv2paymentsOrderInformationInvoiceDetailsTransactionAdviceAddendum,
    "Ptsv2paymentsOrderInformationLineItems": Ptsv2paymentsOrderInformationLineItems,
    "Ptsv2paymentsOrderInformationPassenger": Ptsv2paymentsOrderInformationPassenger,
    "Ptsv2paymentsOrderInformationShipTo": Ptsv2paymentsOrderInformationShipTo,
    "Ptsv2paymentsOrderInformationShippingDetails": Ptsv2paymentsOrderInformationShippingDetails,
    "Ptsv2paymentsPaymentInformation": Ptsv2paymentsPaymentInformation,
    "Ptsv2paymentsPaymentInformationBank": Ptsv2paymentsPaymentInformationBank,
    "Ptsv2paymentsPaymentInformationBankAccount": Ptsv2paymentsPaymentInformationBankAccount,
    "Ptsv2paymentsPaymentInformationCard": Ptsv2paymentsPaymentInformationCard,
    "Ptsv2paymentsPaymentInformationCustomer": Ptsv2paymentsPaymentInformationCustomer,
    "Ptsv2paymentsPaymentInformationDirectDebit": Ptsv2paymentsPaymentInformationDirectDebit,
    "Ptsv2paymentsPaymentInformationDirectDebitMandate": Ptsv2paymentsPaymentInformationDirectDebitMandate,
    "Ptsv2paymentsPaymentInformationEWallet": Ptsv2paymentsPaymentInformationEWallet,
    "Ptsv2paymentsPaymentInformationFluidData": Ptsv2paymentsPaymentInformationFluidData,
    "Ptsv2paymentsPaymentInformationInstrumentIdentifier": Ptsv2paymentsPaymentInformationInstrumentIdentifier,
    "Ptsv2paymentsPaymentInformationLegacyToken": Ptsv2paymentsPaymentInformationLegacyToken,
    "Ptsv2paymentsPaymentInformationOptions": Ptsv2paymentsPaymentInformationOptions,
    "Ptsv2paymentsPaymentInformationPaymentAccountReference": Ptsv2paymentsPaymentInformationPaymentAccountReference,
    "Ptsv2paymentsPaymentInformationPaymentInstrument": Ptsv2paymentsPaymentInformationPaymentInstrument,
    "Ptsv2paymentsPaymentInformationPaymentType": Ptsv2paymentsPaymentInformationPaymentType,
    "Ptsv2paymentsPaymentInformationPaymentTypeMethod": Ptsv2paymentsPaymentInformationPaymentTypeMethod,
    "Ptsv2paymentsPaymentInformationSepa": Ptsv2paymentsPaymentInformationSepa,
    "Ptsv2paymentsPaymentInformationSepaDirectDebit": Ptsv2paymentsPaymentInformationSepaDirectDebit,
    "Ptsv2paymentsPaymentInformationShippingAddress": Ptsv2paymentsPaymentInformationShippingAddress,
    "Ptsv2paymentsPaymentInformationTokenizedCard": Ptsv2paymentsPaymentInformationTokenizedCard,
    "Ptsv2paymentsPaymentInformationTokenizedPaymentMethod": Ptsv2paymentsPaymentInformationTokenizedPaymentMethod,
    "Ptsv2paymentsPointOfSaleInformation": Ptsv2paymentsPointOfSaleInformation,
    "Ptsv2paymentsPointOfSaleInformationEmv": Ptsv2paymentsPointOfSaleInformationEmv,
    "Ptsv2paymentsProcessingInformation": Ptsv2paymentsProcessingInformation,
    "Ptsv2paymentsProcessingInformationAuthorizationOptions": Ptsv2paymentsProcessingInformationAuthorizationOptions,
    "Ptsv2paymentsProcessingInformationAuthorizationOptionsInitiator": Ptsv2paymentsProcessingInformationAuthorizationOptionsInitiator,
    "Ptsv2paymentsProcessingInformationAuthorizationOptionsInitiatorMerchantInitiatedTransaction": Ptsv2paymentsProcessingInformationAuthorizationOptionsInitiatorMerchantInitiatedTransaction,
    "Ptsv2paymentsProcessingInformationBankTransferOptions": Ptsv2paymentsProcessingInformationBankTransferOptions,
    "Ptsv2paymentsProcessingInformationCaptureOptions": Ptsv2paymentsProcessingInformationCaptureOptions,
    "Ptsv2paymentsProcessingInformationElectronicBenefitsTransfer": Ptsv2paymentsProcessingInformationElectronicBenefitsTransfer,
    "Ptsv2paymentsProcessingInformationJapanPaymentOptions": Ptsv2paymentsProcessingInformationJapanPaymentOptions,
    "Ptsv2paymentsProcessingInformationJapanPaymentOptionsBonuses": Ptsv2paymentsProcessingInformationJapanPaymentOptionsBonuses,
    "Ptsv2paymentsProcessingInformationLoanOptions": Ptsv2paymentsProcessingInformationLoanOptions,
    "Ptsv2paymentsProcessingInformationPurchaseOptions": Ptsv2paymentsProcessingInformationPurchaseOptions,
    "Ptsv2paymentsProcessingInformationRecurringOptions": Ptsv2paymentsProcessingInformationRecurringOptions,
    "Ptsv2paymentsProcessorInformation": Ptsv2paymentsProcessorInformation,
    "Ptsv2paymentsProcessorInformationAuthorizationOptions": Ptsv2paymentsProcessorInformationAuthorizationOptions,
    "Ptsv2paymentsProcessorInformationReversal": Ptsv2paymentsProcessorInformationReversal,
    "Ptsv2paymentsPromotionInformation": Ptsv2paymentsPromotionInformation,
    "Ptsv2paymentsRecipientInformation": Ptsv2paymentsRecipientInformation,
    "Ptsv2paymentsRecurringPaymentInformation": Ptsv2paymentsRecurringPaymentInformation,
    "Ptsv2paymentsRiskInformation": Ptsv2paymentsRiskInformation,
    "Ptsv2paymentsRiskInformationAuxiliaryData": Ptsv2paymentsRiskInformationAuxiliaryData,
    "Ptsv2paymentsRiskInformationBuyerHistory": Ptsv2paymentsRiskInformationBuyerHistory,
    "Ptsv2paymentsRiskInformationBuyerHistoryAccountHistory": Ptsv2paymentsRiskInformationBuyerHistoryAccountHistory,
    "Ptsv2paymentsRiskInformationBuyerHistoryCustomerAccount": Ptsv2paymentsRiskInformationBuyerHistoryCustomerAccount,
    "Ptsv2paymentsRiskInformationProfile": Ptsv2paymentsRiskInformationProfile,
    "Ptsv2paymentsSenderInformation": Ptsv2paymentsSenderInformation,
    "Ptsv2paymentsSenderInformationAccount": Ptsv2paymentsSenderInformationAccount,
    "Ptsv2paymentsTokenInformation": Ptsv2paymentsTokenInformation,
    "Ptsv2paymentsTokenInformationPaymentInstrument": Ptsv2paymentsTokenInformationPaymentInstrument,
    "Ptsv2paymentsTokenInformationShippingAddress": Ptsv2paymentsTokenInformationShippingAddress,
    "Ptsv2paymentsTokenInformationTokenProvisioningInformation": Ptsv2paymentsTokenInformationTokenProvisioningInformation,
    "Ptsv2paymentsTravelInformation": Ptsv2paymentsTravelInformation,
    "Ptsv2paymentsTravelInformationAgency": Ptsv2paymentsTravelInformationAgency,
    "Ptsv2paymentsTravelInformationAutoRental": Ptsv2paymentsTravelInformationAutoRental,
    "Ptsv2paymentsTravelInformationAutoRentalRentalAddress": Ptsv2paymentsTravelInformationAutoRentalRentalAddress,
    "Ptsv2paymentsTravelInformationAutoRentalReturnAddress": Ptsv2paymentsTravelInformationAutoRentalReturnAddress,
    "Ptsv2paymentsTravelInformationAutoRentalTaxDetails": Ptsv2paymentsTravelInformationAutoRentalTaxDetails,
    "Ptsv2paymentsTravelInformationLodging": Ptsv2paymentsTravelInformationLodging,
    "Ptsv2paymentsTravelInformationLodgingRoom": Ptsv2paymentsTravelInformationLodgingRoom,
    "Ptsv2paymentsTravelInformationTransit": Ptsv2paymentsTravelInformationTransit,
    "Ptsv2paymentsTravelInformationTransitAirline": Ptsv2paymentsTravelInformationTransitAirline,
    "Ptsv2paymentsTravelInformationTransitAirlineAncillaryInformation": Ptsv2paymentsTravelInformationTransitAirlineAncillaryInformation,
    "Ptsv2paymentsTravelInformationTransitAirlineAncillaryInformationService": Ptsv2paymentsTravelInformationTransitAirlineAncillaryInformationService,
    "Ptsv2paymentsTravelInformationTransitAirlineLegs": Ptsv2paymentsTravelInformationTransitAirlineLegs,
    "Ptsv2paymentsTravelInformationTransitAirlineTicketIssuer": Ptsv2paymentsTravelInformationTransitAirlineTicketIssuer,
    "Ptsv2paymentsTravelInformationVehicleData": Ptsv2paymentsTravelInformationVehicleData,
    "Ptsv2paymentsUnscheduledPaymentInformation": Ptsv2paymentsUnscheduledPaymentInformation,
    "Ptsv2paymentsWatchlistScreeningInformation": Ptsv2paymentsWatchlistScreeningInformation,
    "Ptsv2paymentsWatchlistScreeningInformationWeights": Ptsv2paymentsWatchlistScreeningInformationWeights,
    "Ptsv2paymentsidClientReferenceInformation": Ptsv2paymentsidClientReferenceInformation,
    "Ptsv2paymentsidClientReferenceInformationPartner": Ptsv2paymentsidClientReferenceInformationPartner,
    "Ptsv2paymentsidMerchantInformation": Ptsv2paymentsidMerchantInformation,
    "Ptsv2paymentsidOrderInformation": Ptsv2paymentsidOrderInformation,
    "Ptsv2paymentsidOrderInformationAmountDetails": Ptsv2paymentsidOrderInformationAmountDetails,
    "Ptsv2paymentsidProcessingInformation": Ptsv2paymentsidProcessingInformation,
    "Ptsv2paymentsidProcessingInformationAuthorizationOptions": Ptsv2paymentsidProcessingInformationAuthorizationOptions,
    "Ptsv2paymentsidProcessingInformationAuthorizationOptionsInitiator": Ptsv2paymentsidProcessingInformationAuthorizationOptionsInitiator,
    "Ptsv2paymentsidTravelInformation": Ptsv2paymentsidTravelInformation,
    "Ptsv2paymentsidcapturesAggregatorInformation": Ptsv2paymentsidcapturesAggregatorInformation,
    "Ptsv2paymentsidcapturesAggregatorInformationSubMerchant": Ptsv2paymentsidcapturesAggregatorInformationSubMerchant,
    "Ptsv2paymentsidcapturesBuyerInformation": Ptsv2paymentsidcapturesBuyerInformation,
    "Ptsv2paymentsidcapturesBuyerInformationPersonalIdentification": Ptsv2paymentsidcapturesBuyerInformationPersonalIdentification,
    "Ptsv2paymentsidcapturesDeviceInformation": Ptsv2paymentsidcapturesDeviceInformation,
    "Ptsv2paymentsidcapturesInstallmentInformation": Ptsv2paymentsidcapturesInstallmentInformation,
    "Ptsv2paymentsidcapturesMerchantInformation": Ptsv2paymentsidcapturesMerchantInformation,
    "Ptsv2paymentsidcapturesOrderInformation": Ptsv2paymentsidcapturesOrderInformation,
    "Ptsv2paymentsidcapturesOrderInformationAmountDetails": Ptsv2paymentsidcapturesOrderInformationAmountDetails,
    "Ptsv2paymentsidcapturesOrderInformationBillTo": Ptsv2paymentsidcapturesOrderInformationBillTo,
    "Ptsv2paymentsidcapturesOrderInformationInvoiceDetails": Ptsv2paymentsidcapturesOrderInformationInvoiceDetails,
    "Ptsv2paymentsidcapturesOrderInformationShipTo": Ptsv2paymentsidcapturesOrderInformationShipTo,
    "Ptsv2paymentsidcapturesOrderInformationShippingDetails": Ptsv2paymentsidcapturesOrderInformationShippingDetails,
    "Ptsv2paymentsidcapturesPaymentInformation": Ptsv2paymentsidcapturesPaymentInformation,
    "Ptsv2paymentsidcapturesPaymentInformationCard": Ptsv2paymentsidcapturesPaymentInformationCard,
    "Ptsv2paymentsidcapturesPaymentInformationPaymentType": Ptsv2paymentsidcapturesPaymentInformationPaymentType,
    "Ptsv2paymentsidcapturesPaymentInformationPaymentTypeMethod": Ptsv2paymentsidcapturesPaymentInformationPaymentTypeMethod,
    "Ptsv2paymentsidcapturesPointOfSaleInformation": Ptsv2paymentsidcapturesPointOfSaleInformation,
    "Ptsv2paymentsidcapturesPointOfSaleInformationEmv": Ptsv2paymentsidcapturesPointOfSaleInformationEmv,
    "Ptsv2paymentsidcapturesProcessingInformation": Ptsv2paymentsidcapturesProcessingInformation,
    "Ptsv2paymentsidcapturesProcessingInformationAuthorizationOptions": Ptsv2paymentsidcapturesProcessingInformationAuthorizationOptions,
    "Ptsv2paymentsidcapturesProcessingInformationCaptureOptions": Ptsv2paymentsidcapturesProcessingInformationCaptureOptions,
    "Ptsv2paymentsidrefundsClientReferenceInformation": Ptsv2paymentsidrefundsClientReferenceInformation,
    "Ptsv2paymentsidrefundsMerchantInformation": Ptsv2paymentsidrefundsMerchantInformation,
    "Ptsv2paymentsidrefundsOrderInformation": Ptsv2paymentsidrefundsOrderInformation,
    "Ptsv2paymentsidrefundsOrderInformationLineItems": Ptsv2paymentsidrefundsOrderInformationLineItems,
    "Ptsv2paymentsidrefundsPaymentInformation": Ptsv2paymentsidrefundsPaymentInformation,
    "Ptsv2paymentsidrefundsPaymentInformationBank": Ptsv2paymentsidrefundsPaymentInformationBank,
    "Ptsv2paymentsidrefundsPaymentInformationBankAccount": Ptsv2paymentsidrefundsPaymentInformationBankAccount,
    "Ptsv2paymentsidrefundsPaymentInformationCard": Ptsv2paymentsidrefundsPaymentInformationCard,
    "Ptsv2paymentsidrefundsPaymentInformationEWallet": Ptsv2paymentsidrefundsPaymentInformationEWallet,
    "Ptsv2paymentsidrefundsPaymentInformationPaymentType": Ptsv2paymentsidrefundsPaymentInformationPaymentType,
    "Ptsv2paymentsidrefundsPointOfSaleInformation": Ptsv2paymentsidrefundsPointOfSaleInformation,
    "Ptsv2paymentsidrefundsProcessingInformation": Ptsv2paymentsidrefundsProcessingInformation,
    "Ptsv2paymentsidrefundsProcessingInformationRecurringOptions": Ptsv2paymentsidrefundsProcessingInformationRecurringOptions,
    "Ptsv2paymentsidrefundsProcessingInformationRefundOptions": Ptsv2paymentsidrefundsProcessingInformationRefundOptions,
    "Ptsv2paymentsidreversalsClientReferenceInformation": Ptsv2paymentsidreversalsClientReferenceInformation,
    "Ptsv2paymentsidreversalsClientReferenceInformationPartner": Ptsv2paymentsidreversalsClientReferenceInformationPartner,
    "Ptsv2paymentsidreversalsOrderInformation": Ptsv2paymentsidreversalsOrderInformation,
    "Ptsv2paymentsidreversalsOrderInformationAmountDetails": Ptsv2paymentsidreversalsOrderInformationAmountDetails,
    "Ptsv2paymentsidreversalsOrderInformationLineItems": Ptsv2paymentsidreversalsOrderInformationLineItems,
    "Ptsv2paymentsidreversalsPaymentInformation": Ptsv2paymentsidreversalsPaymentInformation,
    "Ptsv2paymentsidreversalsPaymentInformationPaymentType": Ptsv2paymentsidreversalsPaymentInformationPaymentType,
    "Ptsv2paymentsidreversalsPaymentInformationPaymentTypeMethod": Ptsv2paymentsidreversalsPaymentInformationPaymentTypeMethod,
    "Ptsv2paymentsidreversalsPointOfSaleInformation": Ptsv2paymentsidreversalsPointOfSaleInformation,
    "Ptsv2paymentsidreversalsPointOfSaleInformationEmv": Ptsv2paymentsidreversalsPointOfSaleInformationEmv,
    "Ptsv2paymentsidreversalsProcessingInformation": Ptsv2paymentsidreversalsProcessingInformation,
    "Ptsv2paymentsidreversalsReversalInformation": Ptsv2paymentsidreversalsReversalInformation,
    "Ptsv2paymentsidreversalsReversalInformationAmountDetails": Ptsv2paymentsidreversalsReversalInformationAmountDetails,
    "Ptsv2paymentsidvoidsAgreementInformation": Ptsv2paymentsidvoidsAgreementInformation,
    "Ptsv2paymentsidvoidsMerchantInformation": Ptsv2paymentsidvoidsMerchantInformation,
    "Ptsv2paymentsidvoidsOrderInformation": Ptsv2paymentsidvoidsOrderInformation,
    "Ptsv2paymentsidvoidsPaymentInformation": Ptsv2paymentsidvoidsPaymentInformation,
    "Ptsv2paymentsidvoidsProcessingInformation": Ptsv2paymentsidvoidsProcessingInformation,
    "Ptsv2paymenttokensPaymentInformation": Ptsv2paymenttokensPaymentInformation,
    "Ptsv2paymenttokensProcessingInformation": Ptsv2paymenttokensProcessingInformation,
    "Ptsv2payoutsAggregatorInformation": Ptsv2payoutsAggregatorInformation,
    "Ptsv2payoutsAggregatorInformationSubMerchant": Ptsv2payoutsAggregatorInformationSubMerchant,
    "Ptsv2payoutsClientReferenceInformation": Ptsv2payoutsClientReferenceInformation,
    "Ptsv2payoutsMerchantInformation": Ptsv2payoutsMerchantInformation,
    "Ptsv2payoutsMerchantInformationMerchantDescriptor": Ptsv2payoutsMerchantInformationMerchantDescriptor,
    "Ptsv2payoutsOrderInformation": Ptsv2payoutsOrderInformation,
    "Ptsv2payoutsOrderInformationAmountDetails": Ptsv2payoutsOrderInformationAmountDetails,
    "Ptsv2payoutsOrderInformationAmountDetailsSurcharge": Ptsv2payoutsOrderInformationAmountDetailsSurcharge,
    "Ptsv2payoutsOrderInformationBillTo": Ptsv2payoutsOrderInformationBillTo,
    "Ptsv2payoutsPaymentInformation": Ptsv2payoutsPaymentInformation,
    "Ptsv2payoutsPaymentInformationCard": Ptsv2payoutsPaymentInformationCard,
    "Ptsv2payoutsProcessingInformation": Ptsv2payoutsProcessingInformation,
    "Ptsv2payoutsProcessingInformationFundingOptions": Ptsv2payoutsProcessingInformationFundingOptions,
    "Ptsv2payoutsProcessingInformationFundingOptionsInitiator": Ptsv2payoutsProcessingInformationFundingOptionsInitiator,
    "Ptsv2payoutsProcessingInformationPayoutsOptions": Ptsv2payoutsProcessingInformationPayoutsOptions,
    "Ptsv2payoutsProcessingInformationPurchaseOptions": Ptsv2payoutsProcessingInformationPurchaseOptions,
    "Ptsv2payoutsRecipientInformation": Ptsv2payoutsRecipientInformation,
    "Ptsv2payoutsSenderInformation": Ptsv2payoutsSenderInformation,
    "Ptsv2payoutsSenderInformationAccount": Ptsv2payoutsSenderInformationAccount,
    "Ptsv2refreshpaymentstatusidAgreementInformation": Ptsv2refreshpaymentstatusidAgreementInformation,
    "Ptsv2refreshpaymentstatusidClientReferenceInformation": Ptsv2refreshpaymentstatusidClientReferenceInformation,
    "Ptsv2refreshpaymentstatusidPaymentInformation": Ptsv2refreshpaymentstatusidPaymentInformation,
    "Ptsv2refreshpaymentstatusidPaymentInformationCustomer": Ptsv2refreshpaymentstatusidPaymentInformationCustomer,
    "Ptsv2refreshpaymentstatusidPaymentInformationPaymentType": Ptsv2refreshpaymentstatusidPaymentInformationPaymentType,
    "Ptsv2refreshpaymentstatusidProcessingInformation": Ptsv2refreshpaymentstatusidProcessingInformation,
    "Ptsv2voidsProcessingInformation": Ptsv2voidsProcessingInformation,
    "Rbsv1plansClientReferenceInformation": Rbsv1plansClientReferenceInformation,
    "Rbsv1plansOrderInformation": Rbsv1plansOrderInformation,
    "Rbsv1plansOrderInformationAmountDetails": Rbsv1plansOrderInformationAmountDetails,
    "Rbsv1plansPlanInformation": Rbsv1plansPlanInformation,
    "Rbsv1plansPlanInformationBillingCycles": Rbsv1plansPlanInformationBillingCycles,
    "Rbsv1plansidPlanInformation": Rbsv1plansidPlanInformation,
    "Rbsv1plansidProcessingInformation": Rbsv1plansidProcessingInformation,
    "Rbsv1plansidProcessingInformationSubscriptionBillingOptions": Rbsv1plansidProcessingInformationSubscriptionBillingOptions,
    "Rbsv1subscriptionsClientReferenceInformation": Rbsv1subscriptionsClientReferenceInformation,
    "Rbsv1subscriptionsClientReferenceInformationPartner": Rbsv1subscriptionsClientReferenceInformationPartner,
    "Rbsv1subscriptionsPaymentInformation": Rbsv1subscriptionsPaymentInformation,
    "Rbsv1subscriptionsPaymentInformationCustomer": Rbsv1subscriptionsPaymentInformationCustomer,
    "Rbsv1subscriptionsPlanInformation": Rbsv1subscriptionsPlanInformation,
    "Rbsv1subscriptionsProcessingInformation": Rbsv1subscriptionsProcessingInformation,
    "Rbsv1subscriptionsProcessingInformationAuthorizationOptions": Rbsv1subscriptionsProcessingInformationAuthorizationOptions,
    "Rbsv1subscriptionsProcessingInformationAuthorizationOptionsInitiator": Rbsv1subscriptionsProcessingInformationAuthorizationOptionsInitiator,
    "Rbsv1subscriptionsSubscriptionInformation": Rbsv1subscriptionsSubscriptionInformation,
    "Rbsv1subscriptionsidOrderInformation": Rbsv1subscriptionsidOrderInformation,
    "Rbsv1subscriptionsidOrderInformationAmountDetails": Rbsv1subscriptionsidOrderInformationAmountDetails,
    "Rbsv1subscriptionsidPlanInformation": Rbsv1subscriptionsidPlanInformation,
    "Rbsv1subscriptionsidSubscriptionInformation": Rbsv1subscriptionsidSubscriptionInformation,
    "RefreshPaymentStatusRequest": RefreshPaymentStatusRequest,
    "RefundCaptureRequest": RefundCaptureRequest,
    "RefundPaymentRequest": RefundPaymentRequest,
    "ReportingV3ChargebackDetailsGet200Response": ReportingV3ChargebackDetailsGet200Response,
    "ReportingV3ChargebackDetailsGet200ResponseChargebackDetails": ReportingV3ChargebackDetailsGet200ResponseChargebackDetails,
    "ReportingV3ChargebackSummariesGet200Response": ReportingV3ChargebackSummariesGet200Response,
    "ReportingV3ChargebackSummariesGet200ResponseChargebackSummaries": ReportingV3ChargebackSummariesGet200ResponseChargebackSummaries,
    "ReportingV3ConversionDetailsGet200Response": ReportingV3ConversionDetailsGet200Response,
    "ReportingV3ConversionDetailsGet200ResponseConversionDetails": ReportingV3ConversionDetailsGet200ResponseConversionDetails,
    "ReportingV3ConversionDetailsGet200ResponseNotes": ReportingV3ConversionDetailsGet200ResponseNotes,
    "ReportingV3InterchangeClearingLevelDetailsGet200Response": ReportingV3InterchangeClearingLevelDetailsGet200Response,
    "ReportingV3InterchangeClearingLevelDetailsGet200ResponseInterchangeClearingLevelDetails": ReportingV3InterchangeClearingLevelDetailsGet200ResponseInterchangeClearingLevelDetails,
    "ReportingV3NetFundingsGet200Response": ReportingV3NetFundingsGet200Response,
    "ReportingV3NetFundingsGet200ResponseNetFundingSummaries": ReportingV3NetFundingsGet200ResponseNetFundingSummaries,
    "ReportingV3NetFundingsGet200ResponseTotalPurchases": ReportingV3NetFundingsGet200ResponseTotalPurchases,
    "ReportingV3NotificationofChangesGet200Response": ReportingV3NotificationofChangesGet200Response,
    "ReportingV3NotificationofChangesGet200ResponseNotificationOfChanges": ReportingV3NotificationofChangesGet200ResponseNotificationOfChanges,
    "ReportingV3PaymentBatchSummariesGet200Response": ReportingV3PaymentBatchSummariesGet200Response,
    "ReportingV3PaymentBatchSummariesGet200ResponsePaymentBatchSummaries": ReportingV3PaymentBatchSummariesGet200ResponsePaymentBatchSummaries,
    "ReportingV3PurchaseRefundDetailsGet200Response": ReportingV3PurchaseRefundDetailsGet200Response,
    "ReportingV3PurchaseRefundDetailsGet200ResponseAuthorizations": ReportingV3PurchaseRefundDetailsGet200ResponseAuthorizations,
    "ReportingV3PurchaseRefundDetailsGet200ResponseFeeAndFundingDetails": ReportingV3PurchaseRefundDetailsGet200ResponseFeeAndFundingDetails,
    "ReportingV3PurchaseRefundDetailsGet200ResponseOthers": ReportingV3PurchaseRefundDetailsGet200ResponseOthers,
    "ReportingV3PurchaseRefundDetailsGet200ResponseRequestDetails": ReportingV3PurchaseRefundDetailsGet200ResponseRequestDetails,
    "ReportingV3PurchaseRefundDetailsGet200ResponseSettlementStatuses": ReportingV3PurchaseRefundDetailsGet200ResponseSettlementStatuses,
    "ReportingV3PurchaseRefundDetailsGet200ResponseSettlements": ReportingV3PurchaseRefundDetailsGet200ResponseSettlements,
    "ReportingV3ReportDefinitionsGet200Response": ReportingV3ReportDefinitionsGet200Response,
    "ReportingV3ReportDefinitionsGet200ResponseReportDefinitions": ReportingV3ReportDefinitionsGet200ResponseReportDefinitions,
    "ReportingV3ReportDefinitionsNameGet200Response": ReportingV3ReportDefinitionsNameGet200Response,
    "ReportingV3ReportDefinitionsNameGet200ResponseAttributes": ReportingV3ReportDefinitionsNameGet200ResponseAttributes,
    "ReportingV3ReportDefinitionsNameGet200ResponseDefaultSettings": ReportingV3ReportDefinitionsNameGet200ResponseDefaultSettings,
    "ReportingV3ReportSubscriptionsGet200Response": ReportingV3ReportSubscriptionsGet200Response,
    "ReportingV3ReportSubscriptionsGet200ResponseSubscriptions": ReportingV3ReportSubscriptionsGet200ResponseSubscriptions,
    "ReportingV3ReportsGet200Response": ReportingV3ReportsGet200Response,
    "ReportingV3ReportsGet200ResponseLink": ReportingV3ReportsGet200ResponseLink,
    "ReportingV3ReportsGet200ResponseLinkReportDownload": ReportingV3ReportsGet200ResponseLinkReportDownload,
    "ReportingV3ReportsGet200ResponseReportSearchResults": ReportingV3ReportsGet200ResponseReportSearchResults,
    "ReportingV3ReportsIdGet200Response": ReportingV3ReportsIdGet200Response,
    "ReportingV3RetrievalDetailsGet200Response": ReportingV3RetrievalDetailsGet200Response,
    "ReportingV3RetrievalDetailsGet200ResponseRetrievalDetails": ReportingV3RetrievalDetailsGet200ResponseRetrievalDetails,
    "ReportingV3RetrievalSummariesGet200Response": ReportingV3RetrievalSummariesGet200Response,
    "Reportingv3ReportDownloadsGet400Response": Reportingv3ReportDownloadsGet400Response,
    "Reportingv3ReportDownloadsGet400ResponseDetails": Reportingv3ReportDownloadsGet400ResponseDetails,
    "Reportingv3reportsReportFilters": Reportingv3reportsReportFilters,
    "Reportingv3reportsReportPreferences": Reportingv3reportsReportPreferences,
    "Request": Request,
    "RevokeCertificateRequest": RevokeCertificateRequest,
    "RiskProducts": RiskProducts,
    "RiskProductsDecisionManager": RiskProductsDecisionManager,
    "RiskProductsDecisionManagerConfigurationInformation": RiskProductsDecisionManagerConfigurationInformation,
    "RiskProductsFraudManagementEssentials": RiskProductsFraudManagementEssentials,
    "RiskProductsFraudManagementEssentialsConfigurationInformation": RiskProductsFraudManagementEssentialsConfigurationInformation,
    "RiskProductsPortfolioRiskControls": RiskProductsPortfolioRiskControls,
    "RiskProductsPortfolioRiskControlsConfigurationInformation": RiskProductsPortfolioRiskControlsConfigurationInformation,
    "RiskProductsPortfolioRiskControlsConfigurationInformationConfigurations": RiskProductsPortfolioRiskControlsConfigurationInformationConfigurations,
    "RiskV1AddressVerificationsPost201Response": RiskV1AddressVerificationsPost201Response,
    "RiskV1AddressVerificationsPost201ResponseAddressVerificationInformation": RiskV1AddressVerificationsPost201ResponseAddressVerificationInformation,
    "RiskV1AddressVerificationsPost201ResponseAddressVerificationInformationBarCode": RiskV1AddressVerificationsPost201ResponseAddressVerificationInformationBarCode,
    "RiskV1AddressVerificationsPost201ResponseAddressVerificationInformationStandardAddress": RiskV1AddressVerificationsPost201ResponseAddressVerificationInformationStandardAddress,
    "RiskV1AddressVerificationsPost201ResponseAddressVerificationInformationStandardAddressAddress1": RiskV1AddressVerificationsPost201ResponseAddressVerificationInformationStandardAddressAddress1,
    "RiskV1AddressVerificationsPost201ResponseErrorInformation": RiskV1AddressVerificationsPost201ResponseErrorInformation,
    "RiskV1AuthenticationResultsPost201Response": RiskV1AuthenticationResultsPost201Response,
    "RiskV1AuthenticationResultsPost201ResponseConsumerAuthenticationInformation": RiskV1AuthenticationResultsPost201ResponseConsumerAuthenticationInformation,
    "RiskV1AuthenticationSetupsPost201Response": RiskV1AuthenticationSetupsPost201Response,
    "RiskV1AuthenticationSetupsPost201ResponseConsumerAuthenticationInformation": RiskV1AuthenticationSetupsPost201ResponseConsumerAuthenticationInformation,
    "RiskV1AuthenticationSetupsPost201ResponseErrorInformation": RiskV1AuthenticationSetupsPost201ResponseErrorInformation,
    "RiskV1AuthenticationsPost201Response": RiskV1AuthenticationsPost201Response,
    "RiskV1AuthenticationsPost201ResponseErrorInformation": RiskV1AuthenticationsPost201ResponseErrorInformation,
    "RiskV1AuthenticationsPost400Response": RiskV1AuthenticationsPost400Response,
    "RiskV1AuthenticationsPost400Response1": RiskV1AuthenticationsPost400Response1,
    "RiskV1DecisionsPost201Response": RiskV1DecisionsPost201Response,
    "RiskV1DecisionsPost201ResponseClientReferenceInformation": RiskV1DecisionsPost201ResponseClientReferenceInformation,
    "RiskV1DecisionsPost201ResponseConsumerAuthenticationInformation": RiskV1DecisionsPost201ResponseConsumerAuthenticationInformation,
    "RiskV1DecisionsPost201ResponseErrorInformation": RiskV1DecisionsPost201ResponseErrorInformation,
    "RiskV1DecisionsPost201ResponseOrderInformation": RiskV1DecisionsPost201ResponseOrderInformation,
    "RiskV1DecisionsPost201ResponseOrderInformationAmountDetails": RiskV1DecisionsPost201ResponseOrderInformationAmountDetails,
    "RiskV1DecisionsPost201ResponsePaymentInformation": RiskV1DecisionsPost201ResponsePaymentInformation,
    "RiskV1DecisionsPost400Response": RiskV1DecisionsPost400Response,
    "RiskV1DecisionsPost400Response1": RiskV1DecisionsPost400Response1,
    "RiskV1ExportComplianceInquiriesPost201Response": RiskV1ExportComplianceInquiriesPost201Response,
    "RiskV1ExportComplianceInquiriesPost201ResponseErrorInformation": RiskV1ExportComplianceInquiriesPost201ResponseErrorInformation,
    "RiskV1UpdatePost201Response": RiskV1UpdatePost201Response,
    "Riskv1addressverificationsBuyerInformation": Riskv1addressverificationsBuyerInformation,
    "Riskv1addressverificationsOrderInformation": Riskv1addressverificationsOrderInformation,
    "Riskv1addressverificationsOrderInformationBillTo": Riskv1addressverificationsOrderInformationBillTo,
    "Riskv1addressverificationsOrderInformationLineItems": Riskv1addressverificationsOrderInformationLineItems,
    "Riskv1addressverificationsOrderInformationShipTo": Riskv1addressverificationsOrderInformationShipTo,
    "Riskv1authenticationresultsConsumerAuthenticationInformation": Riskv1authenticationresultsConsumerAuthenticationInformation,
    "Riskv1authenticationresultsDeviceInformation": Riskv1authenticationresultsDeviceInformation,
    "Riskv1authenticationresultsOrderInformation": Riskv1authenticationresultsOrderInformation,
    "Riskv1authenticationresultsOrderInformationAmountDetails": Riskv1authenticationresultsOrderInformationAmountDetails,
    "Riskv1authenticationresultsPaymentInformation": Riskv1authenticationresultsPaymentInformation,
    "Riskv1authenticationresultsPaymentInformationCard": Riskv1authenticationresultsPaymentInformationCard,
    "Riskv1authenticationresultsPaymentInformationFluidData": Riskv1authenticationresultsPaymentInformationFluidData,
    "Riskv1authenticationresultsPaymentInformationTokenizedCard": Riskv1authenticationresultsPaymentInformationTokenizedCard,
    "Riskv1authenticationsBuyerInformation": Riskv1authenticationsBuyerInformation,
    "Riskv1authenticationsDeviceInformation": Riskv1authenticationsDeviceInformation,
    "Riskv1authenticationsOrderInformation": Riskv1authenticationsOrderInformation,
    "Riskv1authenticationsOrderInformationAmountDetails": Riskv1authenticationsOrderInformationAmountDetails,
    "Riskv1authenticationsOrderInformationBillTo": Riskv1authenticationsOrderInformationBillTo,
    "Riskv1authenticationsOrderInformationLineItems": Riskv1authenticationsOrderInformationLineItems,
    "Riskv1authenticationsPaymentInformation": Riskv1authenticationsPaymentInformation,
    "Riskv1authenticationsPaymentInformationCustomer": Riskv1authenticationsPaymentInformationCustomer,
    "Riskv1authenticationsPaymentInformationTokenizedCard": Riskv1authenticationsPaymentInformationTokenizedCard,
    "Riskv1authenticationsRiskInformation": Riskv1authenticationsRiskInformation,
    "Riskv1authenticationsTravelInformation": Riskv1authenticationsTravelInformation,
    "Riskv1authenticationsetupsClientReferenceInformation": Riskv1authenticationsetupsClientReferenceInformation,
    "Riskv1authenticationsetupsPaymentInformation": Riskv1authenticationsetupsPaymentInformation,
    "Riskv1authenticationsetupsPaymentInformationCard": Riskv1authenticationsetupsPaymentInformationCard,
    "Riskv1authenticationsetupsPaymentInformationCustomer": Riskv1authenticationsetupsPaymentInformationCustomer,
    "Riskv1authenticationsetupsPaymentInformationFluidData": Riskv1authenticationsetupsPaymentInformationFluidData,
    "Riskv1authenticationsetupsPaymentInformationTokenizedCard": Riskv1authenticationsetupsPaymentInformationTokenizedCard,
    "Riskv1authenticationsetupsProcessingInformation": Riskv1authenticationsetupsProcessingInformation,
    "Riskv1authenticationsetupsTokenInformation": Riskv1authenticationsetupsTokenInformation,
    "Riskv1decisionsAcquirerInformation": Riskv1decisionsAcquirerInformation,
    "Riskv1decisionsBuyerInformation": Riskv1decisionsBuyerInformation,
    "Riskv1decisionsClientReferenceInformation": Riskv1decisionsClientReferenceInformation,
    "Riskv1decisionsClientReferenceInformationPartner": Riskv1decisionsClientReferenceInformationPartner,
    "Riskv1decisionsConsumerAuthenticationInformation": Riskv1decisionsConsumerAuthenticationInformation,
    "Riskv1decisionsConsumerAuthenticationInformationStrongAuthentication": Riskv1decisionsConsumerAuthenticationInformationStrongAuthentication,
    "Riskv1decisionsDeviceInformation": Riskv1decisionsDeviceInformation,
    "Riskv1decisionsMerchantDefinedInformation": Riskv1decisionsMerchantDefinedInformation,
    "Riskv1decisionsMerchantInformation": Riskv1decisionsMerchantInformation,
    "Riskv1decisionsMerchantInformationMerchantDescriptor": Riskv1decisionsMerchantInformationMerchantDescriptor,
    "Riskv1decisionsOrderInformation": Riskv1decisionsOrderInformation,
    "Riskv1decisionsOrderInformationAmountDetails": Riskv1decisionsOrderInformationAmountDetails,
    "Riskv1decisionsOrderInformationBillTo": Riskv1decisionsOrderInformationBillTo,
    "Riskv1decisionsOrderInformationLineItems": Riskv1decisionsOrderInformationLineItems,
    "Riskv1decisionsOrderInformationShipTo": Riskv1decisionsOrderInformationShipTo,
    "Riskv1decisionsOrderInformationShippingDetails": Riskv1decisionsOrderInformationShippingDetails,
    "Riskv1decisionsPaymentInformation": Riskv1decisionsPaymentInformation,
    "Riskv1decisionsPaymentInformationCard": Riskv1decisionsPaymentInformationCard,
    "Riskv1decisionsPaymentInformationTokenizedCard": Riskv1decisionsPaymentInformationTokenizedCard,
    "Riskv1decisionsProcessingInformation": Riskv1decisionsProcessingInformation,
    "Riskv1decisionsProcessorInformation": Riskv1decisionsProcessorInformation,
    "Riskv1decisionsProcessorInformationAvs": Riskv1decisionsProcessorInformationAvs,
    "Riskv1decisionsProcessorInformationCardVerification": Riskv1decisionsProcessorInformationCardVerification,
    "Riskv1decisionsRiskInformation": Riskv1decisionsRiskInformation,
    "Riskv1decisionsTokenInformation": Riskv1decisionsTokenInformation,
    "Riskv1decisionsTravelInformation": Riskv1decisionsTravelInformation,
    "Riskv1decisionsTravelInformationLegs": Riskv1decisionsTravelInformationLegs,
    "Riskv1decisionsTravelInformationPassengers": Riskv1decisionsTravelInformationPassengers,
    "Riskv1decisionsidactionsDecisionInformation": Riskv1decisionsidactionsDecisionInformation,
    "Riskv1decisionsidactionsProcessingInformation": Riskv1decisionsidactionsProcessingInformation,
    "Riskv1decisionsidmarkingRiskInformation": Riskv1decisionsidmarkingRiskInformation,
    "Riskv1decisionsidmarkingRiskInformationMarkingDetails": Riskv1decisionsidmarkingRiskInformationMarkingDetails,
    "Riskv1exportcomplianceinquiriesDeviceInformation": Riskv1exportcomplianceinquiriesDeviceInformation,
    "Riskv1exportcomplianceinquiriesExportComplianceInformation": Riskv1exportcomplianceinquiriesExportComplianceInformation,
    "Riskv1exportcomplianceinquiriesOrderInformation": Riskv1exportcomplianceinquiriesOrderInformation,
    "Riskv1exportcomplianceinquiriesOrderInformationBillTo": Riskv1exportcomplianceinquiriesOrderInformationBillTo,
    "Riskv1exportcomplianceinquiriesOrderInformationBillToCompany": Riskv1exportcomplianceinquiriesOrderInformationBillToCompany,
    "Riskv1exportcomplianceinquiriesOrderInformationLineItems": Riskv1exportcomplianceinquiriesOrderInformationLineItems,
    "Riskv1exportcomplianceinquiriesOrderInformationShipTo": Riskv1exportcomplianceinquiriesOrderInformationShipTo,
    "Riskv1liststypeentriesBuyerInformation": Riskv1liststypeentriesBuyerInformation,
    "Riskv1liststypeentriesClientReferenceInformation": Riskv1liststypeentriesClientReferenceInformation,
    "Riskv1liststypeentriesDeviceInformation": Riskv1liststypeentriesDeviceInformation,
    "Riskv1liststypeentriesOrderInformation": Riskv1liststypeentriesOrderInformation,
    "Riskv1liststypeentriesOrderInformationAddress": Riskv1liststypeentriesOrderInformationAddress,
    "Riskv1liststypeentriesOrderInformationBillTo": Riskv1liststypeentriesOrderInformationBillTo,
    "Riskv1liststypeentriesOrderInformationLineItems": Riskv1liststypeentriesOrderInformationLineItems,
    "Riskv1liststypeentriesOrderInformationShipTo": Riskv1liststypeentriesOrderInformationShipTo,
    "Riskv1liststypeentriesPaymentInformation": Riskv1liststypeentriesPaymentInformation,
    "Riskv1liststypeentriesPaymentInformationBank": Riskv1liststypeentriesPaymentInformationBank,
    "Riskv1liststypeentriesPaymentInformationCard": Riskv1liststypeentriesPaymentInformationCard,
    "Riskv1liststypeentriesRiskInformation": Riskv1liststypeentriesRiskInformation,
    "Riskv1liststypeentriesRiskInformationMarkingDetails": Riskv1liststypeentriesRiskInformationMarkingDetails,
    "SAConfig": SAConfig,
    "SAConfigCheckout": SAConfigCheckout,
    "SAConfigContactInformation": SAConfigContactInformation,
    "SAConfigNotifications": SAConfigNotifications,
    "SAConfigNotificationsCustomerNotifications": SAConfigNotificationsCustomerNotifications,
    "SAConfigNotificationsMerchantNotifications": SAConfigNotificationsMerchantNotifications,
    "SAConfigPaymentMethods": SAConfigPaymentMethods,
    "SAConfigPaymentTypes": SAConfigPaymentTypes,
    "SAConfigPaymentTypesCardTypes": SAConfigPaymentTypesCardTypes,
    "SAConfigPaymentTypesCardTypesDiscover": SAConfigPaymentTypesCardTypesDiscover,
    "SAConfigService": SAConfigService,
    "SaveAsymEgressKey": SaveAsymEgressKey,
    "SaveSymEgressKey": SaveSymEgressKey,
    "SearchRequest": SearchRequest,
    "ShippingAddressListForCustomer": ShippingAddressListForCustomer,
    "ShippingAddressListForCustomerEmbedded": ShippingAddressListForCustomerEmbedded,
    "ShippingAddressListForCustomerLinks": ShippingAddressListForCustomerLinks,
    "ShippingAddressListForCustomerLinksFirst": ShippingAddressListForCustomerLinksFirst,
    "ShippingAddressListForCustomerLinksLast": ShippingAddressListForCustomerLinksLast,
    "ShippingAddressListForCustomerLinksNext": ShippingAddressListForCustomerLinksNext,
    "ShippingAddressListForCustomerLinksPrev": ShippingAddressListForCustomerLinksPrev,
    "ShippingAddressListForCustomerLinksSelf": ShippingAddressListForCustomerLinksSelf,
    "SuspendSubscriptionResponse": SuspendSubscriptionResponse,
    "SuspendSubscriptionResponseSubscriptionInformation": SuspendSubscriptionResponseSubscriptionInformation,
    "TaxRequest": TaxRequest,
    "TmsAuthorizationOptions": TmsAuthorizationOptions,
    "TmsAuthorizationOptionsInitiator": TmsAuthorizationOptionsInitiator,
    "TmsAuthorizationOptionsInitiatorMerchantInitiatedTransaction": TmsAuthorizationOptionsInitiatorMerchantInitiatedTransaction,
    "TmsBinLookup": TmsBinLookup,
    "TmsBinLookupIssuerInformation": TmsBinLookupIssuerInformation,
    "TmsBinLookupPaymentAccountInformation": TmsBinLookupPaymentAccountInformation,
    "TmsBinLookupPaymentAccountInformationCard": TmsBinLookupPaymentAccountInformationCard,
    "TmsBinLookupPaymentAccountInformationCardBrands": TmsBinLookupPaymentAccountInformationCardBrands,
    "TmsBinLookupPaymentAccountInformationFeatures": TmsBinLookupPaymentAccountInformationFeatures,
    "TmsBinLookupPaymentAccountInformationNetwork": TmsBinLookupPaymentAccountInformationNetwork,
    "TmsBusinessInformation": TmsBusinessInformation,
    "TmsBusinessInformationAcquirer": TmsBusinessInformationAcquirer,
    "TmsBusinessInformationAddress": TmsBusinessInformationAddress,
    "TmsCardArt": TmsCardArt,
    "TmsCardArtBrandLogoAsset": TmsCardArtBrandLogoAsset,
    "TmsCardArtBrandLogoAssetLinks": TmsCardArtBrandLogoAssetLinks,
    "TmsCardArtBrandLogoAssetLinksSelf": TmsCardArtBrandLogoAssetLinksSelf,
    "TmsCardArtCombinedAsset": TmsCardArtCombinedAsset,
    "TmsCardArtCombinedAssetLinks": TmsCardArtCombinedAssetLinks,
    "TmsCardArtCombinedAssetLinksSelf": TmsCardArtCombinedAssetLinksSelf,
    "TmsCardArtIconAsset": TmsCardArtIconAsset,
    "TmsCardArtIconAssetLinks": TmsCardArtIconAssetLinks,
    "TmsCardArtIconAssetLinksSelf": TmsCardArtIconAssetLinksSelf,
    "TmsCardArtIssuerLogoAsset": TmsCardArtIssuerLogoAsset,
    "TmsCardArtIssuerLogoAssetLinks": TmsCardArtIssuerLogoAssetLinks,
    "TmsCardArtIssuerLogoAssetLinksSelf": TmsCardArtIssuerLogoAssetLinksSelf,
    "TmsEmbeddedInstrumentIdentifier": TmsEmbeddedInstrumentIdentifier,
    "TmsEmbeddedInstrumentIdentifierBankAccount": TmsEmbeddedInstrumentIdentifierBankAccount,
    "TmsEmbeddedInstrumentIdentifierBillTo": TmsEmbeddedInstrumentIdentifierBillTo,
    "TmsEmbeddedInstrumentIdentifierCard": TmsEmbeddedInstrumentIdentifierCard,
    "TmsEmbeddedInstrumentIdentifierEmbedded": TmsEmbeddedInstrumentIdentifierEmbedded,
    "TmsEmbeddedInstrumentIdentifierIssuer": TmsEmbeddedInstrumentIdentifierIssuer,
    "TmsEmbeddedInstrumentIdentifierLinks": TmsEmbeddedInstrumentIdentifierLinks,
    "TmsEmbeddedInstrumentIdentifierLinksPaymentInstruments": TmsEmbeddedInstrumentIdentifierLinksPaymentInstruments,
    "TmsEmbeddedInstrumentIdentifierLinksSelf": TmsEmbeddedInstrumentIdentifierLinksSelf,
    "TmsEmbeddedInstrumentIdentifierMetadata": TmsEmbeddedInstrumentIdentifierMetadata,
    "TmsEmbeddedInstrumentIdentifierProcessingInformation": TmsEmbeddedInstrumentIdentifierProcessingInformation,
    "TmsNetworkTokenServices": TmsNetworkTokenServices,
    "TmsNetworkTokenServicesAmericanExpressTokenService": TmsNetworkTokenServicesAmericanExpressTokenService,
    "TmsNetworkTokenServicesMastercardDigitalEnablementService": TmsNetworkTokenServicesMastercardDigitalEnablementService,
    "TmsNetworkTokenServicesNotifications": TmsNetworkTokenServicesNotifications,
    "TmsNetworkTokenServicesPaymentCredentials": TmsNetworkTokenServicesPaymentCredentials,
    "TmsNetworkTokenServicesSynchronousProvisioning": TmsNetworkTokenServicesSynchronousProvisioning,
    "TmsNetworkTokenServicesVisaTokenService": TmsNetworkTokenServicesVisaTokenService,
    "TmsNullify": TmsNullify,
    "TmsPaymentInstrumentProcessingInfo": TmsPaymentInstrumentProcessingInfo,
    "TmsPaymentInstrumentProcessingInfoBankTransferOptions": TmsPaymentInstrumentProcessingInfoBankTransferOptions,
    "TmsSensitivePrivileges": TmsSensitivePrivileges,
    "TmsTokenFormats": TmsTokenFormats,
    "Tmsv2TokenizedCard": Tmsv2TokenizedCard,
    "Tmsv2TokenizedCardCard": Tmsv2TokenizedCardCard,
    "Tmsv2TokenizedCardLinks": Tmsv2TokenizedCardLinks,
    "Tmsv2TokenizedCardLinksSelf": Tmsv2TokenizedCardLinksSelf,
    "Tmsv2TokenizedCardMetadata": Tmsv2TokenizedCardMetadata,
    "Tmsv2TokenizedCardMetadataIssuer": Tmsv2TokenizedCardMetadataIssuer,
    "Tmsv2TokenizedCardPasscode": Tmsv2TokenizedCardPasscode,
    "Tmsv2customersBuyerInformation": Tmsv2customersBuyerInformation,
    "Tmsv2customersClientReferenceInformation": Tmsv2customersClientReferenceInformation,
    "Tmsv2customersDefaultPaymentInstrument": Tmsv2customersDefaultPaymentInstrument,
    "Tmsv2customersDefaultShippingAddress": Tmsv2customersDefaultShippingAddress,
    "Tmsv2customersEmbedded": Tmsv2customersEmbedded,
    "Tmsv2customersEmbeddedDefaultPaymentInstrument": Tmsv2customersEmbeddedDefaultPaymentInstrument,
    "Tmsv2customersEmbeddedDefaultPaymentInstrumentBankAccount": Tmsv2customersEmbeddedDefaultPaymentInstrumentBankAccount,
    "Tmsv2customersEmbeddedDefaultPaymentInstrumentBillTo": Tmsv2customersEmbeddedDefaultPaymentInstrumentBillTo,
    "Tmsv2customersEmbeddedDefaultPaymentInstrumentBuyerInformation": Tmsv2customersEmbeddedDefaultPaymentInstrumentBuyerInformation,
    "Tmsv2customersEmbeddedDefaultPaymentInstrumentBuyerInformationIssuedBy": Tmsv2customersEmbeddedDefaultPaymentInstrumentBuyerInformationIssuedBy,
    "Tmsv2customersEmbeddedDefaultPaymentInstrumentBuyerInformationPersonalIdentification": Tmsv2customersEmbeddedDefaultPaymentInstrumentBuyerInformationPersonalIdentification,
    "Tmsv2customersEmbeddedDefaultPaymentInstrumentCard": Tmsv2customersEmbeddedDefaultPaymentInstrumentCard,
    "Tmsv2customersEmbeddedDefaultPaymentInstrumentCardTokenizedInformation": Tmsv2customersEmbeddedDefaultPaymentInstrumentCardTokenizedInformation,
    "Tmsv2customersEmbeddedDefaultPaymentInstrumentEmbedded": Tmsv2customersEmbeddedDefaultPaymentInstrumentEmbedded,
    "Tmsv2customersEmbeddedDefaultPaymentInstrumentInstrumentIdentifier": Tmsv2customersEmbeddedDefaultPaymentInstrumentInstrumentIdentifier,
    "Tmsv2customersEmbeddedDefaultPaymentInstrumentLinks": Tmsv2customersEmbeddedDefaultPaymentInstrumentLinks,
    "Tmsv2customersEmbeddedDefaultPaymentInstrumentLinksSelf": Tmsv2customersEmbeddedDefaultPaymentInstrumentLinksSelf,
    "Tmsv2customersEmbeddedDefaultPaymentInstrumentMerchantInformation": Tmsv2customersEmbeddedDefaultPaymentInstrumentMerchantInformation,
    "Tmsv2customersEmbeddedDefaultPaymentInstrumentMerchantInformationMerchantDescriptor": Tmsv2customersEmbeddedDefaultPaymentInstrumentMerchantInformationMerchantDescriptor,
    "Tmsv2customersEmbeddedDefaultPaymentInstrumentMetadata": Tmsv2customersEmbeddedDefaultPaymentInstrumentMetadata,
    "Tmsv2customersEmbeddedDefaultShippingAddress": Tmsv2customersEmbeddedDefaultShippingAddress,
    "Tmsv2customersEmbeddedDefaultShippingAddressLinks": Tmsv2customersEmbeddedDefaultShippingAddressLinks,
    "Tmsv2customersEmbeddedDefaultShippingAddressLinksCustomer": Tmsv2customersEmbeddedDefaultShippingAddressLinksCustomer,
    "Tmsv2customersEmbeddedDefaultShippingAddressLinksSelf": Tmsv2customersEmbeddedDefaultShippingAddressLinksSelf,
    "Tmsv2customersEmbeddedDefaultShippingAddressMetadata": Tmsv2customersEmbeddedDefaultShippingAddressMetadata,
    "Tmsv2customersEmbeddedDefaultShippingAddressShipTo": Tmsv2customersEmbeddedDefaultShippingAddressShipTo,
    "Tmsv2customersLinks": Tmsv2customersLinks,
    "Tmsv2customersLinksPaymentInstruments": Tmsv2customersLinksPaymentInstruments,
    "Tmsv2customersLinksSelf": Tmsv2customersLinksSelf,
    "Tmsv2customersLinksShippingAddress": Tmsv2customersLinksShippingAddress,
    "Tmsv2customersMerchantDefinedInformation": Tmsv2customersMerchantDefinedInformation,
    "Tmsv2customersMetadata": Tmsv2customersMetadata,
    "Tmsv2customersObjectInformation": Tmsv2customersObjectInformation,
    "TokenPermissions": TokenPermissions,
    "TokenizedcardRequest": TokenizedcardRequest,
    "TssV2TransactionsGet200Response": TssV2TransactionsGet200Response,
    "TssV2TransactionsGet200ResponseApplicationInformation": TssV2TransactionsGet200ResponseApplicationInformation,
    "TssV2TransactionsGet200ResponseApplicationInformationApplications": TssV2TransactionsGet200ResponseApplicationInformationApplications,
    "TssV2TransactionsGet200ResponseBankAccountValidation": TssV2TransactionsGet200ResponseBankAccountValidation,
    "TssV2TransactionsGet200ResponseBuyerInformation": TssV2TransactionsGet200ResponseBuyerInformation,
    "TssV2TransactionsGet200ResponseClientReferenceInformation": TssV2TransactionsGet200ResponseClientReferenceInformation,
    "TssV2TransactionsGet200ResponseClientReferenceInformationPartner": TssV2TransactionsGet200ResponseClientReferenceInformationPartner,
    "TssV2TransactionsGet200ResponseConsumerAuthenticationInformation": TssV2TransactionsGet200ResponseConsumerAuthenticationInformation,
    "TssV2TransactionsGet200ResponseConsumerAuthenticationInformationStrongAuthentication": TssV2TransactionsGet200ResponseConsumerAuthenticationInformationStrongAuthentication,
    "TssV2TransactionsGet200ResponseDeviceInformation": TssV2TransactionsGet200ResponseDeviceInformation,
    "TssV2TransactionsGet200ResponseErrorInformation": TssV2TransactionsGet200ResponseErrorInformation,
    "TssV2TransactionsGet200ResponseFraudMarkingInformation": TssV2TransactionsGet200ResponseFraudMarkingInformation,
    "TssV2TransactionsGet200ResponseInstallmentInformation": TssV2TransactionsGet200ResponseInstallmentInformation,
    "TssV2TransactionsGet200ResponseLinks": TssV2TransactionsGet200ResponseLinks,
    "TssV2TransactionsGet200ResponseMerchantInformation": TssV2TransactionsGet200ResponseMerchantInformation,
    "TssV2TransactionsGet200ResponseMerchantInformationMerchantDescriptor": TssV2TransactionsGet200ResponseMerchantInformationMerchantDescriptor,
    "TssV2TransactionsGet200ResponseOrderInformation": TssV2TransactionsGet200ResponseOrderInformation,
    "TssV2TransactionsGet200ResponseOrderInformationAmountDetails": TssV2TransactionsGet200ResponseOrderInformationAmountDetails,
    "TssV2TransactionsGet200ResponseOrderInformationBillTo": TssV2TransactionsGet200ResponseOrderInformationBillTo,
    "TssV2TransactionsGet200ResponseOrderInformationInvoiceDetails": TssV2TransactionsGet200ResponseOrderInformationInvoiceDetails,
    "TssV2TransactionsGet200ResponseOrderInformationLineItems": TssV2TransactionsGet200ResponseOrderInformationLineItems,
    "TssV2TransactionsGet200ResponseOrderInformationShipTo": TssV2TransactionsGet200ResponseOrderInformationShipTo,
    "TssV2TransactionsGet200ResponseOrderInformationShippingDetails": TssV2TransactionsGet200ResponseOrderInformationShippingDetails,
    "TssV2TransactionsGet200ResponsePaymentInformation": TssV2TransactionsGet200ResponsePaymentInformation,
    "TssV2TransactionsGet200ResponsePaymentInformationAccountFeatures": TssV2TransactionsGet200ResponsePaymentInformationAccountFeatures,
    "TssV2TransactionsGet200ResponsePaymentInformationBank": TssV2TransactionsGet200ResponsePaymentInformationBank,
    "TssV2TransactionsGet200ResponsePaymentInformationBankAccount": TssV2TransactionsGet200ResponsePaymentInformationBankAccount,
    "TssV2TransactionsGet200ResponsePaymentInformationBankMandate": TssV2TransactionsGet200ResponsePaymentInformationBankMandate,
    "TssV2TransactionsGet200ResponsePaymentInformationBrands": TssV2TransactionsGet200ResponsePaymentInformationBrands,
    "TssV2TransactionsGet200ResponsePaymentInformationCard": TssV2TransactionsGet200ResponsePaymentInformationCard,
    "TssV2TransactionsGet200ResponsePaymentInformationCustomer": TssV2TransactionsGet200ResponsePaymentInformationCustomer,
    "TssV2TransactionsGet200ResponsePaymentInformationFeatures": TssV2TransactionsGet200ResponsePaymentInformationFeatures,
    "TssV2TransactionsGet200ResponsePaymentInformationFluidData": TssV2TransactionsGet200ResponsePaymentInformationFluidData,
    "TssV2TransactionsGet200ResponsePaymentInformationInstrumentIdentifier": TssV2TransactionsGet200ResponsePaymentInformationInstrumentIdentifier,
    "TssV2TransactionsGet200ResponsePaymentInformationInvoice": TssV2TransactionsGet200ResponsePaymentInformationInvoice,
    "TssV2TransactionsGet200ResponsePaymentInformationIssuerInformation": TssV2TransactionsGet200ResponsePaymentInformationIssuerInformation,
    "TssV2TransactionsGet200ResponsePaymentInformationNetwork": TssV2TransactionsGet200ResponsePaymentInformationNetwork,
    "TssV2TransactionsGet200ResponsePaymentInformationPaymentType": TssV2TransactionsGet200ResponsePaymentInformationPaymentType,
    "TssV2TransactionsGet200ResponsePayoutOptions": TssV2TransactionsGet200ResponsePayoutOptions,
    "TssV2TransactionsGet200ResponsePointOfSaleInformation": TssV2TransactionsGet200ResponsePointOfSaleInformation,
    "TssV2TransactionsGet200ResponseProcessingInformation": TssV2TransactionsGet200ResponseProcessingInformation,
    "TssV2TransactionsGet200ResponseProcessingInformationAuthorizationOptions": TssV2TransactionsGet200ResponseProcessingInformationAuthorizationOptions,
    "TssV2TransactionsGet200ResponseProcessingInformationAuthorizationOptionsInitiator": TssV2TransactionsGet200ResponseProcessingInformationAuthorizationOptionsInitiator,
    "TssV2TransactionsGet200ResponseProcessingInformationBankTransferOptions": TssV2TransactionsGet200ResponseProcessingInformationBankTransferOptions,
    "TssV2TransactionsGet200ResponseProcessingInformationCaptureOptions": TssV2TransactionsGet200ResponseProcessingInformationCaptureOptions,
    "TssV2TransactionsGet200ResponseProcessingInformationJapanPaymentOptions": TssV2TransactionsGet200ResponseProcessingInformationJapanPaymentOptions,
    "TssV2TransactionsGet200ResponseProcessorInformation": TssV2TransactionsGet200ResponseProcessorInformation,
    "TssV2TransactionsGet200ResponseProcessorInformationElectronicVerificationResults": TssV2TransactionsGet200ResponseProcessorInformationElectronicVerificationResults,
    "TssV2TransactionsGet200ResponseProcessorInformationMultiProcessorRouting": TssV2TransactionsGet200ResponseProcessorInformationMultiProcessorRouting,
    "TssV2TransactionsGet200ResponseProcessorInformationProcessor": TssV2TransactionsGet200ResponseProcessorInformationProcessor,
    "TssV2TransactionsGet200ResponseRecurringPaymentInformation": TssV2TransactionsGet200ResponseRecurringPaymentInformation,
    "TssV2TransactionsGet200ResponseRiskInformation": TssV2TransactionsGet200ResponseRiskInformation,
    "TssV2TransactionsGet200ResponseRiskInformationProfile": TssV2TransactionsGet200ResponseRiskInformationProfile,
    "TssV2TransactionsGet200ResponseRiskInformationRules": TssV2TransactionsGet200ResponseRiskInformationRules,
    "TssV2TransactionsGet200ResponseRiskInformationScore": TssV2TransactionsGet200ResponseRiskInformationScore,
    "TssV2TransactionsGet200ResponseSenderInformation": TssV2TransactionsGet200ResponseSenderInformation,
    "TssV2TransactionsGet200ResponseTokenInformation": TssV2TransactionsGet200ResponseTokenInformation,
    "TssV2TransactionsPost201Response": TssV2TransactionsPost201Response,
    "TssV2TransactionsPost201ResponseEmbedded": TssV2TransactionsPost201ResponseEmbedded,
    "TssV2TransactionsPost201ResponseEmbeddedApplicationInformation": TssV2TransactionsPost201ResponseEmbeddedApplicationInformation,
    "TssV2TransactionsPost201ResponseEmbeddedApplicationInformationApplications": TssV2TransactionsPost201ResponseEmbeddedApplicationInformationApplications,
    "TssV2TransactionsPost201ResponseEmbeddedClientReferenceInformation": TssV2TransactionsPost201ResponseEmbeddedClientReferenceInformation,
    "TssV2TransactionsPost201ResponseEmbeddedClientReferenceInformationPartner": TssV2TransactionsPost201ResponseEmbeddedClientReferenceInformationPartner,
    "TssV2TransactionsPost201ResponseEmbeddedConsumerAuthenticationInformation": TssV2TransactionsPost201ResponseEmbeddedConsumerAuthenticationInformation,
    "TssV2TransactionsPost201ResponseEmbeddedErrorInformation": TssV2TransactionsPost201ResponseEmbeddedErrorInformation,
    "TssV2TransactionsPost201ResponseEmbeddedLinks": TssV2TransactionsPost201ResponseEmbeddedLinks,
    "TssV2TransactionsPost201ResponseEmbeddedMerchantInformation": TssV2TransactionsPost201ResponseEmbeddedMerchantInformation,
    "TssV2TransactionsPost201ResponseEmbeddedOrderInformation": TssV2TransactionsPost201ResponseEmbeddedOrderInformation,
    "TssV2TransactionsPost201ResponseEmbeddedOrderInformationBillTo": TssV2TransactionsPost201ResponseEmbeddedOrderInformationBillTo,
    "TssV2TransactionsPost201ResponseEmbeddedOrderInformationShipTo": TssV2TransactionsPost201ResponseEmbeddedOrderInformationShipTo,
    "TssV2TransactionsPost201ResponseEmbeddedPaymentInformation": TssV2TransactionsPost201ResponseEmbeddedPaymentInformation,
    "TssV2TransactionsPost201ResponseEmbeddedPaymentInformationBank": TssV2TransactionsPost201ResponseEmbeddedPaymentInformationBank,
    "TssV2TransactionsPost201ResponseEmbeddedPaymentInformationBankAccount": TssV2TransactionsPost201ResponseEmbeddedPaymentInformationBankAccount,
    "TssV2TransactionsPost201ResponseEmbeddedPaymentInformationCard": TssV2TransactionsPost201ResponseEmbeddedPaymentInformationCard,
    "TssV2TransactionsPost201ResponseEmbeddedPaymentInformationPaymentType": TssV2TransactionsPost201ResponseEmbeddedPaymentInformationPaymentType,
    "TssV2TransactionsPost201ResponseEmbeddedPointOfSaleInformation": TssV2TransactionsPost201ResponseEmbeddedPointOfSaleInformation,
    "TssV2TransactionsPost201ResponseEmbeddedPointOfSaleInformationPartner": TssV2TransactionsPost201ResponseEmbeddedPointOfSaleInformationPartner,
    "TssV2TransactionsPost201ResponseEmbeddedProcessingInformation": TssV2TransactionsPost201ResponseEmbeddedProcessingInformation,
    "TssV2TransactionsPost201ResponseEmbeddedProcessorInformation": TssV2TransactionsPost201ResponseEmbeddedProcessorInformation,
    "TssV2TransactionsPost201ResponseEmbeddedRiskInformation": TssV2TransactionsPost201ResponseEmbeddedRiskInformation,
    "TssV2TransactionsPost201ResponseEmbeddedRiskInformationProviders": TssV2TransactionsPost201ResponseEmbeddedRiskInformationProviders,
    "TssV2TransactionsPost201ResponseEmbeddedRiskInformationProvidersFingerprint": TssV2TransactionsPost201ResponseEmbeddedRiskInformationProvidersFingerprint,
    "TssV2TransactionsPost201ResponseEmbeddedTransactionSummaries": TssV2TransactionsPost201ResponseEmbeddedTransactionSummaries,
    "UmsV1UsersGet200Response": UmsV1UsersGet200Response,
    "UmsV1UsersGet200ResponseAccountInformation": UmsV1UsersGet200ResponseAccountInformation,
    "UmsV1UsersGet200ResponseContactInformation": UmsV1UsersGet200ResponseContactInformation,
    "UmsV1UsersGet200ResponseOrganizationInformation": UmsV1UsersGet200ResponseOrganizationInformation,
    "UmsV1UsersGet200ResponseUsers": UmsV1UsersGet200ResponseUsers,
    "UpdateInvoiceRequest": UpdateInvoiceRequest,
    "UpdateOrderRequest": UpdateOrderRequest,
    "UpdatePaymentLinkRequest": UpdatePaymentLinkRequest,
    "UpdatePlanRequest": UpdatePlanRequest,
    "UpdatePlanResponse": UpdatePlanResponse,
    "UpdatePlanResponsePlanInformation": UpdatePlanResponsePlanInformation,
    "UpdateStatus": UpdateStatus,
    "UpdateSubscription": UpdateSubscription,
    "UpdateSubscriptionResponse": UpdateSubscriptionResponse,
    "UpdateWebhook": UpdateWebhook,
    "Upv1capturecontextsCaptureMandate": Upv1capturecontextsCaptureMandate,
    "Upv1capturecontextsCompleteMandate": Upv1capturecontextsCompleteMandate,
    "Upv1capturecontextsOrderInformation": Upv1capturecontextsOrderInformation,
    "Upv1capturecontextsOrderInformationAmountDetails": Upv1capturecontextsOrderInformationAmountDetails,
    "Upv1capturecontextsOrderInformationBillTo": Upv1capturecontextsOrderInformationBillTo,
    "Upv1capturecontextsOrderInformationBillToCompany": Upv1capturecontextsOrderInformationBillToCompany,
    "Upv1capturecontextsOrderInformationShipTo": Upv1capturecontextsOrderInformationShipTo,
    "V1FileDetailsGet200Response": V1FileDetailsGet200Response,
    "V1FileDetailsGet200ResponseFileDetails": V1FileDetailsGet200ResponseFileDetails,
    "V1FileDetailsGet200ResponseLinks": V1FileDetailsGet200ResponseLinks,
    "V1FileDetailsGet200ResponseLinksFiles": V1FileDetailsGet200ResponseLinksFiles,
    "V1FileDetailsGet200ResponseLinksSelf": V1FileDetailsGet200ResponseLinksSelf,
    "VTConfig": VTConfig,
    "VTConfigCardNotPresent": VTConfigCardNotPresent,
    "VTConfigCardNotPresentGlobalPaymentInformation": VTConfigCardNotPresentGlobalPaymentInformation,
    "VTConfigCardNotPresentGlobalPaymentInformationBasicInformation": VTConfigCardNotPresentGlobalPaymentInformationBasicInformation,
    "VTConfigCardNotPresentGlobalPaymentInformationMerchantDefinedDataFields": VTConfigCardNotPresentGlobalPaymentInformationMerchantDefinedDataFields,
    "VTConfigCardNotPresentGlobalPaymentInformationPaymentInformation": VTConfigCardNotPresentGlobalPaymentInformationPaymentInformation,
    "VTConfigCardNotPresentReceiptInformation": VTConfigCardNotPresentReceiptInformation,
    "VTConfigCardNotPresentReceiptInformationEmailReceipt": VTConfigCardNotPresentReceiptInformationEmailReceipt,
    "VTConfigCardNotPresentReceiptInformationHeader": VTConfigCardNotPresentReceiptInformationHeader,
    "VTConfigCardNotPresentReceiptInformationOrderInformation": VTConfigCardNotPresentReceiptInformationOrderInformation,
    "ValidateExportComplianceRequest": ValidateExportComplianceRequest,
    "ValidateRequest": ValidateRequest,
    "ValueAddedServicesProducts": ValueAddedServicesProducts,
    "VasV2PaymentsPost201Response": VasV2PaymentsPost201Response,
    "VasV2PaymentsPost201ResponseLinks": VasV2PaymentsPost201ResponseLinks,
    "VasV2PaymentsPost201ResponseOrderInformation": VasV2PaymentsPost201ResponseOrderInformation,
    "VasV2PaymentsPost201ResponseOrderInformationJurisdiction": VasV2PaymentsPost201ResponseOrderInformationJurisdiction,
    "VasV2PaymentsPost201ResponseOrderInformationLineItems": VasV2PaymentsPost201ResponseOrderInformationLineItems,
    "VasV2PaymentsPost201ResponseOrderInformationTaxDetails": VasV2PaymentsPost201ResponseOrderInformationTaxDetails,
    "VasV2PaymentsPost201ResponseTaxInformation": VasV2PaymentsPost201ResponseTaxInformation,
    "VasV2PaymentsPost400Response": VasV2PaymentsPost400Response,
    "VasV2TaxVoid200Response": VasV2TaxVoid200Response,
    "VasV2TaxVoid200ResponseVoidAmountDetails": VasV2TaxVoid200ResponseVoidAmountDetails,
    "VasV2TaxVoidsPost400Response": VasV2TaxVoidsPost400Response,
    "Vasv2taxBuyerInformation": Vasv2taxBuyerInformation,
    "Vasv2taxClientReferenceInformation": Vasv2taxClientReferenceInformation,
    "Vasv2taxMerchantInformation": Vasv2taxMerchantInformation,
    "Vasv2taxOrderInformation": Vasv2taxOrderInformation,
    "Vasv2taxOrderInformationBillTo": Vasv2taxOrderInformationBillTo,
    "Vasv2taxOrderInformationInvoiceDetails": Vasv2taxOrderInformationInvoiceDetails,
    "Vasv2taxOrderInformationLineItems": Vasv2taxOrderInformationLineItems,
    "Vasv2taxOrderInformationOrderAcceptance": Vasv2taxOrderInformationOrderAcceptance,
    "Vasv2taxOrderInformationOrderOrigin": Vasv2taxOrderInformationOrderOrigin,
    "Vasv2taxOrderInformationShipTo": Vasv2taxOrderInformationShipTo,
    "Vasv2taxOrderInformationShippingDetails": Vasv2taxOrderInformationShippingDetails,
    "Vasv2taxTaxInformation": Vasv2taxTaxInformation,
    "Vasv2taxidClientReferenceInformation": Vasv2taxidClientReferenceInformation,
    "Vasv2taxidClientReferenceInformationPartner": Vasv2taxidClientReferenceInformationPartner,
    "VerifyCustomerAddressRequest": VerifyCustomerAddressRequest,
    "VoidCaptureRequest": VoidCaptureRequest,
    "VoidCreditRequest": VoidCreditRequest,
    "VoidPaymentRequest": VoidPaymentRequest,
    "VoidRefundRequest": VoidRefundRequest,
    "VoidTaxRequest": VoidTaxRequest,
}

export interface Authentication {
    /**
    * Apply authentication settings to header and query params.
    */
    applyToRequest(requestOptions: localVarRequest.Options): void;
}

export class HttpBasicAuth implements Authentication {
    public username: string = '';
    public password: string = '';

    applyToRequest(requestOptions: localVarRequest.Options): void {
        requestOptions.auth = {
            username: this.username, password: this.password
        }
    }
}

export class ApiKeyAuth implements Authentication {
    public apiKey: string = '';

    constructor(private location: string, private paramName: string) {
    }

    applyToRequest(requestOptions: localVarRequest.Options): void {
        if (this.location == "query") {
            (<any>requestOptions.qs)[this.paramName] = this.apiKey;
        } else if (this.location == "header" && requestOptions && requestOptions.headers) {
            requestOptions.headers[this.paramName] = this.apiKey;
        }
    }
}

export class OAuth implements Authentication {
    public accessToken: string = '';

    applyToRequest(requestOptions: localVarRequest.Options): void {
        if (requestOptions && requestOptions.headers) {
            requestOptions.headers["Authorization"] = "Bearer " + this.accessToken;
        }
    }
}

export class VoidAuth implements Authentication {
    public username: string = '';
    public password: string = '';

    applyToRequest(_: localVarRequest.Options): void {
        // Do nothing
    }
}

export enum ActivationCodesAndCertificatesApiApiKeys {
}

export class ActivationCodesAndCertificatesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ActivationCodesAndCertificatesApiApiKeys, value: string) {
        (this.authentications as any)[ActivationCodesAndCertificatesApiApiKeys[key]].apiKey = value;
    }
    /**
     * Returns a list of activation codes for acceptance devices solution
     * @summary Returns a list of activation codes for acceptance devices solution
     * @param merchantId 
     * @param size 
     * @param {*} [options] Override http request options.
     */
    public generateActivationCodes (merchantId: string, size: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: InlineResponse2019;  }> {
        const localVarPath = this.basePath + '/dms/merchants/{merchantId}/activation-codes'
            .replace('{' + 'merchantId' + '}', encodeURIComponent(String(merchantId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'merchantId' is not null or undefined
        if (merchantId === null || merchantId === undefined) {
            throw new Error('Required parameter merchantId was null or undefined when calling generateActivationCodes.');
        }

        // verify required parameter 'size' is not null or undefined
        if (size === null || size === undefined) {
            throw new Error('Required parameter size was null or undefined when calling generateActivationCodes.');
        }

        if (size !== undefined) {
            localVarQueryParameters['size'] = ObjectSerializer.serialize(size, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse2019;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "InlineResponse2019");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Returns expirations dates of certificates installed on devices activated with acceptance devices products
     * @summary Returns expirations dates of certificates installed on devices activated with acceptance devices products
     * @param merchantId 
     * @param {*} [options] Override http request options.
     */
    public getCertificateExpirations (merchantId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: InlineResponse20010;  }> {
        const localVarPath = this.basePath + '/dms/v2/devices/certificates/expirations';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'merchantId' is not null or undefined
        if (merchantId === null || merchantId === undefined) {
            throw new Error('Required parameter merchantId was null or undefined when calling getCertificateExpirations.');
        }

        if (merchantId !== undefined) {
            localVarQueryParameters['merchantId'] = ObjectSerializer.serialize(merchantId, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse20010;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "InlineResponse20010");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * This string representation of certificate can be used to establish TLS communication for the acceptance devices product
     * @summary Returns the string representation of certificate of the certificate issuing authority
     * @param {*} [options] Override http request options.
     */
    public getRootCA (options: any = {}) : Promise<{ response: http.ClientResponse; body: InlineResponse2009;  }> {
        const localVarPath = this.basePath + '/dms/v2/devices/certificates/rootca';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse2009;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "InlineResponse2009");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Revoke the certificate of the specified device of the specified merchant
     * @summary Revoke the certificate of the specified device of the specified merchant
     * @param revokeCertificateRequest Merchant and device details to revoke it&#39;s certificate
     * @param {*} [options] Override http request options.
     */
    public revokeCertificates (revokeCertificateRequest?: RevokeCertificateRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/dms/v2/devices/certificates/revoke';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(revokeCertificateRequest, "RevokeCertificateRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum BatchesApiApiKeys {
}

export class BatchesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: BatchesApiApiKeys, value: string) {
        (this.authentications as any)[BatchesApiApiKeys[key]].apiKey = value;
    }
    /**
     * **Get Batch Report**<br>This resource accepts a batch id and returns: - The batch status. - The total number of accepted, rejected, updated records. - The total number of card association responses. - The billable quantities of:   - New Account Numbers (NAN)   - New Expiry Dates (NED)   - Account Closures (ACL)   - Contact Card Holders (CCH) - Source record information including token ids, masked card number, expiration dates & card type. - Response record information including response code, reason, token ids, masked card number, expiration dates & card type. 
     * @summary Retrieve a Batch Report
     * @param batchId Unique identification number assigned to the submitted request.
     * @param {*} [options] Override http request options.
     */
    public getBatchReport (batchId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: InlineResponse20014;  }> {
        const localVarPath = this.basePath + '/accountupdater/v1/batches/{batchId}/report'
            .replace('{' + 'batchId' + '}', encodeURIComponent(String(batchId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'batchId' is not null or undefined
        if (batchId === null || batchId === undefined) {
            throw new Error('Required parameter batchId was null or undefined when calling getBatchReport.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse20014;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "InlineResponse20014");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * **Get Batch Status**<br>This resource accepts a batch id and returns: - The batch status. - The total number of accepted, rejected, updated records. - The total number of card association responses. - The billable quantities of:   - New Account Numbers (NAN)   - New Expiry Dates (NED)   - Account Closures (ACL)   - Contact Card Holders (CCH) 
     * @summary Retrieve a Batch Status
     * @param batchId Unique identification number assigned to the submitted request.
     * @param {*} [options] Override http request options.
     */
    public getBatchStatus (batchId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: InlineResponse20013;  }> {
        const localVarPath = this.basePath + '/accountupdater/v1/batches/{batchId}/status'
            .replace('{' + 'batchId' + '}', encodeURIComponent(String(batchId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'batchId' is not null or undefined
        if (batchId === null || batchId === undefined) {
            throw new Error('Required parameter batchId was null or undefined when calling getBatchStatus.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse20013;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "InlineResponse20013");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * **List Batches**<br>This resource accepts a optional date range, record offset and limit, returning a paginated response of batches containing: - The batch id. - The batch status. - The batch created / modified dates. - The total number of accepted, rejected, updated records. - The total number of card association responses. 
     * @summary List Batches
     * @param offset Starting record in zero-based dataset that should be returned as the first object in the array.
     * @param limit The maximum number that can be returned in the array starting from the offset record in zero-based dataset.
     * @param fromDate ISO-8601 format: yyyyMMddTHHmmssZ
     * @param toDate ISO-8601 format: yyyyMMddTHHmmssZ
     * @param {*} [options] Override http request options.
     */
    public getBatchesList (offset?: number, limit?: number, fromDate?: string, toDate?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: InlineResponse20012;  }> {
        const localVarPath = this.basePath + '/accountupdater/v1/batches';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (fromDate !== undefined) {
            localVarQueryParameters['fromDate'] = ObjectSerializer.serialize(fromDate, "string");
        }

        if (toDate !== undefined) {
            localVarQueryParameters['toDate'] = ObjectSerializer.serialize(toDate, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse20012;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "InlineResponse20012");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * **Create a Batch**<br>This resource accepts TMS tokens ids of a Customer, Payment Instrument or Instrument Identifier. <br> The card numbers for the supplied tokens ids are then sent to the relevant card associations to check for updates.<br>The following type of batches can be submitted: -  **oneOff** batch containing tokens id for Visa or MasterCard card numbers. - **amexRegistration** batch containing tokens id for Amex card numbers.  A batch id will be returned on a successful response which can be used to get the batch status and the batch report. The availability of API features for a merchant may depend on the portfolio configuration and may need to be enabled at the portfolio level before they can be added to merchant accounts. 
     * @summary Create a Batch
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public postBatch (body: Body, options: any = {}) : Promise<{ response: http.ClientResponse; body: InlineResponse202;  }> {
        const localVarPath = this.basePath + '/accountupdater/v1/batches';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postBatch.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "Body")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse202;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "InlineResponse202");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum BillingAgreementsApiApiKeys {
}

export class BillingAgreementsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: BillingAgreementsApiApiKeys, value: string) {
        (this.authentications as any)[BillingAgreementsApiApiKeys[key]].apiKey = value;
    }
    /**
     * #### Standing Instruction: Standing Instruction with or without Token.  #### Revoke Mandate: When you revoke a mandate, any pending direct debits linked to that mandate are canceled. No notifications are sent. When you revoke a mandate with no pending direct debits, the Bacs scheme or customer’s bank notify you of any subsequent direct debit events. When you revoke a mandate, you cannot send a direct debit request using the mandate ID. Customer payments cannot be made against a revoked mandate. You can revoke a mandate when the customer:   - Requests that you revoke the mandate.   - Closes their account with you. Possible revoke mandate status values -   - Revoked—the revoke mandate request was successfully processed.   - Failed—the revoke mandate request was not accepted.  #### Update Mandate: In most cases, the account details of an existing mandate cannot be updated in the Bacs schema, except by creating a new mandate. However, some very limited customer information, like name and address, can be updated to the mandate without needing to revoke it first  #### Mandate Status: After the customer signs the mandate, request that the mandate status service verify the mandate status. Possible mandate status values:   - Active—the mandate is successfully created. A direct debit can be sent for this mandate ID.   - Pending—a pending mandate means the mandate is not yet signed.   - Failed—the customer did not authenticate.   - Expired—the deadline to create the mandate passed.   - Revoked—the mandate is cancelled.  #### Paypal Billing Agreement:  A billing agreement is set up between PayPal and your customer. When you collect the details of a customer’s billing agreement, you are able to bill that customer without requiring an authorization for each payment.  You can bill the customer at the same time you process their PayPal Express checkout order, which simplifies your business processes. 
     * @summary Modify a Billing Agreement
     * @param modifyBillingAgreement 
     * @param id ID for de-registration or cancellation of Billing Agreement
     * @param {*} [options] Override http request options.
     */
    public billingAgreementsDeRegistration (modifyBillingAgreement: ModifyBillingAgreement, id: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: PtsV2ModifyBillingAgreementPost201Response;  }> {
        const localVarPath = this.basePath + '/pts/v2/billing-agreements/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'modifyBillingAgreement' is not null or undefined
        if (modifyBillingAgreement === null || modifyBillingAgreement === undefined) {
            throw new Error('Required parameter modifyBillingAgreement was null or undefined when calling billingAgreementsDeRegistration.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling billingAgreementsDeRegistration.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(modifyBillingAgreement, "ModifyBillingAgreement")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PtsV2ModifyBillingAgreementPost201Response;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PtsV2ModifyBillingAgreementPost201Response");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Standing Instruction with or without Token.
     * @summary Standing Instruction intimation
     * @param intimateBillingAgreement 
     * @param id ID for intimation of Billing Agreement
     * @param {*} [options] Override http request options.
     */
    public billingAgreementsIntimation (intimateBillingAgreement: IntimateBillingAgreement, id: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: PtsV2CreditsPost201Response1;  }> {
        const localVarPath = this.basePath + '/pts/v2/billing-agreements/{id}/intimations'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'intimateBillingAgreement' is not null or undefined
        if (intimateBillingAgreement === null || intimateBillingAgreement === undefined) {
            throw new Error('Required parameter intimateBillingAgreement was null or undefined when calling billingAgreementsIntimation.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling billingAgreementsIntimation.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(intimateBillingAgreement, "IntimateBillingAgreement")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PtsV2CreditsPost201Response1;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PtsV2CreditsPost201Response1");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * #### Standing Instruction: Standing Instruction with or without Token. Transaction amount in case First payment is coming along with registration. Only 2 decimal places allowed  #### Create Mandate: You can create a mandate through the direct debit mandate flow. Possible create mandate status values:   - Pending—the create mandate request was successfully processed.   - Failed—the create mandate request was not accepted.  #### Import Mandate: In the Bacs scheme, a mandate is created with a status of active. Direct debit collections can be made against it immediately. You can import a mandate to the CyberSource database when:   - You have existing customers with signed, active mandates   - You manage mandates outside of CyberSource.  When you import an existing mandate to the CyberSource database, provide a unique value for the mandate ID or the request results in an error. If an import mandate request is not accepted, the import mandate status value is failed. 
     * @summary Create a Billing Agreement
     * @param createBillingAgreement 
     * @param {*} [options] Override http request options.
     */
    public billingAgreementsRegistration (createBillingAgreement: CreateBillingAgreement, options: any = {}) : Promise<{ response: http.ClientResponse; body: PtsV2CreateBillingAgreementPost201Response;  }> {
        const localVarPath = this.basePath + '/pts/v2/billing-agreements';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'createBillingAgreement' is not null or undefined
        if (createBillingAgreement === null || createBillingAgreement === undefined) {
            throw new Error('Required parameter createBillingAgreement was null or undefined when calling billingAgreementsRegistration.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(createBillingAgreement, "CreateBillingAgreement")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PtsV2CreateBillingAgreementPost201Response;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PtsV2CreateBillingAgreementPost201Response");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum BinLookupApiApiKeys {
}

export class BinLookupApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: BinLookupApiApiKeys, value: string) {
        (this.authentications as any)[BinLookupApiApiKeys[key]].apiKey = value;
    }
    /**
     * The BIN Lookup Service is a versatile business tool that provides card network agnostic solution designed to ensure frictionless transaction experience by utilizing up-to-date Bank Identification Number (BIN) attributes sourced from multiple global and regional data sources. This service helps to improve authorization rates by helping to route transactions to the best-suited card network, minimizes fraud through card detail verification and aids in regulatory compliance by identifying card properties. The service is flexible and provides businesses with a flexible choice of inputs such as primary account number (PAN), network token from major networks (such as Visa, American Express, Discover and several regional networks) which includes device PAN (DPAN), and all types of tokens generated via CyberSource Token Management Service (TMS). Currently, the range of available credentials is contingent on the networks enabled for the business entity. Therefore, the network information specified in this documentation is illustrative and subject to personalized offerings for each reseller or merchant. 
     * @summary BIN Lookup API
     * @param createBinLookupRequest 
     * @param {*} [options] Override http request options.
     */
    public getAccountInfo (createBinLookupRequest: CreateBinLookupRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: InlineResponse2012;  }> {
        const localVarPath = this.basePath + '/bin/v1/binlookup';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'createBinLookupRequest' is not null or undefined
        if (createBinLookupRequest === null || createBinLookupRequest === undefined) {
            throw new Error('Required parameter createBinLookupRequest was null or undefined when calling getAccountInfo.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(createBinLookupRequest, "CreateBinLookupRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse2012;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "InlineResponse2012");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum CaptureApiApiKeys {
}

export class CaptureApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: CaptureApiApiKeys, value: string) {
        (this.authentications as any)[CaptureApiApiKeys[key]].apiKey = value;
    }
    /**
     * Include the payment ID in the POST request to capture the payment amount.
     * @summary Capture a Payment
     * @param capturePaymentRequest 
     * @param id The payment ID returned from a previous payment request. This ID links the capture to the payment. 
     * @param {*} [options] Override http request options.
     */
    public capturePayment (capturePaymentRequest: CapturePaymentRequest, id: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: PtsV2PaymentsCapturesPost201Response;  }> {
        const localVarPath = this.basePath + '/pts/v2/payments/{id}/captures'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'capturePaymentRequest' is not null or undefined
        if (capturePaymentRequest === null || capturePaymentRequest === undefined) {
            throw new Error('Required parameter capturePaymentRequest was null or undefined when calling capturePayment.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling capturePayment.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(capturePaymentRequest, "CapturePaymentRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PtsV2PaymentsCapturesPost201Response;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PtsV2PaymentsCapturesPost201Response");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ChargebackDetailsApiApiKeys {
}

export class ChargebackDetailsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ChargebackDetailsApiApiKeys, value: string) {
        (this.authentications as any)[ChargebackDetailsApiApiKeys[key]].apiKey = value;
    }
    /**
     * Chargeback Detail Report Description
     * @summary Get Chargeback Details
     * @param startTime Valid report Start Time in **ISO 8601 format** Please refer the following link to know more about ISO 8601 format.[Rfc Date Format](https://xml2rfc.tools.ietf.org/public/rfc/html/rfc3339.html#anchor14)  **Example date format:**   - yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ (e.g. 2018-01-01T00:00:00.000Z) 
     * @param endTime Valid report End Time in **ISO 8601 format** Please refer the following link to know more about ISO 8601 format.[Rfc Date Format](https://xml2rfc.tools.ietf.org/public/rfc/html/rfc3339.html#anchor14)  **Example date format:**   - yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ (e.g. 2018-01-01T00:00:00.000Z) 
     * @param organizationId Valid Organization Id
     * @param {*} [options] Override http request options.
     */
    public getChargebackDetails (startTime: Date, endTime: Date, organizationId?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: ReportingV3ChargebackDetailsGet200Response;  }> {
        const localVarPath = this.basePath + '/reporting/v3/chargeback-details';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'startTime' is not null or undefined
        if (startTime === null || startTime === undefined) {
            throw new Error('Required parameter startTime was null or undefined when calling getChargebackDetails.');
        }

        // verify required parameter 'endTime' is not null or undefined
        if (endTime === null || endTime === undefined) {
            throw new Error('Required parameter endTime was null or undefined when calling getChargebackDetails.');
        }

        if (startTime !== undefined) {
            localVarQueryParameters['startTime'] = ObjectSerializer.serialize(startTime, "Date");
        }

        if (endTime !== undefined) {
            localVarQueryParameters['endTime'] = ObjectSerializer.serialize(endTime, "Date");
        }

        if (organizationId !== undefined) {
            localVarQueryParameters['organizationId'] = ObjectSerializer.serialize(organizationId, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ReportingV3ChargebackDetailsGet200Response;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ReportingV3ChargebackDetailsGet200Response");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ChargebackSummariesApiApiKeys {
}

export class ChargebackSummariesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ChargebackSummariesApiApiKeys, value: string) {
        (this.authentications as any)[ChargebackSummariesApiApiKeys[key]].apiKey = value;
    }
    /**
     * Chargeback Summary Report Description
     * @summary Get Chargeback Summaries
     * @param startTime Valid report Start Time in **ISO 8601 format** Please refer the following link to know more about ISO 8601 format.[Rfc Date Format](https://xml2rfc.tools.ietf.org/public/rfc/html/rfc3339.html#anchor14)  **Example date format:**   - yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ (e.g. 2018-01-01T00:00:00.000Z) 
     * @param endTime Valid report End Time in **ISO 8601 format** Please refer the following link to know more about ISO 8601 format.[Rfc Date Format](https://xml2rfc.tools.ietf.org/public/rfc/html/rfc3339.html#anchor14)  **Example date format:**   - yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ (e.g. 2018-01-01T00:00:00.000Z) 
     * @param organizationId Valid Organization Id
     * @param {*} [options] Override http request options.
     */
    public getChargebackSummaries (startTime: Date, endTime: Date, organizationId?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: ReportingV3ChargebackSummariesGet200Response;  }> {
        const localVarPath = this.basePath + '/reporting/v3/chargeback-summaries';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'startTime' is not null or undefined
        if (startTime === null || startTime === undefined) {
            throw new Error('Required parameter startTime was null or undefined when calling getChargebackSummaries.');
        }

        // verify required parameter 'endTime' is not null or undefined
        if (endTime === null || endTime === undefined) {
            throw new Error('Required parameter endTime was null or undefined when calling getChargebackSummaries.');
        }

        if (startTime !== undefined) {
            localVarQueryParameters['startTime'] = ObjectSerializer.serialize(startTime, "Date");
        }

        if (endTime !== undefined) {
            localVarQueryParameters['endTime'] = ObjectSerializer.serialize(endTime, "Date");
        }

        if (organizationId !== undefined) {
            localVarQueryParameters['organizationId'] = ObjectSerializer.serialize(organizationId, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ReportingV3ChargebackSummariesGet200Response;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ReportingV3ChargebackSummariesGet200Response");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ConversionDetailsApiApiKeys {
}

export class ConversionDetailsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ConversionDetailsApiApiKeys, value: string) {
        (this.authentications as any)[ConversionDetailsApiApiKeys[key]].apiKey = value;
    }
    /**
     * Get conversion detail of transactions for a merchant.
     * @summary Get Conversion Detail Transactions
     * @param startTime Valid report Start Time in **ISO 8601 format** Please refer the following link to know more about ISO 8601 format.[Rfc Date Format](https://xml2rfc.tools.ietf.org/public/rfc/html/rfc3339.html#anchor14)  **Example date format:**   - yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ (e.g. 2018-01-01T00:00:00.000Z) 
     * @param endTime Valid report End Time in **ISO 8601 format** Please refer the following link to know more about ISO 8601 format.[Rfc Date Format](https://xml2rfc.tools.ietf.org/public/rfc/html/rfc3339.html#anchor14)  **Example date format:**   - yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ (e.g. 2018-01-01T00:00:00.000Z) 
     * @param organizationId Valid Organization Id
     * @param {*} [options] Override http request options.
     */
    public getConversionDetail (startTime: Date, endTime: Date, organizationId?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: ReportingV3ConversionDetailsGet200Response;  }> {
        const localVarPath = this.basePath + '/reporting/v3/conversion-details';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'startTime' is not null or undefined
        if (startTime === null || startTime === undefined) {
            throw new Error('Required parameter startTime was null or undefined when calling getConversionDetail.');
        }

        // verify required parameter 'endTime' is not null or undefined
        if (endTime === null || endTime === undefined) {
            throw new Error('Required parameter endTime was null or undefined when calling getConversionDetail.');
        }

        if (startTime !== undefined) {
            localVarQueryParameters['startTime'] = ObjectSerializer.serialize(startTime, "Date");
        }

        if (endTime !== undefined) {
            localVarQueryParameters['endTime'] = ObjectSerializer.serialize(endTime, "Date");
        }

        if (organizationId !== undefined) {
            localVarQueryParameters['organizationId'] = ObjectSerializer.serialize(organizationId, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ReportingV3ConversionDetailsGet200Response;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ReportingV3ConversionDetailsGet200Response");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum CreateAndUpdateDevicesApiApiKeys {
}

export class CreateAndUpdateDevicesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: CreateAndUpdateDevicesApiApiKeys, value: string) {
        (this.authentications as any)[CreateAndUpdateDevicesApiApiKeys[key]].apiKey = value;
    }
    /**
     * Create a device or terminal for a merchant.
     * @summary Create device or terminal
     * @param body A new device or terminal.
     * @param {*} [options] Override http request options.
     */
    public createDevice (body?: Body, options: any = {}) : Promise<{ response: http.ClientResponse; body: InlineResponse2018;  }> {
        const localVarPath = this.basePath + '/dms/v2/devices';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "Body")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse2018;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "InlineResponse2018");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update a device or terminal for a merchant.
     * @summary Update a device or terminal
     * @param id Device ID
     * @param body Update a device or terminal.
     * @param {*} [options] Override http request options.
     */
    public updateDevice (id: string, body?: Body1, options: any = {}) : Promise<{ response: http.ClientResponse; body: InlineResponse2006;  }> {
        const localVarPath = this.basePath + '/dms/v2/devices/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateDevice.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "Body1")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse2006;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "InlineResponse2006");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum CreateNewWebhooksApiApiKeys {
}

export class CreateNewWebhooksApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: CreateNewWebhooksApiApiKeys, value: string) {
        (this.authentications as any)[CreateNewWebhooksApiApiKeys[key]].apiKey = value;
    }
    /**
     * Retrieve a list of products and event types that your account is eligible for. These products and events are the ones that you may subscribe to in the next step of creating webhooks.
     * @summary Find Products You Can Subscribe To
     * @param organizationId The Organization Identifier.
     * @param {*} [options] Override http request options.
     */
    public findProductsToSubscribe (organizationId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<InlineResponse2003>;  }> {
        const localVarPath = this.basePath + '/notification-subscriptions/v2/products/{organizationId}'
            .replace('{' + 'organizationId' + '}', encodeURIComponent(String(organizationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'organizationId' is not null or undefined
        if (organizationId === null || organizationId === undefined) {
            throw new Error('Required parameter organizationId was null or undefined when calling findProductsToSubscribe.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<InlineResponse2003>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<InlineResponse2003>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create a new webhook subscription. Before creating a webhook, ensure that a signature key has been created.  For the example \"Create Webhook using oAuth with Client Credentials\" - for clients who have more than one oAuth Provider and have different client secrets that they would like to config for a given webhook, they may do so by overriding the keyId inside security config of webhook subscription. See the Developer Center examples section titled \"Webhook Security - Create or Store Egress Symmetric Key - Store oAuth Credentials For Symmetric Key\" to store these oAuth credentials that CYBS will need for oAuth.  For JWT authentication, attach your oAuth details to the webhook subscription. See the example \"Create Webhook using oAuth with JWT\" 
     * @summary Create a New Webhook Subscription
     * @param createWebhook The webhook payload
     * @param {*} [options] Override http request options.
     */
    public notificationSubscriptionsV2WebhooksPost (createWebhook?: CreateWebhook, options: any = {}) : Promise<{ response: http.ClientResponse; body: InlineResponse2015;  }> {
        const localVarPath = this.basePath + '/notification-subscriptions/v2/webhooks';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(createWebhook, "CreateWebhook")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse2015;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "InlineResponse2015");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create security keys that CyberSource will use internally to connect to your servers and validate messages using a digital signature.  Select the CREATE example for CyberSource to generate the key on our server and maintain it for you as well. Remember to save the key in the API response, so that you can use it to validate messages later. 
     * @summary Create Webhook Security Keys
     * @param vCSenderOrganizationId Sender organization id
     * @param vCPermissions Encoded user permissions returned by the CGK, for the entity user who initiated the boarding
     * @param vCCorrelationId A globally unique id associated with your request
     * @param saveSymEgressKey Provide egress Symmetric key information to save (create or store or refresh)
     * @param {*} [options] Override http request options.
     */
    public saveSymEgressKey (vCSenderOrganizationId: string, vCPermissions: string, vCCorrelationId?: string, saveSymEgressKey?: SaveSymEgressKey, options: any = {}) : Promise<{ response: http.ClientResponse; body: InlineResponse2014;  }> {
        const localVarPath = this.basePath + '/kms/egress/v2/keys-sym';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'vCSenderOrganizationId' is not null or undefined
        if (vCSenderOrganizationId === null || vCSenderOrganizationId === undefined) {
            throw new Error('Required parameter vCSenderOrganizationId was null or undefined when calling saveSymEgressKey.');
        }

        // verify required parameter 'vCPermissions' is not null or undefined
        if (vCPermissions === null || vCPermissions === undefined) {
            throw new Error('Required parameter vCPermissions was null or undefined when calling saveSymEgressKey.');
        }

        localVarHeaderParams['v-c-correlation-id'] = ObjectSerializer.serialize(vCCorrelationId, "string");
        localVarHeaderParams['v-c-sender-organization-id'] = ObjectSerializer.serialize(vCSenderOrganizationId, "string");
        localVarHeaderParams['v-c-permissions'] = ObjectSerializer.serialize(vCPermissions, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(saveSymEgressKey, "SaveSymEgressKey")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse2014;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "InlineResponse2014");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum CreditApiApiKeys {
}

export class CreditApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: CreditApiApiKeys, value: string) {
        (this.authentications as any)[CreditApiApiKeys[key]].apiKey = value;
    }
    /**
     * POST to the credit resource to credit funds to a specified credit card.
     * @summary Process a Credit
     * @param createCreditRequest 
     * @param {*} [options] Override http request options.
     */
    public createCredit (createCreditRequest: CreateCreditRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: PtsV2CreditsPost201Response;  }> {
        const localVarPath = this.basePath + '/pts/v2/credits';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'createCreditRequest' is not null or undefined
        if (createCreditRequest === null || createCreditRequest === undefined) {
            throw new Error('Required parameter createCreditRequest was null or undefined when calling createCredit.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(createCreditRequest, "CreateCreditRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PtsV2CreditsPost201Response;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PtsV2CreditsPost201Response");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum CustomerApiApiKeys {
}

export class CustomerApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: CustomerApiApiKeys, value: string) {
        (this.authentications as any)[CustomerApiApiKeys[key]].apiKey = value;
    }
    /**
     * |  |  |  | | --- | --- | --- | |**Customers**<br>A Customer represents your tokenized customer information.<br>You should associate the Customer Id with the customer account on your systems.<br>A Customer can have one or more [Payment Instruments](#token-management_customer-payment-instrument_create-a-customer-payment-instrumentl) or [Shipping Addresses](#token-management_customer-shipping-address_create-a-customer-shipping-address) with one allocated as the Customers default.|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|**Deleting a Customer**<br>Your system can use this API to delete a complete Customer.<br>When a Customer is deleted all associated Payment Instruments & Shipping Addresses are deleted.<br>Any Instrument Identifiers representing the card number will also be deleted if they are not associated with any other Payment Instruments.<br>Note: Individual [Payment Instruments](#token-management_customer-payment-instrument_delete-a-customer-payment-instrument) or [Shipping Addresses](#token-management_customer-shipping-address_delete-a-customer-shipping-address) can be deleted via their own dedicated API resources. 
     * @summary Delete a Customer
     * @param customerId The Id of a Customer.
     * @param profileId The Id of a profile containing user specific TMS configuration.
     * @param {*} [options] Override http request options.
     */
    public deleteCustomer (customerId: string, profileId?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/tms/v2/customers/{customerId}'
            .replace('{' + 'customerId' + '}', encodeURIComponent(String(customerId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'customerId' is not null or undefined
        if (customerId === null || customerId === undefined) {
            throw new Error('Required parameter customerId was null or undefined when calling deleteCustomer.');
        }

        localVarHeaderParams['profile-id'] = ObjectSerializer.serialize(profileId, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * |  |  |  | | --- | --- | --- | |**Customers**<br>A Customer represents your tokenized customer information.<br>You should associate the Customer Id with the customer account on your systems.<br>A Customer can have one or more [Payment Instruments](#token-management_customer-payment-instrument_create-a-customer-payment-instrumentl) or [Shipping Addresses](#token-management_customer-shipping-address_create-a-customer-shipping-address) with one allocated as the Customers default.<br><br>**Retrieving a Customer**<br>When your customer signs into their account, your system can use this API to retrieve the Customers default Payment Instrument and Shipping Address.<br>**Note: the actual card data will be masked.**<br>If your customer wants to see other available Payment Instruments, your system can [retrieve all Payment Instruments](#token-management_customer-payment-instrument_list-payment-instruments-for-a-customer) associated with the Customer.<br>The same applies to [Shipping Addresses](#token-management_customer-shipping-address_list-shipping-addresses-for-a-customer).|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|**Payment Network Tokens**<br>Network tokens perform better than regular card numbers and they are not necessarily invalidated when a cardholder loses their card, or it expires.<br>A Payment Network Token will be automatically created and used in future payments if you are enabled for the service.<br>A Payment Network Token can also be [provisioned for an existing Instrument Identifier](#token-management_instrument-identifier_enroll-an-instrument-identifier-for-payment-network-token).<br>For more information about Payment Network Tokens see the Developer Guide.<br><br>**Payments with Customers**<br>To perform a payment with the Customers default details specify the [Customer Id in the payments request](#payments_payments_process-a-payment_samplerequests-dropdown_authorization-using-tokens_authorization-with-customer-token-id_liveconsole-tab-request-body).<br>To perform a payment with a particular Payment Instrument or Shipping Address <br>specify the [Payment Instrument or Shipping Address Ids in the payments request](#payments_payments_process-a-payment_samplerequests-dropdown_authorization-using-tokens_authorization-with-customer-payment-instrument-and-shipping-address-token-id_liveconsole-tab-request-body). 
     * @summary Retrieve a Customer
     * @param customerId The Id of a Customer.
     * @param profileId The Id of a profile containing user specific TMS configuration.
     * @param {*} [options] Override http request options.
     */
    public getCustomer (customerId: string, profileId?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: PostCustomerRequest;  }> {
        const localVarPath = this.basePath + '/tms/v2/customers/{customerId}'
            .replace('{' + 'customerId' + '}', encodeURIComponent(String(customerId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'customerId' is not null or undefined
        if (customerId === null || customerId === undefined) {
            throw new Error('Required parameter customerId was null or undefined when calling getCustomer.');
        }

        localVarHeaderParams['profile-id'] = ObjectSerializer.serialize(profileId, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PostCustomerRequest;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PostCustomerRequest");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * |  |  |  | | --- | --- | --- | |**Customers**<br>A Customer represents your tokenized customer information.<br>You should associate the Customer Id with the customer account on your systems.<br>A Customer can have one or more [Payment Instruments](#token-management_customer-payment-instrument_create-a-customer-payment-instrumentl) or [Shipping Addresses](#token-management_customer-shipping-address_create-a-customer-shipping-address) with one allocated as the Customers default.|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|**Updating a Customer**<br>Your system can use this API to update a Customers details including selecting a  [default Payment Instrument](#token-management_customer_update-a-customer_samplerequests-dropdown_update-customers-default-payment-instrument_liveconsole-tab-request-body) or [default Shipping Address](#token-management_customer_update-a-customer_samplerequests-dropdown_update-customers-default-shipping-address_liveconsole-tab-request-body) for use in payments.<br>Note: Updating a Customers [Payment Instrument](#token-management_customer-payment-instrument_update-a-customer-payment-instrument) or [Shipping Address](#token-management_customer-shipping-address_update-a-customer-shipping-address) details is performed using their own dedicated API resources. 
     * @summary Update a Customer
     * @param customerId The Id of a Customer.
     * @param patchCustomerRequest 
     * @param profileId The Id of a profile containing user specific TMS configuration.
     * @param ifMatch Contains an ETag value from a GET request to make the request conditional.
     * @param {*} [options] Override http request options.
     */
    public patchCustomer (customerId: string, patchCustomerRequest: PatchCustomerRequest, profileId?: string, ifMatch?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: PatchCustomerRequest;  }> {
        const localVarPath = this.basePath + '/tms/v2/customers/{customerId}'
            .replace('{' + 'customerId' + '}', encodeURIComponent(String(customerId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'customerId' is not null or undefined
        if (customerId === null || customerId === undefined) {
            throw new Error('Required parameter customerId was null or undefined when calling patchCustomer.');
        }

        // verify required parameter 'patchCustomerRequest' is not null or undefined
        if (patchCustomerRequest === null || patchCustomerRequest === undefined) {
            throw new Error('Required parameter patchCustomerRequest was null or undefined when calling patchCustomer.');
        }

        localVarHeaderParams['profile-id'] = ObjectSerializer.serialize(profileId, "string");
        localVarHeaderParams['if-match'] = ObjectSerializer.serialize(ifMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(patchCustomerRequest, "PatchCustomerRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PatchCustomerRequest;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PatchCustomerRequest");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * |  |  |  | | --- | --- | --- | |**Customers**<br>A Customer represents your tokenized customer information.<br>You should associate the Customer Id with the customer account on your systems.<br>A Customer can have one or more [Payment Instruments](#token-management_customer-payment-instrument_create-a-customer-payment-instrumentl) or [Shipping Addresses](#token-management_customer-shipping-address_create-a-customer-shipping-address) with one allocated as the Customers default.<br><br>**Creating a Customer**<br>It is recommended you [create a Customer via a Payment Authorization](#payments_payments_process-a-payment_samplerequests-dropdown_authorization-with-token-create_authorization-with-customer-token-creation_liveconsole-tab-request-body), this can be for a zero amount.<br>The Customer will be created with a Payment Instrument and Shipping Address.<br>You can also [add additional Payment Instruments to a Customer via a Payment Authorization](#payments_payments_process-a-payment_samplerequests-dropdown_authorization-with-token-create_authorization-create-default-payment-instrument-shipping-address-for-existing-customer_liveconsole-tab-request-body).<br>In Europe: You should perform Payer Authentication alongside the Authorization.|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|**Payment Network Tokens**<br>Network tokens perform better than regular card numbers and they are not necessarily invalidated when a cardholder loses their card, or it expires.<br>A Payment Network Token will be automatically created and used in future payments if you are enabled for the service.<br>A Payment Network Token can also be [provisioned for an existing Instrument Identifier](#token-management_instrument-identifier_enroll-an-instrument-identifier-for-payment-network-token).<br>For more information about Payment Network Tokens see the Developer Guide.<br><br>**Payments with Customers**<br>To perform a payment with the Customers default details specify the [Customer Id in the payments request](#payments_payments_process-a-payment_samplerequests-dropdown_authorization-using-tokens_authorization-with-customer-token-id_liveconsole-tab-request-body).<br>To perform a payment with a particular Payment Instrument or Shipping Address <br>specify the [Payment Instrument or Shipping Address Ids in the payments request](#payments_payments_process-a-payment_samplerequests-dropdown_authorization-using-tokens_authorization-with-customer-payment-instrument-and-shipping-address-token-id_liveconsole-tab-request-body). The availability of API features for a merchant may depend on the portfolio configuration and may need to be enabled at the portfolio level before they can be added to merchant accounts. 
     * @summary Create a Customer
     * @param postCustomerRequest 
     * @param profileId The Id of a profile containing user specific TMS configuration.
     * @param {*} [options] Override http request options.
     */
    public postCustomer (postCustomerRequest: PostCustomerRequest, profileId?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: PostCustomerRequest;  }> {
        const localVarPath = this.basePath + '/tms/v2/customers';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'postCustomerRequest' is not null or undefined
        if (postCustomerRequest === null || postCustomerRequest === undefined) {
            throw new Error('Required parameter postCustomerRequest was null or undefined when calling postCustomer.');
        }

        localVarHeaderParams['profile-id'] = ObjectSerializer.serialize(profileId, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(postCustomerRequest, "PostCustomerRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PostCustomerRequest;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PostCustomerRequest");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum CustomerPaymentInstrumentApiApiKeys {
}

export class CustomerPaymentInstrumentApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: CustomerPaymentInstrumentApiApiKeys, value: string) {
        (this.authentications as any)[CustomerPaymentInstrumentApiApiKeys[key]].apiKey = value;
    }
    /**
     * |  |  |  | | --- | --- | --- | |**Customer Payment Instrument**<br>A Customer Payment Instrument represents tokenized customer payment information such as expiration date, billing address & card type.<br>A [Customer](#token-management_customer_create-a-customer) can have [one or more Payment Instruments](#token-management_customer-payment-instrument_retrieve-a-customer-payment-instrument), with one allocated as the Customers default for use in payments.<br>A Payment Instrument token does not store the card number. A Payment Instrument is associated with an [Instrument Identifier](#token-management_instrument-identifier_create-an-instrument-identifier) that represents either a payment card number, or in the case of an ACH bank account, the routing and account number.<br>|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|**Deleting a Customers Payment Instrument**<br>Your system can use this API to delete an existing Payment Instrument for a Customer.<br>Any Instrument Identifiers representing the card number will also be deleted if they are not associated with any other Payment Instruments.<br>If a customer has more than one Payment Instrument then the default Payment Instrument cannot be deleted without first selecting a [new default Payment Instrument](#token-management_customer-payment-instrument_update-a-customer-payment-instrument_samplerequests-dropdown_make-customer-payment-instrument-the-default_liveconsole-tab-request-body). 
     * @summary Delete a Customer Payment Instrument
     * @param customerId The Id of a Customer.
     * @param paymentInstrumentId The Id of a payment instrument.
     * @param profileId The Id of a profile containing user specific TMS configuration.
     * @param {*} [options] Override http request options.
     */
    public deleteCustomerPaymentInstrument (customerId: string, paymentInstrumentId: string, profileId?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/tms/v2/customers/{customerId}/payment-instruments/{paymentInstrumentId}'
            .replace('{' + 'customerId' + '}', encodeURIComponent(String(customerId)))
            .replace('{' + 'paymentInstrumentId' + '}', encodeURIComponent(String(paymentInstrumentId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'customerId' is not null or undefined
        if (customerId === null || customerId === undefined) {
            throw new Error('Required parameter customerId was null or undefined when calling deleteCustomerPaymentInstrument.');
        }

        // verify required parameter 'paymentInstrumentId' is not null or undefined
        if (paymentInstrumentId === null || paymentInstrumentId === undefined) {
            throw new Error('Required parameter paymentInstrumentId was null or undefined when calling deleteCustomerPaymentInstrument.');
        }

        localVarHeaderParams['profile-id'] = ObjectSerializer.serialize(profileId, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * |  |  |  | | --- | --- | --- | |**Customer Payment Instrument**<br>A Customer Payment Instrument represents tokenized customer payment information such as expiration date, billing address & card type.<br>A [Customer](#token-management_customer_create-a-customer) can have [one or more Payment Instruments](#token-management_customer-payment-instrument_retrieve-a-customer-payment-instrument), with one allocated as the Customers default for use in payments.<br>A Payment Instrument token does not store the card number. A Payment Instrument is associated with an [Instrument Identifier](#token-management_instrument-identifier_create-an-instrument-identifier) that represents either a payment card number, or in the case of an ACH bank account, the routing and account number.<br>|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|**Retrieving a Customer Payment Instrument**<br>Your system can use this API to retrieve an existing Payment Instrument for a Customer.<br>To perform a payment with a particular Payment Instrument simply specify the [Payment Instrument Id in the payments request](#payments_payments_process-a-payment_samplerequests-dropdown_authorization-using-tokens_authorization-with-customer-payment-instrument-and-shipping-address-token-id_liveconsole-tab-request-body). 
     * @summary Retrieve a Customer Payment Instrument
     * @param customerId The Id of a Customer.
     * @param paymentInstrumentId The Id of a payment instrument.
     * @param profileId The Id of a profile containing user specific TMS configuration.
     * @param {*} [options] Override http request options.
     */
    public getCustomerPaymentInstrument (customerId: string, paymentInstrumentId: string, profileId?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: PostCustomerPaymentInstrumentRequest;  }> {
        const localVarPath = this.basePath + '/tms/v2/customers/{customerId}/payment-instruments/{paymentInstrumentId}'
            .replace('{' + 'customerId' + '}', encodeURIComponent(String(customerId)))
            .replace('{' + 'paymentInstrumentId' + '}', encodeURIComponent(String(paymentInstrumentId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'customerId' is not null or undefined
        if (customerId === null || customerId === undefined) {
            throw new Error('Required parameter customerId was null or undefined when calling getCustomerPaymentInstrument.');
        }

        // verify required parameter 'paymentInstrumentId' is not null or undefined
        if (paymentInstrumentId === null || paymentInstrumentId === undefined) {
            throw new Error('Required parameter paymentInstrumentId was null or undefined when calling getCustomerPaymentInstrument.');
        }

        localVarHeaderParams['profile-id'] = ObjectSerializer.serialize(profileId, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PostCustomerPaymentInstrumentRequest;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PostCustomerPaymentInstrumentRequest");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * |  |  |  | | --- | --- | --- | |**Customer Payment Instrument**<br>A Customer Payment Instrument represents tokenized customer payment information such as expiration date, billing address & card type.<br>A [Customer](#token-management_customer_create-a-customer) can have [one or more Payment Instruments](#token-management_customer-payment-instrument_retrieve-a-customer-payment-instrument), with one allocated as the Customers default for use in payments.<br>A Payment Instrument token does not store the card number. A Payment Instrument is associated with an [Instrument Identifier](#token-management_instrument-identifier_create-an-instrument-identifier) that represents either a payment card number, or in the case of an ACH bank account, the routing and account number.<br>|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|**Retrieving all Customer Payment Instruments**<br>Your system can use this API to retrieve all existing Payment Instruments for a Customer. 
     * @summary List Payment Instruments for a Customer
     * @param customerId The Id of a Customer.
     * @param profileId The Id of a profile containing user specific TMS configuration.
     * @param offset Starting record in zero-based dataset that should be returned as the first object in the array. Default is 0.
     * @param limit The maximum number that can be returned in the array starting from the offset record in zero-based dataset. Default is 20, maximum is 100.
     * @param {*} [options] Override http request options.
     */
    public getCustomerPaymentInstrumentsList (customerId: string, profileId?: string, offset?: number, limit?: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: PaymentInstrumentList;  }> {
        const localVarPath = this.basePath + '/tms/v2/customers/{customerId}/payment-instruments'
            .replace('{' + 'customerId' + '}', encodeURIComponent(String(customerId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'customerId' is not null or undefined
        if (customerId === null || customerId === undefined) {
            throw new Error('Required parameter customerId was null or undefined when calling getCustomerPaymentInstrumentsList.');
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        localVarHeaderParams['profile-id'] = ObjectSerializer.serialize(profileId, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PaymentInstrumentList;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PaymentInstrumentList");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * |  |  |  | | --- | --- | --- | |**Customer Payment Instrument**<br>A Customer Payment Instrument represents tokenized customer payment information such as expiration date, billing address & card type.<br>A [Customer](#token-management_customer_create-a-customer) can have [one or more Payment Instruments](#token-management_customer-payment-instrument_retrieve-a-customer-payment-instrument), with one allocated as the Customers default for use in payments.<br>A Payment Instrument token does not store the card number. A Payment Instrument is associated with an [Instrument Identifier](#token-management_instrument-identifier_create-an-instrument-identifier) that represents either a payment card number, or in the case of an ACH bank account, the routing and account number.<br>|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|**Updating a Customers Payment Instrument**<br>Your system can use this API to update an existing Payment Instrument for a Customer, including selecting a [default Payment Instrument](#token-management_customer-payment-instrument_update-a-customer-payment-instrument_samplerequests-dropdown_make-customer-payment-instrument-the-default_liveconsole-tab-request-body) for use in payments. 
     * @summary Update a Customer Payment Instrument
     * @param customerId The Id of a Customer.
     * @param paymentInstrumentId The Id of a payment instrument.
     * @param patchCustomerPaymentInstrumentRequest 
     * @param profileId The Id of a profile containing user specific TMS configuration.
     * @param ifMatch Contains an ETag value from a GET request to make the request conditional.
     * @param {*} [options] Override http request options.
     */
    public patchCustomersPaymentInstrument (customerId: string, paymentInstrumentId: string, patchCustomerPaymentInstrumentRequest: PatchCustomerPaymentInstrumentRequest, profileId?: string, ifMatch?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: PatchCustomerPaymentInstrumentRequest;  }> {
        const localVarPath = this.basePath + '/tms/v2/customers/{customerId}/payment-instruments/{paymentInstrumentId}'
            .replace('{' + 'customerId' + '}', encodeURIComponent(String(customerId)))
            .replace('{' + 'paymentInstrumentId' + '}', encodeURIComponent(String(paymentInstrumentId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'customerId' is not null or undefined
        if (customerId === null || customerId === undefined) {
            throw new Error('Required parameter customerId was null or undefined when calling patchCustomersPaymentInstrument.');
        }

        // verify required parameter 'paymentInstrumentId' is not null or undefined
        if (paymentInstrumentId === null || paymentInstrumentId === undefined) {
            throw new Error('Required parameter paymentInstrumentId was null or undefined when calling patchCustomersPaymentInstrument.');
        }

        // verify required parameter 'patchCustomerPaymentInstrumentRequest' is not null or undefined
        if (patchCustomerPaymentInstrumentRequest === null || patchCustomerPaymentInstrumentRequest === undefined) {
            throw new Error('Required parameter patchCustomerPaymentInstrumentRequest was null or undefined when calling patchCustomersPaymentInstrument.');
        }

        localVarHeaderParams['profile-id'] = ObjectSerializer.serialize(profileId, "string");
        localVarHeaderParams['if-match'] = ObjectSerializer.serialize(ifMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(patchCustomerPaymentInstrumentRequest, "PatchCustomerPaymentInstrumentRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PatchCustomerPaymentInstrumentRequest;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PatchCustomerPaymentInstrumentRequest");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * |  |  |  | | --- | --- | --- | |**Customer Payment Instrument**<br>A Customer Payment Instrument represents tokenized customer payment information such as expiration date, billing address & card type.<br>A [Customer](#token-management_customer_create-a-customer) can have [one or more Payment Instruments](#token-management_customer-payment-instrument_retrieve-a-customer-payment-instrument), with one allocated as the Customers default for use in payments.<br>A Payment Instrument token does not store the card number. A Payment Instrument is associated with an [Instrument Identifier](#token-management_instrument-identifier_create-an-instrument-identifier) that represents either a payment card number, or in the case of an ACH bank account, the routing and account number.<br><br>**Creating a Customer Payment Instrument**<br>It is recommended you [create a Customer Payment Instrument via a Payment Authorization](#payments_payments_process-a-payment_samplerequests-dropdown_authorization-with-token-create_authorization-create-default-payment-instrument-shipping-address-for-existing-customer_liveconsole-tab-request-body), this can be for a zero amount.<br>In Europe: You should perform Payer Authentication alongside the Authorization.|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|**Payment Network Tokens**<br>Network tokens perform better than regular card numbers and they are not necessarily invalidated when a cardholder loses their card, or it expires.<br>A Payment Network Token will be automatically created and used in future payments if you are enabled for the service.<br>A Payment Network Token can also be [provisioned for an existing Instrument Identifier](#token-management_instrument-identifier_enroll-an-instrument-identifier-for-payment-network-token).<br>For more information about Payment Network Tokens see the Developer Guide.<br><br>**Payments with Customers Payment Instrument**<br>To perform a payment with a particular Payment Instrument or Shipping Address specify the [Payment Instrument in the payment request](#payments_payments_process-a-payment_samplerequests-dropdown_authorization-using-tokens_authorization-with-customer-payment-instrument-and-shipping-address-token-id_liveconsole-tab-request-body). 
     * @summary Create a Customer Payment Instrument
     * @param customerId The Id of a Customer.
     * @param postCustomerPaymentInstrumentRequest 
     * @param profileId The Id of a profile containing user specific TMS configuration.
     * @param {*} [options] Override http request options.
     */
    public postCustomerPaymentInstrument (customerId: string, postCustomerPaymentInstrumentRequest: PostCustomerPaymentInstrumentRequest, profileId?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: PostCustomerPaymentInstrumentRequest;  }> {
        const localVarPath = this.basePath + '/tms/v2/customers/{customerId}/payment-instruments'
            .replace('{' + 'customerId' + '}', encodeURIComponent(String(customerId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'customerId' is not null or undefined
        if (customerId === null || customerId === undefined) {
            throw new Error('Required parameter customerId was null or undefined when calling postCustomerPaymentInstrument.');
        }

        // verify required parameter 'postCustomerPaymentInstrumentRequest' is not null or undefined
        if (postCustomerPaymentInstrumentRequest === null || postCustomerPaymentInstrumentRequest === undefined) {
            throw new Error('Required parameter postCustomerPaymentInstrumentRequest was null or undefined when calling postCustomerPaymentInstrument.');
        }

        localVarHeaderParams['profile-id'] = ObjectSerializer.serialize(profileId, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(postCustomerPaymentInstrumentRequest, "PostCustomerPaymentInstrumentRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PostCustomerPaymentInstrumentRequest;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PostCustomerPaymentInstrumentRequest");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum CustomerShippingAddressApiApiKeys {
}

export class CustomerShippingAddressApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: CustomerShippingAddressApiApiKeys, value: string) {
        (this.authentications as any)[CustomerShippingAddressApiApiKeys[key]].apiKey = value;
    }
    /**
     * |  |  |  | | --- | --- | --- | |**Customer Shipping Address**<br>A Customer Shipping Address represents tokenized customer shipping information.<br>A [Customer](#token-management_customer_create-a-customer) can have [one or more Shipping Addresses](#token-management_customer-shipping-address_list-shipping-addresses-for-a-customer), with one allocated as the Customers default for use in payments.|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|**Deleting a Customers Shipping Address**<br>Your system can use this API to delete an existing Shipping Address for a Customer.<br>If a customer has more than one Shipping Address then the default Shipping Address cannot be deleted without first selecting a [new default Shipping Address](#token-management_customer-shipping-address_update-a-customer-shipping-address_samplerequests-dropdown_make-customer-shipping-address-the-default_liveconsole-tab-request-body). 
     * @summary Delete a Customer Shipping Address
     * @param customerId The Id of a Customer.
     * @param shippingAddressId The Id of a shipping address.
     * @param profileId The Id of a profile containing user specific TMS configuration.
     * @param {*} [options] Override http request options.
     */
    public deleteCustomerShippingAddress (customerId: string, shippingAddressId: string, profileId?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/tms/v2/customers/{customerId}/shipping-addresses/{shippingAddressId}'
            .replace('{' + 'customerId' + '}', encodeURIComponent(String(customerId)))
            .replace('{' + 'shippingAddressId' + '}', encodeURIComponent(String(shippingAddressId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'customerId' is not null or undefined
        if (customerId === null || customerId === undefined) {
            throw new Error('Required parameter customerId was null or undefined when calling deleteCustomerShippingAddress.');
        }

        // verify required parameter 'shippingAddressId' is not null or undefined
        if (shippingAddressId === null || shippingAddressId === undefined) {
            throw new Error('Required parameter shippingAddressId was null or undefined when calling deleteCustomerShippingAddress.');
        }

        localVarHeaderParams['profile-id'] = ObjectSerializer.serialize(profileId, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * |  |  |  | | --- | --- | --- | |**Customer Shipping Address**<br>A Customer Shipping Address represents tokenized customer shipping information.<br>A [Customer](#token-management_customer_create-a-customer) can have [one or more Shipping Addresses](#token-management_customer-shipping-address_list-shipping-addresses-for-a-customer), with one allocated as the Customers default for use in payments.|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|**Retrieving a Customer Shipping Address**<br>Your system can use this API to retrieve an existing Shipping Address for a Customer.<br>To perform a payment with a particular Shipping Address simply specify the [Shipping Address Id in the payments request](#payments_payments_process-a-payment_samplerequests-dropdown_authorization-using-tokens_authorization-with-customer-payment-instrument-and-shipping-address-token-id_liveconsole-tab-request-body). 
     * @summary Retrieve a Customer Shipping Address
     * @param customerId The Id of a Customer.
     * @param shippingAddressId The Id of a shipping address.
     * @param profileId The Id of a profile containing user specific TMS configuration.
     * @param {*} [options] Override http request options.
     */
    public getCustomerShippingAddress (customerId: string, shippingAddressId: string, profileId?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: PostCustomerShippingAddressRequest;  }> {
        const localVarPath = this.basePath + '/tms/v2/customers/{customerId}/shipping-addresses/{shippingAddressId}'
            .replace('{' + 'customerId' + '}', encodeURIComponent(String(customerId)))
            .replace('{' + 'shippingAddressId' + '}', encodeURIComponent(String(shippingAddressId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'customerId' is not null or undefined
        if (customerId === null || customerId === undefined) {
            throw new Error('Required parameter customerId was null or undefined when calling getCustomerShippingAddress.');
        }

        // verify required parameter 'shippingAddressId' is not null or undefined
        if (shippingAddressId === null || shippingAddressId === undefined) {
            throw new Error('Required parameter shippingAddressId was null or undefined when calling getCustomerShippingAddress.');
        }

        localVarHeaderParams['profile-id'] = ObjectSerializer.serialize(profileId, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PostCustomerShippingAddressRequest;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PostCustomerShippingAddressRequest");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * |  |  |  | | --- | --- | --- | |**Customer Shipping Address**<br>A Customer Shipping Address represents tokenized customer shipping information.<br>A [Customer](#token-management_customer_create-a-customer) can have [one or more Shipping Addresses](#token-management_customer-shipping-address_list-shipping-addresses-for-a-customer), with one allocated as the Customers default for use in payments.|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|**Retrieving all Customer Shipping Addresses**<br>Your system can use this API to retrieve all existing Shipping Addresses for a Customer. 
     * @summary List Shipping Addresses for a Customer
     * @param customerId The Id of a Customer.
     * @param profileId The Id of a profile containing user specific TMS configuration.
     * @param offset Starting record in zero-based dataset that should be returned as the first object in the array. Default is 0.
     * @param limit The maximum number that can be returned in the array starting from the offset record in zero-based dataset. Default is 20, maximum is 100.
     * @param {*} [options] Override http request options.
     */
    public getCustomerShippingAddressesList (customerId: string, profileId?: string, offset?: number, limit?: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: ShippingAddressListForCustomer;  }> {
        const localVarPath = this.basePath + '/tms/v2/customers/{customerId}/shipping-addresses'
            .replace('{' + 'customerId' + '}', encodeURIComponent(String(customerId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'customerId' is not null or undefined
        if (customerId === null || customerId === undefined) {
            throw new Error('Required parameter customerId was null or undefined when calling getCustomerShippingAddressesList.');
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        localVarHeaderParams['profile-id'] = ObjectSerializer.serialize(profileId, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ShippingAddressListForCustomer;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ShippingAddressListForCustomer");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * |  |  |  | | --- | --- | --- | |**Customer Shipping Address**<br>A Customer Shipping Address represents tokenized customer shipping information.<br>A [Customer](#token-management_customer_create-a-customer) can have [one or more Shipping Addresses](#token-management_customer-shipping-address_list-shipping-addresses-for-a-customer), with one allocated as the Customers default for use in payments.|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|**Updating a Customers Shipping Address**<br>Your system can use this API to update an existing Shipping Addresses for a Customer, including selecting a [default Shipping Address](#token-management_customer-shipping-address_update-a-customer-shipping-address_samplerequests-dropdown_make-customer-shipping-address-the-default_liveconsole-tab-request-body) for use in payments. 
     * @summary Update a Customer Shipping Address
     * @param customerId The Id of a Customer.
     * @param shippingAddressId The Id of a shipping address.
     * @param patchCustomerShippingAddressRequest 
     * @param profileId The Id of a profile containing user specific TMS configuration.
     * @param ifMatch Contains an ETag value from a GET request to make the request conditional.
     * @param {*} [options] Override http request options.
     */
    public patchCustomersShippingAddress (customerId: string, shippingAddressId: string, patchCustomerShippingAddressRequest: PatchCustomerShippingAddressRequest, profileId?: string, ifMatch?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: PatchCustomerShippingAddressRequest;  }> {
        const localVarPath = this.basePath + '/tms/v2/customers/{customerId}/shipping-addresses/{shippingAddressId}'
            .replace('{' + 'customerId' + '}', encodeURIComponent(String(customerId)))
            .replace('{' + 'shippingAddressId' + '}', encodeURIComponent(String(shippingAddressId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'customerId' is not null or undefined
        if (customerId === null || customerId === undefined) {
            throw new Error('Required parameter customerId was null or undefined when calling patchCustomersShippingAddress.');
        }

        // verify required parameter 'shippingAddressId' is not null or undefined
        if (shippingAddressId === null || shippingAddressId === undefined) {
            throw new Error('Required parameter shippingAddressId was null or undefined when calling patchCustomersShippingAddress.');
        }

        // verify required parameter 'patchCustomerShippingAddressRequest' is not null or undefined
        if (patchCustomerShippingAddressRequest === null || patchCustomerShippingAddressRequest === undefined) {
            throw new Error('Required parameter patchCustomerShippingAddressRequest was null or undefined when calling patchCustomersShippingAddress.');
        }

        localVarHeaderParams['profile-id'] = ObjectSerializer.serialize(profileId, "string");
        localVarHeaderParams['if-match'] = ObjectSerializer.serialize(ifMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(patchCustomerShippingAddressRequest, "PatchCustomerShippingAddressRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PatchCustomerShippingAddressRequest;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PatchCustomerShippingAddressRequest");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * |  |  |  | | --- | --- | --- | |**Customer Shipping Address**<br>A Customer Shipping Address represents tokenized customer shipping information.<br>A [Customer](#token-management_customer_create-a-customer) can have [one or more Shipping Addresses](#token-management_customer-shipping-address_list-shipping-addresses-for-a-customer), with one allocated as the Customers default for use in payments.|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|**Creating a Customer Shipping Address**<br>Your system can use this API to create an existing Customers default or non default Shipping Address.<br>You can also create additional Customer Shipping Addresses via the [Payments API](#payments_payments_process-a-payment_samplerequests-dropdown_authorization-with-token-create_authorization-create-default-payment-instrument-shipping-address-for-existing-customer_liveconsole-tab-request-body). 
     * @summary Create a Customer Shipping Address
     * @param customerId The Id of a Customer.
     * @param postCustomerShippingAddressRequest 
     * @param profileId The Id of a profile containing user specific TMS configuration.
     * @param {*} [options] Override http request options.
     */
    public postCustomerShippingAddress (customerId: string, postCustomerShippingAddressRequest: PostCustomerShippingAddressRequest, profileId?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: PostCustomerShippingAddressRequest;  }> {
        const localVarPath = this.basePath + '/tms/v2/customers/{customerId}/shipping-addresses'
            .replace('{' + 'customerId' + '}', encodeURIComponent(String(customerId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'customerId' is not null or undefined
        if (customerId === null || customerId === undefined) {
            throw new Error('Required parameter customerId was null or undefined when calling postCustomerShippingAddress.');
        }

        // verify required parameter 'postCustomerShippingAddressRequest' is not null or undefined
        if (postCustomerShippingAddressRequest === null || postCustomerShippingAddressRequest === undefined) {
            throw new Error('Required parameter postCustomerShippingAddressRequest was null or undefined when calling postCustomerShippingAddress.');
        }

        localVarHeaderParams['profile-id'] = ObjectSerializer.serialize(profileId, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(postCustomerShippingAddressRequest, "PostCustomerShippingAddressRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PostCustomerShippingAddressRequest;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PostCustomerShippingAddressRequest");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum CustomizationsApiApiKeys {
}

export class CustomizationsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: CustomizationsApiApiKeys, value: string) {
        (this.authentications as any)[CustomizationsApiApiKeys[key]].apiKey = value;
    }
    /**
     * Create Customization for device or organization (Portfolio, Merchant, Transacting MID).
     * @summary Create Customization for device or organization
     * @param body A new Customization.
     * @param {*} [options] Override http request options.
     */
    public addCustomization (body?: Body2, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/dms/v2/customization';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "Body2")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get Customization for device or organization (Portfolio, Merchant, Transacting MID).
     * @summary Get Customization for device or organization
     * @param type ID of the customization
     * @param id Type of the customization there are 2 types of customization device, organization
     * @param {*} [options] Override http request options.
     */
    public customization (type: string, id: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: InlineResponse20011;  }> {
        const localVarPath = this.basePath + '/dms/v2/customization/{type}/{id}'
            .replace('{' + 'type' + '}', encodeURIComponent(String(type)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'type' is not null or undefined
        if (type === null || type === undefined) {
            throw new Error('Required parameter type was null or undefined when calling customization.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling customization.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse20011;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "InlineResponse20011");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * delete entire customization for device or organization (Portfolio, Merchant, Transacting MID).
     * @summary Delete customization for device or organization
     * @param type Type of the customization there are 2 types of customization device, organization
     * @param id ID of the customization
     * @param {*} [options] Override http request options.
     */
    public deleteCustomization (type: string, id: string, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/dms/v2/customization/{type}/{id}'
            .replace('{' + 'type' + '}', encodeURIComponent(String(type)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'type' is not null or undefined
        if (type === null || type === undefined) {
            throw new Error('Required parameter type was null or undefined when calling deleteCustomization.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteCustomization.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * delete customization for device or organization (Portfolio, Merchant, Transacting MID).
     * @summary Delete customization for device or organization
     * @param type Type of the customization there are 2 types of customization device, organization
     * @param id ID of the customization
     * @param key Key of the customization to be deleted
     * @param {*} [options] Override http request options.
     */
    public deleteCustomizationKey (type: string, id: string, key: string, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/dms/v2/customization/{type}/{id}/{key}'
            .replace('{' + 'type' + '}', encodeURIComponent(String(type)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)))
            .replace('{' + 'key' + '}', encodeURIComponent(String(key)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'type' is not null or undefined
        if (type === null || type === undefined) {
            throw new Error('Required parameter type was null or undefined when calling deleteCustomizationKey.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteCustomizationKey.');
        }

        // verify required parameter 'key' is not null or undefined
        if (key === null || key === undefined) {
            throw new Error('Required parameter key was null or undefined when calling deleteCustomizationKey.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update Customization for device or organization (Portfolio, Merchant, Transacting MID).
     * @summary Update Customization for device or organization
     * @param body Update Customization.
     * @param {*} [options] Override http request options.
     */
    public replaceCustomizations (body?: Body3, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/dms/v2/customization';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "Body3")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum DecisionManagerApiApiKeys {
}

export class DecisionManagerApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: DecisionManagerApiApiKeys, value: string) {
        (this.authentications as any)[DecisionManagerApiApiKeys[key]].apiKey = value;
    }
    /**
     * Take action on a DM post-transactional case
     * @summary Take action on a DM post-transactional case
     * @param id An unique identification number generated by Cybersource to identify the submitted request.
     * @param caseManagementActionsRequest 
     * @param {*} [options] Override http request options.
     */
    public actionDecisionManagerCase (id: string, caseManagementActionsRequest: CaseManagementActionsRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: InlineResponse2001;  }> {
        const localVarPath = this.basePath + '/risk/v1/decisions/{id}/actions'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling actionDecisionManagerCase.');
        }

        // verify required parameter 'caseManagementActionsRequest' is not null or undefined
        if (caseManagementActionsRequest === null || caseManagementActionsRequest === undefined) {
            throw new Error('Required parameter caseManagementActionsRequest was null or undefined when calling actionDecisionManagerCase.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(caseManagementActionsRequest, "CaseManagementActionsRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse2001;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "InlineResponse2001");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * This call adds/deletes/converts the request information in the negative list.  Provide the list to be updated as the path parameter. This value can be 'postiive', 'negative' or 'review'. 
     * @summary List Management
     * @param type The list to be updated. It can be &#39;positive&#39;, &#39;negative&#39; or &#39;review&#39;.
     * @param addNegativeListRequest 
     * @param {*} [options] Override http request options.
     */
    public addNegative (type: string, addNegativeListRequest: AddNegativeListRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: RiskV1UpdatePost201Response;  }> {
        const localVarPath = this.basePath + '/risk/v1/lists/{type}/entries'
            .replace('{' + 'type' + '}', encodeURIComponent(String(type)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'type' is not null or undefined
        if (type === null || type === undefined) {
            throw new Error('Required parameter type was null or undefined when calling addNegative.');
        }

        // verify required parameter 'addNegativeListRequest' is not null or undefined
        if (addNegativeListRequest === null || addNegativeListRequest === undefined) {
            throw new Error('Required parameter addNegativeListRequest was null or undefined when calling addNegative.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(addNegativeListRequest, "AddNegativeListRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: RiskV1UpdatePost201Response;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RiskV1UpdatePost201Response");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Add a comment to a DM post-transactional case
     * @summary Add a comment to a DM post-transactional case
     * @param id An unique identification number generated by Cybersource to identify the submitted request.
     * @param caseManagementCommentsRequest 
     * @param {*} [options] Override http request options.
     */
    public commentDecisionManagerCase (id: string, caseManagementCommentsRequest: CaseManagementCommentsRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: InlineResponse2011;  }> {
        const localVarPath = this.basePath + '/risk/v1/decisions/{id}/comments'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling commentDecisionManagerCase.');
        }

        // verify required parameter 'caseManagementCommentsRequest' is not null or undefined
        if (caseManagementCommentsRequest === null || caseManagementCommentsRequest === undefined) {
            throw new Error('Required parameter caseManagementCommentsRequest was null or undefined when calling commentDecisionManagerCase.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(caseManagementCommentsRequest, "CaseManagementCommentsRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse2011;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "InlineResponse2011");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Decision Manager can help you automate and streamline your fraud operations. Decision Manager will return a decision based on the request values.
     * @summary Create Decision Manager
     * @param createBundledDecisionManagerCaseRequest 
     * @param {*} [options] Override http request options.
     */
    public createBundledDecisionManagerCase (createBundledDecisionManagerCaseRequest: CreateBundledDecisionManagerCaseRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: RiskV1DecisionsPost201Response;  }> {
        const localVarPath = this.basePath + '/risk/v1/decisions';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'createBundledDecisionManagerCaseRequest' is not null or undefined
        if (createBundledDecisionManagerCaseRequest === null || createBundledDecisionManagerCaseRequest === undefined) {
            throw new Error('Required parameter createBundledDecisionManagerCaseRequest was null or undefined when calling createBundledDecisionManagerCase.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(createBundledDecisionManagerCaseRequest, "CreateBundledDecisionManagerCaseRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: RiskV1DecisionsPost201Response;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RiskV1DecisionsPost201Response");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * This can be used to - 1. Add known fraudulent data to the fraud history 2. Remove data added to history with Transaction Marking Tool or by uploading chargeback files 3. Remove chargeback data from history that was automatically added. For detailed information, contact your Cybersource representative  Place the request ID of the transaction you want to mark as suspect (or remove from history) as the path parameter in this request. 
     * @summary Fraud Marking
     * @param id Request ID of the transaction that you want to mark as suspect or remove from history.
     * @param fraudMarkingActionRequest 
     * @param {*} [options] Override http request options.
     */
    public fraudUpdate (id: string, fraudMarkingActionRequest: FraudMarkingActionRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: RiskV1UpdatePost201Response;  }> {
        const localVarPath = this.basePath + '/risk/v1/decisions/{id}/marking'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling fraudUpdate.');
        }

        // verify required parameter 'fraudMarkingActionRequest' is not null or undefined
        if (fraudMarkingActionRequest === null || fraudMarkingActionRequest === undefined) {
            throw new Error('Required parameter fraudMarkingActionRequest was null or undefined when calling fraudUpdate.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(fraudMarkingActionRequest, "FraudMarkingActionRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: RiskV1UpdatePost201Response;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RiskV1UpdatePost201Response");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum DeviceDeAssociationApiApiKeys {
}

export class DeviceDeAssociationApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: DeviceDeAssociationApiApiKeys, value: string) {
        (this.authentications as any)[DeviceDeAssociationApiApiKeys[key]].apiKey = value;
    }
    /**
     * A device will be de-associated from its current organization and moved up in the hierarchy. The device's new position will be determined by a specified destination, either an account or a portfolio. If no destination is provided, the device will default to the currently logged-in user. 
     * @summary De-associate a device from merchant to account or reseller and from account to reseller
     * @param deviceDeAssociateV3Request deviceId that has to be de-associated to the destination organizationId.
     * @param {*} [options] Override http request options.
     */
    public postDeAssociateV3Terminal (deviceDeAssociateV3Request: Array<DeviceDeAssociateV3Request>, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<InlineResponse2007>;  }> {
        const localVarPath = this.basePath + '/dms/v3/devices/deassociate';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'deviceDeAssociateV3Request' is not null or undefined
        if (deviceDeAssociateV3Request === null || deviceDeAssociateV3Request === undefined) {
            throw new Error('Required parameter deviceDeAssociateV3Request was null or undefined when calling postDeAssociateV3Terminal.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(deviceDeAssociateV3Request, "Array<DeviceDeAssociateV3Request>")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<InlineResponse2007>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<InlineResponse2007>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum DeviceOperationsApiApiKeys {
}

export class DeviceOperationsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: DeviceOperationsApiApiKeys, value: string) {
        (this.authentications as any)[DeviceOperationsApiApiKeys[key]].apiKey = value;
    }
    /**
     * Allows transferring of devices within the hierarchy. Both 'Active' and 'Inactive' devices can be transferred. 
     * @summary Device Transfer
     * @param deviceTransferRequest deviceId that has to be transferred along with the destination organizationId or merchantId. Any one of organizationId or merchantId is required alongside deviceId for a valid transfer request.
     * @param {*} [options] Override http request options.
     */
    public postTransferTerminalAssociation (deviceTransferRequest: Array<DeviceTransferRequest>, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<InlineResponse20110>;  }> {
        const localVarPath = this.basePath + '/dms/v2/device-transfer';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'deviceTransferRequest' is not null or undefined
        if (deviceTransferRequest === null || deviceTransferRequest === undefined) {
            throw new Error('Required parameter deviceTransferRequest was null or undefined when calling postTransferTerminalAssociation.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(deviceTransferRequest, "Array<DeviceTransferRequest>")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<InlineResponse20110>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<InlineResponse20110>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum DeviceSearchApiApiKeys {
}

export class DeviceSearchApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: DeviceSearchApiApiKeys, value: string) {
        (this.authentications as any)[DeviceSearchApiApiKeys[key]].apiKey = value;
    }
    /**
     * Search for devices matching a given search query.  The search query supports serialNumber, readerId, terminalId, status, statusChangeReason or organizationId  Matching results are paginated. 
     * @summary Retrieve List of Devices for a given search query
     * @param postDeviceSearchRequestV3 
     * @param {*} [options] Override http request options.
     */
    public postSearchQueryV3 (postDeviceSearchRequestV3: PostDeviceSearchRequestV3, options: any = {}) : Promise<{ response: http.ClientResponse; body: InlineResponse2008;  }> {
        const localVarPath = this.basePath + '/dms/v3/devices/search';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'postDeviceSearchRequestV3' is not null or undefined
        if (postDeviceSearchRequestV3 === null || postDeviceSearchRequestV3 === undefined) {
            throw new Error('Required parameter postDeviceSearchRequestV3 was null or undefined when calling postSearchQueryV3.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(postDeviceSearchRequestV3, "PostDeviceSearchRequestV3")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse2008;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "InlineResponse2008");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum DownloadDTDApiApiKeys {
}

export class DownloadDTDApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: DownloadDTDApiApiKeys, value: string) {
        (this.authentications as any)[DownloadDTDApiApiKeys[key]].apiKey = value;
    }
    /**
     * Used to download DTDs for reports on no-auth.
     * @summary Download DTD for Report
     * @param reportDefinitionNameVersion Name and version of DTD file to download. Some DTDs only have one version. In that case version name is not needed. Some example values are ctdr-1.0, tdr, pbdr-1.1
     * @param {*} [options] Override http request options.
     */
    public getDTDV2 (reportDefinitionNameVersion: string, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/reporting/v3/dtds/{reportDefinitionNameVersion}'
            .replace('{' + 'reportDefinitionNameVersion' + '}', encodeURIComponent(String(reportDefinitionNameVersion)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'reportDefinitionNameVersion' is not null or undefined
        if (reportDefinitionNameVersion === null || reportDefinitionNameVersion === undefined) {
            throw new Error('Required parameter reportDefinitionNameVersion was null or undefined when calling getDTDV2.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum DownloadXSDApiApiKeys {
}

export class DownloadXSDApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: DownloadXSDApiApiKeys, value: string) {
        (this.authentications as any)[DownloadXSDApiApiKeys[key]].apiKey = value;
    }
    /**
     * Used to download XSDs for reports on no-auth.
     * @summary Download XSD for Report
     * @param reportDefinitionNameVersion Name and version of XSD file to download. Some XSDs only have one version. In that case version name is not needed. Some example values are DecisionManagerDetailReport, DecisionManagerTypes
     * @param {*} [options] Override http request options.
     */
    public getXSDV2 (reportDefinitionNameVersion: string, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/reporting/v3/xsds/{reportDefinitionNameVersion}'
            .replace('{' + 'reportDefinitionNameVersion' + '}', encodeURIComponent(String(reportDefinitionNameVersion)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'reportDefinitionNameVersion' is not null or undefined
        if (reportDefinitionNameVersion === null || reportDefinitionNameVersion === undefined) {
            throw new Error('Required parameter reportDefinitionNameVersion was null or undefined when calling getXSDV2.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum InstrumentIdentifierApiApiKeys {
}

export class InstrumentIdentifierApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: InstrumentIdentifierApiApiKeys, value: string) {
        (this.authentications as any)[InstrumentIdentifierApiApiKeys[key]].apiKey = value;
    }
    /**
     * |  |  |  | | --- | --- | --- | |**Instrument Identifiers**<br>An Instrument Identifier represents either a card number, or in the case of an ACH bank account, the routing <br>and account numbers.<br>The same token Id is returned for a specific card number or bank account & routing number allowing the <br>Instrument Identifier Id to be used for cross-channel payment tracking.<br>An Instrument Identifier can exist independently but also be associated with a [Customer Payment Instrument](#token-management_customer-payment-instrument_create-a-customer-payment-instrument) <br>or [Standalone Payment Instrument](#token-management_payment-instrument_create-a-payment-instrument).|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|**Deleting an Instrument Identifier**<br>Your system can use this API to delete an existing Instrument Identifier.<br>An Instrument Identifier cannot be deleted if it is linked to any Payment Instruments.<br>You can [retrieve all Payment Instruments associated with an Instrument Identifier](#token-management_instrument-identifier_list-payment-instruments-for-an-instrument-identifier). 
     * @summary Delete an Instrument Identifier
     * @param instrumentIdentifierId The Id of an Instrument Identifier.
     * @param profileId The Id of a profile containing user specific TMS configuration.
     * @param {*} [options] Override http request options.
     */
    public deleteInstrumentIdentifier (instrumentIdentifierId: string, profileId?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/tms/v1/instrumentidentifiers/{instrumentIdentifierId}'
            .replace('{' + 'instrumentIdentifierId' + '}', encodeURIComponent(String(instrumentIdentifierId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'instrumentIdentifierId' is not null or undefined
        if (instrumentIdentifierId === null || instrumentIdentifierId === undefined) {
            throw new Error('Required parameter instrumentIdentifierId was null or undefined when calling deleteInstrumentIdentifier.');
        }

        localVarHeaderParams['profile-id'] = ObjectSerializer.serialize(profileId, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * |  |  |  | | --- | --- | --- | |**Instrument Identifiers**<br>An Instrument Identifier represents either a card number, or in the case of an ACH bank account, the routing and account number.<br>The same token Id is returned for a specific card number or bank account & routing number allowing the Instrument Identifier Id to be used for cross-channel payment tracking.<br>An Instrument Identifier can exist independently but also be associated with a [Customer Payment Instrument](#token-management_customer-payment-instrument_create-a-customer-payment-instrument) or [Standalone Payment Instrument](#token-management_payment-instrument_create-a-payment-instrument).<br><br>**Retrieving an Instrument Identifier**<br>Your system can use this API to retrieve an Instrument Identifier.<br>**Note: the actual card data will be masked.**<br>The Instrument Identifier will also be returned when retrieving a [Customer](#token-management_customer_retrieve-a-customer), [Customer Payment Instrument](#token-management_customer-payment-instrument_retrieve-a-customer-payment-instrument) or [Standalone Payment Instrument](#token-management_payment-instrument_retrieve-a-payment-instrument).|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|**Payment Network Tokens**<br>Network tokens perform better than regular card numbers and they are not necessarily invalidated when a cardholder loses their card, or it expires.<br>A Payment Network Token will be automatically created and used in future payments if you are enabled for the service.<br>A Payment Network Token can also be [provisioned for an existing Instrument Identifier](#token-management_instrument-identifier_enroll-an-instrument-identifier-for-payment-network-token).<br>For more information about Payment Network Tokens see the Developer Guide.<br><br>**Payments with Instrument Identifiers**<br>To perform a payment with an Instrument Identifier simply specify the [Instrument Identifier Id in the payments request along with the expiration date, card type, & billing address](#payments_payments_process-a-payment_samplerequests-dropdown_authorization-using-tokens_authorization-with-instrument-identifier-token-id_liveconsole-tab-request-body).<br>When an Instrument Identifier is used in a payment the **_previousTransactionId_** and **_originalAuthorizedAmount_** values are automatically recorded.<br>These values will be added for you to future Merchant Initiated Transaction payments. 
     * @summary Retrieve an Instrument Identifier
     * @param instrumentIdentifierId The Id of an Instrument Identifier.
     * @param profileId The Id of a profile containing user specific TMS configuration.
     * @param retrieveBinDetails Retrieve the Bin Details of PAN or network token
     * @param {*} [options] Override http request options.
     */
    public getInstrumentIdentifier (instrumentIdentifierId: string, profileId?: string, retrieveBinDetails?: boolean, options: any = {}) : Promise<{ response: http.ClientResponse; body: PostInstrumentIdentifierRequest;  }> {
        const localVarPath = this.basePath + '/tms/v1/instrumentidentifiers/{instrumentIdentifierId}'
            .replace('{' + 'instrumentIdentifierId' + '}', encodeURIComponent(String(instrumentIdentifierId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'instrumentIdentifierId' is not null or undefined
        if (instrumentIdentifierId === null || instrumentIdentifierId === undefined) {
            throw new Error('Required parameter instrumentIdentifierId was null or undefined when calling getInstrumentIdentifier.');
        }

        if (retrieveBinDetails !== undefined) {
            localVarQueryParameters['retrieveBinDetails'] = ObjectSerializer.serialize(retrieveBinDetails, "boolean");
        }

        localVarHeaderParams['profile-id'] = ObjectSerializer.serialize(profileId, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PostInstrumentIdentifierRequest;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PostInstrumentIdentifierRequest");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * |  |  |  | | --- | --- | --- | |**Instrument Identifiers**<br>An Instrument Identifier represents either a card number, or in the case of an ACH bank account, the routing <br>and account numbers.<br>The same token Id is returned for a specific card number or bank account & routing number allowing the <br>Instrument Identifier Id to be used for cross-channel payment tracking.<br>An Instrument Identifier can exist independently but also be associated with a [Customer Payment Instrument](#token-management_customer-payment-instrument_create-a-customer-payment-instrument) <br>or [Standalone Payment Instrument](#token-management_payment-instrument_create-a-payment-instrument).|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|**Retrieving all Payment Instruments associated with an Instrument Identifier**<br>Your system can use this API to retrieve all Payment Instruments linked to an Instrument Identifier. 
     * @summary List Payment Instruments for an Instrument Identifier
     * @param instrumentIdentifierId The Id of an Instrument Identifier.
     * @param profileId The Id of a profile containing user specific TMS configuration.
     * @param retrieveBinDetails Retrieve the Bin Details of PAN or network token
     * @param offset Starting record in zero-based dataset that should be returned as the first object in the array. Default is 0.
     * @param limit The maximum number that can be returned in the array starting from the offset record in zero-based dataset. Default is 20, maximum is 100.
     * @param {*} [options] Override http request options.
     */
    public getInstrumentIdentifierPaymentInstrumentsList (instrumentIdentifierId: string, profileId?: string, retrieveBinDetails?: boolean, offset?: number, limit?: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: PaymentInstrumentList1;  }> {
        const localVarPath = this.basePath + '/tms/v1/instrumentidentifiers/{instrumentIdentifierId}/paymentinstruments'
            .replace('{' + 'instrumentIdentifierId' + '}', encodeURIComponent(String(instrumentIdentifierId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'instrumentIdentifierId' is not null or undefined
        if (instrumentIdentifierId === null || instrumentIdentifierId === undefined) {
            throw new Error('Required parameter instrumentIdentifierId was null or undefined when calling getInstrumentIdentifierPaymentInstrumentsList.');
        }

        if (retrieveBinDetails !== undefined) {
            localVarQueryParameters['retrieveBinDetails'] = ObjectSerializer.serialize(retrieveBinDetails, "boolean");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        localVarHeaderParams['profile-id'] = ObjectSerializer.serialize(profileId, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PaymentInstrumentList1;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PaymentInstrumentList1");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * |  |  |  | | --- | --- | --- | |**Instrument Identifiers**<br>An Instrument Identifier represents either a card number, or in the case of an ACH bank account, the routing and account number.<br>The same token Id is returned for a specific card number or bank account & routing number allowing the Instrument Identifier Id to be used for cross-channel payment tracking.<br>An Instrument Identifier can exist independently but also be associated with a [Customer Payment Instrument](#token-management_customer-payment-instrument_create-a-customer-payment-instrument) or [Standalone Payment Instrument](#token-management_payment-instrument_create-a-payment-instrument).|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|**Updating an Instrument Identifier**<br>When an Instrument Identifier is used in a payment the **_previousTransactionId_** and **_originalAuthorizedAmount_** values are automatically recorded.<br>These values will be added for you to future Merchant Initiated Transaction payments.<br>Your system can use this API to update these values. 
     * @summary Update an Instrument Identifier
     * @param instrumentIdentifierId The Id of an Instrument Identifier.
     * @param patchInstrumentIdentifierRequest Specify the previous transaction Id to update.
     * @param profileId The Id of a profile containing user specific TMS configuration.
     * @param retrieveBinDetails Retrieve the Bin Details of PAN or network token
     * @param ifMatch Contains an ETag value from a GET request to make the request conditional.
     * @param {*} [options] Override http request options.
     */
    public patchInstrumentIdentifier (instrumentIdentifierId: string, patchInstrumentIdentifierRequest: PatchInstrumentIdentifierRequest, profileId?: string, retrieveBinDetails?: boolean, ifMatch?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: PatchInstrumentIdentifierRequest;  }> {
        const localVarPath = this.basePath + '/tms/v1/instrumentidentifiers/{instrumentIdentifierId}'
            .replace('{' + 'instrumentIdentifierId' + '}', encodeURIComponent(String(instrumentIdentifierId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'instrumentIdentifierId' is not null or undefined
        if (instrumentIdentifierId === null || instrumentIdentifierId === undefined) {
            throw new Error('Required parameter instrumentIdentifierId was null or undefined when calling patchInstrumentIdentifier.');
        }

        // verify required parameter 'patchInstrumentIdentifierRequest' is not null or undefined
        if (patchInstrumentIdentifierRequest === null || patchInstrumentIdentifierRequest === undefined) {
            throw new Error('Required parameter patchInstrumentIdentifierRequest was null or undefined when calling patchInstrumentIdentifier.');
        }

        if (retrieveBinDetails !== undefined) {
            localVarQueryParameters['retrieveBinDetails'] = ObjectSerializer.serialize(retrieveBinDetails, "boolean");
        }

        localVarHeaderParams['profile-id'] = ObjectSerializer.serialize(profileId, "string");
        localVarHeaderParams['if-match'] = ObjectSerializer.serialize(ifMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(patchInstrumentIdentifierRequest, "PatchInstrumentIdentifierRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PatchInstrumentIdentifierRequest;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PatchInstrumentIdentifierRequest");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * |  |  |  | | --- | --- | --- | |**Instrument Identifiers**<br>An Instrument Identifier represents either a card number, or in the case of an ACH bank account, the routing and account number.<br>The same token Id is returned for a specific card number or bank account & routing number allowing the Instrument Identifier Id to be used for cross-channel payment tracking.<br>An Instrument Identifier can exist independently but also be associated with a [Customer Payment Instrument](#token-management_customer-payment-instrument_create-a-customer-payment-instrument) or [Standalone Payment Instrument](#token-management_payment-instrument_create-a-payment-instrument).<br><br>**Creating an Instrument Identifier**<br>It is recommended you [create an Instrument Identifier via a Payment Authorization](#payments_payments_process-a-payment_samplerequests-dropdown_authorization-with-token-create_authorization-with-instrument-identifier-token-creation_liveconsole-tab-request-body), this can be for a zero amount.<br>An Instrument Identifier will also be created if you [create a Customer via a Payment Authorization](#payments_payments_process-a-payment_samplerequests-dropdown_authorization-with-token-create_authorization-with-customer-token-creation_liveconsole-tab-request-body)<br>In Europe: You should perform Payer Authentication alongside the Authorization.|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|**Payment Network Tokens**<br>Network tokens perform better than regular card numbers and they are not necessarily invalidated when a cardholder loses their card, or it expires.<br>A Payment Network Token will be automatically created and used in future payments if you are enabled for the service.<br>A Payment Network Token can also be [provisioned for an existing Instrument Identifier](#token-management_instrument-identifier_enroll-an-instrument-identifier-for-payment-network-token).<br>For more information about Payment Network Tokens see the Developer Guide.<br><br>**Payments with Instrument Identifiers**<br>To perform a payment with an Instrument Identifier simply specify the [Instrument Identifier Id in the payments request along with the expiration date, card type, & billing address](#payments_payments_process-a-payment_samplerequests-dropdown_authorization-using-tokens_authorization-with-instrument-identifier-token-id_liveconsole-tab-request-body).<br>When an Instrument Identifier is used in a payment the **_previousTransactionId_** and **_originalAuthorizedAmount_** values are automatically recorded.<br>These values will be added for you to future Merchant Initiated Transaction payments. 
     * @summary Create an Instrument Identifier
     * @param postInstrumentIdentifierRequest Specify either a Card, Bank Account or Enrollable Card
     * @param profileId The Id of a profile containing user specific TMS configuration.
     * @param retrieveBinDetails Retrieve the Bin Details of PAN or network token
     * @param {*} [options] Override http request options.
     */
    public postInstrumentIdentifier (postInstrumentIdentifierRequest: PostInstrumentIdentifierRequest, profileId?: string, retrieveBinDetails?: boolean, options: any = {}) : Promise<{ response: http.ClientResponse; body: PostInstrumentIdentifierRequest;  }> {
        const localVarPath = this.basePath + '/tms/v1/instrumentidentifiers';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'postInstrumentIdentifierRequest' is not null or undefined
        if (postInstrumentIdentifierRequest === null || postInstrumentIdentifierRequest === undefined) {
            throw new Error('Required parameter postInstrumentIdentifierRequest was null or undefined when calling postInstrumentIdentifier.');
        }

        if (retrieveBinDetails !== undefined) {
            localVarQueryParameters['retrieveBinDetails'] = ObjectSerializer.serialize(retrieveBinDetails, "boolean");
        }

        localVarHeaderParams['profile-id'] = ObjectSerializer.serialize(profileId, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(postInstrumentIdentifierRequest, "PostInstrumentIdentifierRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PostInstrumentIdentifierRequest;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PostInstrumentIdentifierRequest");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * |  |  |  | | --- | --- | --- | |**Instrument Identifiers**<br>An Instrument Identifier represents either a card number, or in the case of an ACH bank account, the routing and account number.<br>The same token Id is returned for a specific card number or bank account & routing number allowing the Instrument Identifier Id to be used for cross-channel payment tracking.<br>An Instrument Identifier can exist independently but also be associated with a [Customer Payment Instrument](#token-management_customer-payment-instrument_create-a-customer-payment-instrument) or [Standalone Payment Instrument](#token-management_payment-instrument_create-a-payment-instrument).|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|**Enroll an Instrument Identifier for a Payment Network Token**<br>Your system can use this API to provision a Network token for an existing Instrument Identifier.<br>Network tokens perform better than regular card numbers and they are not necessarily invalidated when a cardholder loses their card, or it expires.<br>A Network token can be [provisioned when creating an Instrument Identifier](#token-management_instrument-identifier_create-an-instrument-identifier_samplerequests-dropdown_create-instrument-identifier-card-enroll-for-network-token_liveconsole-tab-request-body).This will occur automatically when creating a [Customer](#payments_payments_process-a-payment_samplerequests-dropdown_authorization-with-token-create_authorization-with-customer-token-creation_liveconsole-tab-request-body), [Payment Instrument](#payments_payments_process-a-payment_samplerequests-dropdown_authorization-with-token-create_authorization-create-default-payment-instrument-shipping-address-for-existing-customer_liveconsole-tab-request-body) or [Instrument Identifier](#payments_payments_process-a-payment_samplerequests-dropdown_authorization-with-token-create_authorization-with-instrument-identifier-token-creation_liveconsole-tab-request-body) via the Payments API.<br>For more information about Payment Network Tokens see the Developer Guide. 
     * @summary Enroll an Instrument Identifier for Payment Network Token
     * @param instrumentIdentifierId The Id of an Instrument Identifier.
     * @param postInstrumentIdentifierEnrollmentRequest Specify Enrollable Card details
     * @param profileId The Id of a profile containing user specific TMS configuration.
     * @param {*} [options] Override http request options.
     */
    public postInstrumentIdentifierEnrollment (instrumentIdentifierId: string, postInstrumentIdentifierEnrollmentRequest: PostInstrumentIdentifierEnrollmentRequest, profileId?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/tms/v1/instrumentidentifiers/{instrumentIdentifierId}/enrollment'
            .replace('{' + 'instrumentIdentifierId' + '}', encodeURIComponent(String(instrumentIdentifierId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'instrumentIdentifierId' is not null or undefined
        if (instrumentIdentifierId === null || instrumentIdentifierId === undefined) {
            throw new Error('Required parameter instrumentIdentifierId was null or undefined when calling postInstrumentIdentifierEnrollment.');
        }

        // verify required parameter 'postInstrumentIdentifierEnrollmentRequest' is not null or undefined
        if (postInstrumentIdentifierEnrollmentRequest === null || postInstrumentIdentifierEnrollmentRequest === undefined) {
            throw new Error('Required parameter postInstrumentIdentifierEnrollmentRequest was null or undefined when calling postInstrumentIdentifierEnrollment.');
        }

        localVarHeaderParams['profile-id'] = ObjectSerializer.serialize(profileId, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(postInstrumentIdentifierEnrollmentRequest, "PostInstrumentIdentifierEnrollmentRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum InterchangeClearingLevelDetailsApiApiKeys {
}

export class InterchangeClearingLevelDetailsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: InterchangeClearingLevelDetailsApiApiKeys, value: string) {
        (this.authentications as any)[InterchangeClearingLevelDetailsApiApiKeys[key]].apiKey = value;
    }
    /**
     * Interchange Clearing Level data for an account or a merchant
     * @summary Interchange Clearing Level data for an account or a merchant
     * @param startTime Valid report Start Time in **ISO 8601 format** Please refer the following link to know more about ISO 8601 format.[Rfc Date Format](https://xml2rfc.tools.ietf.org/public/rfc/html/rfc3339.html#anchor14)  **Example date format:**   - yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ (e.g. 2018-01-01T00:00:00.000Z) 
     * @param endTime Valid report End Time in **ISO 8601 format** Please refer the following link to know more about ISO 8601 format.[Rfc Date Format](https://xml2rfc.tools.ietf.org/public/rfc/html/rfc3339.html#anchor14)  **Example date format:**   - yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ (e.g. 2018-01-01T00:00:00.000Z) 
     * @param organizationId Valid Organization Id
     * @param {*} [options] Override http request options.
     */
    public getInterchangeClearingLevelDetails (startTime: Date, endTime: Date, organizationId?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: ReportingV3InterchangeClearingLevelDetailsGet200Response;  }> {
        const localVarPath = this.basePath + '/reporting/v3/interchange-clearing-level-details';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'startTime' is not null or undefined
        if (startTime === null || startTime === undefined) {
            throw new Error('Required parameter startTime was null or undefined when calling getInterchangeClearingLevelDetails.');
        }

        // verify required parameter 'endTime' is not null or undefined
        if (endTime === null || endTime === undefined) {
            throw new Error('Required parameter endTime was null or undefined when calling getInterchangeClearingLevelDetails.');
        }

        if (startTime !== undefined) {
            localVarQueryParameters['startTime'] = ObjectSerializer.serialize(startTime, "Date");
        }

        if (endTime !== undefined) {
            localVarQueryParameters['endTime'] = ObjectSerializer.serialize(endTime, "Date");
        }

        if (organizationId !== undefined) {
            localVarQueryParameters['organizationId'] = ObjectSerializer.serialize(organizationId, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ReportingV3InterchangeClearingLevelDetailsGet200Response;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ReportingV3InterchangeClearingLevelDetailsGet200Response");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum InvoiceSettingsApiApiKeys {
}

export class InvoiceSettingsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: InvoiceSettingsApiApiKeys, value: string) {
        (this.authentications as any)[InvoiceSettingsApiApiKeys[key]].apiKey = value;
    }
    /**
     * Allows you to retrieve the invoice settings for the payment page.
     * @summary Get Invoice Settings
     * @param {*} [options] Override http request options.
     */
    public getInvoiceSettings (options: any = {}) : Promise<{ response: http.ClientResponse; body: InvoicingV2InvoiceSettingsGet200Response;  }> {
        const localVarPath = this.basePath + '/invoicing/v2/invoiceSettings';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InvoicingV2InvoiceSettingsGet200Response;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "InvoicingV2InvoiceSettingsGet200Response");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Allows you to customize the payment page, the checkout experience, email communication and payer authentication. You can customize the invoice to match your brand with your business name, logo and brand colors, and a VAT Tax number. You can choose to capture the payers shipping details, phone number and email during the checkout process. You can add a custom message to all invoice emails and enable or disable payer authentication for invoice payments.
     * @summary Update Invoice Settings
     * @param invoiceSettingsRequest 
     * @param {*} [options] Override http request options.
     */
    public updateInvoiceSettings (invoiceSettingsRequest: InvoiceSettingsRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: InvoicingV2InvoiceSettingsGet200Response;  }> {
        const localVarPath = this.basePath + '/invoicing/v2/invoiceSettings';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'invoiceSettingsRequest' is not null or undefined
        if (invoiceSettingsRequest === null || invoiceSettingsRequest === undefined) {
            throw new Error('Required parameter invoiceSettingsRequest was null or undefined when calling updateInvoiceSettings.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(invoiceSettingsRequest, "InvoiceSettingsRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InvoicingV2InvoiceSettingsGet200Response;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "InvoicingV2InvoiceSettingsGet200Response");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum InvoicesApiApiKeys {
}

export class InvoicesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: InvoicesApiApiKeys, value: string) {
        (this.authentications as any)[InvoicesApiApiKeys[key]].apiKey = value;
    }
    /**
     * The invoicing product enables you to bill any customer with an email address and accept digital payments securely from any connected device. You can either use the system generated email or use the invoice payment link in your own communication. You can add discounts and taxes for the entire invoice or for each line item. To customize the invoice to match your brand see [Invoice Settings](https://developer.cybersource.com/api-reference-assets/index.html#invoicing_invoice-settings_update-invoice-settings). The invoice payment page uses Unified Checkout to process the payments. The availability of API features for a merchant can depend on the portfolio configuration and may need to be enabled at the portfolio level before they can be added to merchant accounts.
     * @summary Create a New Invoice
     * @param createInvoiceRequest 
     * @param {*} [options] Override http request options.
     */
    public createInvoice (createInvoiceRequest: CreateInvoiceRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: InvoicingV2InvoicesPost201Response;  }> {
        const localVarPath = this.basePath + '/invoicing/v2/invoices';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'createInvoiceRequest' is not null or undefined
        if (createInvoiceRequest === null || createInvoiceRequest === undefined) {
            throw new Error('Required parameter createInvoiceRequest was null or undefined when calling createInvoice.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(createInvoiceRequest, "CreateInvoiceRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InvoicingV2InvoicesPost201Response;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "InvoicingV2InvoicesPost201Response");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Provides a (filtered) list of invoices that have been created in your account. You can filter the list based on Invoice Status by setting the status query parameter to one of DRAFT, CREATED, SENT, PARTIAL, PAID or CANCELED.
     * @summary Get a List of Invoices
     * @param offset Page offset number.
     * @param limit Maximum number of items you would like returned.
     * @param status The status of the invoice.  Possible values:   - DRAFT   - CREATED   - SENT   - PARTIAL   - PAID   - CANCELED 
     * @param {*} [options] Override http request options.
     */
    public getAllInvoices (offset: number, limit: number, status?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: InvoicingV2InvoicesAllGet200Response;  }> {
        const localVarPath = this.basePath + '/invoicing/v2/invoices';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'offset' is not null or undefined
        if (offset === null || offset === undefined) {
            throw new Error('Required parameter offset was null or undefined when calling getAllInvoices.');
        }

        // verify required parameter 'limit' is not null or undefined
        if (limit === null || limit === undefined) {
            throw new Error('Required parameter limit was null or undefined when calling getAllInvoices.');
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (status !== undefined) {
            localVarQueryParameters['status'] = ObjectSerializer.serialize(status, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InvoicingV2InvoicesAllGet200Response;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "InvoicingV2InvoicesAllGet200Response");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * You can retrieve details of a specific invoice. This can be used to check the Invoice status and get a list of invoice payments in the invoice history section of the response. For each payment transaction you can use the Transaction Details API to get more details on the payment transaction.
     * @summary Get Invoice Details
     * @param id The invoice number.
     * @param {*} [options] Override http request options.
     */
    public getInvoice (id: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: InvoicingV2InvoicesGet200Response;  }> {
        const localVarPath = this.basePath + '/invoicing/v2/invoices/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getInvoice.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InvoicingV2InvoicesGet200Response;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "InvoicingV2InvoicesGet200Response");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * You can cancel an invoice if no payment is made to it. You cannot cancel partially or fully paid invoices.
     * @summary Cancel an Invoice
     * @param id The invoice number.
     * @param {*} [options] Override http request options.
     */
    public performCancelAction (id: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: InvoicingV2InvoicesCancel200Response;  }> {
        const localVarPath = this.basePath + '/invoicing/v2/invoices/{id}/cancelation'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling performCancelAction.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InvoicingV2InvoicesCancel200Response;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "InvoicingV2InvoicesCancel200Response");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * You can publish an invoice in DRAFT status. After invoking this method, the invoice status is changed to CREATED.
     * @summary Publish an Invoice
     * @param id The invoice number.
     * @param {*} [options] Override http request options.
     */
    public performPublishAction (id: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: InvoicingV2InvoicesPublish200Response;  }> {
        const localVarPath = this.basePath + '/invoicing/v2/invoices/{id}/publication'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling performPublishAction.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InvoicingV2InvoicesPublish200Response;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "InvoicingV2InvoicesPublish200Response");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * You can send an invoice in draft or created state or resend a sent or partially paid invoice. Fully paid or canceled invoices cannot be resent.
     * @summary Send an Invoice
     * @param id The invoice number.
     * @param {*} [options] Override http request options.
     */
    public performSendAction (id: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: InvoicingV2InvoicesSend200Response;  }> {
        const localVarPath = this.basePath + '/invoicing/v2/invoices/{id}/delivery'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling performSendAction.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InvoicingV2InvoicesSend200Response;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "InvoicingV2InvoicesSend200Response");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * You can update all information except the invoice number till any payment is received for an invoice. Invoices that are partially or fully paid or cancelled cannot be updated.
     * @summary Update an Invoice
     * @param id The invoice number.
     * @param updateInvoiceRequest Updating the invoice does not resend the invoice automatically. You must resend the invoice separately.
     * @param {*} [options] Override http request options.
     */
    public updateInvoice (id: string, updateInvoiceRequest: UpdateInvoiceRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: InvoicingV2InvoicesPut200Response;  }> {
        const localVarPath = this.basePath + '/invoicing/v2/invoices/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateInvoice.');
        }

        // verify required parameter 'updateInvoiceRequest' is not null or undefined
        if (updateInvoiceRequest === null || updateInvoiceRequest === undefined) {
            throw new Error('Required parameter updateInvoiceRequest was null or undefined when calling updateInvoice.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(updateInvoiceRequest, "UpdateInvoiceRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InvoicingV2InvoicesPut200Response;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "InvoicingV2InvoicesPut200Response");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ManageWebhooksApiApiKeys {
}

export class ManageWebhooksApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ManageWebhooksApiApiKeys, value: string) {
        (this.authentications as any)[ManageWebhooksApiApiKeys[key]].apiKey = value;
    }
    /**
     * Delete the webhook. Please note that deleting a particular webhook does not delete the history of the webhook notifications.
     * @summary Delete a Webhook Subscription
     * @param webhookId The webhook identifier.
     * @param {*} [options] Override http request options.
     */
    public deleteWebhookSubscription (webhookId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/notification-subscriptions/v2/webhooks/{webhookId}'
            .replace('{' + 'webhookId' + '}', encodeURIComponent(String(webhookId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'webhookId' is not null or undefined
        if (webhookId === null || webhookId === undefined) {
            throw new Error('Required parameter webhookId was null or undefined when calling deleteWebhookSubscription.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve the details of a specific webhook by supplying the webhook ID in the path.
     * @summary Get Details On a Single Webhook
     * @param webhookId The webhook Identifier
     * @param {*} [options] Override http request options.
     */
    public getWebhookSubscriptionById (webhookId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: InlineResponse2015;  }> {
        const localVarPath = this.basePath + '/notification-subscriptions/v2/webhooks/{webhookId}'
            .replace('{' + 'webhookId' + '}', encodeURIComponent(String(webhookId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'webhookId' is not null or undefined
        if (webhookId === null || webhookId === undefined) {
            throw new Error('Required parameter webhookId was null or undefined when calling getWebhookSubscriptionById.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse2015;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "InlineResponse2015");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve a list of all previously created webhooks.
     * @summary Get Details On All Created Webhooks
     * @param organizationId The Organization Identifier.
     * @param productId The Product Identifier.
     * @param eventType The Event Type.
     * @param {*} [options] Override http request options.
     */
    public getWebhookSubscriptionsByOrg (organizationId: string, productId?: string, eventType?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: Array<InlineResponse2004>;  }> {
        const localVarPath = this.basePath + '/notification-subscriptions/v2/webhooks';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'organizationId' is not null or undefined
        if (organizationId === null || organizationId === undefined) {
            throw new Error('Required parameter organizationId was null or undefined when calling getWebhookSubscriptionsByOrg.');
        }

        if (organizationId !== undefined) {
            localVarQueryParameters['organizationId'] = ObjectSerializer.serialize(organizationId, "string");
        }

        if (productId !== undefined) {
            localVarQueryParameters['productId'] = ObjectSerializer.serialize(productId, "string");
        }

        if (eventType !== undefined) {
            localVarQueryParameters['eventType'] = ObjectSerializer.serialize(eventType, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: Array<InlineResponse2004>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<InlineResponse2004>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Test the webhook configuration by sending a sample webhook. Calling this endpoint sends a sample webhook to the endpoint identified in the user's subscription.   It will contain sample values for the product & eventType based on values present in your subscription along with a sample message in the payload.   Based on the webhook response users can make any necessary modifications or rest assured knowing their setup is configured correctly. 
     * @summary Test a Webhook Configuration
     * @param webhookId The Webhook Identifier.
     * @param {*} [options] Override http request options.
     */
    public notificationSubscriptionsV1WebhooksWebhookIdPost (webhookId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: InlineResponse2016;  }> {
        const localVarPath = this.basePath + '/notification-subscriptions/v1/webhooks/{webhookId}'
            .replace('{' + 'webhookId' + '}', encodeURIComponent(String(webhookId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'webhookId' is not null or undefined
        if (webhookId === null || webhookId === undefined) {
            throw new Error('Required parameter webhookId was null or undefined when calling notificationSubscriptionsV1WebhooksWebhookIdPost.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse2016;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "InlineResponse2016");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update a Webhook Subscription.
     * @summary Update a Webhook Subscription
     * @param webhookId The Webhook Identifier.
     * @param updateWebhook The webhook payload or changes to apply.
     * @param {*} [options] Override http request options.
     */
    public notificationSubscriptionsV2WebhooksWebhookIdPatch (webhookId: string, updateWebhook?: UpdateWebhook, options: any = {}) : Promise<{ response: http.ClientResponse; body: InlineResponse2005;  }> {
        const localVarPath = this.basePath + '/notification-subscriptions/v2/webhooks/{webhookId}'
            .replace('{' + 'webhookId' + '}', encodeURIComponent(String(webhookId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'webhookId' is not null or undefined
        if (webhookId === null || webhookId === undefined) {
            throw new Error('Required parameter webhookId was null or undefined when calling notificationSubscriptionsV2WebhooksWebhookIdPatch.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(updateWebhook, "UpdateWebhook")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse2005;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "InlineResponse2005");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Users can update the status of a webhook subscription by calling this endpoint.   The webhookId parameter in the URL path identifies the specific webhook subscription to be updated. The request body accepts the values ACTIVE or INACTIVE. If the subscription is set to INACTIVE, webhooks will not be delivered until the subscription is activated again. 
     * @summary Update a Webhook Status
     * @param webhookId The Webhook Identifier.
     * @param updateStatus The status that the subscription should be updated to.
     * @param {*} [options] Override http request options.
     */
    public notificationSubscriptionsV2WebhooksWebhookIdStatusPut (webhookId: string, updateStatus?: UpdateStatus, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/notification-subscriptions/v2/webhooks/{webhookId}/status'
            .replace('{' + 'webhookId' + '}', encodeURIComponent(String(webhookId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'webhookId' is not null or undefined
        if (webhookId === null || webhookId === undefined) {
            throw new Error('Required parameter webhookId was null or undefined when calling notificationSubscriptionsV2WebhooksWebhookIdStatusPut.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(updateStatus, "UpdateStatus")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Store and manage certificates that will be used to preform Message Level Encryption (MLE). Each new webhook will need its own unique asymmetric certificate. You can either use a digital certificate issued/signed by a CA or self-sign your own using the documentation available on the Developer Guide. 
     * @summary Message Level Encryption
     * @param vCSenderOrganizationId Sender organization id
     * @param vCPermissions Encoded user permissions returned by the CGK, for the entity user who initiated the boarding
     * @param saveAsymEgressKey Provide egress Asymmetric key information to save (create or store)
     * @param vCCorrelationId A globally unique id associated with your request
     * @param {*} [options] Override http request options.
     */
    public saveAsymEgressKey (vCSenderOrganizationId: string, vCPermissions: string, saveAsymEgressKey: SaveAsymEgressKey, vCCorrelationId?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: InlineResponse2017;  }> {
        const localVarPath = this.basePath + '/kms/egress/v2/keys-asym';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'vCSenderOrganizationId' is not null or undefined
        if (vCSenderOrganizationId === null || vCSenderOrganizationId === undefined) {
            throw new Error('Required parameter vCSenderOrganizationId was null or undefined when calling saveAsymEgressKey.');
        }

        // verify required parameter 'vCPermissions' is not null or undefined
        if (vCPermissions === null || vCPermissions === undefined) {
            throw new Error('Required parameter vCPermissions was null or undefined when calling saveAsymEgressKey.');
        }

        // verify required parameter 'saveAsymEgressKey' is not null or undefined
        if (saveAsymEgressKey === null || saveAsymEgressKey === undefined) {
            throw new Error('Required parameter saveAsymEgressKey was null or undefined when calling saveAsymEgressKey.');
        }

        localVarHeaderParams['v-c-correlation-id'] = ObjectSerializer.serialize(vCCorrelationId, "string");
        localVarHeaderParams['v-c-sender-organization-id'] = ObjectSerializer.serialize(vCSenderOrganizationId, "string");
        localVarHeaderParams['v-c-permissions'] = ObjectSerializer.serialize(vCPermissions, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(saveAsymEgressKey, "SaveAsymEgressKey")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse2017;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "InlineResponse2017");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum MerchantBoardingApiApiKeys {
}

export class MerchantBoardingApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: MerchantBoardingApiApiKeys, value: string) {
        (this.authentications as any)[MerchantBoardingApiApiKeys[key]].apiKey = value;
    }
    /**
     * This end point will get all information of a boarding registration 
     * @summary Gets all the information on a boarding registration
     * @param registrationId Identifies the boarding registration to be updated
     * @param {*} [options] Override http request options.
     */
    public getRegistration (registrationId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: InlineResponse2002;  }> {
        const localVarPath = this.basePath + '/boarding/v1/registrations/{registrationId}'
            .replace('{' + 'registrationId' + '}', encodeURIComponent(String(registrationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'registrationId' is not null or undefined
        if (registrationId === null || registrationId === undefined) {
            throw new Error('Required parameter registrationId was null or undefined when calling getRegistration.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse2002;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "InlineResponse2002");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Boarding Product is specifically for resellers who onboard merchants to resell their services to merchants and help integrate REST API into their systems.  The Boarding API is designed to simplify and streamline the onboarding process of merchants by enabling administrators and developers to: 1. Enable and Configure Products: The API helps in adding new products to an existing organization and configuring them to suit specific needs. 2. Update Merchant Information: The API allows for updating an organization’s information efficiently. 3. Manage Payment Integration: It provides templates for secure payment integration and management. 
     * @summary Create a boarding registration
     * @param postRegistrationBody Boarding registration data
     * @param vCIdempotencyId defines idempotency of the request
     * @param {*} [options] Override http request options.
     */
    public postRegistration (postRegistrationBody: PostRegistrationBody, vCIdempotencyId?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: InlineResponse2013;  }> {
        const localVarPath = this.basePath + '/boarding/v1/registrations';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'postRegistrationBody' is not null or undefined
        if (postRegistrationBody === null || postRegistrationBody === undefined) {
            throw new Error('Required parameter postRegistrationBody was null or undefined when calling postRegistration.');
        }

        localVarHeaderParams['v-c-idempotency-id'] = ObjectSerializer.serialize(vCIdempotencyId, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(postRegistrationBody, "PostRegistrationBody")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse2013;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "InlineResponse2013");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum MicroformIntegrationApiApiKeys {
}

export class MicroformIntegrationApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: MicroformIntegrationApiApiKeys, value: string) {
        (this.authentications as any)[MicroformIntegrationApiApiKeys[key]].apiKey = value;
    }
    /**
     * This API is used to generate the Capture Context data structure for the Microform Integration.  Microform is a browser-based acceptance solution that allows a seller to capture payment information is a secure manner from their website.  For more information about Flex Microform transactions, see the [Flex Developer Guides Page](https://developer.cybersource.com/api/developer-guides/dita-flex/SAFlexibleToken.html). For examples on how to integrate Flex Microform within your webpage please see our [GitHub Flex Samples](https://github.com/CyberSource?q=flex&type=&language=) This API is a server-to-server API to generate the capture context that can be used to initiate instance of microform on a acceptance page.  The capture context is a digitally signed JWT that provides authentication, one-time keys, and the target origin to the Microform Integration application.  The availability of API features for a merchant may depend on the portfolio configuration and may need to be enabled at the portfolio level before they can be added to merchant accounts.
     * @summary Generate Capture Context
     * @param generateCaptureContextRequest 
     * @param {*} [options] Override http request options.
     */
    public generateCaptureContext (generateCaptureContextRequest: GenerateCaptureContextRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: string;  }> {
        const localVarPath = this.basePath + '/microform/v2/sessions';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'generateCaptureContextRequest' is not null or undefined
        if (generateCaptureContextRequest === null || generateCaptureContextRequest === undefined) {
            throw new Error('Required parameter generateCaptureContextRequest was null or undefined when calling generateCaptureContext.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(generateCaptureContextRequest, "GenerateCaptureContextRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: string;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum NetFundingsApiApiKeys {
}

export class NetFundingsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: NetFundingsApiApiKeys, value: string) {
        (this.authentications as any)[NetFundingsApiApiKeys[key]].apiKey = value;
    }
    /**
     * Get Netfunding information for an account or a merchant.
     * @summary Get Netfunding Information for an Account or a Merchant
     * @param startTime Valid report Start Time in **ISO 8601 format** Please refer the following link to know more about ISO 8601 format.[Rfc Date Format](https://xml2rfc.tools.ietf.org/public/rfc/html/rfc3339.html#anchor14)  **Example date format:**   - yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ (e.g. 2018-01-01T00:00:00.000Z) 
     * @param endTime Valid report End Time in **ISO 8601 format** Please refer the following link to know more about ISO 8601 format.[Rfc Date Format](https://xml2rfc.tools.ietf.org/public/rfc/html/rfc3339.html#anchor14)  **Example date format:**   - yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ (e.g. 2018-01-01T00:00:00.000Z) 
     * @param organizationId Valid Organization Id
     * @param groupName Valid CyberSource Group Name.
     * @param {*} [options] Override http request options.
     */
    public getNetFundingDetails (startTime: Date, endTime: Date, organizationId?: string, groupName?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: ReportingV3NetFundingsGet200Response;  }> {
        const localVarPath = this.basePath + '/reporting/v3/net-fundings';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'startTime' is not null or undefined
        if (startTime === null || startTime === undefined) {
            throw new Error('Required parameter startTime was null or undefined when calling getNetFundingDetails.');
        }

        // verify required parameter 'endTime' is not null or undefined
        if (endTime === null || endTime === undefined) {
            throw new Error('Required parameter endTime was null or undefined when calling getNetFundingDetails.');
        }

        if (startTime !== undefined) {
            localVarQueryParameters['startTime'] = ObjectSerializer.serialize(startTime, "Date");
        }

        if (endTime !== undefined) {
            localVarQueryParameters['endTime'] = ObjectSerializer.serialize(endTime, "Date");
        }

        if (organizationId !== undefined) {
            localVarQueryParameters['organizationId'] = ObjectSerializer.serialize(organizationId, "string");
        }

        if (groupName !== undefined) {
            localVarQueryParameters['groupName'] = ObjectSerializer.serialize(groupName, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ReportingV3NetFundingsGet200Response;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ReportingV3NetFundingsGet200Response");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum NotificationOfChangesApiApiKeys {
}

export class NotificationOfChangesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: NotificationOfChangesApiApiKeys, value: string) {
        (this.authentications as any)[NotificationOfChangesApiApiKeys[key]].apiKey = value;
    }
    /**
     * Download the Notification of Change report. This report shows eCheck-related fields updated as a result of a response to an eCheck settlement transaction. 
     * @summary Get Notification of Changes
     * @param startTime Valid report Start Time in **ISO 8601 format** Please refer the following link to know more about ISO 8601 format.[Rfc Date Format](https://xml2rfc.tools.ietf.org/public/rfc/html/rfc3339.html#anchor14)  **Example date format:**   - yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ (e.g. 2018-01-01T00:00:00.000Z) 
     * @param endTime Valid report End Time in **ISO 8601 format** Please refer the following link to know more about ISO 8601 format.[Rfc Date Format](https://xml2rfc.tools.ietf.org/public/rfc/html/rfc3339.html#anchor14)  **Example date format:**   - yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ (e.g. 2018-01-01T00:00:00.000Z) 
     * @param {*} [options] Override http request options.
     */
    public getNotificationOfChangeReport (startTime: Date, endTime: Date, options: any = {}) : Promise<{ response: http.ClientResponse; body: ReportingV3NotificationofChangesGet200Response;  }> {
        const localVarPath = this.basePath + '/reporting/v3/notification-of-changes';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'startTime' is not null or undefined
        if (startTime === null || startTime === undefined) {
            throw new Error('Required parameter startTime was null or undefined when calling getNotificationOfChangeReport.');
        }

        // verify required parameter 'endTime' is not null or undefined
        if (endTime === null || endTime === undefined) {
            throw new Error('Required parameter endTime was null or undefined when calling getNotificationOfChangeReport.');
        }

        if (startTime !== undefined) {
            localVarQueryParameters['startTime'] = ObjectSerializer.serialize(startTime, "Date");
        }

        if (endTime !== undefined) {
            localVarQueryParameters['endTime'] = ObjectSerializer.serialize(endTime, "Date");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ReportingV3NotificationofChangesGet200Response;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ReportingV3NotificationofChangesGet200Response");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum OrdersApiApiKeys {
}

export class OrdersApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: OrdersApiApiKeys, value: string) {
        (this.authentications as any)[OrdersApiApiKeys[key]].apiKey = value;
    }
    /**
     * A create order request enables you to send the itemized details along with the order. This API can be used by merchants initiating their transactions with the create order API.  
     * @summary Create an Order
     * @param createOrderRequest 
     * @param {*} [options] Override http request options.
     */
    public createOrder (createOrderRequest: CreateOrderRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: PtsV2CreateOrderPost201Response;  }> {
        const localVarPath = this.basePath + '/pts/v2/intents';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'createOrderRequest' is not null or undefined
        if (createOrderRequest === null || createOrderRequest === undefined) {
            throw new Error('Required parameter createOrderRequest was null or undefined when calling createOrder.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(createOrderRequest, "CreateOrderRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PtsV2CreateOrderPost201Response;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PtsV2CreateOrderPost201Response");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * This API can be used in two flavours - for updating the order as well as saving the order. 
     * @summary Update an Order
     * @param id The ID returned from the original create order response.
     * @param updateOrderRequest 
     * @param {*} [options] Override http request options.
     */
    public updateOrder (id: string, updateOrderRequest: UpdateOrderRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: PtsV2UpdateOrderPatch201Response;  }> {
        const localVarPath = this.basePath + '/pts/v2/intents/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateOrder.');
        }

        // verify required parameter 'updateOrderRequest' is not null or undefined
        if (updateOrderRequest === null || updateOrderRequest === undefined) {
            throw new Error('Required parameter updateOrderRequest was null or undefined when calling updateOrder.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(updateOrderRequest, "UpdateOrderRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PtsV2UpdateOrderPatch201Response;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PtsV2UpdateOrderPatch201Response");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum PayerAuthenticationApiApiKeys {
}

export class PayerAuthenticationApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: PayerAuthenticationApiApiKeys, value: string) {
        (this.authentications as any)[PayerAuthenticationApiApiKeys[key]].apiKey = value;
    }
    /**
     * This call verifies that the card is enrolled in a card authentication program.
     * @summary Check Payer Auth Enrollment
     * @param checkPayerAuthEnrollmentRequest 
     * @param {*} [options] Override http request options.
     */
    public checkPayerAuthEnrollment (checkPayerAuthEnrollmentRequest: CheckPayerAuthEnrollmentRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: RiskV1AuthenticationsPost201Response;  }> {
        const localVarPath = this.basePath + '/risk/v1/authentications';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'checkPayerAuthEnrollmentRequest' is not null or undefined
        if (checkPayerAuthEnrollmentRequest === null || checkPayerAuthEnrollmentRequest === undefined) {
            throw new Error('Required parameter checkPayerAuthEnrollmentRequest was null or undefined when calling checkPayerAuthEnrollment.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(checkPayerAuthEnrollmentRequest, "CheckPayerAuthEnrollmentRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: RiskV1AuthenticationsPost201Response;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RiskV1AuthenticationsPost201Response");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * A new service for Merchants to get reference_id for Digital Wallets to use in place of BIN number in Cardinal. Set up file while authenticating with Cardinal. This service should be called by Merchant when payment instrument chosen or changes. This service has to be called before enrollment check. The availability of API features for a merchant may depend on the portfolio configuration and may need to be enabled at the portfolio level before they can be added to merchant accounts.
     * @summary Setup Payer Auth
     * @param payerAuthSetupRequest 
     * @param {*} [options] Override http request options.
     */
    public payerAuthSetup (payerAuthSetupRequest: PayerAuthSetupRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: RiskV1AuthenticationSetupsPost201Response;  }> {
        const localVarPath = this.basePath + '/risk/v1/authentication-setups';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'payerAuthSetupRequest' is not null or undefined
        if (payerAuthSetupRequest === null || payerAuthSetupRequest === undefined) {
            throw new Error('Required parameter payerAuthSetupRequest was null or undefined when calling payerAuthSetup.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(payerAuthSetupRequest, "PayerAuthSetupRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: RiskV1AuthenticationSetupsPost201Response;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RiskV1AuthenticationSetupsPost201Response");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * This call retrieves and validates the authentication results from issuer and allows the merchant to proceed with processing the payment. 
     * @summary Validate Authentication Results
     * @param validateRequest 
     * @param {*} [options] Override http request options.
     */
    public validateAuthenticationResults (validateRequest: ValidateRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: RiskV1AuthenticationResultsPost201Response;  }> {
        const localVarPath = this.basePath + '/risk/v1/authentication-results';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'validateRequest' is not null or undefined
        if (validateRequest === null || validateRequest === undefined) {
            throw new Error('Required parameter validateRequest was null or undefined when calling validateAuthenticationResults.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(validateRequest, "ValidateRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: RiskV1AuthenticationResultsPost201Response;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RiskV1AuthenticationResultsPost201Response");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum PaymentBatchSummariesApiApiKeys {
}

export class PaymentBatchSummariesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: PaymentBatchSummariesApiApiKeys, value: string) {
        (this.authentications as any)[PaymentBatchSummariesApiApiKeys[key]].apiKey = value;
    }
    /**
     * Scope can be either account/merchant or reseller.
     * @summary Get Payment Batch Summary Data
     * @param startTime Valid report Start Time in **ISO 8601 format** Please refer the following link to know more about ISO 8601 format.[Rfc Date Format](https://xml2rfc.tools.ietf.org/public/rfc/html/rfc3339.html#anchor14)  **Example date format:**   - yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ (e.g. 2018-01-01T00:00:00.000Z) 
     * @param endTime Valid report End Time in **ISO 8601 format** Please refer the following link to know more about ISO 8601 format.[Rfc Date Format](https://xml2rfc.tools.ietf.org/public/rfc/html/rfc3339.html#anchor14)  **Example date format:**   - yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ (e.g. 2018-01-01T00:00:00.000Z) 
     * @param organizationId Valid Organization Id
     * @param rollUp Conditional - RollUp for data for day/week/month. Required while getting breakdown data for a Merchant
     * @param breakdown Conditional - Breakdown on account_rollup/all_merchant/selected_merchant. Required while getting breakdown data for a Merchant.
     * @param startDayOfWeek Optional - Start day of week to breakdown data for weeks in a month
     * @param {*} [options] Override http request options.
     */
    public getPaymentBatchSummary (startTime: Date, endTime: Date, organizationId?: string, rollUp?: string, breakdown?: string, startDayOfWeek?: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: ReportingV3PaymentBatchSummariesGet200Response;  }> {
        const localVarPath = this.basePath + '/reporting/v3/payment-batch-summaries';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'startTime' is not null or undefined
        if (startTime === null || startTime === undefined) {
            throw new Error('Required parameter startTime was null or undefined when calling getPaymentBatchSummary.');
        }

        // verify required parameter 'endTime' is not null or undefined
        if (endTime === null || endTime === undefined) {
            throw new Error('Required parameter endTime was null or undefined when calling getPaymentBatchSummary.');
        }

        if (startTime !== undefined) {
            localVarQueryParameters['startTime'] = ObjectSerializer.serialize(startTime, "Date");
        }

        if (endTime !== undefined) {
            localVarQueryParameters['endTime'] = ObjectSerializer.serialize(endTime, "Date");
        }

        if (organizationId !== undefined) {
            localVarQueryParameters['organizationId'] = ObjectSerializer.serialize(organizationId, "string");
        }

        if (rollUp !== undefined) {
            localVarQueryParameters['rollUp'] = ObjectSerializer.serialize(rollUp, "string");
        }

        if (breakdown !== undefined) {
            localVarQueryParameters['breakdown'] = ObjectSerializer.serialize(breakdown, "string");
        }

        if (startDayOfWeek !== undefined) {
            localVarQueryParameters['startDayOfWeek'] = ObjectSerializer.serialize(startDayOfWeek, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ReportingV3PaymentBatchSummariesGet200Response;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ReportingV3PaymentBatchSummariesGet200Response");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum PaymentInstrumentApiApiKeys {
}

export class PaymentInstrumentApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: PaymentInstrumentApiApiKeys, value: string) {
        (this.authentications as any)[PaymentInstrumentApiApiKeys[key]].apiKey = value;
    }
    /**
     * |  |  |  | | --- | --- | --- | |**Standalone Payment Instruments**<br>A Payment Instrument represents tokenized payment information such as expiration date, billing address & card type.<br>A Payment Instrument token does not store the card number. A Payment Instrument is associated with an [Instrument Identifier](#token-management_instrument-identifier_create-an-instrument-identifier) that represents either a payment card number, or in the case of an ACH bank account, the routing and account number.<br>**Standalone Payment Instruments do not belong to a [Customer](#token-management_customer_create-a-customer).**|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|**Deleting a Payment Instrument**<br>Your system can use this API to delete an existing Payment Instrument.<br>Any Instrument Identifiers representing the card number will also be deleted if they are not associated with any other Payment Instruments. 
     * @summary Delete a Payment Instrument
     * @param paymentInstrumentId The Id of a payment instrument.
     * @param profileId The Id of a profile containing user specific TMS configuration.
     * @param {*} [options] Override http request options.
     */
    public deletePaymentInstrument (paymentInstrumentId: string, profileId?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/tms/v1/paymentinstruments/{paymentInstrumentId}'
            .replace('{' + 'paymentInstrumentId' + '}', encodeURIComponent(String(paymentInstrumentId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'paymentInstrumentId' is not null or undefined
        if (paymentInstrumentId === null || paymentInstrumentId === undefined) {
            throw new Error('Required parameter paymentInstrumentId was null or undefined when calling deletePaymentInstrument.');
        }

        localVarHeaderParams['profile-id'] = ObjectSerializer.serialize(profileId, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * |  |  |  | | --- | --- | --- | |**Standalone Payment Instruments**<br>A Payment Instrument represents tokenized payment information such as expiration date, billing address & card type.<br>A Payment Instrument token does not store the card number. A Payment Instrument is associated with an [Instrument Identifier](#token-management_instrument-identifier_create-an-instrument-identifier) that represents either a payment card number, or in the case of an ACH bank account, the routing and account number.<br>**Standalone Payment Instruments do not belong to a [Customer](#token-management_customer_create-a-customer).**|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|**Retrieving a Payment Instrument**<br>Your system can use this API to retrieve an existing Payment Instrument.<br>To perform a payment with a particular Payment Instrument simply specify the [Payment Instrument Id in the payments request](#payments_payments_process-a-payment_samplerequests-dropdown_authorization-using-tokens_authorization-with-customer-payment-instrument-and-shipping-address-token-id_liveconsole-tab-request-body). 
     * @summary Retrieve a Payment Instrument
     * @param paymentInstrumentId The Id of a payment instrument.
     * @param profileId The Id of a profile containing user specific TMS configuration.
     * @param retrieveBinDetails Retrieve the Bin Details of PAN or network token
     * @param {*} [options] Override http request options.
     */
    public getPaymentInstrument (paymentInstrumentId: string, profileId?: string, retrieveBinDetails?: boolean, options: any = {}) : Promise<{ response: http.ClientResponse; body: PostPaymentInstrumentRequest;  }> {
        const localVarPath = this.basePath + '/tms/v1/paymentinstruments/{paymentInstrumentId}'
            .replace('{' + 'paymentInstrumentId' + '}', encodeURIComponent(String(paymentInstrumentId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'paymentInstrumentId' is not null or undefined
        if (paymentInstrumentId === null || paymentInstrumentId === undefined) {
            throw new Error('Required parameter paymentInstrumentId was null or undefined when calling getPaymentInstrument.');
        }

        if (retrieveBinDetails !== undefined) {
            localVarQueryParameters['retrieveBinDetails'] = ObjectSerializer.serialize(retrieveBinDetails, "boolean");
        }

        localVarHeaderParams['profile-id'] = ObjectSerializer.serialize(profileId, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PostPaymentInstrumentRequest;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PostPaymentInstrumentRequest");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * |  |  |  | | --- | --- | --- | |**Standalone Payment Instruments**<br>A Payment Instrument represents tokenized payment information such as expiration date, billing address & card type.<br>A Payment Instrument token does not store the card number. A Payment Instrument is associated with an [Instrument Identifier](#token-management_instrument-identifier_create-an-instrument-identifier) that represents either a payment card number, or in the case of an ACH bank account, the routing and account number.<br>**Standalone Payment Instruments do not belong to a [Customer](#token-management_customer_create-a-customer).**|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|**Updating a Payment Instrument**<br>Your system can use this API to update an existing Payment Instrument. 
     * @summary Update a Payment Instrument
     * @param paymentInstrumentId The Id of a payment instrument.
     * @param patchPaymentInstrumentRequest 
     * @param profileId The Id of a profile containing user specific TMS configuration.
     * @param retrieveBinDetails Retrieve the Bin Details of PAN or network token
     * @param ifMatch Contains an ETag value from a GET request to make the request conditional.
     * @param {*} [options] Override http request options.
     */
    public patchPaymentInstrument (paymentInstrumentId: string, patchPaymentInstrumentRequest: PatchPaymentInstrumentRequest, profileId?: string, retrieveBinDetails?: boolean, ifMatch?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: PatchPaymentInstrumentRequest;  }> {
        const localVarPath = this.basePath + '/tms/v1/paymentinstruments/{paymentInstrumentId}'
            .replace('{' + 'paymentInstrumentId' + '}', encodeURIComponent(String(paymentInstrumentId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'paymentInstrumentId' is not null or undefined
        if (paymentInstrumentId === null || paymentInstrumentId === undefined) {
            throw new Error('Required parameter paymentInstrumentId was null or undefined when calling patchPaymentInstrument.');
        }

        // verify required parameter 'patchPaymentInstrumentRequest' is not null or undefined
        if (patchPaymentInstrumentRequest === null || patchPaymentInstrumentRequest === undefined) {
            throw new Error('Required parameter patchPaymentInstrumentRequest was null or undefined when calling patchPaymentInstrument.');
        }

        if (retrieveBinDetails !== undefined) {
            localVarQueryParameters['retrieveBinDetails'] = ObjectSerializer.serialize(retrieveBinDetails, "boolean");
        }

        localVarHeaderParams['profile-id'] = ObjectSerializer.serialize(profileId, "string");
        localVarHeaderParams['if-match'] = ObjectSerializer.serialize(ifMatch, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(patchPaymentInstrumentRequest, "PatchPaymentInstrumentRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PatchPaymentInstrumentRequest;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PatchPaymentInstrumentRequest");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * |  |  |  | | --- | --- | --- | |**Standalone Payment Instruments**<br>A Payment Instrument represents tokenized payment information such as expiration date, billing address & card type.<br>A Payment Instrument token does not store the card number. A Payment Instrument is associated with an [Instrument Identifier](#token-management_instrument-identifier_create-an-instrument-identifier) that represents either a payment card number, or in the case of an ACH bank account, the routing and account number.<br>**Standalone Payment Instruments do not belong to a [Customer](#token-management_customer_create-a-customer).**<br><br>**Creating a Payment Instrument**<br>It is recommended you [create a Payment Instrument via a Payment Authorization](#payments_payments_process-a-payment_samplerequests-dropdown_authorization-with-token-create_authorization-with-customer-token-creation_liveconsole-tab-request-body), this can be for a zero amount.<br>In Europe: You should perform Payer Authentication alongside the Authorization.|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|**Payment Network Tokens**<br>Network tokens perform better than regular card numbers and they are not necessarily invalidated when a cardholder loses their card, or it expires.<br>A Payment Network Token will be automatically created and used in future payments if you are enabled for the service.<br>A Payment Network Token can also be [provisioned for an existing Instrument Identifier](#token-management_instrument-identifier_enroll-an-instrument-identifier-for-payment-network-token).<br>For more information about Payment Network Tokens see the Developer Guide.<br><br>**Payments with Payment Instruments**<br>To perform a payment with a particular Payment Instrument specify the [Payment Instrument in the payment request](#payments_payments_process-a-payment_samplerequests-dropdown_authorization-using-tokens_authorization-with-customer-payment-instrument-and-shipping-address-token-id_liveconsole-tab-request-body). 
     * @summary Create a Payment Instrument
     * @param postPaymentInstrumentRequest 
     * @param profileId The Id of a profile containing user specific TMS configuration.
     * @param retrieveBinDetails Retrieve the Bin Details of PAN or network token
     * @param {*} [options] Override http request options.
     */
    public postPaymentInstrument (postPaymentInstrumentRequest: PostPaymentInstrumentRequest, profileId?: string, retrieveBinDetails?: boolean, options: any = {}) : Promise<{ response: http.ClientResponse; body: PostPaymentInstrumentRequest;  }> {
        const localVarPath = this.basePath + '/tms/v1/paymentinstruments';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'postPaymentInstrumentRequest' is not null or undefined
        if (postPaymentInstrumentRequest === null || postPaymentInstrumentRequest === undefined) {
            throw new Error('Required parameter postPaymentInstrumentRequest was null or undefined when calling postPaymentInstrument.');
        }

        if (retrieveBinDetails !== undefined) {
            localVarQueryParameters['retrieveBinDetails'] = ObjectSerializer.serialize(retrieveBinDetails, "boolean");
        }

        localVarHeaderParams['profile-id'] = ObjectSerializer.serialize(profileId, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(postPaymentInstrumentRequest, "PostPaymentInstrumentRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PostPaymentInstrumentRequest;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PostPaymentInstrumentRequest");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum PaymentLinksApiApiKeys {
}

export class PaymentLinksApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: PaymentLinksApiApiKeys, value: string) {
        (this.authentications as any)[PaymentLinksApiApiKeys[key]].apiKey = value;
    }
    /**
     * Pay by Link is an easy and fast way to securely sell products or receive donations online. This solution is ideal for distributing the same payment link to multiple customers.   Links for making purchases are referred to as fixed-price links, and links for making donations are referred to as customer-set price links. 
     * @summary Create a Payment Link
     * @param createPaymentLinkRequest 
     * @param {*} [options] Override http request options.
     */
    public createPaymentLink (createPaymentLinkRequest: CreatePaymentLinkRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: PblPaymentLinksPost201Response;  }> {
        const localVarPath = this.basePath + '/ipl/v2/payment-links';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'createPaymentLinkRequest' is not null or undefined
        if (createPaymentLinkRequest === null || createPaymentLinkRequest === undefined) {
            throw new Error('Required parameter createPaymentLinkRequest was null or undefined when calling createPaymentLink.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(createPaymentLinkRequest, "CreatePaymentLinkRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PblPaymentLinksPost201Response;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PblPaymentLinksPost201Response");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Provides a (filtered) list of payment links that have been created in your account. You can filter the list based on the following status types:  - ACTIVE  - INACTIVE 
     * @summary Get a List of Payment Links
     * @param offset Page offset number.
     * @param limit Maximum number of items you would like returned.   Maximum limit: 1000 
     * @param status The status of the purchase or donation link.  Possible values:   - ACTIVE   - INACTIVE 
     * @param {*} [options] Override http request options.
     */
    public getAllPaymentLinks (offset: number, limit: number, status?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: PblPaymentLinksAllGet200Response;  }> {
        const localVarPath = this.basePath + '/ipl/v2/payment-links';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'offset' is not null or undefined
        if (offset === null || offset === undefined) {
            throw new Error('Required parameter offset was null or undefined when calling getAllPaymentLinks.');
        }

        // verify required parameter 'limit' is not null or undefined
        if (limit === null || limit === undefined) {
            throw new Error('Required parameter limit was null or undefined when calling getAllPaymentLinks.');
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (status !== undefined) {
            localVarQueryParameters['status'] = ObjectSerializer.serialize(status, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PblPaymentLinksAllGet200Response;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PblPaymentLinksAllGet200Response");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * You can retrieve details of a specific payment link. For each payment transaction you can use the Transaction Details API to get more details on the payment transaction.
     * @summary Get Payment Link Details
     * @param id The purchase number.
     * @param {*} [options] Override http request options.
     */
    public getPaymentLink (id: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: PblPaymentLinksGet200Response;  }> {
        const localVarPath = this.basePath + '/ipl/v2/payment-links/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getPaymentLink.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PblPaymentLinksGet200Response;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PblPaymentLinksGet200Response");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * You can update all information except the payment link number for a payment link. Changes made to amount/price will apply to new payments made using the payment link. 
     * @summary Update a Payment Link
     * @param id The purchase number.
     * @param updatePaymentLinkRequest Updating the purchase or donation link does not resend the link automatically. You must resend the purchase or donation link separately.
     * @param {*} [options] Override http request options.
     */
    public updatePaymentLink (id: string, updatePaymentLinkRequest: UpdatePaymentLinkRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: PblPaymentLinksPost201Response;  }> {
        const localVarPath = this.basePath + '/ipl/v2/payment-links/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updatePaymentLink.');
        }

        // verify required parameter 'updatePaymentLinkRequest' is not null or undefined
        if (updatePaymentLinkRequest === null || updatePaymentLinkRequest === undefined) {
            throw new Error('Required parameter updatePaymentLinkRequest was null or undefined when calling updatePaymentLink.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(updatePaymentLinkRequest, "UpdatePaymentLinkRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PblPaymentLinksPost201Response;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PblPaymentLinksPost201Response");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum PaymentTokensApiApiKeys {
}

export class PaymentTokensApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: PaymentTokensApiApiKeys, value: string) {
        (this.authentications as any)[PaymentTokensApiApiKeys[key]].apiKey = value;
    }
    /**
     * This API can be used in two flavours - for retrieval or deletion of vault id. 
     * @summary Retrieve or Delete Payment Token
     * @param request 
     * @param {*} [options] Override http request options.
     */
    public retrieveOrDeletePaymentToken (request: Request, options: any = {}) : Promise<{ response: http.ClientResponse; body: InlineResponse201;  }> {
        const localVarPath = this.basePath + '/pts/v2/payment-tokens';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'request' is not null or undefined
        if (request === null || request === undefined) {
            throw new Error('Required parameter request was null or undefined when calling retrieveOrDeletePaymentToken.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(request, "Request")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse201;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "InlineResponse201");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum PaymentsApiApiKeys {
}

export class PaymentsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: PaymentsApiApiKeys, value: string) {
        (this.authentications as any)[PaymentsApiApiKeys[key]].apiKey = value;
    }
    /**
     * Create a Payment Order Request
     * @summary Create a Payment Order Request
     * @param orderPaymentRequest 
     * @param id Request identifier number for the order request. 
     * @param {*} [options] Override http request options.
     */
    public createOrderRequest (orderPaymentRequest: OrderPaymentRequest, id: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: PtsV2PaymentsOrderPost201Response;  }> {
        const localVarPath = this.basePath + '/pts/v2/payment-references/{id}/intents'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'orderPaymentRequest' is not null or undefined
        if (orderPaymentRequest === null || orderPaymentRequest === undefined) {
            throw new Error('Required parameter orderPaymentRequest was null or undefined when calling createOrderRequest.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling createOrderRequest.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(orderPaymentRequest, "OrderPaymentRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PtsV2PaymentsOrderPost201Response;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PtsV2PaymentsOrderPost201Response");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * A payment authorizes the amount for the transaction. There are a number of supported payment features, such as E-commerce and Card Present - Credit Card/Debit Card, Echeck, e-Wallets, Level II/III Data, etc..  A payment response includes the status of the request. It also includes processor-specific information when the request is successful and errors if unsuccessful. See the [Payments Developer Guides Page](https://developer.cybersource.com/docs/cybs/en-us/payments/developer/ctv/rest/payments/payments-intro.html).  Authorization can be requested with Capture, Decision Manager, Payer Authentication(3ds), and Token Creation. 
     * @summary Process a Payment
     * @param createPaymentRequest 
     * @param {*} [options] Override http request options.
     */
    public createPayment (createPaymentRequest: CreatePaymentRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: PtsV2PaymentsPost201Response;  }> {
        const localVarPath = this.basePath + '/pts/v2/payments';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'createPaymentRequest' is not null or undefined
        if (createPaymentRequest === null || createPaymentRequest === undefined) {
            throw new Error('Required parameter createPaymentRequest was null or undefined when calling createPayment.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(createPaymentRequest, "CreatePaymentRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PtsV2PaymentsPost201Response;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PtsV2PaymentsPost201Response");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create Alternative Payments Sessions Request
     * @summary Create Alternative Payments Sessions Request
     * @param createSessionReq 
     * @param {*} [options] Override http request options.
     */
    public createSessionRequest (createSessionReq: CreateSessionReq, options: any = {}) : Promise<{ response: http.ClientResponse; body: PtsV2PaymentsPost201Response2;  }> {
        const localVarPath = this.basePath + '/pts/v2/payment-references';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'createSessionReq' is not null or undefined
        if (createSessionReq === null || createSessionReq === undefined) {
            throw new Error('Required parameter createSessionReq was null or undefined when calling createSessionRequest.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(createSessionReq, "CreateSessionReq")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PtsV2PaymentsPost201Response2;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PtsV2PaymentsPost201Response2");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Use this service to authorize additional charges in a lodging or autorental transaction. Include the ID returned from the original authorization in the PATCH request to add additional charges to that authorization. 
     * @summary Increment an Authorization
     * @param id The ID returned from the original authorization request.
     * @param incrementAuthRequest 
     * @param {*} [options] Override http request options.
     */
    public incrementAuth (id: string, incrementAuthRequest: IncrementAuthRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: PtsV2IncrementalAuthorizationPatch201Response;  }> {
        const localVarPath = this.basePath + '/pts/v2/payments/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling incrementAuth.');
        }

        // verify required parameter 'incrementAuthRequest' is not null or undefined
        if (incrementAuthRequest === null || incrementAuthRequest === undefined) {
            throw new Error('Required parameter incrementAuthRequest was null or undefined when calling incrementAuth.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(incrementAuthRequest, "IncrementAuthRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PtsV2IncrementalAuthorizationPatch201Response;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PtsV2IncrementalAuthorizationPatch201Response");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Checks and updates the payment status 
     * @summary Check a Payment Status
     * @param id The payment id whose status needs to be checked and updated.
     * @param refreshPaymentStatusRequest 
     * @param {*} [options] Override http request options.
     */
    public refreshPaymentStatus (id: string, refreshPaymentStatusRequest: RefreshPaymentStatusRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: PtsV2PaymentsPost201Response1;  }> {
        const localVarPath = this.basePath + '/pts/v2/refresh-payment-status/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling refreshPaymentStatus.');
        }

        // verify required parameter 'refreshPaymentStatusRequest' is not null or undefined
        if (refreshPaymentStatusRequest === null || refreshPaymentStatusRequest === undefined) {
            throw new Error('Required parameter refreshPaymentStatusRequest was null or undefined when calling refreshPaymentStatus.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(refreshPaymentStatusRequest, "RefreshPaymentStatusRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PtsV2PaymentsPost201Response1;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PtsV2PaymentsPost201Response1");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update Alternative Payments Sessions Request
     * @summary Update Alternative Payments Sessions Request
     * @param createSessionRequest 
     * @param id The payment ID. This ID is returned from a previous payment request.
     * @param {*} [options] Override http request options.
     */
    public updateSessionReq (createSessionRequest: CreateSessionRequest, id: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: PtsV2PaymentsPost201Response2;  }> {
        const localVarPath = this.basePath + '/pts/v2/payment-references/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'createSessionRequest' is not null or undefined
        if (createSessionRequest === null || createSessionRequest === undefined) {
            throw new Error('Required parameter createSessionRequest was null or undefined when calling updateSessionReq.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateSessionReq.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(createSessionRequest, "CreateSessionRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PtsV2PaymentsPost201Response2;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PtsV2PaymentsPost201Response2");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum PayoutsApiApiKeys {
}

export class PayoutsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: PayoutsApiApiKeys, value: string) {
        (this.authentications as any)[PayoutsApiApiKeys[key]].apiKey = value;
    }
    /**
     * Send funds from a selected funding source to a designated credit/debit card account or a prepaid card using an Original Credit Transaction (OCT). The availability of API features for a merchant can depend on the portfolio configuration and may need to be enabled at the portfolio level before they can be added to merchant accounts. 
     * @summary Process a Payout
     * @param octCreatePaymentRequest 
     * @param {*} [options] Override http request options.
     */
    public octCreatePayment (octCreatePaymentRequest: OctCreatePaymentRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: PtsV2PayoutsPost201Response;  }> {
        const localVarPath = this.basePath + '/pts/v2/payouts';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'octCreatePaymentRequest' is not null or undefined
        if (octCreatePaymentRequest === null || octCreatePaymentRequest === undefined) {
            throw new Error('Required parameter octCreatePaymentRequest was null or undefined when calling octCreatePayment.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(octCreatePaymentRequest, "OctCreatePaymentRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PtsV2PayoutsPost201Response;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PtsV2PayoutsPost201Response");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum PlansApiApiKeys {
}

export class PlansApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: PlansApiApiKeys, value: string) {
        (this.authentications as any)[PlansApiApiKeys[key]].apiKey = value;
    }
    /**
     * Activate a Plan
     * @summary Activate a Plan
     * @param id Plan Id
     * @param {*} [options] Override http request options.
     */
    public activatePlan (id: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: ActivateDeactivatePlanResponse;  }> {
        const localVarPath = this.basePath + '/rbs/v1/plans/{id}/activate'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling activatePlan.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ActivateDeactivatePlanResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ActivateDeactivatePlanResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * The recurring billing service enables you to manage payment plans and subscriptions for recurring payment schedules. It securely stores your customer's payment information and personal data within secure Visa data centers, reducing storage risks and PCI DSS scope through the use of *Token Management* (*TMS*).  The three key elements of *Cybersource* Recurring Billing are:  -  **Token**: stores customer billing, shipping, and payment details.  -  **Plan**: stores the billing schedule.  -  **Subscription**: combines the token and plan, and defines the subscription start date, name, and description.  The APIs in this section demonstrate the management of the Plans and Subscriptions. For Tokens please refer to [Token Management](#token-management) The availability of API features for a merchant can depend on the portfolio configuration and may need to be enabled at the portfolio level before they can be added to merchant accounts. 
     * @summary Create a Plan
     * @param createPlanRequest 
     * @param {*} [options] Override http request options.
     */
    public createPlan (createPlanRequest: CreatePlanRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: CreatePlanResponse;  }> {
        const localVarPath = this.basePath + '/rbs/v1/plans';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'createPlanRequest' is not null or undefined
        if (createPlanRequest === null || createPlanRequest === undefined) {
            throw new Error('Required parameter createPlanRequest was null or undefined when calling createPlan.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(createPlanRequest, "CreatePlanRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CreatePlanResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CreatePlanResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Deactivate a Plan
     * @summary Deactivate a Plan
     * @param id Plan Id
     * @param {*} [options] Override http request options.
     */
    public deactivatePlan (id: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: ActivateDeactivatePlanResponse;  }> {
        const localVarPath = this.basePath + '/rbs/v1/plans/{id}/deactivate'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deactivatePlan.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ActivateDeactivatePlanResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ActivateDeactivatePlanResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete a Plan is only allowed: - plan status is in `DRAFT` - plan status is in `ACTIVE`, and `INACTIVE` only allowed when no subscriptions attached to a plan in the lifetime of a plan 
     * @summary Delete a Plan
     * @param id Plan Id
     * @param {*} [options] Override http request options.
     */
    public deletePlan (id: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: DeletePlanResponse;  }> {
        const localVarPath = this.basePath + '/rbs/v1/plans/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deletePlan.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: DeletePlanResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "DeletePlanResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve a Plan details by Plan Id.
     * @summary Get a Plan
     * @param id Plan Id
     * @param {*} [options] Override http request options.
     */
    public getPlan (id: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: GetPlanResponse;  }> {
        const localVarPath = this.basePath + '/rbs/v1/plans/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getPlan.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetPlanResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetPlanResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a Unique Plan Code
     * @summary Get a Plan Code
     * @param {*} [options] Override http request options.
     */
    public getPlanCode (options: any = {}) : Promise<{ response: http.ClientResponse; body: GetPlanCodeResponse;  }> {
        const localVarPath = this.basePath + '/rbs/v1/plans/code';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetPlanCodeResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetPlanCodeResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve Plans by Plan Code & Plan Status. 
     * @summary Get a List of Plans
     * @param offset Page offset number.
     * @param limit Number of items to be returned. Default - &#x60;20&#x60;, Max - &#x60;100&#x60; 
     * @param code Filter by Plan Code
     * @param status Filter by Plan Status
     * @param name Filter by Plan Name. (First sub string or full string) **[Not Recommended]** 
     * @param {*} [options] Override http request options.
     */
    public getPlans (offset?: number, limit?: number, code?: string, status?: string, name?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: GetAllPlansResponse;  }> {
        const localVarPath = this.basePath + '/rbs/v1/plans';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (code !== undefined) {
            localVarQueryParameters['code'] = ObjectSerializer.serialize(code, "string");
        }

        if (status !== undefined) {
            localVarQueryParameters['status'] = ObjectSerializer.serialize(status, "string");
        }

        if (name !== undefined) {
            localVarQueryParameters['name'] = ObjectSerializer.serialize(name, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetAllPlansResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetAllPlansResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update a Plan  Plan in `DRAFT` status - All updates are allowed on Plan with `DRAFT` status  Plan in `ACTIVE` status [Following fields are **Not Updatable**] - `planInformation.billingPeriod` - `planInformation.billingCycles` [Update is only allowed to **increase** billingCycles] - `orderInformation.amountDetails.currency` 
     * @summary Update a Plan
     * @param id Plan Id
     * @param updatePlanRequest 
     * @param {*} [options] Override http request options.
     */
    public updatePlan (id: string, updatePlanRequest: UpdatePlanRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: UpdatePlanResponse;  }> {
        const localVarPath = this.basePath + '/rbs/v1/plans/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updatePlan.');
        }

        // verify required parameter 'updatePlanRequest' is not null or undefined
        if (updatePlanRequest === null || updatePlanRequest === undefined) {
            throw new Error('Required parameter updatePlanRequest was null or undefined when calling updatePlan.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(updatePlanRequest, "UpdatePlanRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: UpdatePlanResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "UpdatePlanResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum PurchaseAndRefundDetailsApiApiKeys {
}

export class PurchaseAndRefundDetailsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: PurchaseAndRefundDetailsApiApiKeys, value: string) {
        (this.authentications as any)[PurchaseAndRefundDetailsApiApiKeys[key]].apiKey = value;
    }
    /**
     * Download the Purchase and Refund Details report. This report report includes all purchases and refund transactions, as well as all activities related to transactions resulting in an adjustment to the net proceeds. 
     * @summary Get Purchase and Refund Details
     * @param startTime Valid report Start Time in **ISO 8601 format** Please refer the following link to know more about ISO 8601 format.[Rfc Date Format](https://xml2rfc.tools.ietf.org/public/rfc/html/rfc3339.html#anchor14)  **Example date format:**   - yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ (e.g. 2018-01-01T00:00:00.000Z) 
     * @param endTime Valid report End Time in **ISO 8601 format** Please refer the following link to know more about ISO 8601 format.[Rfc Date Format](https://xml2rfc.tools.ietf.org/public/rfc/html/rfc3339.html#anchor14)  **Example date format:**   - yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ (e.g. 2018-01-01T00:00:00.000Z) 
     * @param organizationId Valid Organization Id
     * @param paymentSubtype Payment Subtypes.   - **ALL**:  All Payment Subtypes   - **VI** :  Visa   - **MC** :  Master Card   - **AX** :  American Express   - **DI** :  Discover   - **DP** :  Pinless Debit 
     * @param viewBy View results by Request Date or Submission Date.   - **requestDate** : Request Date   - **submissionDate**: Submission Date 
     * @param groupName Valid CyberSource Group Name.User can define groups using CBAPI and Group Management Module in EBC2. Groups are collection of organizationIds
     * @param offset Offset of the Purchase and Refund Results.
     * @param limit Results count per page. Range(1-2000)
     * @param {*} [options] Override http request options.
     */
    public getPurchaseAndRefundDetails (startTime: Date, endTime: Date, organizationId?: string, paymentSubtype?: string, viewBy?: string, groupName?: string, offset?: number, limit?: number, options: any = {}) : Promise<{ response: http.ClientResponse; body: ReportingV3PurchaseRefundDetailsGet200Response;  }> {
        const localVarPath = this.basePath + '/reporting/v3/purchase-refund-details';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'startTime' is not null or undefined
        if (startTime === null || startTime === undefined) {
            throw new Error('Required parameter startTime was null or undefined when calling getPurchaseAndRefundDetails.');
        }

        // verify required parameter 'endTime' is not null or undefined
        if (endTime === null || endTime === undefined) {
            throw new Error('Required parameter endTime was null or undefined when calling getPurchaseAndRefundDetails.');
        }

        if (startTime !== undefined) {
            localVarQueryParameters['startTime'] = ObjectSerializer.serialize(startTime, "Date");
        }

        if (endTime !== undefined) {
            localVarQueryParameters['endTime'] = ObjectSerializer.serialize(endTime, "Date");
        }

        if (organizationId !== undefined) {
            localVarQueryParameters['organizationId'] = ObjectSerializer.serialize(organizationId, "string");
        }

        if (paymentSubtype !== undefined) {
            localVarQueryParameters['paymentSubtype'] = ObjectSerializer.serialize(paymentSubtype, "string");
        }

        if (viewBy !== undefined) {
            localVarQueryParameters['viewBy'] = ObjectSerializer.serialize(viewBy, "string");
        }

        if (groupName !== undefined) {
            localVarQueryParameters['groupName'] = ObjectSerializer.serialize(groupName, "string");
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ReportingV3PurchaseRefundDetailsGet200Response;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ReportingV3PurchaseRefundDetailsGet200Response");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum RefundApiApiKeys {
}

export class RefundApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: RefundApiApiKeys, value: string) {
        (this.authentications as any)[RefundApiApiKeys[key]].apiKey = value;
    }
    /**
     * Refund a capture API is only used, if you have requested Capture independenlty using [/pts/v2/payments/{id}/captures](https://developer.cybersource.com/api-reference-assets/index.html#payments_capture) API call. Include the capture ID in the POST request to refund the captured amount. 
     * @summary Refund a Capture
     * @param refundCaptureRequest 
     * @param id The capture ID. This ID is returned from a previous capture request.
     * @param {*} [options] Override http request options.
     */
    public refundCapture (refundCaptureRequest: RefundCaptureRequest, id: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: PtsV2PaymentsRefundPost201Response;  }> {
        const localVarPath = this.basePath + '/pts/v2/captures/{id}/refunds'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'refundCaptureRequest' is not null or undefined
        if (refundCaptureRequest === null || refundCaptureRequest === undefined) {
            throw new Error('Required parameter refundCaptureRequest was null or undefined when calling refundCapture.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling refundCapture.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(refundCaptureRequest, "RefundCaptureRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PtsV2PaymentsRefundPost201Response;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PtsV2PaymentsRefundPost201Response");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Refund a Payment API is only used, if you have requested Authorization and Capture together in [/pts/v2/payments](https://developer.cybersource.com/api-reference-assets/index.html#payments_payments) API call. Include the payment ID in the POST request to refund the payment amount. 
     * @summary Refund a Payment
     * @param refundPaymentRequest 
     * @param id The payment ID. This ID is returned from a previous payment request.
     * @param {*} [options] Override http request options.
     */
    public refundPayment (refundPaymentRequest: RefundPaymentRequest, id: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: PtsV2PaymentsRefundPost201Response;  }> {
        const localVarPath = this.basePath + '/pts/v2/payments/{id}/refunds'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'refundPaymentRequest' is not null or undefined
        if (refundPaymentRequest === null || refundPaymentRequest === undefined) {
            throw new Error('Required parameter refundPaymentRequest was null or undefined when calling refundPayment.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling refundPayment.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(refundPaymentRequest, "RefundPaymentRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PtsV2PaymentsRefundPost201Response;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PtsV2PaymentsRefundPost201Response");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ReportDefinitionsApiApiKeys {
}

export class ReportDefinitionsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ReportDefinitionsApiApiKeys, value: string) {
        (this.authentications as any)[ReportDefinitionsApiApiKeys[key]].apiKey = value;
    }
    /**
     * View the attributes of an individual report type. For a list of values for reportDefinitionName, see the [Reporting Developer Guide](https://www.cybersource.com/developers/documentation/reporting_and_reconciliation/) 
     * @summary Get Report Definition
     * @param reportDefinitionName Name of the Report definition to retrieve
     * @param subscriptionType The subscription type for which report definition is required. By default the type will be CUSTOM. Valid Values: - CLASSIC - CUSTOM - STANDARD 
     * @param reportMimeType The format for which the report definition is required. By default the value will be CSV. Valid Values: - application/xml - text/csv 
     * @param organizationId Valid Organization Id
     * @param {*} [options] Override http request options.
     */
    public getResourceInfoByReportDefinition (reportDefinitionName: string, subscriptionType?: string, reportMimeType?: string, organizationId?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: ReportingV3ReportDefinitionsNameGet200Response;  }> {
        const localVarPath = this.basePath + '/reporting/v3/report-definitions/{reportDefinitionName}'
            .replace('{' + 'reportDefinitionName' + '}', encodeURIComponent(String(reportDefinitionName)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'reportDefinitionName' is not null or undefined
        if (reportDefinitionName === null || reportDefinitionName === undefined) {
            throw new Error('Required parameter reportDefinitionName was null or undefined when calling getResourceInfoByReportDefinition.');
        }

        if (subscriptionType !== undefined) {
            localVarQueryParameters['subscriptionType'] = ObjectSerializer.serialize(subscriptionType, "string");
        }

        if (reportMimeType !== undefined) {
            localVarQueryParameters['reportMimeType'] = ObjectSerializer.serialize(reportMimeType, "string");
        }

        if (organizationId !== undefined) {
            localVarQueryParameters['organizationId'] = ObjectSerializer.serialize(organizationId, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ReportingV3ReportDefinitionsNameGet200Response;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ReportingV3ReportDefinitionsNameGet200Response");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * View a list of supported reports and their attributes before subscribing to them. 
     * @summary Get Reporting Resource Information
     * @param subscriptionType Valid Values: - CLASSIC - CUSTOM - STANDARD 
     * @param organizationId Valid Organization Id
     * @param {*} [options] Override http request options.
     */
    public getResourceV2Info (subscriptionType?: string, organizationId?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: ReportingV3ReportDefinitionsGet200Response;  }> {
        const localVarPath = this.basePath + '/reporting/v3/report-definitions';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (subscriptionType !== undefined) {
            localVarQueryParameters['subscriptionType'] = ObjectSerializer.serialize(subscriptionType, "string");
        }

        if (organizationId !== undefined) {
            localVarQueryParameters['organizationId'] = ObjectSerializer.serialize(organizationId, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ReportingV3ReportDefinitionsGet200Response;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ReportingV3ReportDefinitionsGet200Response");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ReportDownloadsApiApiKeys {
}

export class ReportDownloadsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ReportDownloadsApiApiKeys, value: string) {
        (this.authentications as any)[ReportDownloadsApiApiKeys[key]].apiKey = value;
    }
    /**
     * Download a report using the unique report name and date. 
     * @summary Download a Report
     * @param reportDate Valid date on which to download the report in **ISO 8601 format** Please refer the following link to know more about ISO 8601 format.[Rfc Date Format](https://xml2rfc.tools.ietf.org/public/rfc/html/rfc3339.html#anchor14)  **Example date format:**  yyyy-mm-dd For reports that span multiple days, this value would be the end date of the report in the time zone of the report subscription. Example 1: If your report start date is 2020-03-06 and the end date is 2020-03-09, the reportDate passed in the query is 2020-03-09. Example 2: If your report runs from midnight to midnight on 2020-03-09, the reportDate passed in the query is 2020-03-10 
     * @param reportName Name of the report to download
     * @param organizationId Valid Organization Id
     * @param {*} [options] Override http request options.
     */
    public downloadReport (reportDate: string, reportName: string, organizationId?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/reporting/v3/report-downloads';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'reportDate' is not null or undefined
        if (reportDate === null || reportDate === undefined) {
            throw new Error('Required parameter reportDate was null or undefined when calling downloadReport.');
        }

        // verify required parameter 'reportName' is not null or undefined
        if (reportName === null || reportName === undefined) {
            throw new Error('Required parameter reportName was null or undefined when calling downloadReport.');
        }

        if (organizationId !== undefined) {
            localVarQueryParameters['organizationId'] = ObjectSerializer.serialize(organizationId, "string");
        }

        if (reportDate !== undefined) {
            localVarQueryParameters['reportDate'] = ObjectSerializer.serialize(reportDate, "string");
        }

        if (reportName !== undefined) {
            localVarQueryParameters['reportName'] = ObjectSerializer.serialize(reportName, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ReportSubscriptionsApiApiKeys {
}

export class ReportSubscriptionsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ReportSubscriptionsApiApiKeys, value: string) {
        (this.authentications as any)[ReportSubscriptionsApiApiKeys[key]].apiKey = value;
    }
    /**
     * Create or update an already existing classic or standard subscription. 
     * @summary Create a Standard or Classic Subscription
     * @param predefinedSubscriptionRequestBean Report subscription request payload
     * @param organizationId Valid Organization Id
     * @param {*} [options] Override http request options.
     */
    public createStandardOrClassicSubscription (predefinedSubscriptionRequestBean: PredefinedSubscriptionRequestBean, organizationId?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/reporting/v3/predefined-report-subscriptions';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'predefinedSubscriptionRequestBean' is not null or undefined
        if (predefinedSubscriptionRequestBean === null || predefinedSubscriptionRequestBean === undefined) {
            throw new Error('Required parameter predefinedSubscriptionRequestBean was null or undefined when calling createStandardOrClassicSubscription.');
        }

        if (organizationId !== undefined) {
            localVarQueryParameters['organizationId'] = ObjectSerializer.serialize(organizationId, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(predefinedSubscriptionRequestBean, "PredefinedSubscriptionRequestBean")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create a report subscription for your organization. The report name must be unique. 
     * @summary Create Report Subscription for a Report Name by Organization
     * @param createReportSubscriptionRequest Report subscription request payload
     * @param organizationId Valid Organization Id
     * @param {*} [options] Override http request options.
     */
    public createSubscription (createReportSubscriptionRequest: CreateReportSubscriptionRequest, organizationId?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/reporting/v3/report-subscriptions';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'createReportSubscriptionRequest' is not null or undefined
        if (createReportSubscriptionRequest === null || createReportSubscriptionRequest === undefined) {
            throw new Error('Required parameter createReportSubscriptionRequest was null or undefined when calling createSubscription.');
        }

        if (organizationId !== undefined) {
            localVarQueryParameters['organizationId'] = ObjectSerializer.serialize(organizationId, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(createReportSubscriptionRequest, "CreateReportSubscriptionRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Delete a report subscription for your organization. You must know the unique name of the report you want to delete. 
     * @summary Delete Subscription of a Report Name by Organization
     * @param reportName Name of the Report to Delete
     * @param organizationId Valid Organization Id
     * @param {*} [options] Override http request options.
     */
    public deleteSubscription (reportName: string, organizationId?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/reporting/v3/report-subscriptions/{reportName}'
            .replace('{' + 'reportName' + '}', encodeURIComponent(String(reportName)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'reportName' is not null or undefined
        if (reportName === null || reportName === undefined) {
            throw new Error('Required parameter reportName was null or undefined when calling deleteSubscription.');
        }

        if (organizationId !== undefined) {
            localVarQueryParameters['organizationId'] = ObjectSerializer.serialize(organizationId, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * View a summary of all report subscriptions. 
     * @summary Get All Subscriptions
     * @param organizationId Valid Organization Id
     * @param {*} [options] Override http request options.
     */
    public getAllSubscriptions (organizationId?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: ReportingV3ReportSubscriptionsGet200Response;  }> {
        const localVarPath = this.basePath + '/reporting/v3/report-subscriptions';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (organizationId !== undefined) {
            localVarQueryParameters['organizationId'] = ObjectSerializer.serialize(organizationId, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ReportingV3ReportSubscriptionsGet200Response;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ReportingV3ReportSubscriptionsGet200Response");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * View the details of a report subscription, such as the report format or report frequency, using the report’s unique name. 
     * @summary Get Subscription for Report Name
     * @param reportName Name of the Report to Retrieve
     * @param organizationId Valid Organization Id
     * @param {*} [options] Override http request options.
     */
    public getSubscription (reportName: string, organizationId?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: ReportingV3ReportSubscriptionsGet200ResponseSubscriptions;  }> {
        const localVarPath = this.basePath + '/reporting/v3/report-subscriptions/{reportName}'
            .replace('{' + 'reportName' + '}', encodeURIComponent(String(reportName)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'reportName' is not null or undefined
        if (reportName === null || reportName === undefined) {
            throw new Error('Required parameter reportName was null or undefined when calling getSubscription.');
        }

        if (organizationId !== undefined) {
            localVarQueryParameters['organizationId'] = ObjectSerializer.serialize(organizationId, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ReportingV3ReportSubscriptionsGet200ResponseSubscriptions;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ReportingV3ReportSubscriptionsGet200ResponseSubscriptions");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ReportsApiApiKeys {
}

export class ReportsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ReportsApiApiKeys, value: string) {
        (this.authentications as any)[ReportsApiApiKeys[key]].apiKey = value;
    }
    /**
     * Create a one-time report. You must specify the type of report in reportDefinitionName. For a list of values for reportDefinitionName, see the [Reporting Developer Guide](https://www.cybersource.com/developers/documentation/reporting_and_reconciliation) 
     * @summary Create Adhoc Report
     * @param createAdhocReportRequest Report subscription request payload
     * @param organizationId Valid Organization Id
     * @param {*} [options] Override http request options.
     */
    public createReport (createAdhocReportRequest: CreateAdhocReportRequest, organizationId?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/reporting/v3/reports';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'createAdhocReportRequest' is not null or undefined
        if (createAdhocReportRequest === null || createAdhocReportRequest === undefined) {
            throw new Error('Required parameter createAdhocReportRequest was null or undefined when calling createReport.');
        }

        if (organizationId !== undefined) {
            localVarQueryParameters['organizationId'] = ObjectSerializer.serialize(organizationId, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(createAdhocReportRequest, "CreateAdhocReportRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Download a report using the reportId value. If you don’t already know this value, you can obtain it using the Retrieve available reports call. 
     * @summary Get Report Based on Report Id
     * @param reportId Valid Report Id
     * @param organizationId Valid Organization Id
     * @param {*} [options] Override http request options.
     */
    public getReportByReportId (reportId: string, organizationId?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: ReportingV3ReportsIdGet200Response;  }> {
        const localVarPath = this.basePath + '/reporting/v3/reports/{reportId}'
            .replace('{' + 'reportId' + '}', encodeURIComponent(String(reportId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'reportId' is not null or undefined
        if (reportId === null || reportId === undefined) {
            throw new Error('Required parameter reportId was null or undefined when calling getReportByReportId.');
        }

        if (organizationId !== undefined) {
            localVarQueryParameters['organizationId'] = ObjectSerializer.serialize(organizationId, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ReportingV3ReportsIdGet200Response;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ReportingV3ReportsIdGet200Response");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve a list of the available reports to which you are subscribed. This will also give you the reportId value, which you can also use to download a report. 
     * @summary Retrieve Available Reports
     * @param startTime Valid report Start Time in **ISO 8601 format** Please refer the following link to know more about ISO 8601 format.[Rfc Date Format](https://xml2rfc.tools.ietf.org/public/rfc/html/rfc3339.html#anchor14)  **Example date format:**   - yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ (e.g. 2018-01-01T00:00:00.000Z) 
     * @param endTime Valid report End Time in **ISO 8601 format** Please refer the following link to know more about ISO 8601 format.[Rfc Date Format](https://xml2rfc.tools.ietf.org/public/rfc/html/rfc3339.html#anchor14)  **Example date format:**   - yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ (e.g. 2018-01-01T00:00:00.000Z) 
     * @param timeQueryType Specify time you would like to search  Valid values: - reportTimeFrame - executedTime 
     * @param organizationId Valid Organization Id
     * @param reportMimeType Valid Report Format  Valid values: - application/xml - text/csv 
     * @param reportFrequency Valid Report Frequency  Valid values: - DAILY - WEEKLY - MONTHLY - USER_DEFINED - ADHOC 
     * @param reportName Valid Report Name
     * @param reportDefinitionId Valid Report Definition Id
     * @param reportStatus Valid Report Status  Valid values: - COMPLETED - PENDING - QUEUED - RUNNING - ERROR - NO_DATA 
     * @param {*} [options] Override http request options.
     */
    public searchReports (startTime: Date, endTime: Date, timeQueryType: string, organizationId?: string, reportMimeType?: string, reportFrequency?: string, reportName?: string, reportDefinitionId?: number, reportStatus?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: ReportingV3ReportsGet200Response;  }> {
        const localVarPath = this.basePath + '/reporting/v3/reports';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'startTime' is not null or undefined
        if (startTime === null || startTime === undefined) {
            throw new Error('Required parameter startTime was null or undefined when calling searchReports.');
        }

        // verify required parameter 'endTime' is not null or undefined
        if (endTime === null || endTime === undefined) {
            throw new Error('Required parameter endTime was null or undefined when calling searchReports.');
        }

        // verify required parameter 'timeQueryType' is not null or undefined
        if (timeQueryType === null || timeQueryType === undefined) {
            throw new Error('Required parameter timeQueryType was null or undefined when calling searchReports.');
        }

        if (organizationId !== undefined) {
            localVarQueryParameters['organizationId'] = ObjectSerializer.serialize(organizationId, "string");
        }

        if (startTime !== undefined) {
            localVarQueryParameters['startTime'] = ObjectSerializer.serialize(startTime, "Date");
        }

        if (endTime !== undefined) {
            localVarQueryParameters['endTime'] = ObjectSerializer.serialize(endTime, "Date");
        }

        if (timeQueryType !== undefined) {
            localVarQueryParameters['timeQueryType'] = ObjectSerializer.serialize(timeQueryType, "string");
        }

        if (reportMimeType !== undefined) {
            localVarQueryParameters['reportMimeType'] = ObjectSerializer.serialize(reportMimeType, "string");
        }

        if (reportFrequency !== undefined) {
            localVarQueryParameters['reportFrequency'] = ObjectSerializer.serialize(reportFrequency, "string");
        }

        if (reportName !== undefined) {
            localVarQueryParameters['reportName'] = ObjectSerializer.serialize(reportName, "string");
        }

        if (reportDefinitionId !== undefined) {
            localVarQueryParameters['reportDefinitionId'] = ObjectSerializer.serialize(reportDefinitionId, "number");
        }

        if (reportStatus !== undefined) {
            localVarQueryParameters['reportStatus'] = ObjectSerializer.serialize(reportStatus, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ReportingV3ReportsGet200Response;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ReportingV3ReportsGet200Response");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum RetrievalDetailsApiApiKeys {
}

export class RetrievalDetailsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: RetrievalDetailsApiApiKeys, value: string) {
        (this.authentications as any)[RetrievalDetailsApiApiKeys[key]].apiKey = value;
    }
    /**
     * Retrieval Detail Report Description
     * @summary Get Retrieval Details
     * @param startTime Valid report Start Time in **ISO 8601 format** Please refer the following link to know more about ISO 8601 format.[Rfc Date Format](https://xml2rfc.tools.ietf.org/public/rfc/html/rfc3339.html#anchor14)  **Example date format:**   - yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ (e.g. 2018-01-01T00:00:00.000Z) 
     * @param endTime Valid report End Time in **ISO 8601 format** Please refer the following link to know more about ISO 8601 format.[Rfc Date Format](https://xml2rfc.tools.ietf.org/public/rfc/html/rfc3339.html#anchor14)  **Example date format:**   - yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ (e.g. 2018-01-01T00:00:00.000Z) 
     * @param organizationId Valid Organization Id
     * @param {*} [options] Override http request options.
     */
    public getRetrievalDetails (startTime: Date, endTime: Date, organizationId?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: ReportingV3RetrievalDetailsGet200Response;  }> {
        const localVarPath = this.basePath + '/reporting/v3/retrieval-details';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'startTime' is not null or undefined
        if (startTime === null || startTime === undefined) {
            throw new Error('Required parameter startTime was null or undefined when calling getRetrievalDetails.');
        }

        // verify required parameter 'endTime' is not null or undefined
        if (endTime === null || endTime === undefined) {
            throw new Error('Required parameter endTime was null or undefined when calling getRetrievalDetails.');
        }

        if (startTime !== undefined) {
            localVarQueryParameters['startTime'] = ObjectSerializer.serialize(startTime, "Date");
        }

        if (endTime !== undefined) {
            localVarQueryParameters['endTime'] = ObjectSerializer.serialize(endTime, "Date");
        }

        if (organizationId !== undefined) {
            localVarQueryParameters['organizationId'] = ObjectSerializer.serialize(organizationId, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ReportingV3RetrievalDetailsGet200Response;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ReportingV3RetrievalDetailsGet200Response");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum RetrievalSummariesApiApiKeys {
}

export class RetrievalSummariesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: RetrievalSummariesApiApiKeys, value: string) {
        (this.authentications as any)[RetrievalSummariesApiApiKeys[key]].apiKey = value;
    }
    /**
     * Retrieval Summary Report Description
     * @summary Get Retrieval Summaries
     * @param startTime Valid report Start Time in **ISO 8601 format** Please refer the following link to know more about ISO 8601 format.[Rfc Date Format](https://xml2rfc.tools.ietf.org/public/rfc/html/rfc3339.html#anchor14)  **Example date format:**   - yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ (e.g. 2018-01-01T00:00:00.000Z) 
     * @param endTime Valid report End Time in **ISO 8601 format** Please refer the following link to know more about ISO 8601 format.[Rfc Date Format](https://xml2rfc.tools.ietf.org/public/rfc/html/rfc3339.html#anchor14)  **Example date format:**   - yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ (e.g. 2018-01-01T00:00:00.000Z) 
     * @param organizationId Valid Organization Id
     * @param {*} [options] Override http request options.
     */
    public getRetrievalSummary (startTime: Date, endTime: Date, organizationId?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: ReportingV3RetrievalSummariesGet200Response;  }> {
        const localVarPath = this.basePath + '/reporting/v3/retrieval-summaries';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'startTime' is not null or undefined
        if (startTime === null || startTime === undefined) {
            throw new Error('Required parameter startTime was null or undefined when calling getRetrievalSummary.');
        }

        // verify required parameter 'endTime' is not null or undefined
        if (endTime === null || endTime === undefined) {
            throw new Error('Required parameter endTime was null or undefined when calling getRetrievalSummary.');
        }

        if (startTime !== undefined) {
            localVarQueryParameters['startTime'] = ObjectSerializer.serialize(startTime, "Date");
        }

        if (endTime !== undefined) {
            localVarQueryParameters['endTime'] = ObjectSerializer.serialize(endTime, "Date");
        }

        if (organizationId !== undefined) {
            localVarQueryParameters['organizationId'] = ObjectSerializer.serialize(organizationId, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ReportingV3RetrievalSummariesGet200Response;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ReportingV3RetrievalSummariesGet200Response");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ReversalApiApiKeys {
}

export class ReversalApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ReversalApiApiKeys, value: string) {
        (this.authentications as any)[ReversalApiApiKeys[key]].apiKey = value;
    }
    /**
     * Include the payment ID in the POST request to reverse the payment amount.
     * @summary Process an Authorization Reversal
     * @param id The payment ID returned from a previous payment request.
     * @param authReversalRequest 
     * @param {*} [options] Override http request options.
     */
    public authReversal (id: string, authReversalRequest: AuthReversalRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: PtsV2PaymentsReversalsPost201Response;  }> {
        const localVarPath = this.basePath + '/pts/v2/payments/{id}/reversals'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling authReversal.');
        }

        // verify required parameter 'authReversalRequest' is not null or undefined
        if (authReversalRequest === null || authReversalRequest === undefined) {
            throw new Error('Required parameter authReversalRequest was null or undefined when calling authReversal.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(authReversalRequest, "AuthReversalRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PtsV2PaymentsReversalsPost201Response;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PtsV2PaymentsReversalsPost201Response");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * This is to reverse a previous payment that merchant does not receive a reply(Mostly due to Timeout). To use this feature/API, make sure to pass unique value to field - clientReferenceInformation -> transactionId in [/pts/v2/payments](https://developer.cybersource.com/api-reference-assets/index.html#payments_payments) API call and use same transactionId in this API request payload to reverse the payment.
     * @summary Timeout Reversal
     * @param mitReversalRequest 
     * @param {*} [options] Override http request options.
     */
    public mitReversal (mitReversalRequest: MitReversalRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: PtsV2PaymentsReversalsPost201Response;  }> {
        const localVarPath = this.basePath + '/pts/v2/reversals';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'mitReversalRequest' is not null or undefined
        if (mitReversalRequest === null || mitReversalRequest === undefined) {
            throw new Error('Required parameter mitReversalRequest was null or undefined when calling mitReversal.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(mitReversalRequest, "MitReversalRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PtsV2PaymentsReversalsPost201Response;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PtsV2PaymentsReversalsPost201Response");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum SearchTransactionsApiApiKeys {
}

export class SearchTransactionsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: SearchTransactionsApiApiKeys, value: string) {
        (this.authentications as any)[SearchTransactionsApiApiKeys[key]].apiKey = value;
    }
    /**
     * Create a search request. 
     * @summary Create a Search Request
     * @param createSearchRequest 
     * @param {*} [options] Override http request options.
     */
    public createSearch (createSearchRequest: CreateSearchRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: TssV2TransactionsPost201Response;  }> {
        const localVarPath = this.basePath + '/tss/v2/searches';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'createSearchRequest' is not null or undefined
        if (createSearchRequest === null || createSearchRequest === undefined) {
            throw new Error('Required parameter createSearchRequest was null or undefined when calling createSearch.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(createSearchRequest, "CreateSearchRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TssV2TransactionsPost201Response;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TssV2TransactionsPost201Response");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Include the Search ID in the GET request to retrieve the search results.
     * @summary Get Search Results
     * @param searchId Search ID.
     * @param {*} [options] Override http request options.
     */
    public getSearch (searchId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: TssV2TransactionsPost201Response;  }> {
        const localVarPath = this.basePath + '/tss/v2/searches/{searchId}'
            .replace('{' + 'searchId' + '}', encodeURIComponent(String(searchId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'searchId' is not null or undefined
        if (searchId === null || searchId === undefined) {
            throw new Error('Required parameter searchId was null or undefined when calling getSearch.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TssV2TransactionsPost201Response;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TssV2TransactionsPost201Response");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum SecureFileShareApiApiKeys {
}

export class SecureFileShareApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: SecureFileShareApiApiKeys, value: string) {
        (this.authentications as any)[SecureFileShareApiApiKeys[key]].apiKey = value;
    }
    /**
     * Download a file for the given file identifier
     * @summary Download a File with File Identifier
     * @param fileId Unique identifier for each file
     * @param organizationId Valid Cybersource Organization Id
     * @param {*} [options] Override http request options.
     */
    public getFile (fileId: string, organizationId?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/sfs/v1/files/{fileId}'
            .replace('{' + 'fileId' + '}', encodeURIComponent(String(fileId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'fileId' is not null or undefined
        if (fileId === null || fileId === undefined) {
            throw new Error('Required parameter fileId was null or undefined when calling getFile.');
        }

        if (organizationId !== undefined) {
            localVarQueryParameters['organizationId'] = ObjectSerializer.serialize(organizationId, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get list of files and it's information of them available inside the report directory
     * @summary Get List of Files
     * @param startDate Valid start date in **ISO 8601 format** Please refer the following link to know more about ISO 8601 format.[Rfc Date Format](https://xml2rfc.tools.ietf.org/public/rfc/html/rfc3339.html#anchor14)   **Example date format:**   - yyyy-MM-dd 
     * @param endDate Valid end date in **ISO 8601 format** Please refer the following link to know more about ISO 8601 format.[Rfc Date Format](https://xml2rfc.tools.ietf.org/public/rfc/html/rfc3339.html#anchor14)   **Example date format:**   - yyyy-MM-dd 
     * @param organizationId Valid Cybersource Organization Id
     * @param name **Tailored to searches for specific files with in given Date range** example : MyTransactionDetailreport.xml 
     * @param {*} [options] Override http request options.
     */
    public getFileDetail (startDate: string, endDate: string, organizationId?: string, name?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: V1FileDetailsGet200Response;  }> {
        const localVarPath = this.basePath + '/sfs/v1/file-details';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'startDate' is not null or undefined
        if (startDate === null || startDate === undefined) {
            throw new Error('Required parameter startDate was null or undefined when calling getFileDetail.');
        }

        // verify required parameter 'endDate' is not null or undefined
        if (endDate === null || endDate === undefined) {
            throw new Error('Required parameter endDate was null or undefined when calling getFileDetail.');
        }

        if (startDate !== undefined) {
            localVarQueryParameters['startDate'] = ObjectSerializer.serialize(startDate, "string");
        }

        if (endDate !== undefined) {
            localVarQueryParameters['endDate'] = ObjectSerializer.serialize(endDate, "string");
        }

        if (organizationId !== undefined) {
            localVarQueryParameters['organizationId'] = ObjectSerializer.serialize(organizationId, "string");
        }

        if (name !== undefined) {
            localVarQueryParameters['name'] = ObjectSerializer.serialize(name, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: V1FileDetailsGet200Response;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "V1FileDetailsGet200Response");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum SubscriptionsApiApiKeys {
}

export class SubscriptionsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: SubscriptionsApiApiKeys, value: string) {
        (this.authentications as any)[SubscriptionsApiApiKeys[key]].apiKey = value;
    }
    /**
     * Activate a `SUSPENDED` Subscription 
     * @summary Activate a Subscription
     * @param id Subscription Id
     * @param processSkippedPayments Indicates if skipped payments should be processed from the period when the subscription was suspended. By default, this is set to true.
     * @param {*} [options] Override http request options.
     */
    public activateSubscription (id: string, processSkippedPayments?: boolean, options: any = {}) : Promise<{ response: http.ClientResponse; body: ActivateSubscriptionResponse;  }> {
        const localVarPath = this.basePath + '/rbs/v1/subscriptions/{id}/activate'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling activateSubscription.');
        }

        if (processSkippedPayments !== undefined) {
            localVarQueryParameters['processSkippedPayments'] = ObjectSerializer.serialize(processSkippedPayments, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: ActivateSubscriptionResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ActivateSubscriptionResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Cancel a Subscription
     * @summary Cancel a Subscription
     * @param id Subscription Id
     * @param {*} [options] Override http request options.
     */
    public cancelSubscription (id: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: CancelSubscriptionResponse;  }> {
        const localVarPath = this.basePath + '/rbs/v1/subscriptions/{id}/cancel'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling cancelSubscription.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CancelSubscriptionResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CancelSubscriptionResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create a Recurring Billing Subscription
     * @summary Create a Subscription
     * @param createSubscriptionRequest 
     * @param {*} [options] Override http request options.
     */
    public createSubscription (createSubscriptionRequest: CreateSubscriptionRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: CreateSubscriptionResponse;  }> {
        const localVarPath = this.basePath + '/rbs/v1/subscriptions';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'createSubscriptionRequest' is not null or undefined
        if (createSubscriptionRequest === null || createSubscriptionRequest === undefined) {
            throw new Error('Required parameter createSubscriptionRequest was null or undefined when calling createSubscription.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(createSubscriptionRequest, "CreateSubscriptionRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CreateSubscriptionResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CreateSubscriptionResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve Subscriptions by Subscription Code & Subscription Status. 
     * @summary Get a List of Subscriptions
     * @param offset Page offset number.
     * @param limit Number of items to be returned. Default - &#x60;20&#x60;, Max - &#x60;100&#x60; 
     * @param code Filter by Subscription Code
     * @param status Filter by Subscription Status
     * @param {*} [options] Override http request options.
     */
    public getAllSubscriptions (offset?: number, limit?: number, code?: string, status?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: GetAllSubscriptionsResponse;  }> {
        const localVarPath = this.basePath + '/rbs/v1/subscriptions';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, "number");
        }

        if (code !== undefined) {
            localVarQueryParameters['code'] = ObjectSerializer.serialize(code, "string");
        }

        if (status !== undefined) {
            localVarQueryParameters['status'] = ObjectSerializer.serialize(status, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetAllSubscriptionsResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetAllSubscriptionsResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a Subscription by Subscription Id
     * @summary Get a Subscription
     * @param id Subscription Id
     * @param {*} [options] Override http request options.
     */
    public getSubscription (id: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: GetSubscriptionResponse;  }> {
        const localVarPath = this.basePath + '/rbs/v1/subscriptions/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getSubscription.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetSubscriptionResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetSubscriptionResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a Unique Subscription Code
     * @summary Get a Subscription Code
     * @param {*} [options] Override http request options.
     */
    public getSubscriptionCode (options: any = {}) : Promise<{ response: http.ClientResponse; body: GetSubscriptionCodeResponse;  }> {
        const localVarPath = this.basePath + '/rbs/v1/subscriptions/code';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetSubscriptionCodeResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetSubscriptionCodeResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Suspend a Subscription
     * @summary Suspend a Subscription
     * @param id Subscription Id
     * @param {*} [options] Override http request options.
     */
    public suspendSubscription (id: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: SuspendSubscriptionResponse;  }> {
        const localVarPath = this.basePath + '/rbs/v1/subscriptions/{id}/suspend'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling suspendSubscription.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: SuspendSubscriptionResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "SuspendSubscriptionResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Update a Subscription by Subscription Id
     * @summary Update a Subscription
     * @param id Subscription Id
     * @param updateSubscription Update Subscription
     * @param {*} [options] Override http request options.
     */
    public updateSubscription (id: string, updateSubscription: UpdateSubscription, options: any = {}) : Promise<{ response: http.ClientResponse; body: UpdateSubscriptionResponse;  }> {
        const localVarPath = this.basePath + '/rbs/v1/subscriptions/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateSubscription.');
        }

        // verify required parameter 'updateSubscription' is not null or undefined
        if (updateSubscription === null || updateSubscription === undefined) {
            throw new Error('Required parameter updateSubscription was null or undefined when calling updateSubscription.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(updateSubscription, "UpdateSubscription")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: UpdateSubscriptionResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "UpdateSubscriptionResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum SubscriptionsFollowOnsApiApiKeys {
}

export class SubscriptionsFollowOnsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: SubscriptionsFollowOnsApiApiKeys, value: string) {
        (this.authentications as any)[SubscriptionsFollowOnsApiApiKeys[key]].apiKey = value;
    }
    /**
     * Create a new Subscription based on the Request Id of an existing successful Transaction.
     * @summary Create a Follow-On Subscription
     * @param requestId Request Id of an existing successful Transaction
     * @param createSubscriptionRequest 
     * @param {*} [options] Override http request options.
     */
    public createFollowOnSubscription (requestId: string, createSubscriptionRequest: CreateSubscriptionRequest1, options: any = {}) : Promise<{ response: http.ClientResponse; body: CreateSubscriptionResponse;  }> {
        const localVarPath = this.basePath + '/rbs/v1/subscriptions/follow-ons/{requestId}'
            .replace('{' + 'requestId' + '}', encodeURIComponent(String(requestId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'requestId' is not null or undefined
        if (requestId === null || requestId === undefined) {
            throw new Error('Required parameter requestId was null or undefined when calling createFollowOnSubscription.');
        }

        // verify required parameter 'createSubscriptionRequest' is not null or undefined
        if (createSubscriptionRequest === null || createSubscriptionRequest === undefined) {
            throw new Error('Required parameter createSubscriptionRequest was null or undefined when calling createFollowOnSubscription.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(createSubscriptionRequest, "CreateSubscriptionRequest1")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: CreateSubscriptionResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CreateSubscriptionResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get details of the Subscription being created based on the Request Id of an existing successful Transaction. 
     * @summary Get a Follow-On Subscription
     * @param requestId Request Id of an existing successful Transaction
     * @param {*} [options] Override http request options.
     */
    public getFollowOnSubscription (requestId: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: GetSubscriptionResponse1;  }> {
        const localVarPath = this.basePath + '/rbs/v1/subscriptions/follow-ons/{requestId}'
            .replace('{' + 'requestId' + '}', encodeURIComponent(String(requestId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'requestId' is not null or undefined
        if (requestId === null || requestId === undefined) {
            throw new Error('Required parameter requestId was null or undefined when calling getFollowOnSubscription.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: GetSubscriptionResponse1;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "GetSubscriptionResponse1");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum TaxesApiApiKeys {
}

export class TaxesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: TaxesApiApiKeys, value: string) {
        (this.authentications as any)[TaxesApiApiKeys[key]].apiKey = value;
    }
    /**
     * The tax calculation service provides real-time sales tax and VAT calculations for orders placed with your business worldwide.  It enhances your ability to conduct business globally and enables you to avoid the risk and complexity of managing online tax calculation.  The service supports product-based tax rules and exemptions for goods and services.  The tax rates are updated twice a month and calculations include sub-level detail (rates per taxing jurisdiction, names and types of jurisdictions). Implementation guidance, list of supported countries, and information on tax reporting are in the [Tax User Guide](https://developer.cybersource.com/docs/cybs/en-us/tax-calculation/developer/all/rest/tax-calculation/tax-overview.html). The availability of API features for a merchant can depend on the portfolio configuration and may need to be enabled at the portfolio level before they can be added to merchant accounts. 
     * @summary Calculate Taxes
     * @param taxRequest 
     * @param {*} [options] Override http request options.
     */
    public calculateTax (taxRequest: TaxRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: VasV2PaymentsPost201Response;  }> {
        const localVarPath = this.basePath + '/vas/v2/tax';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'taxRequest' is not null or undefined
        if (taxRequest === null || taxRequest === undefined) {
            throw new Error('Required parameter taxRequest was null or undefined when calling calculateTax.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(taxRequest, "TaxRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: VasV2PaymentsPost201Response;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "VasV2PaymentsPost201Response");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Pass the Tax Request ID in the PATCH request to void the committed tax calculation.
     * @summary Void Taxes
     * @param voidTaxRequest 
     * @param id The tax ID returned from a previous request.
     * @param {*} [options] Override http request options.
     */
    public voidTax (voidTaxRequest: VoidTaxRequest, id: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: VasV2TaxVoid200Response;  }> {
        const localVarPath = this.basePath + '/vas/v2/tax/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'voidTaxRequest' is not null or undefined
        if (voidTaxRequest === null || voidTaxRequest === undefined) {
            throw new Error('Required parameter voidTaxRequest was null or undefined when calling voidTax.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling voidTax.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(voidTaxRequest, "VoidTaxRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: VasV2TaxVoid200Response;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "VasV2TaxVoid200Response");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum TokenApiApiKeys {
}

export class TokenApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: TokenApiApiKeys, value: string) {
        (this.authentications as any)[TokenApiApiKeys[key]].apiKey = value;
    }
    /**
     * Retrieves Card Art for a specific Instrument Identifier. The Card Art is a visual representation of the cardholder's payment card. Card Art is only available if a Network Token is successfully provisioned. 
     * @summary Retrieve Card Art
     * @param instrumentIdentifierId The Id of an Instrument Identifier.
     * @param tokenProvider The token provider.
     * @param assetType The type of asset.
     * @param {*} [options] Override http request options.
     */
    public getCardArtAsset (instrumentIdentifierId: string, tokenProvider: 'vts' | 'mdes' | 'amex' | 'mscof', assetType: 'card-art-combined' | 'brand-logo' | 'issuer-logo' | 'icon-logo', options: any = {}) : Promise<{ response: http.ClientResponse; body: InlineResponse200;  }> {
        const localVarPath = this.basePath + '/tms/v2/tokens/{instrumentIdentifierId}/{tokenProvider}/assets/{assetType}'
            .replace('{' + 'instrumentIdentifierId' + '}', encodeURIComponent(String(instrumentIdentifierId)))
            .replace('{' + 'tokenProvider' + '}', encodeURIComponent(String(tokenProvider)))
            .replace('{' + 'assetType' + '}', encodeURIComponent(String(assetType)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'instrumentIdentifierId' is not null or undefined
        if (instrumentIdentifierId === null || instrumentIdentifierId === undefined) {
            throw new Error('Required parameter instrumentIdentifierId was null or undefined when calling getCardArtAsset.');
        }

        // verify required parameter 'tokenProvider' is not null or undefined
        if (tokenProvider === null || tokenProvider === undefined) {
            throw new Error('Required parameter tokenProvider was null or undefined when calling getCardArtAsset.');
        }

        // verify required parameter 'assetType' is not null or undefined
        if (assetType === null || assetType === undefined) {
            throw new Error('Required parameter assetType was null or undefined when calling getCardArtAsset.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse200;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "InlineResponse200");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * |  |  |  |     | --- | --- | --- |     |**Token**<br>A Token can represent your tokenized Customer, Payment Instrument or Instrument Identifier information.|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|**Payment Credentials**<br>Contains payment information such as the network token, generated cryptogram for Visa & MasterCard or dynamic CVV for Amex in a JSON Web Encryption (JWE) response.<br>Your system can use this API to retrieve the Payment Credentials for an existing Customer, Payment Instrument or Instrument Identifier. 
     * @summary Generate Payment Credentials for a TMS Token
     * @param tokenId The Id of a token representing a Customer, Payment Instrument or Instrument Identifier.
     * @param postPaymentCredentialsRequest 
     * @param profileId The Id of a profile containing user specific TMS configuration.
     * @param {*} [options] Override http request options.
     */
    public postTokenPaymentCredentials (tokenId: string, postPaymentCredentialsRequest: PostPaymentCredentialsRequest, profileId?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: string;  }> {
        const localVarPath = this.basePath + '/tms/v2/tokens/{tokenId}/payment-credentials'
            .replace('{' + 'tokenId' + '}', encodeURIComponent(String(tokenId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'tokenId' is not null or undefined
        if (tokenId === null || tokenId === undefined) {
            throw new Error('Required parameter tokenId was null or undefined when calling postTokenPaymentCredentials.');
        }

        // verify required parameter 'postPaymentCredentialsRequest' is not null or undefined
        if (postPaymentCredentialsRequest === null || postPaymentCredentialsRequest === undefined) {
            throw new Error('Required parameter postPaymentCredentialsRequest was null or undefined when calling postTokenPaymentCredentials.');
        }

        localVarHeaderParams['profile-id'] = ObjectSerializer.serialize(profileId, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(postPaymentCredentialsRequest, "PostPaymentCredentialsRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: string;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum TokenizedCardApiApiKeys {
}

export class TokenizedCardApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: TokenizedCardApiApiKeys, value: string) {
        (this.authentications as any)[TokenizedCardApiApiKeys[key]].apiKey = value;
    }
    /**
     * |  |  |  | | --- | --- | --- | | The Network Token will attempt to be deleted from the card association and if successful the corresponding TMS Network Token will be deleted. 
     * @summary Delete a Tokenized Card
     * @param tokenizedCardId The Id of a tokenized card.
     * @param profileId The Id of a profile containing user specific TMS configuration.
     * @param {*} [options] Override http request options.
     */
    public deleteTokenizedCard (tokenizedCardId: string, profileId?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/tms/v2/tokenized-cards/{tokenizedCardId}'
            .replace('{' + 'tokenizedCardId' + '}', encodeURIComponent(String(tokenizedCardId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'tokenizedCardId' is not null or undefined
        if (tokenizedCardId === null || tokenizedCardId === undefined) {
            throw new Error('Required parameter tokenizedCardId was null or undefined when calling deleteTokenizedCard.');
        }

        localVarHeaderParams['profile-id'] = ObjectSerializer.serialize(profileId, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * |  |  |  | | --- | --- | --- | |**Tokenized Cards**<br>A Tokenized Card represents a network token. Network tokens perform better than regular card numbers and they are not necessarily invalidated when a cardholder loses their card, or it expires.  
     * @summary Retrieve a Tokenized Card
     * @param tokenizedCardId The Id of a tokenized card.
     * @param profileId The Id of a profile containing user specific TMS configuration.
     * @param {*} [options] Override http request options.
     */
    public getTokenizedCard (tokenizedCardId: string, profileId?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: TokenizedcardRequest;  }> {
        const localVarPath = this.basePath + '/tms/v2/tokenized-cards/{tokenizedCardId}'
            .replace('{' + 'tokenizedCardId' + '}', encodeURIComponent(String(tokenizedCardId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'tokenizedCardId' is not null or undefined
        if (tokenizedCardId === null || tokenizedCardId === undefined) {
            throw new Error('Required parameter tokenizedCardId was null or undefined when calling getTokenizedCard.');
        }

        localVarHeaderParams['profile-id'] = ObjectSerializer.serialize(profileId, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TokenizedcardRequest;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TokenizedcardRequest");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * |  |  |  | | --- | --- | --- | |**Tokenized cards**<br>A Tokenized card represents a network token. Network tokens perform better than regular card numbers and they are not necessarily invalidated when a cardholder loses their card, or it expires. 
     * @summary Create a Tokenized Card
     * @param tokenizedcardRequest 
     * @param profileId The Id of a profile containing user specific TMS configuration.
     * @param {*} [options] Override http request options.
     */
    public postTokenizedCard (tokenizedcardRequest: TokenizedcardRequest, profileId?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: TokenizedcardRequest;  }> {
        const localVarPath = this.basePath + '/tms/v2/tokenized-cards';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'tokenizedcardRequest' is not null or undefined
        if (tokenizedcardRequest === null || tokenizedcardRequest === undefined) {
            throw new Error('Required parameter tokenizedcardRequest was null or undefined when calling postTokenizedCard.');
        }

        localVarHeaderParams['profile-id'] = ObjectSerializer.serialize(profileId, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(tokenizedcardRequest, "TokenizedcardRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TokenizedcardRequest;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TokenizedcardRequest");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum TransactionBatchesApiApiKeys {
}

export class TransactionBatchesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: TransactionBatchesApiApiKeys, value: string) {
        (this.authentications as any)[TransactionBatchesApiApiKeys[key]].apiKey = value;
    }
    /**
     * Provides real-time detailed status information about the transactions that you previously uploaded in the Business Center or processed with the Offline Transaction File Submission service. 
     * @summary Get Transaction Details for a given Batch Id
     * @param id The batch id assigned for the template.
     * @param uploadDate Date in which the original batch file was uploaded. Date must be in ISO-8601 format. Please refer the following link to know more about ISO 8601 format.[Rfc Date Format](https://xml2rfc.tools.ietf.org/public/rfc/html/rfc3339.html#anchor14) **Example date format:**  - yyyy-MM-dd 
     * @param status Allows you to filter by rejected response.  Valid values: - Rejected 
     * @param {*} [options] Override http request options.
     */
    public getTransactionBatchDetails (id: string, uploadDate?: string, status?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/pts/v1/transaction-batch-details/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getTransactionBatchDetails.');
        }

        if (uploadDate !== undefined) {
            localVarQueryParameters['uploadDate'] = ObjectSerializer.serialize(uploadDate, "string");
        }

        if (status !== undefined) {
            localVarQueryParameters['status'] = ObjectSerializer.serialize(status, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * This API provides details like upload date, completion date, transaction count and accepted and rejected transaction count of the individual batch file using the batch id
     * @summary Get Individual Batch File
     * @param id The batch id assigned for the template.
     * @param {*} [options] Override http request options.
     */
    public getTransactionBatchId (id: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: PtsV1TransactionBatchesIdGet200Response;  }> {
        const localVarPath = this.basePath + '/pts/v1/transaction-batches/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getTransactionBatchId.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PtsV1TransactionBatchesIdGet200Response;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PtsV1TransactionBatchesIdGet200Response");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Provide the date and time search range to get a list of Batch Files ready for settlement
     * @summary Get a List of Batch Files
     * @param startTime Valid report Start Time in **ISO 8601 format** Please refer the following link to know more about ISO 8601 format.[Rfc Date Format](https://xml2rfc.tools.ietf.org/public/rfc/html/rfc3339.html#anchor14)   **Example date format:**   - yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZZ 
     * @param endTime Valid report End Time in **ISO 8601 format** Please refer the following link to know more about ISO 8601 format.[Rfc Date Format](https://xml2rfc.tools.ietf.org/public/rfc/html/rfc3339.html#anchor14)   **Example date format:**   - yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZZ 
     * @param {*} [options] Override http request options.
     */
    public getTransactionBatches (startTime: Date, endTime: Date, options: any = {}) : Promise<{ response: http.ClientResponse; body: PtsV1TransactionBatchesGet200Response;  }> {
        const localVarPath = this.basePath + '/pts/v1/transaction-batches';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'startTime' is not null or undefined
        if (startTime === null || startTime === undefined) {
            throw new Error('Required parameter startTime was null or undefined when calling getTransactionBatches.');
        }

        // verify required parameter 'endTime' is not null or undefined
        if (endTime === null || endTime === undefined) {
            throw new Error('Required parameter endTime was null or undefined when calling getTransactionBatches.');
        }

        if (startTime !== undefined) {
            localVarQueryParameters['startTime'] = ObjectSerializer.serialize(startTime, "Date");
        }

        if (endTime !== undefined) {
            localVarQueryParameters['endTime'] = ObjectSerializer.serialize(endTime, "Date");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PtsV1TransactionBatchesGet200Response;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PtsV1TransactionBatchesGet200Response");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum TransactionDetailsApiApiKeys {
}

export class TransactionDetailsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: TransactionDetailsApiApiKeys, value: string) {
        (this.authentications as any)[TransactionDetailsApiApiKeys[key]].apiKey = value;
    }
    /**
     * Include the Request ID in the GET request to retrieve the transaction details.
     * @summary Retrieve a Transaction
     * @param id Request ID. 
     * @param {*} [options] Override http request options.
     */
    public getTransaction (id: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: TssV2TransactionsGet200Response;  }> {
        const localVarPath = this.basePath + '/tss/v2/transactions/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getTransaction.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: TssV2TransactionsGet200Response;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TssV2TransactionsGet200Response");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum TransientTokenDataApiApiKeys {
}

export class TransientTokenDataApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: TransientTokenDataApiApiKeys, value: string) {
        (this.authentications as any)[TransientTokenDataApiApiKeys[key]].apiKey = value;
    }
    /**
     * Retrieve the Payment data captured by Unified Checkout. This API is used to retrieve the detailed data represented by the Transient Token. This API will return PCI payment data captured by the Unified Checkout platform.
     * @summary Get Payment Credentials
     * @param paymentCredentialsReference The paymentCredentialsReference field contained within the Transient token returned from a successful Unified Checkout transaction 
     * @param {*} [options] Override http request options.
     */
    public getPaymentCredentialsForTransientToken (paymentCredentialsReference: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: string;  }> {
        const localVarPath = this.basePath + '/flex/v2/payment-credentials/{paymentCredentialsReference}'
            .replace('{' + 'paymentCredentialsReference' + '}', encodeURIComponent(String(paymentCredentialsReference)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'paymentCredentialsReference' is not null or undefined
        if (paymentCredentialsReference === null || paymentCredentialsReference === undefined) {
            throw new Error('Required parameter paymentCredentialsReference was null or undefined when calling getPaymentCredentialsForTransientToken.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: string;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Retrieve the data captured by Unified Checkout. This API is used to retrieve the detailed data represented by the Transient Token. This API will not return PCI payment data (PAN). Include the Request ID in the GET request to retrieve the transaction details.
     * @summary Get Transient Token Data
     * @param transientToken Transient Token returned by the Unified Checkout application. 
     * @param {*} [options] Override http request options.
     */
    public getTransactionForTransientToken (transientToken: string, options: any = {}) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/up/v1/payment-details/{transientToken}'
            .replace('{' + 'transientToken' + '}', encodeURIComponent(String(transientToken)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'transientToken' is not null or undefined
        if (transientToken === null || transientToken === undefined) {
            throw new Error('Required parameter transientToken was null or undefined when calling getTransactionForTransientToken.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum UnifiedCheckoutCaptureContextApiApiKeys {
}

export class UnifiedCheckoutCaptureContextApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: UnifiedCheckoutCaptureContextApiApiKeys, value: string) {
        (this.authentications as any)[UnifiedCheckoutCaptureContextApiApiKeys[key]].apiKey = value;
    }
    /**
     * Unified Checkout is a powerful product within the Digital Acceptance Suite. Unified Checkout is designed to assist merchants with the adoption and inclusion of digital payments within their payment acceptance page. With Unified Checkout Integration you can add digital payment methods to create familiar, convenient and seamless payment experiences that are designed to reduce checkout friction and increase conversions. Click to Pay Drop-in UI is built on the Unified Checkout platform. For more information about Unified Checkout, see the [Unified Checkout Developer Guides Page](https://developer.cybersource.com/docs/cybs/en-us/unified-checkout/developer/all/rest/unified-checkout/uc-intro.html). For examples on how to integrate Unified Checkout within your webpage please see our [GitHub Unified Checkout Samples](https://github.com/CyberSource/cybersource-unified-checkout-sample-java). Generate Unified Checkout Capture Context Generate a one-time use capture context used for the invocation of Unified Checkout. The Request wil contain all of the parameters for how Unified Checkout will operate within a client webpage. The resulting payload will be a JWT signed object that can be used to initiate Unified Checkout or Click to Pay Drop-in UI within a web page
     * @summary Generate Unified Checkout Capture Context
     * @param generateUnifiedCheckoutCaptureContextRequest 
     * @param {*} [options] Override http request options.
     */
    public generateUnifiedCheckoutCaptureContext (generateUnifiedCheckoutCaptureContextRequest: GenerateUnifiedCheckoutCaptureContextRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: string;  }> {
        const localVarPath = this.basePath + '/up/v1/capture-contexts';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'generateUnifiedCheckoutCaptureContextRequest' is not null or undefined
        if (generateUnifiedCheckoutCaptureContextRequest === null || generateUnifiedCheckoutCaptureContextRequest === undefined) {
            throw new Error('Required parameter generateUnifiedCheckoutCaptureContextRequest was null or undefined when calling generateUnifiedCheckoutCaptureContext.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(generateUnifiedCheckoutCaptureContextRequest, "GenerateUnifiedCheckoutCaptureContextRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: string;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum UserManagementApiApiKeys {
}

export class UserManagementApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: UserManagementApiApiKeys, value: string) {
        (this.authentications as any)[UserManagementApiApiKeys[key]].apiKey = value;
    }
    /**
     * This endpoint is deprecated. Please use the search end point.
     * @summary Get User Information - Deprecated
     * @param organizationId This is the orgId of the organization which the user belongs to.
     * @param userName User ID of the user you want to get details on.
     * @param permissionId permission that you are trying to search user on.
     * @param roleId role of the user you are trying to search on.
     * @param {*} [options] Override http request options.
     */
    public getUsers (organizationId?: string, userName?: string, permissionId?: string, roleId?: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: UmsV1UsersGet200Response;  }> {
        const localVarPath = this.basePath + '/ums/v1/users';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (organizationId !== undefined) {
            localVarQueryParameters['organizationId'] = ObjectSerializer.serialize(organizationId, "string");
        }

        if (userName !== undefined) {
            localVarQueryParameters['userName'] = ObjectSerializer.serialize(userName, "string");
        }

        if (permissionId !== undefined) {
            localVarQueryParameters['permissionId'] = ObjectSerializer.serialize(permissionId, "string");
        }

        if (roleId !== undefined) {
            localVarQueryParameters['roleId'] = ObjectSerializer.serialize(roleId, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: UmsV1UsersGet200Response;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "UmsV1UsersGet200Response");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum UserManagementSearchApiApiKeys {
}

export class UserManagementSearchApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: UserManagementSearchApiApiKeys, value: string) {
        (this.authentications as any)[UserManagementSearchApiApiKeys[key]].apiKey = value;
    }
    /**
     * This endpoint is to get all the user information depending on the filter criteria passed in request body.
     * @summary Search User Information
     * @param searchRequest 
     * @param {*} [options] Override http request options.
     */
    public searchUsers (searchRequest: SearchRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: UmsV1UsersGet200Response;  }> {
        const localVarPath = this.basePath + '/ums/v1/users/search';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'searchRequest' is not null or undefined
        if (searchRequest === null || searchRequest === undefined) {
            throw new Error('Required parameter searchRequest was null or undefined when calling searchUsers.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(searchRequest, "SearchRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: UmsV1UsersGet200Response;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "UmsV1UsersGet200Response");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum VerificationApiApiKeys {
}

export class VerificationApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: VerificationApiApiKeys, value: string) {
        (this.authentications as any)[VerificationApiApiKeys[key]].apiKey = value;
    }
    /**
     * This call checks customer data against specified watch lists to ensure export compliance. 
     * @summary Validate export compliance
     * @param validateExportComplianceRequest 
     * @param {*} [options] Override http request options.
     */
    public validateExportCompliance (validateExportComplianceRequest: ValidateExportComplianceRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: RiskV1ExportComplianceInquiriesPost201Response;  }> {
        const localVarPath = this.basePath + '/risk/v1/export-compliance-inquiries';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'validateExportComplianceRequest' is not null or undefined
        if (validateExportComplianceRequest === null || validateExportComplianceRequest === undefined) {
            throw new Error('Required parameter validateExportComplianceRequest was null or undefined when calling validateExportCompliance.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(validateExportComplianceRequest, "ValidateExportComplianceRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: RiskV1ExportComplianceInquiriesPost201Response;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RiskV1ExportComplianceInquiriesPost201Response");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * This call verifies that the customer address submitted is valid.
     * @summary Verify customer address
     * @param verifyCustomerAddressRequest 
     * @param {*} [options] Override http request options.
     */
    public verifyCustomerAddress (verifyCustomerAddressRequest: VerifyCustomerAddressRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: RiskV1AddressVerificationsPost201Response;  }> {
        const localVarPath = this.basePath + '/risk/v1/address-verifications';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'verifyCustomerAddressRequest' is not null or undefined
        if (verifyCustomerAddressRequest === null || verifyCustomerAddressRequest === undefined) {
            throw new Error('Required parameter verifyCustomerAddressRequest was null or undefined when calling verifyCustomerAddress.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(verifyCustomerAddressRequest, "VerifyCustomerAddressRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: RiskV1AddressVerificationsPost201Response;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RiskV1AddressVerificationsPost201Response");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum VoidApiApiKeys {
}

export class VoidApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: VoidApiApiKeys, value: string) {
        (this.authentications as any)[VoidApiApiKeys[key]].apiKey = value;
    }
    /**
     * This is to void a previous payment, capture, refund, or credit that merchant does not receive a reply(Mostly due to timeout). To use this feature/API, make sure to pass unique value to field - clientReferenceInformation -> transactionId in your payment, capture, refund, or credit API call and use same transactionId in this API request payload to reverse the payment.
     * @summary Timeout Void
     * @param mitVoidRequest 
     * @param {*} [options] Override http request options.
     */
    public mitVoid (mitVoidRequest: MitVoidRequest, options: any = {}) : Promise<{ response: http.ClientResponse; body: PtsV2PaymentsVoidsPost201Response;  }> {
        const localVarPath = this.basePath + '/pts/v2/voids';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'mitVoidRequest' is not null or undefined
        if (mitVoidRequest === null || mitVoidRequest === undefined) {
            throw new Error('Required parameter mitVoidRequest was null or undefined when calling mitVoid.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(mitVoidRequest, "MitVoidRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PtsV2PaymentsVoidsPost201Response;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PtsV2PaymentsVoidsPost201Response");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Refund a capture API is only used, if you have requested Capture independenlty using [/pts/v2/payments/{id}/captures](https://developer.cybersource.com/api-reference-assets/index.html#payments_capture) API call. Include the capture ID in the POST request to cancel the capture. 
     * @summary Void a Capture
     * @param voidCaptureRequest 
     * @param id The capture ID returned from a previous capture request.
     * @param {*} [options] Override http request options.
     */
    public voidCapture (voidCaptureRequest: VoidCaptureRequest, id: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: PtsV2PaymentsVoidsPost201Response;  }> {
        const localVarPath = this.basePath + '/pts/v2/captures/{id}/voids'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'voidCaptureRequest' is not null or undefined
        if (voidCaptureRequest === null || voidCaptureRequest === undefined) {
            throw new Error('Required parameter voidCaptureRequest was null or undefined when calling voidCapture.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling voidCapture.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(voidCaptureRequest, "VoidCaptureRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PtsV2PaymentsVoidsPost201Response;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PtsV2PaymentsVoidsPost201Response");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Include the credit ID in the POST request to cancel the credit.
     * @summary Void a Credit
     * @param voidCreditRequest 
     * @param id The credit ID returned from a previous credit request.
     * @param {*} [options] Override http request options.
     */
    public voidCredit (voidCreditRequest: VoidCreditRequest, id: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: PtsV2PaymentsVoidsPost201Response;  }> {
        const localVarPath = this.basePath + '/pts/v2/credits/{id}/voids'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'voidCreditRequest' is not null or undefined
        if (voidCreditRequest === null || voidCreditRequest === undefined) {
            throw new Error('Required parameter voidCreditRequest was null or undefined when calling voidCredit.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling voidCredit.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(voidCreditRequest, "VoidCreditRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PtsV2PaymentsVoidsPost201Response;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PtsV2PaymentsVoidsPost201Response");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Void a Payment API is only used, if you have requested Authorization and Capture together in [/pts/v2/payments](https://developer.cybersource.com/api-reference-assets/index.html#payments_payments) API call. Include the payment ID in the POST request to cancel the payment. 
     * @summary Void a Payment
     * @param voidPaymentRequest 
     * @param id The payment ID returned from a previous payment request.
     * @param {*} [options] Override http request options.
     */
    public voidPayment (voidPaymentRequest: VoidPaymentRequest, id: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: PtsV2PaymentsVoidsPost201Response;  }> {
        const localVarPath = this.basePath + '/pts/v2/payments/{id}/voids'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'voidPaymentRequest' is not null or undefined
        if (voidPaymentRequest === null || voidPaymentRequest === undefined) {
            throw new Error('Required parameter voidPaymentRequest was null or undefined when calling voidPayment.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling voidPayment.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(voidPaymentRequest, "VoidPaymentRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PtsV2PaymentsVoidsPost201Response;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PtsV2PaymentsVoidsPost201Response");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Include the refund ID in the POST request to cancel the refund.
     * @summary Void a Refund
     * @param voidRefundRequest 
     * @param id The refund ID returned from a previous refund request.
     * @param {*} [options] Override http request options.
     */
    public voidRefund (voidRefundRequest: VoidRefundRequest, id: string, options: any = {}) : Promise<{ response: http.ClientResponse; body: PtsV2PaymentsVoidsPost201Response;  }> {
        const localVarPath = this.basePath + '/pts/v2/refunds/{id}/voids'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'voidRefundRequest' is not null or undefined
        if (voidRefundRequest === null || voidRefundRequest === undefined) {
            throw new Error('Required parameter voidRefundRequest was null or undefined when calling voidRefund.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling voidRefund.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(voidRefundRequest, "VoidRefundRequest")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: PtsV2PaymentsVoidsPost201Response;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PtsV2PaymentsVoidsPost201Response");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
